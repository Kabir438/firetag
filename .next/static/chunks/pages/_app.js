/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/@react-google-maps/api/dist/esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/@react-google-maps/api/dist/esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Autocomplete\": function() { return /* binding */ Autocomplete; },\n/* harmony export */   \"BicyclingLayer\": function() { return /* binding */ BicyclingLayer; },\n/* harmony export */   \"BicyclingLayerF\": function() { return /* binding */ BicyclingLayerF; },\n/* harmony export */   \"Circle\": function() { return /* binding */ Circle; },\n/* harmony export */   \"CircleF\": function() { return /* binding */ CircleF; },\n/* harmony export */   \"Data\": function() { return /* binding */ Data; },\n/* harmony export */   \"DataF\": function() { return /* binding */ DataF; },\n/* harmony export */   \"DirectionsRenderer\": function() { return /* binding */ DirectionsRenderer; },\n/* harmony export */   \"DirectionsService\": function() { return /* binding */ DirectionsService; },\n/* harmony export */   \"DistanceMatrixService\": function() { return /* binding */ DistanceMatrixService; },\n/* harmony export */   \"DrawingManager\": function() { return /* binding */ DrawingManager; },\n/* harmony export */   \"DrawingManagerF\": function() { return /* binding */ DrawingManagerF; },\n/* harmony export */   \"FLOAT_PANE\": function() { return /* binding */ FLOAT_PANE; },\n/* harmony export */   \"GoogleMap\": function() { return /* binding */ GoogleMap; },\n/* harmony export */   \"GoogleMapsMarkerClusterer\": function() { return /* binding */ index_esm; },\n/* harmony export */   \"GoogleMarkerClusterer\": function() { return /* binding */ GoogleMarkerClusterer$1; },\n/* harmony export */   \"GroundOverlay\": function() { return /* binding */ GroundOverlay; },\n/* harmony export */   \"GroundOverlayF\": function() { return /* binding */ GroundOverlayF; },\n/* harmony export */   \"HeatmapLayer\": function() { return /* binding */ HeatmapLayer; },\n/* harmony export */   \"HeatmapLayerF\": function() { return /* binding */ HeatmapLayerF; },\n/* harmony export */   \"InfoBox\": function() { return /* binding */ InfoBoxComponent; },\n/* harmony export */   \"InfoBoxF\": function() { return /* binding */ InfoBoxF; },\n/* harmony export */   \"InfoWindow\": function() { return /* binding */ InfoWindow; },\n/* harmony export */   \"InfoWindowF\": function() { return /* binding */ InfoWindowF; },\n/* harmony export */   \"KmlLayer\": function() { return /* binding */ KmlLayer; },\n/* harmony export */   \"LoadScript\": function() { return /* binding */ LoadScript; },\n/* harmony export */   \"LoadScriptNext\": function() { return /* binding */ LoadScriptNext$1; },\n/* harmony export */   \"MAP_PANE\": function() { return /* binding */ MAP_PANE; },\n/* harmony export */   \"MARKER_LAYER\": function() { return /* binding */ MARKER_LAYER; },\n/* harmony export */   \"MapContext\": function() { return /* binding */ MapContext; },\n/* harmony export */   \"Marker\": function() { return /* binding */ Marker; },\n/* harmony export */   \"MarkerClusterer\": function() { return /* binding */ ClustererComponent; },\n/* harmony export */   \"MarkerClustererF\": function() { return /* binding */ MarkerClustererF; },\n/* harmony export */   \"MarkerF\": function() { return /* binding */ MarkerF; },\n/* harmony export */   \"OVERLAY_LAYER\": function() { return /* binding */ OVERLAY_LAYER; },\n/* harmony export */   \"OVERLAY_MOUSE_TARGET\": function() { return /* binding */ OVERLAY_MOUSE_TARGET; },\n/* harmony export */   \"OverlayView\": function() { return /* binding */ OverlayView; },\n/* harmony export */   \"OverlayViewF\": function() { return /* binding */ OverlayViewF; },\n/* harmony export */   \"Polygon\": function() { return /* binding */ Polygon; },\n/* harmony export */   \"PolygonF\": function() { return /* binding */ PolygonF; },\n/* harmony export */   \"Polyline\": function() { return /* binding */ Polyline; },\n/* harmony export */   \"PolylineF\": function() { return /* binding */ PolylineF; },\n/* harmony export */   \"Rectangle\": function() { return /* binding */ Rectangle; },\n/* harmony export */   \"RectangleF\": function() { return /* binding */ RectangleF; },\n/* harmony export */   \"StandaloneSearchBox\": function() { return /* binding */ StandaloneSearchBox; },\n/* harmony export */   \"StreetViewPanorama\": function() { return /* binding */ StreetViewPanorama; },\n/* harmony export */   \"StreetViewService\": function() { return /* binding */ StreetViewService; },\n/* harmony export */   \"TrafficLayer\": function() { return /* binding */ TrafficLayer; },\n/* harmony export */   \"TrafficLayerF\": function() { return /* binding */ TrafficLayerF; },\n/* harmony export */   \"TransitLayer\": function() { return /* binding */ TransitLayer; },\n/* harmony export */   \"TransitLayerF\": function() { return /* binding */ TransitLayerF; },\n/* harmony export */   \"useGoogleMap\": function() { return /* binding */ useGoogleMap; },\n/* harmony export */   \"useJsApiLoader\": function() { return /* binding */ useJsApiLoader; },\n/* harmony export */   \"useLoadScript\": function() { return /* binding */ useLoadScript; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest$1(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter$1(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\n/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar NODE_ENV = \"development\";\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nvar invariant_1 = invariant;\n\nvar invariant$1 = /*@__PURE__*/getDefaultExportFromCjs(invariant_1);\n\nvar MapContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nfunction useGoogleMap() {\n    invariant$1(!!react__WEBPACK_IMPORTED_MODULE_1__.useContext, 'useGoogleMap is React hook and requires React version 16.8+');\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    invariant$1(!!map, 'useGoogleMap needs a GoogleMap available up in the tree');\n    return map;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction reduce(obj, fn, acc) {\n    return Object.keys(obj).reduce(function reducer(newAcc, key) {\n        return fn(newAcc, obj[key], key);\n    }, acc);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction forEach(obj, fn) {\n    Object.keys(obj).forEach(function (key) {\n        return fn(obj[key], key);\n    });\n}\n\n/* global google */\nfunction applyUpdaterToNextProps(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nupdaterMap, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nprevProps, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nnextProps, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninstance\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var map = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var iter = function (fn, key) {\n        var nextValue = nextProps[key];\n        if (nextValue !== prevProps[key]) {\n            map[key] = nextValue;\n            fn(instance, nextValue);\n        }\n    };\n    forEach(updaterMap, iter);\n    return map;\n}\nfunction registerEvents(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nprops, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ninstance, eventMap) {\n    var registeredList = reduce(eventMap, function reducer(acc, googleEventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onEventName) {\n        if (typeof props[onEventName] === 'function') {\n            acc.push(google.maps.event.addListener(instance, googleEventName, props[onEventName]));\n        }\n        return acc;\n    }, []);\n    return registeredList;\n}\nfunction unregisterEvent(registered) {\n    google.maps.event.removeListener(registered);\n}\nfunction unregisterEvents(events) {\n    if (events === void 0) { events = []; }\n    events.forEach(unregisterEvent);\n}\nfunction applyUpdatersToPropsAndRegisterEvents(_a) {\n    var updaterMap = _a.updaterMap, eventMap = _a.eventMap, prevProps = _a.prevProps, nextProps = _a.nextProps, instance = _a.instance;\n    var registeredEvents = registerEvents(nextProps, instance, eventMap);\n    applyUpdaterToNextProps(updaterMap, prevProps, nextProps, instance);\n    return registeredEvents;\n}\n\nvar eventMap$i = {\n    onDblClick: 'dblclick',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMapTypeIdChanged: 'maptypeid_changed',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseDown: 'mousedown',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n    onTilesLoaded: 'tilesloaded',\n    onBoundsChanged: 'bounds_changed',\n    onCenterChanged: 'center_changed',\n    onClick: 'click',\n    onDrag: 'drag',\n    onHeadingChanged: 'heading_changed',\n    onIdle: 'idle',\n    onProjectionChanged: 'projection_changed',\n    onResize: 'resize',\n    onTiltChanged: 'tilt_changed',\n    onZoomChanged: 'zoom_changed',\n};\nvar updaterMap$i = {\n    extraMapTypes: function (map, extra) {\n        extra.forEach(function forEachExtra(it, i) {\n            map.mapTypes.set(String(i), it);\n        });\n    },\n    center: function (map, center) {\n        map.setCenter(center);\n    },\n    clickableIcons: function (map, clickable) {\n        map.setClickableIcons(clickable);\n    },\n    heading: function (map, heading) {\n        map.setHeading(heading);\n    },\n    mapTypeId: function (map, mapTypeId) {\n        map.setMapTypeId(mapTypeId);\n    },\n    options: function (map, options) {\n        map.setOptions(options);\n    },\n    streetView: function (map, streetView) {\n        map.setStreetView(streetView);\n    },\n    tilt: function (map, tilt) {\n        map.setTilt(tilt);\n    },\n    zoom: function (map, zoom) {\n        map.setZoom(zoom);\n    },\n};\n// TODO: unfinished!\nfunction GoogleMapFunctional(_a) {\n    var children = _a.children, options = _a.options, id = _a.id, mapContainerStyle = _a.mapContainerStyle, mapContainerClassName = _a.mapContainerClassName, center = _a.center, \n    // clickableIcons,\n    // extraMapTypes,\n    // heading,\n    // mapTypeId,\n    onClick = _a.onClick, onDblClick = _a.onDblClick, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseDown = _a.onMouseDown, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, \n    // onMapTypeIdChanged,\n    // onTilesLoaded,\n    // onBoundsChanged,\n    onCenterChanged = _a.onCenterChanged, \n    // onHeadingChanged,\n    // onIdle,\n    // onProjectionChanged,\n    // onResize,\n    // onTiltChanged,\n    // onZoomChanged,\n    onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), map = _b[0], setMap = _b[1];\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // const [extraMapTypesListener, setExtraMapTypesListener] = useState<google.maps.MapsEventListener | null>(null)\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), centerChangedListener = _c[0], setCenterChangedListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dblclickListener = _d[0], setDblclickListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragendListener = _e[0], setDragendListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragstartListener = _f[0], setDragstartListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousedownListener = _g[0], setMousedownListener = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousemoveListener = _h[0], setMousemoveListener = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoutListener = _j[0], setMouseoutListener = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoverListener = _k[0], setMouseoverListener = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseupListener = _l[0], setMouseupListener = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), rightclickListener = _m[0], setRightclickListener = _m[1];\n    var _o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clickListener = _o[0], setClickListener = _o[1];\n    var _p = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragListener = _p[0], setDragListener = _p[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (options && map !== null) {\n            map.setOptions(options);\n        }\n    }, [map, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map !== null && typeof center !== 'undefined') {\n            map.setCenter(center);\n        }\n    }, [map, center]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(map, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(map, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(map, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(map, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(map, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(map, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(map, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(map, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(map, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(map, 'click', onClick));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(map, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && onCenterChanged) {\n            if (centerChangedListener !== null) {\n                google.maps.event.removeListener(centerChangedListener);\n            }\n            setCenterChangedListener(google.maps.event.addListener(map, 'center_changed', onCenterChanged));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var map = ref.current === null\n            ? null\n            : new google.maps.Map(ref.current, options);\n        setMap(map);\n        if (map !== null && onLoad) {\n            onLoad(map);\n        }\n        return function () {\n            if (map !== null) {\n                if (onUnmount) {\n                    onUnmount(map);\n                }\n            }\n        };\n    }, []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { id: id, ref: ref, style: mapContainerStyle, className: mapContainerClassName, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MapContext.Provider, { value: map, children: map !== null ? children : null }) }));\n}\n(0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GoogleMapFunctional);\nvar GoogleMap = /** @class */ (function (_super) {\n    __extends(GoogleMap, _super);\n    function GoogleMap() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            map: null,\n        };\n        _this.registeredEvents = [];\n        _this.mapRef = null;\n        _this.getInstance = function () {\n            if (_this.mapRef === null) {\n                return null;\n            }\n            return new google.maps.Map(_this.mapRef, _this.props.options);\n        };\n        _this.panTo = function (latLng) {\n            var map = _this.getInstance();\n            if (map) {\n                map.panTo(latLng);\n            }\n        };\n        _this.setMapCallback = function () {\n            if (_this.state.map !== null) {\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.map);\n                }\n            }\n        };\n        _this.getRef = function (ref) {\n            _this.mapRef = ref;\n        };\n        return _this;\n    }\n    GoogleMap.prototype.componentDidMount = function () {\n        var map = this.getInstance();\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$i,\n            eventMap: eventMap$i,\n            prevProps: {},\n            nextProps: this.props,\n            instance: map,\n        });\n        this.setState(function setMap() {\n            return {\n                map: map,\n            };\n        }, this.setMapCallback);\n    };\n    GoogleMap.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.map !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$i,\n                eventMap: eventMap$i,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.map,\n            });\n        }\n    };\n    GoogleMap.prototype.componentWillUnmount = function () {\n        if (this.state.map !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.map);\n            }\n            unregisterEvents(this.registeredEvents);\n        }\n    };\n    GoogleMap.prototype.render = function () {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MapContext.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) }));\n    };\n    return GoogleMap;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar isBrowser = typeof document !== 'undefined';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction injectScript(_a) {\n    var url = _a.url, id = _a.id, nonce = _a.nonce;\n    if (!isBrowser) {\n        return Promise.reject(new Error('document is undefined'));\n    }\n    return new Promise(function injectScriptCallback(resolve, reject) {\n        var existingScript = document.getElementById(id);\n        var windowWithGoogleMap = window;\n        if (existingScript) {\n            // Same script id/url: keep same script\n            var dataStateAttribute = existingScript.getAttribute('data-state');\n            if (existingScript.src === url && dataStateAttribute !== 'error') {\n                if (dataStateAttribute === 'ready') {\n                    return resolve(id);\n                }\n                else {\n                    var originalInitMap_1 = windowWithGoogleMap.initMap;\n                    var originalErrorCallback_1 = existingScript.onerror;\n                    windowWithGoogleMap.initMap = function initMap() {\n                        if (originalInitMap_1) {\n                            originalInitMap_1();\n                        }\n                        resolve(id);\n                    };\n                    existingScript.onerror = function (err) {\n                        if (originalErrorCallback_1) {\n                            originalErrorCallback_1(err);\n                        }\n                        reject(err);\n                    };\n                    return;\n                }\n            }\n            // Same script id, but either\n            // 1. requested URL is different\n            // 2. script failed to load\n            else {\n                existingScript.remove();\n            }\n        }\n        var script = document.createElement('script');\n        script.type = 'text/javascript';\n        script.src = url;\n        script.id = id;\n        script.async = true;\n        script.nonce = nonce || '';\n        script.onerror = function onerror(err) {\n            script.setAttribute('data-state', 'error');\n            reject(err);\n        };\n        windowWithGoogleMap.initMap = function onload() {\n            script.setAttribute('data-state', 'ready');\n            resolve(id);\n        };\n        document.head.appendChild(script);\n    }).catch(function (err) {\n        console.error('injectScript error: ', err);\n        throw err;\n    });\n}\n\nfunction isGoogleFontStyle(element) {\n    // 'Roboto' or 'Google Sans Text' font download\n    var href = element.href;\n    if (href && (href.indexOf('https://fonts.googleapis.com/css?family=Roboto') === 0 ||\n        href.indexOf('https://fonts.googleapis.com/css?family=Google+Sans+Text') === 0)) {\n        return true;\n    }\n    // font style elements\n    if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    element.tagName.toLowerCase() === 'style' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.styleSheet &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.styleSheet.cssText &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.styleSheet.cssText.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.styleSheet.cssText = '';\n        return true;\n    }\n    // font style elements for other browsers\n    if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    element.tagName.toLowerCase() === 'style' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.innerHTML &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.innerHTML.replace('\\r\\n', '').indexOf('.gm-style') === 0) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        element.innerHTML = '';\n        return true;\n    }\n    // when google tries to add empty style\n    if (\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    element.tagName.toLowerCase() === 'style' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        !element.styleSheet &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        !element.innerHTML) {\n        return true;\n    }\n    return false;\n}\n// Preventing the Google Maps library from downloading an extra font\nfunction preventGoogleFonts() {\n    // we override these methods only for one particular head element\n    // default methods for other elements are not affected\n    var head = document.getElementsByTagName('head')[0];\n    if (head) {\n        var trueInsertBefore_1 = head.insertBefore.bind(head);\n        // TODO: adding return before reflect solves the TS issue\n        head.insertBefore = function insertBefore(newElement, referenceElement) {\n            if (!isGoogleFontStyle(newElement)) {\n                Reflect.apply(trueInsertBefore_1, head, [newElement, referenceElement]);\n            }\n            return newElement;\n        };\n        var trueAppend_1 = head.appendChild.bind(head);\n        // TODO: adding return before reflect solves the TS issue\n        head.appendChild = function appendChild(textNode) {\n            if (!isGoogleFontStyle(textNode)) {\n                Reflect.apply(trueAppend_1, head, [textNode]);\n            }\n            return textNode;\n        };\n    }\n}\n\nfunction makeLoadScriptUrl(_a) {\n    var googleMapsApiKey = _a.googleMapsApiKey, googleMapsClientId = _a.googleMapsClientId, _b = _a.version, version = _b === void 0 ? 'weekly' : _b, language = _a.language, region = _a.region, libraries = _a.libraries, channel = _a.channel, mapIds = _a.mapIds, authReferrerPolicy = _a.authReferrerPolicy;\n    var params = [];\n    invariant$1((googleMapsApiKey && googleMapsClientId) || !(googleMapsApiKey && googleMapsClientId), 'You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time.');\n    if (googleMapsApiKey) {\n        params.push(\"key=\".concat(googleMapsApiKey));\n    }\n    else if (googleMapsClientId) {\n        params.push(\"client=\".concat(googleMapsClientId));\n    }\n    if (version) {\n        params.push(\"v=\".concat(version));\n    }\n    if (language) {\n        params.push(\"language=\".concat(language));\n    }\n    if (region) {\n        params.push(\"region=\".concat(region));\n    }\n    if (libraries && libraries.length) {\n        params.push(\"libraries=\".concat(libraries.sort().join(',')));\n    }\n    if (channel) {\n        params.push(\"channel=\".concat(channel));\n    }\n    if (mapIds && mapIds.length) {\n        params.push(\"map_ids=\".concat(mapIds.join(',')));\n    }\n    if (authReferrerPolicy) {\n        params.push(\"auth_referrer_policy=\".concat(authReferrerPolicy));\n    }\n    params.push('callback=initMap');\n    return \"https://maps.googleapis.com/maps/api/js?\".concat(params.join('&'));\n}\n\nvar cleaningUp = false;\nfunction DefaultLoadingElement() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { children: \"Loading...\" });\n}\nvar defaultLoadScriptProps = {\n    id: 'script-loader',\n    version: 'weekly',\n};\nvar LoadScript = /** @class */ (function (_super) {\n    __extends(LoadScript, _super);\n    function LoadScript() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.check = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.state = {\n            loaded: false,\n        };\n        _this.cleanupCallback = function () {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            delete window.google.maps;\n            _this.injectScript();\n        };\n        _this.isCleaningUp = function () { return __awaiter$1(_this, void 0, void 0, function () {\n            function promiseCallback(resolve) {\n                if (!cleaningUp) {\n                    resolve();\n                }\n                else {\n                    if (isBrowser) {\n                        var timer_1 = window.setInterval(function interval() {\n                            if (!cleaningUp) {\n                                window.clearInterval(timer_1);\n                                resolve();\n                            }\n                        }, 1);\n                    }\n                }\n                return;\n            }\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(promiseCallback)];\n            });\n        }); };\n        _this.cleanup = function () {\n            cleaningUp = true;\n            var script = document.getElementById(_this.props.id);\n            if (script && script.parentNode) {\n                script.parentNode.removeChild(script);\n            }\n            Array.prototype.slice\n                .call(document.getElementsByTagName('script'))\n                .filter(function filter(script) {\n                return typeof script.src === 'string' && script.src.includes('maps.googleapis');\n            })\n                .forEach(function forEach(script) {\n                if (script.parentNode) {\n                    script.parentNode.removeChild(script);\n                }\n            });\n            Array.prototype.slice\n                .call(document.getElementsByTagName('link'))\n                .filter(function filter(link) {\n                return (link.href === 'https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans');\n            })\n                .forEach(function forEach(link) {\n                if (link.parentNode) {\n                    link.parentNode.removeChild(link);\n                }\n            });\n            Array.prototype.slice\n                .call(document.getElementsByTagName('style'))\n                .filter(function filter(style) {\n                return (style.innerText !== undefined &&\n                    style.innerText.length > 0 &&\n                    style.innerText.includes('.gm-'));\n            })\n                .forEach(function forEach(style) {\n                if (style.parentNode) {\n                    style.parentNode.removeChild(style);\n                }\n            });\n        };\n        _this.injectScript = function () {\n            if (_this.props.preventGoogleFontsLoading) {\n                preventGoogleFonts();\n            }\n            invariant$1(!!_this.props.id, 'LoadScript requires \"id\" prop to be a string: %s', _this.props.id);\n            var injectScriptOptions = {\n                id: _this.props.id,\n                nonce: _this.props.nonce,\n                url: makeLoadScriptUrl(_this.props),\n            };\n            injectScript(injectScriptOptions)\n                .then(function () {\n                if (_this.props.onLoad) {\n                    _this.props.onLoad();\n                }\n                _this.setState(function setLoaded() {\n                    return {\n                        loaded: true,\n                    };\n                });\n                return;\n            })\n                .catch(function (err) {\n                if (_this.props.onError) {\n                    _this.props.onError(err);\n                }\n                console.error(\"\\n          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\".concat(_this\n                    .props.googleMapsApiKey || '-', \") or Client ID (\").concat(_this.props.googleMapsClientId ||\n                    '-', \") to <LoadScript />\\n          Otherwise it is a Network issue.\\n        \"));\n            });\n        };\n        return _this;\n    }\n    LoadScript.prototype.componentDidMount = function () {\n        if (isBrowser) {\n            if (window.google && window.google.maps && !cleaningUp) {\n                console.error('google api is already presented');\n                return;\n            }\n            this.isCleaningUp()\n                .then(this.injectScript)\n                .catch(function error(err) {\n                console.error('Error at injecting script after cleaning up: ', err);\n            });\n        }\n    };\n    LoadScript.prototype.componentDidUpdate = function (prevProps) {\n        if (this.props.libraries !== prevProps.libraries) {\n            console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n        }\n        if (isBrowser && prevProps.language !== this.props.language) {\n            this.cleanup();\n            // TODO: refactor to use gDSFP maybe... wait for hooks refactoring.\n            this.setState(function setLoaded() {\n                return {\n                    loaded: false,\n                };\n            }, this.cleanupCallback);\n        }\n    };\n    LoadScript.prototype.componentWillUnmount = function () {\n        var _this = this;\n        if (isBrowser) {\n            this.cleanup();\n            var timeoutCallback = function () {\n                if (!_this.check.current) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    delete window.google;\n                    cleaningUp = false;\n                }\n            };\n            window.setTimeout(timeoutCallback, 1);\n            if (this.props.onUnmount) {\n                this.props.onUnmount();\n            }\n        }\n    };\n    LoadScript.prototype.render = function () {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: this.check }), this.state.loaded\n                    ? this.props.children\n                    : this.props.loadingElement || (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultLoadingElement, {})] }));\n    };\n    LoadScript.defaultProps = defaultLoadScriptProps;\n    return LoadScript;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\n/* eslint-disable filenames/match-regex */\nvar previouslyLoadedUrl;\nfunction useLoadScript(_a) {\n    var _b = _a.id, id = _b === void 0 ? defaultLoadScriptProps.id : _b, _c = _a.version, version = _c === void 0 ? defaultLoadScriptProps.version : _c, nonce = _a.nonce, googleMapsApiKey = _a.googleMapsApiKey, googleMapsClientId = _a.googleMapsClientId, language = _a.language, region = _a.region, libraries = _a.libraries, preventGoogleFontsLoading = _a.preventGoogleFontsLoading, channel = _a.channel, mapIds = _a.mapIds, authReferrerPolicy = _a.authReferrerPolicy;\n    var isMounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), isLoaded = _d[0], setLoaded = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(undefined), loadError = _e[0], setLoadError = _e[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function trackMountedState() {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function applyPreventGoogleFonts() {\n        if (isBrowser && preventGoogleFontsLoading) {\n            preventGoogleFonts();\n        }\n    }, [preventGoogleFontsLoading]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function validateLoadedState() {\n        if (isLoaded) {\n            invariant$1(!!window.google, 'useLoadScript was marked as loaded, but window.google is not present. Something went wrong.');\n        }\n    }, [isLoaded]);\n    var url = makeLoadScriptUrl({\n        version: version,\n        googleMapsApiKey: googleMapsApiKey,\n        googleMapsClientId: googleMapsClientId,\n        language: language,\n        region: region,\n        libraries: libraries,\n        channel: channel,\n        mapIds: mapIds,\n        authReferrerPolicy: authReferrerPolicy\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function loadScriptAndModifyLoadedState() {\n        if (!isBrowser) {\n            return;\n        }\n        function setLoadedIfMounted() {\n            if (isMounted.current) {\n                setLoaded(true);\n                previouslyLoadedUrl = url;\n            }\n        }\n        if (window.google && window.google.maps && previouslyLoadedUrl === url) {\n            setLoadedIfMounted();\n            return;\n        }\n        injectScript({ id: id, url: url, nonce: nonce })\n            .then(setLoadedIfMounted)\n            .catch(function handleInjectError(err) {\n            if (isMounted.current) {\n                setLoadError(err);\n            }\n            console.warn(\"\\n        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\".concat(googleMapsApiKey ||\n                '-', \") or Client ID (\").concat(googleMapsClientId || '-', \")\\n        Otherwise it is a Network issue.\\n      \"));\n            console.error(err);\n        });\n    }, [id, url, nonce]);\n    var prevLibraries = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function checkPerformance() {\n        if (prevLibraries.current && libraries !== prevLibraries.current) {\n            console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n        }\n        prevLibraries.current = libraries;\n    }, [libraries]);\n    return { isLoaded: isLoaded, loadError: loadError, url: url };\n}\n\nvar defaultLoadingElement = (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DefaultLoadingElement, {});\nfunction LoadScriptNext(_a) {\n    var loadingElement = _a.loadingElement, onLoad = _a.onLoad, onError = _a.onError, onUnmount = _a.onUnmount, children = _a.children, hookOptions = __rest$1(_a, [\"loadingElement\", \"onLoad\", \"onError\", \"onUnmount\", \"children\"]);\n    var _b = useLoadScript(hookOptions), isLoaded = _b.isLoaded, loadError = _b.loadError;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function handleOnLoad() {\n        if (isLoaded && typeof onLoad === 'function') {\n            onLoad();\n        }\n    }, [isLoaded, onLoad]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function handleOnError() {\n        if (loadError && typeof onError === 'function') {\n            onError(loadError);\n        }\n    }, [loadError, onError]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function handleOnUnmount() {\n        return function () {\n            if (onUnmount) {\n                onUnmount();\n            }\n        };\n    }, [onUnmount]);\n    return isLoaded ? children : loadingElement || defaultLoadingElement;\n}\nvar LoadScriptNext$1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(LoadScriptNext);\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nvar fastDeepEqual$1 = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at.\n *\n *      Http://www.apache.org/licenses/LICENSE-2.0.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst DEFAULT_ID = \"__googleMapsScriptId\";\n/**\n * The status of the [[Loader]].\n */\nvar LoaderStatus;\n(function (LoaderStatus) {\n    LoaderStatus[LoaderStatus[\"INITIALIZED\"] = 0] = \"INITIALIZED\";\n    LoaderStatus[LoaderStatus[\"LOADING\"] = 1] = \"LOADING\";\n    LoaderStatus[LoaderStatus[\"SUCCESS\"] = 2] = \"SUCCESS\";\n    LoaderStatus[LoaderStatus[\"FAILURE\"] = 3] = \"FAILURE\";\n})(LoaderStatus || (LoaderStatus = {}));\n/**\n * [[Loader]] makes it easier to add Google Maps JavaScript API to your application\n * dynamically using\n * [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).\n * It works by dynamically creating and appending a script node to the the\n * document head and wrapping the callback function so as to return a promise.\n *\n * ```\n * const loader = new Loader({\n *   apiKey: \"\",\n *   version: \"weekly\",\n *   libraries: [\"places\"]\n * });\n *\n * loader.load().then((google) => {\n *   const map = new google.maps.Map(...)\n * })\n * ```\n */\nclass Loader {\n    /**\n     * Creates an instance of Loader using [[LoaderOptions]]. No defaults are set\n     * using this library, instead the defaults are set by the Google Maps\n     * JavaScript API server.\n     *\n     * ```\n     * const loader = Loader({apiKey, version: 'weekly', libraries: ['places']});\n     * ```\n     */\n    constructor({ apiKey, authReferrerPolicy, channel, client, id = DEFAULT_ID, language, libraries = [], mapIds, nonce, region, retries = 3, url = \"https://maps.googleapis.com/maps/api/js\", version, }) {\n        this.callbacks = [];\n        this.done = false;\n        this.loading = false;\n        this.errors = [];\n        this.apiKey = apiKey;\n        this.authReferrerPolicy = authReferrerPolicy;\n        this.channel = channel;\n        this.client = client;\n        this.id = id || DEFAULT_ID; // Do not allow empty string\n        this.language = language;\n        this.libraries = libraries;\n        this.mapIds = mapIds;\n        this.nonce = nonce;\n        this.region = region;\n        this.retries = retries;\n        this.url = url;\n        this.version = version;\n        if (Loader.instance) {\n            if (!fastDeepEqual$1(this.options, Loader.instance.options)) {\n                throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(Loader.instance.options)}`);\n            }\n            return Loader.instance;\n        }\n        Loader.instance = this;\n    }\n    get options() {\n        return {\n            version: this.version,\n            apiKey: this.apiKey,\n            channel: this.channel,\n            client: this.client,\n            id: this.id,\n            libraries: this.libraries,\n            language: this.language,\n            region: this.region,\n            mapIds: this.mapIds,\n            nonce: this.nonce,\n            url: this.url,\n            authReferrerPolicy: this.authReferrerPolicy,\n        };\n    }\n    get status() {\n        if (this.errors.length) {\n            return LoaderStatus.FAILURE;\n        }\n        if (this.done) {\n            return LoaderStatus.SUCCESS;\n        }\n        if (this.loading) {\n            return LoaderStatus.LOADING;\n        }\n        return LoaderStatus.INITIALIZED;\n    }\n    get failed() {\n        return this.done && !this.loading && this.errors.length >= this.retries + 1;\n    }\n    /**\n     * CreateUrl returns the Google Maps JavaScript API script url given the [[LoaderOptions]].\n     *\n     * @ignore\n     * @deprecated\n     */\n    createUrl() {\n        let url = this.url;\n        url += `?callback=__googleMapsCallback`;\n        if (this.apiKey) {\n            url += `&key=${this.apiKey}`;\n        }\n        if (this.channel) {\n            url += `&channel=${this.channel}`;\n        }\n        if (this.client) {\n            url += `&client=${this.client}`;\n        }\n        if (this.libraries.length > 0) {\n            url += `&libraries=${this.libraries.join(\",\")}`;\n        }\n        if (this.language) {\n            url += `&language=${this.language}`;\n        }\n        if (this.region) {\n            url += `&region=${this.region}`;\n        }\n        if (this.version) {\n            url += `&v=${this.version}`;\n        }\n        if (this.mapIds) {\n            url += `&map_ids=${this.mapIds.join(\",\")}`;\n        }\n        if (this.authReferrerPolicy) {\n            url += `&auth_referrer_policy=${this.authReferrerPolicy}`;\n        }\n        return url;\n    }\n    deleteScript() {\n        const script = document.getElementById(this.id);\n        if (script) {\n            script.remove();\n        }\n    }\n    /**\n     * Load the Google Maps JavaScript API script and return a Promise.\n     * @deprecated, use importLibrary() instead.\n     */\n    load() {\n        return this.loadPromise();\n    }\n    /**\n     * Load the Google Maps JavaScript API script and return a Promise.\n     *\n     * @ignore\n     * @deprecated, use importLibrary() instead.\n     */\n    loadPromise() {\n        return new Promise((resolve, reject) => {\n            this.loadCallback((err) => {\n                if (!err) {\n                    resolve(window.google);\n                }\n                else {\n                    reject(err.error);\n                }\n            });\n        });\n    }\n    importLibrary(name) {\n        this.execute();\n        return google.maps.importLibrary(name);\n    }\n    /**\n     * Load the Google Maps JavaScript API script with a callback.\n     * @deprecated, use importLibrary() instead.\n     */\n    loadCallback(fn) {\n        this.callbacks.push(fn);\n        this.execute();\n    }\n    /**\n     * Set the script on document.\n     */\n    setScript() {\n        var _a, _b;\n        if (document.getElementById(this.id)) {\n            // TODO wrap onerror callback for cases where the script was loaded elsewhere\n            this.callback();\n            return;\n        }\n        const params = {\n            key: this.apiKey,\n            channel: this.channel,\n            client: this.client,\n            libraries: this.libraries.length && this.libraries,\n            v: this.version,\n            mapIds: this.mapIds,\n            language: this.language,\n            region: this.region,\n            authReferrerPolicy: this.authReferrerPolicy,\n        };\n        // keep the URL minimal:\n        Object.keys(params).forEach(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (key) => !params[key] && delete params[key]);\n        if (!((_b = (_a = window === null || window === void 0 ? void 0 : window.google) === null || _a === void 0 ? void 0 : _a.maps) === null || _b === void 0 ? void 0 : _b.importLibrary)) {\n            // tweaked copy of https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n            // which also sets the base url, the id, and the nonce\n            /* eslint-disable */\n            ((g) => {\n                // @ts-ignore\n                let h, a, k, p = \"The Google Maps JavaScript API\", c = \"google\", l = \"importLibrary\", q = \"__ib__\", m = document, b = window;\n                // @ts-ignore\n                b = b[c] || (b[c] = {});\n                // @ts-ignore\n                const d = b.maps || (b.maps = {}), r = new Set(), e = new URLSearchParams(), u = () => \n                // @ts-ignore\n                h || (h = new Promise((f, n) => __awaiter(this, void 0, void 0, function* () {\n                    var _a;\n                    yield (a = m.createElement(\"script\"));\n                    a.id = this.id;\n                    e.set(\"libraries\", [...r] + \"\");\n                    // @ts-ignore\n                    for (k in g)\n                        e.set(k.replace(/[A-Z]/g, (t) => \"_\" + t[0].toLowerCase()), g[k]);\n                    e.set(\"callback\", c + \".maps.\" + q);\n                    a.src = this.url + `?` + e;\n                    d[q] = f;\n                    a.onerror = () => (h = n(Error(p + \" could not load.\")));\n                    // @ts-ignore\n                    a.nonce = this.nonce || ((_a = m.querySelector(\"script[nonce]\")) === null || _a === void 0 ? void 0 : _a.nonce) || \"\";\n                    m.head.append(a);\n                })));\n                // @ts-ignore\n                d[l] ? console.warn(p + \" only loads once. Ignoring:\", g) : (d[l] = (f, ...n) => r.add(f) && u().then(() => d[l](f, ...n)));\n            })(params);\n            /* eslint-enable */\n        }\n        // While most libraries populate the global namespace when loaded via bootstrap params,\n        // this is not the case for \"marker\" when used with the inline bootstrap loader\n        // (and maybe others in the future). So ensure there is an importLibrary for each:\n        const libraryPromises = this.libraries.map((library) => this.importLibrary(library));\n        // ensure at least one library, to kick off loading...\n        if (!libraryPromises.length) {\n            libraryPromises.push(this.importLibrary(\"core\"));\n        }\n        Promise.all(libraryPromises).then(() => this.callback(), (error) => {\n            const event = new ErrorEvent(\"error\", { error }); // for backwards compat\n            this.loadErrorCallback(event);\n        });\n    }\n    /**\n     * Reset the loader state.\n     */\n    reset() {\n        this.deleteScript();\n        this.done = false;\n        this.loading = false;\n        this.errors = [];\n        this.onerrorEvent = null;\n    }\n    resetIfRetryingFailed() {\n        if (this.failed) {\n            this.reset();\n        }\n    }\n    loadErrorCallback(e) {\n        this.errors.push(e);\n        if (this.errors.length <= this.retries) {\n            const delay = this.errors.length * Math.pow(2, this.errors.length);\n            console.error(`Failed to load Google Maps script, retrying in ${delay} ms.`);\n            setTimeout(() => {\n                this.deleteScript();\n                this.setScript();\n            }, delay);\n        }\n        else {\n            this.onerrorEvent = e;\n            this.callback();\n        }\n    }\n    callback() {\n        this.done = true;\n        this.loading = false;\n        this.callbacks.forEach((cb) => {\n            cb(this.onerrorEvent);\n        });\n        this.callbacks = [];\n    }\n    execute() {\n        this.resetIfRetryingFailed();\n        if (this.done) {\n            this.callback();\n        }\n        else {\n            // short circuit and warn if google.maps is already loaded\n            if (window.google && window.google.maps && window.google.maps.version) {\n                console.warn(\"Google Maps already loaded outside @googlemaps/js-api-loader.\" +\n                    \"This may result in undesirable behavior as options and script parameters may not match.\");\n                this.callback();\n                return;\n            }\n            if (this.loading) ;\n            else {\n                this.loading = true;\n                this.setScript();\n            }\n        }\n    }\n}\n\nvar defaultLibraries = ['maps'];\nfunction useJsApiLoader(_a) {\n    var _b = _a.id, id = _b === void 0 ? defaultLoadScriptProps.id : _b, _c = _a.version, version = _c === void 0 ? defaultLoadScriptProps.version : _c, nonce = _a.nonce, googleMapsApiKey = _a.googleMapsApiKey, \n    // googleMapsClientId,\n    language = _a.language, region = _a.region, _d = _a.libraries, libraries = _d === void 0 ? defaultLibraries : _d, preventGoogleFontsLoading = _a.preventGoogleFontsLoading, \n    // channel,\n    mapIds = _a.mapIds, authReferrerPolicy = _a.authReferrerPolicy;\n    var isMounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false), isLoaded = _e[0], setLoaded = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(undefined), loadError = _f[0], setLoadError = _f[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function trackMountedState() {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    var loader = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        return new Loader({\n            id: id,\n            apiKey: googleMapsApiKey,\n            version: version,\n            libraries: libraries,\n            language: language || 'en',\n            region: region || 'US',\n            mapIds: mapIds || [],\n            nonce: nonce || '',\n            authReferrerPolicy: authReferrerPolicy || 'origin',\n        });\n    }, [id, googleMapsApiKey, version, libraries, language, region, mapIds, nonce, authReferrerPolicy]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function effect() {\n        if (isLoaded) {\n            return;\n        }\n        else {\n            loader.load().then(function () {\n                if (isMounted.current) {\n                    setLoaded(true);\n                }\n                return;\n            })\n                .catch(function (error) {\n                setLoadError(error);\n            });\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (isBrowser && preventGoogleFontsLoading) {\n            preventGoogleFonts();\n        }\n    }, [preventGoogleFontsLoading]);\n    var prevLibraries = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (prevLibraries.current && libraries !== prevLibraries.current) {\n            console.warn('Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables');\n        }\n        prevLibraries.current = libraries;\n    }, [libraries]);\n    return { isLoaded: isLoaded, loadError: loadError };\n}\n\nvar eventMap$h = {};\nvar updaterMap$h = {\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n};\nfunction TrafficLayerFunctional(_a) {\n    var options = _a.options, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var trafficLayer = new google.maps.TrafficLayer(__assign(__assign({}, (options || {})), { map: map }));\n        setInstance(trafficLayer);\n        if (onLoad) {\n            onLoad(trafficLayer);\n        }\n        return function () {\n            if (instance !== null) {\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar TrafficLayerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(TrafficLayerFunctional);\nvar TrafficLayer = /** @class */ (function (_super) {\n    __extends(TrafficLayer, _super);\n    function TrafficLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            trafficLayer: null,\n        };\n        _this.setTrafficLayerCallback = function () {\n            if (_this.state.trafficLayer !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.trafficLayer);\n            }\n        };\n        _this.registeredEvents = [];\n        return _this;\n    }\n    TrafficLayer.prototype.componentDidMount = function () {\n        var trafficLayer = new google.maps.TrafficLayer(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$h,\n            eventMap: eventMap$h,\n            prevProps: {},\n            nextProps: this.props,\n            instance: trafficLayer,\n        });\n        this.setState(function setTrafficLayer() {\n            return {\n                trafficLayer: trafficLayer,\n            };\n        }, this.setTrafficLayerCallback);\n    };\n    TrafficLayer.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.trafficLayer !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$h,\n                eventMap: eventMap$h,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.trafficLayer,\n            });\n        }\n    };\n    TrafficLayer.prototype.componentWillUnmount = function () {\n        if (this.state.trafficLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.trafficLayer);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.trafficLayer.setMap(null);\n        }\n    };\n    TrafficLayer.prototype.render = function () {\n        return null;\n    };\n    TrafficLayer.contextType = MapContext;\n    return TrafficLayer;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nfunction BicyclingLayerFunctional(_a) {\n    var onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var bicyclingLayer = new google.maps.BicyclingLayer();\n        setInstance(bicyclingLayer);\n        bicyclingLayer.setMap(map);\n        if (onLoad) {\n            onLoad(bicyclingLayer);\n        }\n        return function () {\n            if (bicyclingLayer !== null) {\n                if (onUnmount) {\n                    onUnmount(bicyclingLayer);\n                }\n                bicyclingLayer.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar BicyclingLayerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BicyclingLayerFunctional);\nvar BicyclingLayer = /** @class */ (function (_super) {\n    __extends(BicyclingLayer, _super);\n    function BicyclingLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            bicyclingLayer: null,\n        };\n        _this.setBicyclingLayerCallback = function () {\n            if (_this.state.bicyclingLayer !== null) {\n                _this.state.bicyclingLayer.setMap(_this.context);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.bicyclingLayer);\n                }\n            }\n        };\n        return _this;\n    }\n    BicyclingLayer.prototype.componentDidMount = function () {\n        var bicyclingLayer = new google.maps.BicyclingLayer();\n        this.setState(function () {\n            return {\n                bicyclingLayer: bicyclingLayer,\n            };\n        }, this.setBicyclingLayerCallback);\n    };\n    BicyclingLayer.prototype.componentWillUnmount = function () {\n        if (this.state.bicyclingLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.bicyclingLayer);\n            }\n            this.state.bicyclingLayer.setMap(null);\n        }\n    };\n    BicyclingLayer.prototype.render = function () {\n        return null;\n    };\n    BicyclingLayer.contextType = MapContext;\n    return BicyclingLayer;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nfunction TransitLayerFunctional(_a) {\n    var onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var transitLayer = new google.maps.TransitLayer();\n        setInstance(transitLayer);\n        transitLayer.setMap(map);\n        if (onLoad) {\n            onLoad(transitLayer);\n        }\n        return function () {\n            if (instance !== null) {\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar TransitLayerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(TransitLayerFunctional);\nvar TransitLayer = /** @class */ (function (_super) {\n    __extends(TransitLayer, _super);\n    function TransitLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            transitLayer: null,\n        };\n        _this.setTransitLayerCallback = function () {\n            if (_this.state.transitLayer !== null) {\n                _this.state.transitLayer.setMap(_this.context);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.transitLayer);\n                }\n            }\n        };\n        return _this;\n    }\n    TransitLayer.prototype.componentDidMount = function () {\n        var transitLayer = new google.maps.TransitLayer();\n        this.setState(function setTransitLayer() {\n            return {\n                transitLayer: transitLayer,\n            };\n        }, this.setTransitLayerCallback);\n    };\n    TransitLayer.prototype.componentWillUnmount = function () {\n        if (this.state.transitLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.transitLayer);\n            }\n            this.state.transitLayer.setMap(null);\n        }\n    };\n    TransitLayer.prototype.render = function () {\n        return null;\n    };\n    TransitLayer.contextType = MapContext;\n    return TransitLayer;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$g = {\n    onCircleComplete: 'circlecomplete',\n    onMarkerComplete: 'markercomplete',\n    onOverlayComplete: 'overlaycomplete',\n    onPolygonComplete: 'polygoncomplete',\n    onPolylineComplete: 'polylinecomplete',\n    onRectangleComplete: 'rectanglecomplete',\n};\nvar updaterMap$g = {\n    drawingMode: function (instance, drawingMode) {\n        instance.setDrawingMode(drawingMode);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n};\nfunction DrawingManagerFunctional(_a) {\n    var options = _a.options, drawingMode = _a.drawingMode, onCircleComplete = _a.onCircleComplete, onMarkerComplete = _a.onMarkerComplete, onOverlayComplete = _a.onOverlayComplete, onPolygonComplete = _a.onPolygonComplete, onPolylineComplete = _a.onPolylineComplete, onRectangleComplete = _a.onRectangleComplete, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), circlecompleteListener = _c[0], setCircleCompleteListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), markercompleteListener = _d[0], setMarkerCompleteListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), overlaycompleteListener = _e[0], setOverlayCompleteListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), polygoncompleteListener = _f[0], setPolygonCompleteListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), polylinecompleteListener = _g[0], setPolylineCompleteListener = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), rectanglecompleteListener = _h[0], setRectangleCompleteListener = _h[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setDrawingMode(drawingMode !== null && drawingMode !== void 0 ? drawingMode : null);\n        }\n    }, [instance, drawingMode]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onCircleComplete) {\n            if (circlecompleteListener !== null) {\n                google.maps.event.removeListener(circlecompleteListener);\n            }\n            setCircleCompleteListener(google.maps.event.addListener(instance, 'circlecomplete', onCircleComplete));\n        }\n    }, [instance, onCircleComplete]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMarkerComplete) {\n            if (markercompleteListener !== null) {\n                google.maps.event.removeListener(markercompleteListener);\n            }\n            setMarkerCompleteListener(google.maps.event.addListener(instance, 'markercomplete', onMarkerComplete));\n        }\n    }, [instance, onMarkerComplete]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onOverlayComplete) {\n            if (overlaycompleteListener !== null) {\n                google.maps.event.removeListener(overlaycompleteListener);\n            }\n            setOverlayCompleteListener(google.maps.event.addListener(instance, 'overlaycomplete', onOverlayComplete));\n        }\n    }, [instance, onOverlayComplete]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onPolygonComplete) {\n            if (polygoncompleteListener !== null) {\n                google.maps.event.removeListener(polygoncompleteListener);\n            }\n            setPolygonCompleteListener(google.maps.event.addListener(instance, 'polygoncomplete', onPolygonComplete));\n        }\n    }, [instance, onPolygonComplete]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onPolylineComplete) {\n            if (polylinecompleteListener !== null) {\n                google.maps.event.removeListener(polylinecompleteListener);\n            }\n            setPolylineCompleteListener(google.maps.event.addListener(instance, 'polylinecomplete', onPolylineComplete));\n        }\n    }, [instance, onPolylineComplete]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRectangleComplete) {\n            if (rectanglecompleteListener !== null) {\n                google.maps.event.removeListener(rectanglecompleteListener);\n            }\n            setRectangleCompleteListener(google.maps.event.addListener(instance, 'rectanglecomplete', onRectangleComplete));\n        }\n    }, [instance, onRectangleComplete]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        invariant$1(!!google.maps.drawing, \"Did you include prop libraries={['drawing']} in the URL? %s\", google.maps.drawing);\n        var drawingManager = new google.maps.drawing.DrawingManager(__assign(__assign({}, (options || {})), { map: map }));\n        if (drawingMode) {\n            drawingManager.setDrawingMode(drawingMode);\n        }\n        if (onCircleComplete) {\n            setCircleCompleteListener(google.maps.event.addListener(drawingManager, 'circlecomplete', onCircleComplete));\n        }\n        if (onMarkerComplete) {\n            setMarkerCompleteListener(google.maps.event.addListener(drawingManager, 'markercomplete', onMarkerComplete));\n        }\n        if (onOverlayComplete) {\n            setOverlayCompleteListener(google.maps.event.addListener(drawingManager, 'overlaycomplete', onOverlayComplete));\n        }\n        if (onPolygonComplete) {\n            setPolygonCompleteListener(google.maps.event.addListener(drawingManager, 'polygoncomplete', onPolygonComplete));\n        }\n        if (onPolylineComplete) {\n            setPolylineCompleteListener(google.maps.event.addListener(drawingManager, 'polylinecomplete', onPolylineComplete));\n        }\n        if (onRectangleComplete) {\n            setRectangleCompleteListener(google.maps.event.addListener(drawingManager, 'rectanglecomplete', onRectangleComplete));\n        }\n        setInstance(drawingManager);\n        if (onLoad) {\n            onLoad(drawingManager);\n        }\n        return function () {\n            if (instance !== null) {\n                if (circlecompleteListener) {\n                    google.maps.event.removeListener(circlecompleteListener);\n                }\n                if (markercompleteListener) {\n                    google.maps.event.removeListener(markercompleteListener);\n                }\n                if (overlaycompleteListener) {\n                    google.maps.event.removeListener(overlaycompleteListener);\n                }\n                if (polygoncompleteListener) {\n                    google.maps.event.removeListener(polygoncompleteListener);\n                }\n                if (polylinecompleteListener) {\n                    google.maps.event.removeListener(polylinecompleteListener);\n                }\n                if (rectanglecompleteListener) {\n                    google.maps.event.removeListener(rectanglecompleteListener);\n                }\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar DrawingManagerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(DrawingManagerFunctional);\nvar DrawingManager = /** @class */ (function (_super) {\n    __extends(DrawingManager, _super);\n    function DrawingManager(props) {\n        var _this = _super.call(this, props) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            drawingManager: null,\n        };\n        _this.setDrawingManagerCallback = function () {\n            if (_this.state.drawingManager !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.drawingManager);\n            }\n        };\n        invariant$1(!!google.maps.drawing, \"Did you include prop libraries={['drawing']} in the URL? %s\", google.maps.drawing);\n        return _this;\n    }\n    DrawingManager.prototype.componentDidMount = function () {\n        var drawingManager = new google.maps.drawing.DrawingManager(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$g,\n            eventMap: eventMap$g,\n            prevProps: {},\n            nextProps: this.props,\n            instance: drawingManager,\n        });\n        this.setState(function setDrawingManager() {\n            return {\n                drawingManager: drawingManager,\n            };\n        }, this.setDrawingManagerCallback);\n    };\n    DrawingManager.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.drawingManager !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$g,\n                eventMap: eventMap$g,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.drawingManager,\n            });\n        }\n    };\n    DrawingManager.prototype.componentWillUnmount = function () {\n        if (this.state.drawingManager !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.drawingManager);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.drawingManager.setMap(null);\n        }\n    };\n    DrawingManager.prototype.render = function () {\n        return null;\n    };\n    DrawingManager.contextType = MapContext;\n    return DrawingManager;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$f = {\n    onAnimationChanged: 'animation_changed',\n    onClick: 'click',\n    onClickableChanged: 'clickable_changed',\n    onCursorChanged: 'cursor_changed',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDraggableChanged: 'draggable_changed',\n    onDragStart: 'dragstart',\n    onFlatChanged: 'flat_changed',\n    onIconChanged: 'icon_changed',\n    onMouseDown: 'mousedown',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onPositionChanged: 'position_changed',\n    onRightClick: 'rightclick',\n    onShapeChanged: 'shape_changed',\n    onTitleChanged: 'title_changed',\n    onVisibleChanged: 'visible_changed',\n    onZindexChanged: 'zindex_changed',\n};\nvar updaterMap$f = {\n    animation: function (instance, animation) {\n        instance.setAnimation(animation);\n    },\n    clickable: function (instance, clickable) {\n        instance.setClickable(clickable);\n    },\n    cursor: function (instance, cursor) {\n        instance.setCursor(cursor);\n    },\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    icon: function (instance, icon) {\n        instance.setIcon(icon);\n    },\n    label: function (instance, label) {\n        instance.setLabel(label);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    opacity: function (instance, opacity) {\n        instance.setOpacity(opacity);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    position: function (instance, position) {\n        instance.setPosition(position);\n    },\n    shape: function (instance, shape) {\n        instance.setShape(shape);\n    },\n    title: function (instance, title) {\n        instance.setTitle(title);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n    zIndex: function (instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nvar defaultOptions$5 = {};\nfunction MarkerFunctional(_a) {\n    var position = _a.position, options = _a.options, clusterer = _a.clusterer, noClustererRedraw = _a.noClustererRedraw, children = _a.children, draggable = _a.draggable, visible = _a.visible, animation = _a.animation, clickable = _a.clickable, cursor = _a.cursor, icon = _a.icon, label = _a.label, opacity = _a.opacity, shape = _a.shape, title = _a.title, zIndex = _a.zIndex, onClick = _a.onClick, onDblClick = _a.onDblClick, onDrag = _a.onDrag, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onMouseDown = _a.onMouseDown, onRightClick = _a.onRightClick, onClickableChanged = _a.onClickableChanged, onCursorChanged = _a.onCursorChanged, onAnimationChanged = _a.onAnimationChanged, onDraggableChanged = _a.onDraggableChanged, onFlatChanged = _a.onFlatChanged, onIconChanged = _a.onIconChanged, onPositionChanged = _a.onPositionChanged, onShapeChanged = _a.onShapeChanged, onTitleChanged = _a.onTitleChanged, onVisibleChanged = _a.onVisibleChanged, onZindexChanged = _a.onZindexChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoutListener = _g[0], setMouseoutListener = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoverListener = _h[0], setMouseoverListener = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseupListener = _j[0], setMouseupListener = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), rightclickListener = _k[0], setRightclickListener = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clickListener = _l[0], setClickListener = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragListener = _m[0], setDragListener = _m[1];\n    var _o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clickableChangedListener = _o[0], setClickableChangedListener = _o[1];\n    var _p = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), cursorChangedListener = _p[0], setCursorChangedListener = _p[1];\n    var _q = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), animationChangedListener = _q[0], setAnimationChangedListener = _q[1];\n    var _r = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), draggableChangedListener = _r[0], setDraggableChangedListener = _r[1];\n    var _s = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), flatChangedListener = _s[0], setFlatChangedListener = _s[1];\n    var _t = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), iconChangedListener = _t[0], setIconChangedListener = _t[1];\n    var _u = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), positionChangedListener = _u[0], setPositionChangedListener = _u[1];\n    var _v = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), shapeChangedListener = _v[0], setShapeChangedListener = _v[1];\n    var _w = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), titleChangedListener = _w[0], setTitleChangedListener = _w[1];\n    var _x = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), visibleChangedListener = _x[0], setVisibleChangedListener = _x[1];\n    var _y = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), zIndexChangedListener = _y[0], setZindexChangedListener = _y[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (position && instance !== null) {\n            instance.setPosition(position);\n        }\n    }, [instance, position]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        instance === null || instance === void 0 ? void 0 : instance.setAnimation(animation);\n    }, [instance, animation]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && clickable !== undefined) {\n            instance.setClickable(clickable);\n        }\n    }, [instance, clickable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && cursor !== undefined) {\n            instance.setCursor(cursor);\n        }\n    }, [instance, cursor]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && icon !== undefined) {\n            instance.setIcon(icon);\n        }\n    }, [instance, icon]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && label !== undefined) {\n            instance.setLabel(label);\n        }\n    }, [instance, label]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && opacity !== undefined) {\n            instance.setOpacity(opacity);\n        }\n    }, [instance, opacity]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && shape !== undefined) {\n            instance.setShape(shape);\n        }\n    }, [instance, shape]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && title !== undefined) {\n            instance.setTitle(title);\n        }\n    }, [instance, title]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && zIndex !== undefined) {\n            instance.setZIndex(zIndex);\n        }\n    }, [instance, zIndex]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClickableChanged) {\n            if (clickableChangedListener !== null) {\n                google.maps.event.removeListener(clickableChangedListener);\n            }\n            setClickableChangedListener(google.maps.event.addListener(instance, 'clickable_changed', onClickableChanged));\n        }\n    }, [onClickableChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onCursorChanged) {\n            if (cursorChangedListener !== null) {\n                google.maps.event.removeListener(cursorChangedListener);\n            }\n            setCursorChangedListener(google.maps.event.addListener(instance, 'cursor_changed', onCursorChanged));\n        }\n    }, [onCursorChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onAnimationChanged) {\n            if (animationChangedListener !== null) {\n                google.maps.event.removeListener(animationChangedListener);\n            }\n            setAnimationChangedListener(google.maps.event.addListener(instance, 'animation_changed', onAnimationChanged));\n        }\n    }, [onAnimationChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDraggableChanged) {\n            if (draggableChangedListener !== null) {\n                google.maps.event.removeListener(draggableChangedListener);\n            }\n            setDraggableChangedListener(google.maps.event.addListener(instance, 'draggable_changed', onDraggableChanged));\n        }\n    }, [onDraggableChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onFlatChanged) {\n            if (flatChangedListener !== null) {\n                google.maps.event.removeListener(flatChangedListener);\n            }\n            setFlatChangedListener(google.maps.event.addListener(instance, 'flat_changed', onFlatChanged));\n        }\n    }, [onFlatChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onIconChanged) {\n            if (iconChangedListener !== null) {\n                google.maps.event.removeListener(iconChangedListener);\n            }\n            setIconChangedListener(google.maps.event.addListener(instance, 'icon_changed', onIconChanged));\n        }\n    }, [onIconChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onPositionChanged) {\n            if (positionChangedListener !== null) {\n                google.maps.event.removeListener(positionChangedListener);\n            }\n            setPositionChangedListener(google.maps.event.addListener(instance, 'position_changed', onPositionChanged));\n        }\n    }, [onPositionChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onShapeChanged) {\n            if (shapeChangedListener !== null) {\n                google.maps.event.removeListener(shapeChangedListener);\n            }\n            setShapeChangedListener(google.maps.event.addListener(instance, 'shape_changed', onShapeChanged));\n        }\n    }, [onShapeChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onTitleChanged) {\n            if (titleChangedListener !== null) {\n                google.maps.event.removeListener(titleChangedListener);\n            }\n            setTitleChangedListener(google.maps.event.addListener(instance, 'title_changed', onTitleChanged));\n        }\n    }, [onTitleChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onVisibleChanged) {\n            if (visibleChangedListener !== null) {\n                google.maps.event.removeListener(visibleChangedListener);\n            }\n            setVisibleChangedListener(google.maps.event.addListener(instance, 'visible_changed', onVisibleChanged));\n        }\n    }, [onVisibleChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onZindexChanged) {\n            if (zIndexChangedListener !== null) {\n                google.maps.event.removeListener(zIndexChangedListener);\n            }\n            setZindexChangedListener(google.maps.event.addListener(instance, 'zindex_changed', onZindexChanged));\n        }\n    }, [onZindexChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var markerOptions = __assign(__assign(__assign({}, (options || defaultOptions$5)), (clusterer ? defaultOptions$5 : { map: map })), { position: position });\n        var marker = new google.maps.Marker(markerOptions);\n        if (clusterer) {\n            clusterer.addMarker(marker, !!noClustererRedraw);\n        }\n        else {\n            marker.setMap(map);\n        }\n        if (position) {\n            marker.setPosition(position);\n        }\n        if (typeof visible !== 'undefined') {\n            marker.setVisible(visible);\n        }\n        if (typeof draggable !== 'undefined') {\n            marker.setDraggable(draggable);\n        }\n        if (typeof clickable !== 'undefined') {\n            marker.setClickable(clickable);\n        }\n        if (typeof cursor === 'string') {\n            marker.setCursor(cursor);\n        }\n        if (icon) {\n            marker.setIcon(icon);\n        }\n        if (typeof label !== 'undefined') {\n            marker.setLabel(label);\n        }\n        if (typeof opacity !== 'undefined') {\n            marker.setOpacity(opacity);\n        }\n        if (shape) {\n            marker.setShape(shape);\n        }\n        if (typeof title === 'string') {\n            marker.setTitle(title);\n        }\n        if (typeof zIndex === 'number') {\n            marker.setZIndex(zIndex);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(marker, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(marker, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(marker, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(marker, 'mousedown', onMouseDown));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(marker, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(marker, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(marker, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightclickListener(google.maps.event.addListener(marker, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(marker, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(marker, 'drag', onDrag));\n        }\n        if (onClickableChanged) {\n            setClickableChangedListener(google.maps.event.addListener(marker, 'clickable_changed', onClickableChanged));\n        }\n        if (onCursorChanged) {\n            setCursorChangedListener(google.maps.event.addListener(marker, 'cursor_changed', onCursorChanged));\n        }\n        if (onAnimationChanged) {\n            setAnimationChangedListener(google.maps.event.addListener(marker, 'animation_changed', onAnimationChanged));\n        }\n        if (onDraggableChanged) {\n            setDraggableChangedListener(google.maps.event.addListener(marker, 'draggable_changed', onDraggableChanged));\n        }\n        if (onFlatChanged) {\n            setFlatChangedListener(google.maps.event.addListener(marker, 'flat_changed', onFlatChanged));\n        }\n        if (onIconChanged) {\n            setIconChangedListener(google.maps.event.addListener(marker, 'icon_changed', onIconChanged));\n        }\n        if (onPositionChanged) {\n            setPositionChangedListener(google.maps.event.addListener(marker, 'position_changed', onPositionChanged));\n        }\n        if (onShapeChanged) {\n            setShapeChangedListener(google.maps.event.addListener(marker, 'shape_changed', onShapeChanged));\n        }\n        if (onTitleChanged) {\n            setTitleChangedListener(google.maps.event.addListener(marker, 'title_changed', onTitleChanged));\n        }\n        if (onVisibleChanged) {\n            setVisibleChangedListener(google.maps.event.addListener(marker, 'visible_changed', onVisibleChanged));\n        }\n        if (onZindexChanged) {\n            setZindexChangedListener(google.maps.event.addListener(marker, 'zindex_changed', onZindexChanged));\n        }\n        setInstance(marker);\n        if (onLoad) {\n            onLoad(marker);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (clickableChangedListener !== null) {\n                google.maps.event.removeListener(clickableChangedListener);\n            }\n            if (cursorChangedListener !== null) {\n                google.maps.event.removeListener(cursorChangedListener);\n            }\n            if (animationChangedListener !== null) {\n                google.maps.event.removeListener(animationChangedListener);\n            }\n            if (draggableChangedListener !== null) {\n                google.maps.event.removeListener(draggableChangedListener);\n            }\n            if (flatChangedListener !== null) {\n                google.maps.event.removeListener(flatChangedListener);\n            }\n            if (iconChangedListener !== null) {\n                google.maps.event.removeListener(iconChangedListener);\n            }\n            if (positionChangedListener !== null) {\n                google.maps.event.removeListener(positionChangedListener);\n            }\n            if (titleChangedListener !== null) {\n                google.maps.event.removeListener(titleChangedListener);\n            }\n            if (visibleChangedListener !== null) {\n                google.maps.event.removeListener(visibleChangedListener);\n            }\n            if (zIndexChangedListener !== null) {\n                google.maps.event.removeListener(zIndexChangedListener);\n            }\n            if (onUnmount) {\n                onUnmount(marker);\n            }\n            if (clusterer) {\n                clusterer.removeMarker(marker, !!noClustererRedraw);\n            }\n            else if (marker) {\n                marker.setMap(null);\n            }\n        };\n    }, []);\n    var chx = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        return children\n            ? react__WEBPACK_IMPORTED_MODULE_1__.Children.map(children, function (child) {\n                if (!(0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(child)) {\n                    return child;\n                }\n                var elementChild = child;\n                return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(elementChild, { anchor: instance });\n            })\n            : null;\n    }, [children, instance]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: chx }) || null;\n}\nvar MarkerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerFunctional);\nvar Marker = /** @class */ (function (_super) {\n    __extends(Marker, _super);\n    function Marker() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        return _this;\n    }\n    Marker.prototype.componentDidMount = function () {\n        var markerOptions = __assign(__assign(__assign({}, (this.props.options || defaultOptions$5)), (this.props.clusterer ? defaultOptions$5 : { map: this.context })), { position: this.props.position });\n        // Unfortunately we can't just do this in the contstructor, because the\n        // `MapContext` might not be filled in yet.\n        this.marker = new google.maps.Marker(markerOptions);\n        if (this.props.clusterer) {\n            this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw);\n        }\n        else {\n            this.marker.setMap(this.context);\n        }\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$f,\n            eventMap: eventMap$f,\n            prevProps: {},\n            nextProps: this.props,\n            instance: this.marker,\n        });\n        if (this.props.onLoad) {\n            this.props.onLoad(this.marker);\n        }\n    };\n    Marker.prototype.componentDidUpdate = function (prevProps) {\n        if (this.marker) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$f,\n                eventMap: eventMap$f,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.marker,\n            });\n        }\n    };\n    Marker.prototype.componentWillUnmount = function () {\n        if (this.marker) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.marker);\n            }\n            unregisterEvents(this.registeredEvents);\n            if (this.props.clusterer) {\n                this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw);\n            }\n            else {\n                this.marker && this.marker.setMap(null);\n            }\n        }\n    };\n    Marker.prototype.render = function () {\n        var _this = this;\n        var children = null;\n        if (this.props.children) {\n            children = react__WEBPACK_IMPORTED_MODULE_1__.Children.map(this.props.children, function (child) {\n                if (!(0,react__WEBPACK_IMPORTED_MODULE_1__.isValidElement)(child)) {\n                    return child;\n                }\n                var elementChild = child;\n                return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(elementChild, { anchor: _this.marker });\n            });\n        }\n        return children || null;\n    };\n    Marker.contextType = MapContext;\n    return Marker;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar ClusterIcon = /** @class */ (function () {\n    function ClusterIcon(cluster, styles) {\n        cluster.getClusterer().extend(ClusterIcon, google.maps.OverlayView);\n        this.cluster = cluster;\n        this.clusterClassName = this.cluster.getClusterer().getClusterClass();\n        this.className = this.clusterClassName;\n        this.styles = styles;\n        this.center = undefined;\n        this.div = null;\n        this.sums = null;\n        this.visible = false;\n        this.boundsChangedListener = null;\n        this.url = '';\n        this.height = 0;\n        this.width = 0;\n        this.anchorText = [0, 0];\n        this.anchorIcon = [0, 0];\n        this.textColor = 'black';\n        this.textSize = 11;\n        this.textDecoration = 'none';\n        this.fontWeight = 'bold';\n        this.fontStyle = 'normal';\n        this.fontFamily = 'Arial,sans-serif';\n        this.backgroundPosition = '0 0';\n        this.cMouseDownInCluster = null;\n        this.cDraggingMapByCluster = null;\n        this.timeOut = null;\n        this.setMap(cluster.getMap()); // Note: this causes onAdd to be called\n        this.onBoundsChanged = this.onBoundsChanged.bind(this);\n        this.onMouseDown = this.onMouseDown.bind(this);\n        this.onClick = this.onClick.bind(this);\n        this.onMouseOver = this.onMouseOver.bind(this);\n        this.onMouseOut = this.onMouseOut.bind(this);\n        this.onAdd = this.onAdd.bind(this);\n        this.onRemove = this.onRemove.bind(this);\n        this.draw = this.draw.bind(this);\n        this.hide = this.hide.bind(this);\n        this.show = this.show.bind(this);\n        this.useStyle = this.useStyle.bind(this);\n        this.setCenter = this.setCenter.bind(this);\n        this.getPosFromLatLng = this.getPosFromLatLng.bind(this);\n    }\n    ClusterIcon.prototype.onBoundsChanged = function () {\n        this.cDraggingMapByCluster = this.cMouseDownInCluster;\n    };\n    ClusterIcon.prototype.onMouseDown = function () {\n        this.cMouseDownInCluster = true;\n        this.cDraggingMapByCluster = false;\n    };\n    ClusterIcon.prototype.onClick = function (event) {\n        this.cMouseDownInCluster = false;\n        if (!this.cDraggingMapByCluster) {\n            var markerClusterer_1 = this.cluster.getClusterer();\n            /**\n             * This event is fired when a cluster marker is clicked.\n             * @name MarkerClusterer#click\n             * @param {Cluster} c The cluster that was clicked.\n             * @event\n             */\n            google.maps.event.trigger(markerClusterer_1, 'click', this.cluster);\n            google.maps.event.trigger(markerClusterer_1, 'clusterclick', this.cluster); // deprecated name\n            // The default click handler follows. Disable it by setting\n            // the zoomOnClick property to false.\n            if (markerClusterer_1.getZoomOnClick()) {\n                // Zoom into the cluster.\n                var maxZoom_1 = markerClusterer_1.getMaxZoom();\n                var bounds_1 = this.cluster.getBounds();\n                var map = markerClusterer_1.getMap();\n                if (map !== null && 'fitBounds' in map) {\n                    map.fitBounds(bounds_1);\n                }\n                // There is a fix for Issue 170 here:\n                this.timeOut = window.setTimeout(function () {\n                    var map = markerClusterer_1.getMap();\n                    if (map !== null) {\n                        if ('fitBounds' in map) {\n                            map.fitBounds(bounds_1);\n                        }\n                        var zoom = map.getZoom() || 0;\n                        // Don't zoom beyond the max zoom level\n                        if (maxZoom_1 !== null &&\n                            zoom > maxZoom_1) {\n                            map.setZoom(maxZoom_1 + 1);\n                        }\n                    }\n                }, 100);\n            }\n            // Prevent event propagation to the map:\n            event.cancelBubble = true;\n            if (event.stopPropagation) {\n                event.stopPropagation();\n            }\n        }\n    };\n    ClusterIcon.prototype.onMouseOver = function () {\n        /**\n         * This event is fired when the mouse moves over a cluster marker.\n         * @name MarkerClusterer#mouseover\n         * @param {Cluster} c The cluster that the mouse moved over.\n         * @event\n         */\n        google.maps.event.trigger(this.cluster.getClusterer(), 'mouseover', this.cluster);\n    };\n    ClusterIcon.prototype.onMouseOut = function () {\n        /**\n         * This event is fired when the mouse moves out of a cluster marker.\n         * @name MarkerClusterer#mouseout\n         * @param {Cluster} c The cluster that the mouse moved out of.\n         * @event\n         */\n        google.maps.event.trigger(this.cluster.getClusterer(), 'mouseout', this.cluster);\n    };\n    ClusterIcon.prototype.onAdd = function () {\n        var _a;\n        this.div = document.createElement('div');\n        this.div.className = this.className;\n        if (this.visible) {\n            this.show();\n        }\n        (_a = this.getPanes()) === null || _a === void 0 ? void 0 : _a.overlayMouseTarget.appendChild(this.div);\n        var map = this.getMap();\n        if (map !== null) {\n            // Fix for Issue 157\n            this.boundsChangedListener = google.maps.event.addListener(map, 'bounds_changed', this.onBoundsChanged);\n            this.div.addEventListener('mousedown', this.onMouseDown);\n            this.div.addEventListener('click', this.onClick);\n            this.div.addEventListener('mouseover', this.onMouseOver);\n            this.div.addEventListener('mouseout', this.onMouseOut);\n        }\n    };\n    ClusterIcon.prototype.onRemove = function () {\n        if (this.div && this.div.parentNode) {\n            this.hide();\n            if (this.boundsChangedListener !== null) {\n                google.maps.event.removeListener(this.boundsChangedListener);\n            }\n            this.div.removeEventListener('mousedown', this.onMouseDown);\n            this.div.removeEventListener('click', this.onClick);\n            this.div.removeEventListener('mouseover', this.onMouseOver);\n            this.div.removeEventListener('mouseout', this.onMouseOut);\n            this.div.parentNode.removeChild(this.div);\n            if (this.timeOut !== null) {\n                window.clearTimeout(this.timeOut);\n                this.timeOut = null;\n            }\n            this.div = null;\n        }\n    };\n    ClusterIcon.prototype.draw = function () {\n        if (this.visible && this.div !== null && this.center) {\n            var pos = this.getPosFromLatLng(this.center);\n            this.div.style.top = pos !== null ? \"\".concat(pos.y, \"px\") : '0';\n            this.div.style.left = pos !== null ? \"\".concat(pos.x, \"px\") : '0';\n        }\n    };\n    ClusterIcon.prototype.hide = function () {\n        if (this.div) {\n            this.div.style.display = 'none';\n        }\n        this.visible = false;\n    };\n    ClusterIcon.prototype.show = function () {\n        var _a, _b, _c, _d, _e, _f;\n        if (this.div && this.center) {\n            var divTitle = this.sums === null ||\n                typeof this.sums.title === 'undefined' ||\n                this.sums.title === '' ? this.cluster.getClusterer().getTitle() : this.sums.title;\n            // NOTE: values must be specified in px units\n            var bp = this.backgroundPosition.split(' ');\n            var spriteH = parseInt(((_a = bp[0]) === null || _a === void 0 ? void 0 : _a.replace(/^\\s+|\\s+$/g, '')) || '0', 10);\n            var spriteV = parseInt(((_b = bp[1]) === null || _b === void 0 ? void 0 : _b.replace(/^\\s+|\\s+$/g, '')) || '0', 10);\n            var pos = this.getPosFromLatLng(this.center);\n            this.div.className = this.className;\n            this.div.setAttribute('style', \"cursor: pointer; position: absolute; top: \".concat(pos !== null ? \"\".concat(pos.y, \"px\") : '0', \"; left: \").concat(pos !== null ? \"\".concat(pos.x, \"px\") : '0', \"; width: \").concat(this.width, \"px; height: \").concat(this.height, \"px; \"));\n            var img = document.createElement('img');\n            img.alt = divTitle;\n            img.src = this.url;\n            img.width = this.width;\n            img.height = this.height;\n            img.setAttribute('style', \"position: absolute; top: \".concat(spriteV, \"px; left: \").concat(spriteH, \"px\"));\n            if (!this.cluster.getClusterer().enableRetinaIcons) {\n                img.style.clip = \"rect(-\".concat(spriteV, \"px, -\").concat(spriteH + this.width, \"px, -\").concat(spriteV + this.height, \", -\").concat(spriteH, \")\");\n            }\n            var textElm = document.createElement('div');\n            textElm.setAttribute('style', \"position: absolute; top: \".concat(this.anchorText[0], \"px; left: \").concat(this.anchorText[1], \"px; color: \").concat(this.textColor, \"; font-size: \").concat(this.textSize, \"px; font-family: \").concat(this.fontFamily, \"; font-weight: \").concat(this.fontWeight, \"; fontStyle: \").concat(this.fontStyle, \"; text-decoration: \").concat(this.textDecoration, \"; text-align: center; width: \").concat(this.width, \"px; line-height: \").concat(this.height, \"px\"));\n            if ((_c = this.sums) === null || _c === void 0 ? void 0 : _c.text)\n                textElm.innerText = \"\".concat((_d = this.sums) === null || _d === void 0 ? void 0 : _d.text);\n            if ((_e = this.sums) === null || _e === void 0 ? void 0 : _e.html)\n                textElm.innerHTML = \"\".concat((_f = this.sums) === null || _f === void 0 ? void 0 : _f.html);\n            this.div.innerHTML = '';\n            this.div.appendChild(img);\n            this.div.appendChild(textElm);\n            this.div.title = divTitle;\n            this.div.style.display = '';\n        }\n        this.visible = true;\n    };\n    ClusterIcon.prototype.useStyle = function (sums) {\n        this.sums = sums;\n        var styles = this.cluster.getClusterer().getStyles();\n        var style = styles[Math.min(styles.length - 1, Math.max(0, sums.index - 1))];\n        if (style) {\n            this.url = style.url;\n            this.height = style.height;\n            this.width = style.width;\n            if (style.className) {\n                this.className = \"\".concat(this.clusterClassName, \" \").concat(style.className);\n            }\n            this.anchorText = style.anchorText || [0, 0];\n            this.anchorIcon = style.anchorIcon || [this.height / 2, this.width / 2];\n            this.textColor = style.textColor || 'black';\n            this.textSize = style.textSize || 11;\n            this.textDecoration = style.textDecoration || 'none';\n            this.fontWeight = style.fontWeight || 'bold';\n            this.fontStyle = style.fontStyle || 'normal';\n            this.fontFamily = style.fontFamily || 'Arial,sans-serif';\n            this.backgroundPosition = style.backgroundPosition || '0 0';\n        }\n    };\n    ClusterIcon.prototype.setCenter = function (center) {\n        this.center = center;\n    };\n    ClusterIcon.prototype.getPosFromLatLng = function (latlng) {\n        var pos = this.getProjection().fromLatLngToDivPixel(latlng);\n        if (pos !== null) {\n            pos.x -= this.anchorIcon[1];\n            pos.y -= this.anchorIcon[0];\n        }\n        return pos;\n    };\n    return ClusterIcon;\n}());\n\n/* global google */\nvar Cluster$1 = /** @class */ (function () {\n    function Cluster(markerClusterer) {\n        this.markerClusterer = markerClusterer;\n        this.map = this.markerClusterer.getMap();\n        this.gridSize = this.markerClusterer.getGridSize();\n        this.minClusterSize = this.markerClusterer.getMinimumClusterSize();\n        this.averageCenter = this.markerClusterer.getAverageCenter();\n        this.markers = [];\n        this.center = undefined;\n        this.bounds = null;\n        this.clusterIcon = new ClusterIcon(this, this.markerClusterer.getStyles());\n        this.getSize = this.getSize.bind(this);\n        this.getMarkers = this.getMarkers.bind(this);\n        this.getCenter = this.getCenter.bind(this);\n        this.getMap = this.getMap.bind(this);\n        this.getClusterer = this.getClusterer.bind(this);\n        this.getBounds = this.getBounds.bind(this);\n        this.remove = this.remove.bind(this);\n        this.addMarker = this.addMarker.bind(this);\n        this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this);\n        this.calculateBounds = this.calculateBounds.bind(this);\n        this.updateIcon = this.updateIcon.bind(this);\n        this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);\n    }\n    Cluster.prototype.getSize = function () {\n        return this.markers.length;\n    };\n    Cluster.prototype.getMarkers = function () {\n        return this.markers;\n    };\n    Cluster.prototype.getCenter = function () {\n        return this.center;\n    };\n    Cluster.prototype.getMap = function () {\n        return this.map;\n    };\n    Cluster.prototype.getClusterer = function () {\n        return this.markerClusterer;\n    };\n    Cluster.prototype.getBounds = function () {\n        var bounds = new google.maps.LatLngBounds(this.center, this.center);\n        var markers = this.getMarkers();\n        for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {\n            var marker = markers_1[_i];\n            var position = marker.getPosition();\n            if (position) {\n                bounds.extend(position);\n            }\n        }\n        return bounds;\n    };\n    Cluster.prototype.remove = function () {\n        this.clusterIcon.setMap(null);\n        this.markers = [];\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        delete this.markers;\n    };\n    Cluster.prototype.addMarker = function (marker) {\n        var _a;\n        if (this.isMarkerAlreadyAdded(marker)) {\n            return false;\n        }\n        if (!this.center) {\n            var position = marker.getPosition();\n            if (position) {\n                this.center = position;\n                this.calculateBounds();\n            }\n        }\n        else {\n            if (this.averageCenter) {\n                var position = marker.getPosition();\n                if (position) {\n                    var length_1 = this.markers.length + 1;\n                    this.center = new google.maps.LatLng((this.center.lat() * (length_1 - 1) + position.lat()) / length_1, (this.center.lng() * (length_1 - 1) + position.lng()) / length_1);\n                    this.calculateBounds();\n                }\n            }\n        }\n        marker.isAdded = true;\n        this.markers.push(marker);\n        var mCount = this.markers.length;\n        var maxZoom = this.markerClusterer.getMaxZoom();\n        var zoom = (_a = this.map) === null || _a === void 0 ? void 0 : _a.getZoom();\n        if (maxZoom !== null && typeof zoom !== 'undefined' && zoom > maxZoom) {\n            // Zoomed in past max zoom, so show the marker.\n            if (marker.getMap() !== this.map) {\n                marker.setMap(this.map);\n            }\n        }\n        else if (mCount < this.minClusterSize) {\n            // Min cluster size not reached so show the marker.\n            if (marker.getMap() !== this.map) {\n                marker.setMap(this.map);\n            }\n        }\n        else if (mCount === this.minClusterSize) {\n            // Hide the markers that were showing.\n            for (var _i = 0, _b = this.markers; _i < _b.length; _i++) {\n                var markerElement = _b[_i];\n                markerElement.setMap(null);\n            }\n        }\n        else {\n            marker.setMap(null);\n        }\n        return true;\n    };\n    Cluster.prototype.isMarkerInClusterBounds = function (marker) {\n        if (this.bounds !== null) {\n            var position = marker.getPosition();\n            if (position) {\n                return this.bounds.contains(position);\n            }\n        }\n        return false;\n    };\n    Cluster.prototype.calculateBounds = function () {\n        this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));\n    };\n    Cluster.prototype.updateIcon = function () {\n        var _a;\n        var mCount = this.markers.length;\n        var maxZoom = this.markerClusterer.getMaxZoom();\n        var zoom = (_a = this.map) === null || _a === void 0 ? void 0 : _a.getZoom();\n        if (maxZoom !== null && typeof zoom !== 'undefined' && zoom > maxZoom) {\n            this.clusterIcon.hide();\n            return;\n        }\n        if (mCount < this.minClusterSize) {\n            // Min cluster size not yet reached.\n            this.clusterIcon.hide();\n            return;\n        }\n        if (this.center) {\n            this.clusterIcon.setCenter(this.center);\n        }\n        this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length));\n        this.clusterIcon.show();\n    };\n    Cluster.prototype.isMarkerAlreadyAdded = function (marker) {\n        if (this.markers.includes) {\n            return this.markers.includes(marker);\n        }\n        for (var i = 0; i < this.markers.length; i++) {\n            if (marker === this.markers[i]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    return Cluster;\n}());\n\n/* global google */\n/**\n * Supports up to 9007199254740991 (Number.MAX_SAFE_INTEGER) markers\n * which is not a problem as max array length is 4294967296 (2**32)\n */\nfunction CALCULATOR(markers, numStyles) {\n    var count = markers.length;\n    var numberOfDigits = count.toString().length;\n    var index = Math.min(numberOfDigits, numStyles);\n    return {\n        text: count.toString(),\n        index: index,\n        title: '',\n    };\n}\nvar BATCH_SIZE = 2000;\nvar BATCH_SIZE_IE = 500;\nvar IMAGE_PATH = 'https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m';\nvar IMAGE_EXTENSION = 'png';\nvar IMAGE_SIZES = [53, 56, 66, 78, 90];\nvar CLUSTERER_CLASS = 'cluster';\nvar Clusterer = /** @class */ (function () {\n    function Clusterer(map, optMarkers, optOptions) {\n        if (optMarkers === void 0) { optMarkers = []; }\n        if (optOptions === void 0) { optOptions = {}; }\n        this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this);\n        this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this);\n        this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this);\n        this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this);\n        this.addToClosestCluster = this.addToClosestCluster.bind(this);\n        this.getImageExtension = this.getImageExtension.bind(this);\n        this.setImageExtension = this.setImageExtension.bind(this);\n        this.getExtendedBounds = this.getExtendedBounds.bind(this);\n        this.getAverageCenter = this.getAverageCenter.bind(this);\n        this.setAverageCenter = this.setAverageCenter.bind(this);\n        this.getTotalClusters = this.getTotalClusters.bind(this);\n        this.fitMapToMarkers = this.fitMapToMarkers.bind(this);\n        this.getIgnoreHidden = this.getIgnoreHidden.bind(this);\n        this.setIgnoreHidden = this.setIgnoreHidden.bind(this);\n        this.getClusterClass = this.getClusterClass.bind(this);\n        this.setClusterClass = this.setClusterClass.bind(this);\n        this.getTotalMarkers = this.getTotalMarkers.bind(this);\n        this.getZoomOnClick = this.getZoomOnClick.bind(this);\n        this.setZoomOnClick = this.setZoomOnClick.bind(this);\n        this.getBatchSizeIE = this.getBatchSizeIE.bind(this);\n        this.setBatchSizeIE = this.setBatchSizeIE.bind(this);\n        this.createClusters = this.createClusters.bind(this);\n        this.onZoomChanged = this.onZoomChanged.bind(this);\n        this.getImageSizes = this.getImageSizes.bind(this);\n        this.setImageSizes = this.setImageSizes.bind(this);\n        this.getCalculator = this.getCalculator.bind(this);\n        this.setCalculator = this.setCalculator.bind(this);\n        this.removeMarkers = this.removeMarkers.bind(this);\n        this.resetViewport = this.resetViewport.bind(this);\n        this.getImagePath = this.getImagePath.bind(this);\n        this.setImagePath = this.setImagePath.bind(this);\n        this.pushMarkerTo = this.pushMarkerTo.bind(this);\n        this.removeMarker = this.removeMarker.bind(this);\n        this.clearMarkers = this.clearMarkers.bind(this);\n        this.setupStyles = this.setupStyles.bind(this);\n        this.getGridSize = this.getGridSize.bind(this);\n        this.setGridSize = this.setGridSize.bind(this);\n        this.getClusters = this.getClusters.bind(this);\n        this.getMaxZoom = this.getMaxZoom.bind(this);\n        this.setMaxZoom = this.setMaxZoom.bind(this);\n        this.getMarkers = this.getMarkers.bind(this);\n        this.addMarkers = this.addMarkers.bind(this);\n        this.getStyles = this.getStyles.bind(this);\n        this.setStyles = this.setStyles.bind(this);\n        this.addMarker = this.addMarker.bind(this);\n        this.onRemove = this.onRemove.bind(this);\n        this.getTitle = this.getTitle.bind(this);\n        this.setTitle = this.setTitle.bind(this);\n        this.repaint = this.repaint.bind(this);\n        this.onIdle = this.onIdle.bind(this);\n        this.redraw = this.redraw.bind(this);\n        this.onAdd = this.onAdd.bind(this);\n        this.draw = this.draw.bind(this);\n        this.extend = this.extend.bind(this);\n        this.extend(Clusterer, google.maps.OverlayView);\n        this.markers = [];\n        this.clusters = [];\n        this.listeners = [];\n        this.activeMap = null;\n        this.ready = false;\n        this.gridSize = optOptions.gridSize || 60;\n        this.minClusterSize = optOptions.minimumClusterSize || 2;\n        this.maxZoom = optOptions.maxZoom || null;\n        this.styles = optOptions.styles || [];\n        this.title = optOptions.title || '';\n        this.zoomOnClick = true;\n        if (optOptions.zoomOnClick !== undefined) {\n            this.zoomOnClick = optOptions.zoomOnClick;\n        }\n        this.averageCenter = false;\n        if (optOptions.averageCenter !== undefined) {\n            this.averageCenter = optOptions.averageCenter;\n        }\n        this.ignoreHidden = false;\n        if (optOptions.ignoreHidden !== undefined) {\n            this.ignoreHidden = optOptions.ignoreHidden;\n        }\n        this.enableRetinaIcons = false;\n        if (optOptions.enableRetinaIcons !== undefined) {\n            this.enableRetinaIcons = optOptions.enableRetinaIcons;\n        }\n        this.imagePath = optOptions.imagePath || IMAGE_PATH;\n        this.imageExtension = optOptions.imageExtension || IMAGE_EXTENSION;\n        this.imageSizes = optOptions.imageSizes || IMAGE_SIZES;\n        this.calculator = optOptions.calculator || CALCULATOR;\n        this.batchSize = optOptions.batchSize || BATCH_SIZE;\n        this.batchSizeIE = optOptions.batchSizeIE || BATCH_SIZE_IE;\n        this.clusterClass = optOptions.clusterClass || CLUSTERER_CLASS;\n        if (navigator.userAgent.toLowerCase().indexOf('msie') !== -1) {\n            // Try to avoid IE timeout when processing a huge number of markers:\n            this.batchSize = this.batchSizeIE;\n        }\n        this.timerRefStatic = null;\n        this.setupStyles();\n        this.addMarkers(optMarkers, true);\n        this.setMap(map); // Note: this causes onAdd to be called\n    }\n    Clusterer.prototype.onZoomChanged = function () {\n        var _a, _b;\n        this.resetViewport(false);\n        // Workaround for this Google bug: when map is at level 0 and \"-\" of\n        // zoom slider is clicked, a \"zoom_changed\" event is fired even though\n        // the map doesn't zoom out any further. In this situation, no \"idle\"\n        // event is triggered so the cluster markers that have been removed\n        // do not get redrawn. Same goes for a zoom in at maxZoom.\n        if (((_a = this.getMap()) === null || _a === void 0 ? void 0 : _a.getZoom()) === (this.get('minZoom') || 0) ||\n            ((_b = this.getMap()) === null || _b === void 0 ? void 0 : _b.getZoom()) === this.get('maxZoom')) {\n            google.maps.event.trigger(this, 'idle');\n        }\n    };\n    Clusterer.prototype.onIdle = function () {\n        this.redraw();\n    };\n    Clusterer.prototype.onAdd = function () {\n        var map = this.getMap();\n        this.activeMap = map;\n        this.ready = true;\n        this.repaint();\n        if (map !== null) {\n            // Add the map event listeners\n            this.listeners = [\n                google.maps.event.addListener(map, 'zoom_changed', this.onZoomChanged),\n                google.maps.event.addListener(map, 'idle', this.onIdle),\n            ];\n        }\n    };\n    Clusterer.prototype.onRemove = function () {\n        // Put all the managed markers back on the map:\n        for (var _i = 0, _a = this.markers; _i < _a.length; _i++) {\n            var marker = _a[_i];\n            if (marker.getMap() !== this.activeMap) {\n                marker.setMap(this.activeMap);\n            }\n        }\n        // Remove all clusters:\n        for (var _b = 0, _c = this.clusters; _b < _c.length; _b++) {\n            var cluster = _c[_b];\n            cluster.remove();\n        }\n        this.clusters = [];\n        // Remove map event listeners:\n        for (var _d = 0, _e = this.listeners; _d < _e.length; _d++) {\n            var listener = _e[_d];\n            google.maps.event.removeListener(listener);\n        }\n        this.listeners = [];\n        this.activeMap = null;\n        this.ready = false;\n    };\n    Clusterer.prototype.draw = function () { return; };\n    Clusterer.prototype.getMap = function () { return null; };\n    Clusterer.prototype.getPanes = function () { return null; };\n    Clusterer.prototype.getProjection = function () {\n        return {\n            fromContainerPixelToLatLng: function () { return null; },\n            fromDivPixelToLatLng: function () { return null; },\n            fromLatLngToContainerPixel: function () { return null; },\n            fromLatLngToDivPixel: function () { return null; },\n            getVisibleRegion: function () { return null; },\n            getWorldWidth: function () { return 0; }\n        };\n    };\n    Clusterer.prototype.setMap = function () { return; };\n    Clusterer.prototype.addListener = function () {\n        return {\n            remove: function () { return; }\n        };\n    };\n    Clusterer.prototype.bindTo = function () { return; };\n    Clusterer.prototype.get = function () { return; };\n    Clusterer.prototype.notify = function () { return; };\n    Clusterer.prototype.set = function () { return; };\n    Clusterer.prototype.setValues = function () { return; };\n    Clusterer.prototype.unbind = function () { return; };\n    Clusterer.prototype.unbindAll = function () { return; };\n    Clusterer.prototype.setupStyles = function () {\n        if (this.styles.length > 0) {\n            return;\n        }\n        for (var i = 0; i < this.imageSizes.length; i++) {\n            this.styles.push({\n                url: \"\".concat(this.imagePath + (i + 1), \".\").concat(this.imageExtension),\n                height: this.imageSizes[i] || 0,\n                width: this.imageSizes[i] || 0,\n            });\n        }\n    };\n    Clusterer.prototype.fitMapToMarkers = function () {\n        var markers = this.getMarkers();\n        var bounds = new google.maps.LatLngBounds();\n        for (var _i = 0, markers_1 = markers; _i < markers_1.length; _i++) {\n            var marker = markers_1[_i];\n            var position = marker.getPosition();\n            if (position) {\n                bounds.extend(position);\n            }\n        }\n        var map = this.getMap();\n        if (map !== null && 'fitBounds' in map) {\n            map.fitBounds(bounds);\n        }\n    };\n    Clusterer.prototype.getGridSize = function () {\n        return this.gridSize;\n    };\n    Clusterer.prototype.setGridSize = function (gridSize) {\n        this.gridSize = gridSize;\n    };\n    Clusterer.prototype.getMinimumClusterSize = function () {\n        return this.minClusterSize;\n    };\n    Clusterer.prototype.setMinimumClusterSize = function (minimumClusterSize) {\n        this.minClusterSize = minimumClusterSize;\n    };\n    Clusterer.prototype.getMaxZoom = function () {\n        return this.maxZoom;\n    };\n    Clusterer.prototype.setMaxZoom = function (maxZoom) {\n        this.maxZoom = maxZoom;\n    };\n    Clusterer.prototype.getStyles = function () {\n        return this.styles;\n    };\n    Clusterer.prototype.setStyles = function (styles) {\n        this.styles = styles;\n    };\n    Clusterer.prototype.getTitle = function () {\n        return this.title;\n    };\n    Clusterer.prototype.setTitle = function (title) {\n        this.title = title;\n    };\n    Clusterer.prototype.getZoomOnClick = function () {\n        return this.zoomOnClick;\n    };\n    Clusterer.prototype.setZoomOnClick = function (zoomOnClick) {\n        this.zoomOnClick = zoomOnClick;\n    };\n    Clusterer.prototype.getAverageCenter = function () {\n        return this.averageCenter;\n    };\n    Clusterer.prototype.setAverageCenter = function (averageCenter) {\n        this.averageCenter = averageCenter;\n    };\n    Clusterer.prototype.getIgnoreHidden = function () {\n        return this.ignoreHidden;\n    };\n    Clusterer.prototype.setIgnoreHidden = function (ignoreHidden) {\n        this.ignoreHidden = ignoreHidden;\n    };\n    Clusterer.prototype.getEnableRetinaIcons = function () {\n        return this.enableRetinaIcons;\n    };\n    Clusterer.prototype.setEnableRetinaIcons = function (enableRetinaIcons) {\n        this.enableRetinaIcons = enableRetinaIcons;\n    };\n    Clusterer.prototype.getImageExtension = function () {\n        return this.imageExtension;\n    };\n    Clusterer.prototype.setImageExtension = function (imageExtension) {\n        this.imageExtension = imageExtension;\n    };\n    Clusterer.prototype.getImagePath = function () {\n        return this.imagePath;\n    };\n    Clusterer.prototype.setImagePath = function (imagePath) {\n        this.imagePath = imagePath;\n    };\n    Clusterer.prototype.getImageSizes = function () {\n        return this.imageSizes;\n    };\n    Clusterer.prototype.setImageSizes = function (imageSizes) {\n        this.imageSizes = imageSizes;\n    };\n    Clusterer.prototype.getCalculator = function () {\n        return this.calculator;\n    };\n    Clusterer.prototype.setCalculator = function (calculator) {\n        this.calculator = calculator;\n    };\n    Clusterer.prototype.getBatchSizeIE = function () {\n        return this.batchSizeIE;\n    };\n    Clusterer.prototype.setBatchSizeIE = function (batchSizeIE) {\n        this.batchSizeIE = batchSizeIE;\n    };\n    Clusterer.prototype.getClusterClass = function () {\n        return this.clusterClass;\n    };\n    Clusterer.prototype.setClusterClass = function (clusterClass) {\n        this.clusterClass = clusterClass;\n    };\n    Clusterer.prototype.getMarkers = function () {\n        return this.markers;\n    };\n    Clusterer.prototype.getTotalMarkers = function () {\n        return this.markers.length;\n    };\n    Clusterer.prototype.getClusters = function () {\n        return this.clusters;\n    };\n    Clusterer.prototype.getTotalClusters = function () {\n        return this.clusters.length;\n    };\n    Clusterer.prototype.addMarker = function (marker, optNoDraw) {\n        this.pushMarkerTo(marker);\n        if (!optNoDraw) {\n            this.redraw();\n        }\n    };\n    Clusterer.prototype.addMarkers = function (markers, optNoDraw) {\n        for (var key in markers) {\n            if (Object.prototype.hasOwnProperty.call(markers, key)) {\n                var marker = markers[key];\n                if (marker) {\n                    this.pushMarkerTo(marker);\n                }\n            }\n        }\n        if (!optNoDraw) {\n            this.redraw();\n        }\n    };\n    Clusterer.prototype.pushMarkerTo = function (marker) {\n        var _this = this;\n        // If the marker is draggable add a listener so we can update the clusters on the dragend:\n        if (marker.getDraggable()) {\n            google.maps.event.addListener(marker, 'dragend', function () {\n                if (_this.ready) {\n                    marker.isAdded = false;\n                    _this.repaint();\n                }\n            });\n        }\n        marker.isAdded = false;\n        this.markers.push(marker);\n    };\n    Clusterer.prototype.removeMarker_ = function (marker) {\n        var index = -1;\n        if (this.markers.indexOf) {\n            index = this.markers.indexOf(marker);\n        }\n        else {\n            for (var i = 0; i < this.markers.length; i++) {\n                if (marker === this.markers[i]) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        if (index === -1) {\n            // Marker is not in our list of markers, so do nothing:\n            return false;\n        }\n        marker.setMap(null);\n        this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n        return true;\n    };\n    Clusterer.prototype.removeMarker = function (marker, optNoDraw) {\n        var removed = this.removeMarker_(marker);\n        if (!optNoDraw && removed) {\n            this.repaint();\n        }\n        return removed;\n    };\n    Clusterer.prototype.removeMarkers = function (markers, optNoDraw) {\n        var removed = false;\n        for (var _i = 0, markers_2 = markers; _i < markers_2.length; _i++) {\n            var marker = markers_2[_i];\n            removed = removed || this.removeMarker_(marker);\n        }\n        if (!optNoDraw && removed) {\n            this.repaint();\n        }\n        return removed;\n    };\n    Clusterer.prototype.clearMarkers = function () {\n        this.resetViewport(true);\n        this.markers = [];\n    };\n    Clusterer.prototype.repaint = function () {\n        var oldClusters = this.clusters.slice();\n        this.clusters = [];\n        this.resetViewport(false);\n        this.redraw();\n        // Remove the old clusters.\n        // Do it in a timeout to prevent blinking effect.\n        setTimeout(function timeout() {\n            for (var _i = 0, oldClusters_1 = oldClusters; _i < oldClusters_1.length; _i++) {\n                var oldCluster = oldClusters_1[_i];\n                oldCluster.remove();\n            }\n        }, 0);\n    };\n    Clusterer.prototype.getExtendedBounds = function (bounds) {\n        var projection = this.getProjection();\n        // Convert the points to pixels and the extend out by the grid size.\n        var trPix = projection.fromLatLngToDivPixel(\n        // Turn the bounds into latlng.\n        new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng()));\n        if (trPix !== null) {\n            trPix.x += this.gridSize;\n            trPix.y -= this.gridSize;\n        }\n        var blPix = projection.fromLatLngToDivPixel(\n        // Turn the bounds into latlng.\n        new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()));\n        if (blPix !== null) {\n            blPix.x -= this.gridSize;\n            blPix.y += this.gridSize;\n        }\n        // Extend the bounds to contain the new bounds.\n        if (trPix !== null) {\n            // Convert the pixel points back to LatLng nw\n            var point1 = projection.fromDivPixelToLatLng(trPix);\n            if (point1 !== null) {\n                bounds.extend(point1);\n            }\n        }\n        if (blPix !== null) {\n            // Convert the pixel points back to LatLng sw\n            var point2 = projection.fromDivPixelToLatLng(blPix);\n            if (point2 !== null) {\n                bounds.extend(point2);\n            }\n        }\n        return bounds;\n    };\n    Clusterer.prototype.redraw = function () {\n        // Redraws all the clusters.\n        this.createClusters(0);\n    };\n    Clusterer.prototype.resetViewport = function (optHide) {\n        // Remove all the clusters\n        for (var _i = 0, _a = this.clusters; _i < _a.length; _i++) {\n            var cluster = _a[_i];\n            cluster.remove();\n        }\n        this.clusters = [];\n        // Reset the markers to not be added and to be removed from the map.\n        for (var _b = 0, _c = this.markers; _b < _c.length; _b++) {\n            var marker = _c[_b];\n            marker.isAdded = false;\n            if (optHide) {\n                marker.setMap(null);\n            }\n        }\n    };\n    Clusterer.prototype.distanceBetweenPoints = function (p1, p2) {\n        var R = 6371; // Radius of the Earth in km\n        var dLat = ((p2.lat() - p1.lat()) * Math.PI) / 180;\n        var dLon = ((p2.lng() - p1.lng()) * Math.PI) / 180;\n        var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos((p1.lat() * Math.PI) / 180) *\n                Math.cos((p2.lat() * Math.PI) / 180) *\n                Math.sin(dLon / 2) *\n                Math.sin(dLon / 2);\n        return R * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));\n    };\n    Clusterer.prototype.isMarkerInBounds = function (marker, bounds) {\n        var position = marker.getPosition();\n        if (position) {\n            return bounds.contains(position);\n        }\n        return false;\n    };\n    Clusterer.prototype.addToClosestCluster = function (marker) {\n        var cluster;\n        var distance = 40000; // Some large number\n        var clusterToAddTo = null;\n        for (var _i = 0, _a = this.clusters; _i < _a.length; _i++) {\n            var clusterElement = _a[_i];\n            cluster = clusterElement;\n            var center = cluster.getCenter();\n            var position = marker.getPosition();\n            if (center && position) {\n                var d = this.distanceBetweenPoints(center, position);\n                if (d < distance) {\n                    distance = d;\n                    clusterToAddTo = cluster;\n                }\n            }\n        }\n        if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) {\n            clusterToAddTo.addMarker(marker);\n        }\n        else {\n            cluster = new Cluster$1(this);\n            cluster.addMarker(marker);\n            this.clusters.push(cluster);\n        }\n    };\n    Clusterer.prototype.createClusters = function (iFirst) {\n        var _this = this;\n        if (!this.ready) {\n            return;\n        }\n        // Cancel previous batch processing if we're working on the first batch:\n        if (iFirst === 0) {\n            /**\n             * This event is fired when the <code>Clusterer</code> begins\n             *  clustering markers.\n             * @name Clusterer#clusteringbegin\n             * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n             * @event\n             */\n            google.maps.event.trigger(this, 'clusteringbegin', this);\n            if (this.timerRefStatic !== null) {\n                window.clearTimeout(this.timerRefStatic);\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                delete this.timerRefStatic;\n            }\n        }\n        var map = this.getMap();\n        var bounds = map !== null && 'getBounds' in map ? map.getBounds() : null;\n        var zoom = (map === null || map === void 0 ? void 0 : map.getZoom()) || 0;\n        // Get our current map view bounds.\n        // Create a new bounds object so we don't affect the map.\n        //\n        // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:\n        var mapBounds = zoom > 3\n            ? new google.maps.LatLngBounds(bounds === null || bounds === void 0 ? void 0 : bounds.getSouthWest(), bounds === null || bounds === void 0 ? void 0 : bounds.getNorthEast())\n            : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));\n        var extendedMapBounds = this.getExtendedBounds(mapBounds);\n        var iLast = Math.min(iFirst + this.batchSize, this.markers.length);\n        for (var i = iFirst; i < iLast; i++) {\n            var marker = this.markers[i];\n            if (marker && !marker.isAdded && this.isMarkerInBounds(marker, extendedMapBounds) && (!this.ignoreHidden || (this.ignoreHidden && marker.getVisible()))) {\n                this.addToClosestCluster(marker);\n            }\n        }\n        if (iLast < this.markers.length) {\n            this.timerRefStatic = window.setTimeout(function () {\n                _this.createClusters(iLast);\n            }, 0);\n        }\n        else {\n            this.timerRefStatic = null;\n            /**\n             * This event is fired when the <code>Clusterer</code> stops\n             *  clustering markers.\n             * @name Clusterer#clusteringend\n             * @param {Clusterer} mc The Clusterer whose markers are being clustered.\n             * @event\n             */\n            google.maps.event.trigger(this, 'clusteringend', this);\n            for (var _i = 0, _a = this.clusters; _i < _a.length; _i++) {\n                var cluster = _a[_i];\n                cluster.updateIcon();\n            }\n        }\n    };\n    Clusterer.prototype.extend = function (obj1, obj2) {\n        return function applyExtend(object) {\n            for (var property in object.prototype) {\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                var prop = property;\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                this.prototype[prop] = object.prototype[prop];\n            }\n            return this;\n        }.apply(obj1, [obj2]);\n    };\n    return Clusterer;\n}());\n\nvar eventMap$e = {\n    onClick: 'click',\n    onClusteringBegin: 'clusteringbegin',\n    onClusteringEnd: 'clusteringend',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n};\nvar updaterMap$e = {\n    averageCenter: function (instance, averageCenter) {\n        instance.setAverageCenter(averageCenter);\n    },\n    batchSizeIE: function (instance, batchSizeIE) {\n        instance.setBatchSizeIE(batchSizeIE);\n    },\n    calculator: function (instance, calculator) {\n        instance.setCalculator(calculator);\n    },\n    clusterClass: function (instance, clusterClass) {\n        instance.setClusterClass(clusterClass);\n    },\n    enableRetinaIcons: function (instance, enableRetinaIcons) {\n        instance.setEnableRetinaIcons(enableRetinaIcons);\n    },\n    gridSize: function (instance, gridSize) {\n        instance.setGridSize(gridSize);\n    },\n    ignoreHidden: function (instance, ignoreHidden) {\n        instance.setIgnoreHidden(ignoreHidden);\n    },\n    imageExtension: function (instance, imageExtension) {\n        instance.setImageExtension(imageExtension);\n    },\n    imagePath: function (instance, imagePath) {\n        instance.setImagePath(imagePath);\n    },\n    imageSizes: function (instance, imageSizes) {\n        instance.setImageSizes(imageSizes);\n    },\n    maxZoom: function (instance, maxZoom) {\n        instance.setMaxZoom(maxZoom);\n    },\n    minimumClusterSize: function (instance, minimumClusterSize) {\n        instance.setMinimumClusterSize(minimumClusterSize);\n    },\n    styles: function (instance, styles) {\n        instance.setStyles(styles);\n    },\n    title: function (instance, title) {\n        instance.setTitle(title);\n    },\n    zoomOnClick: function (instance, zoomOnClick) {\n        instance.setZoomOnClick(zoomOnClick);\n    },\n};\nvar defaultOptions$4 = {};\nfunction MarkerClustererFunctional(props) {\n    var children = props.children, options = props.options, averageCenter = props.averageCenter, batchSizeIE = props.batchSizeIE, calculator = props.calculator, clusterClass = props.clusterClass, enableRetinaIcons = props.enableRetinaIcons, gridSize = props.gridSize, ignoreHidden = props.ignoreHidden, imageExtension = props.imageExtension, imagePath = props.imagePath, imageSizes = props.imageSizes, maxZoom = props.maxZoom, minimumClusterSize = props.minimumClusterSize, styles = props.styles, title = props.title, zoomOnClick = props.zoomOnClick, onClick = props.onClick, onClusteringBegin = props.onClusteringBegin, onClusteringEnd = props.onClusteringEnd, onMouseOver = props.onMouseOver, onMouseOut = props.onMouseOut, onLoad = props.onLoad, onUnmount = props.onUnmount;\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _a[0], setInstance = _a[1];\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clickListener = _b[0], setClickListener = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clusteringBeginListener = _c[0], setClusteringBeginListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clusteringEndListener = _d[0], setClusteringEndListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoutListener = _e[0], setMouseoutListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoverListener = _f[0], setMouseoverListener = _f[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, eventMap$e.onMouseOut, onMouseOut));\n        }\n    }, [onMouseOut]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, eventMap$e.onMouseOver, onMouseOver));\n        }\n    }, [onMouseOver]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, eventMap$e.onClick, onClick));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClusteringBegin) {\n            if (clusteringBeginListener !== null) {\n                google.maps.event.removeListener(clusteringBeginListener);\n            }\n            setClusteringBeginListener(google.maps.event.addListener(instance, eventMap$e.onClusteringBegin, onClusteringBegin));\n        }\n    }, [onClusteringBegin]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClusteringEnd) {\n            if (clusteringEndListener !== null) {\n                google.maps.event.removeListener(clusteringEndListener);\n            }\n            setClusteringBeginListener(google.maps.event.addListener(instance, eventMap$e.onClusteringEnd, onClusteringEnd));\n        }\n    }, [onClusteringEnd]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof averageCenter !== 'undefined' && instance !== null) {\n            updaterMap$e.averageCenter(instance, averageCenter);\n        }\n    }, [instance, averageCenter]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof batchSizeIE !== 'undefined' && instance !== null) {\n            updaterMap$e.batchSizeIE(instance, batchSizeIE);\n        }\n    }, [instance, batchSizeIE]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof calculator !== 'undefined' && instance !== null) {\n            updaterMap$e.calculator(instance, calculator);\n        }\n    }, [instance, calculator]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof clusterClass !== 'undefined' && instance !== null) {\n            updaterMap$e.clusterClass(instance, clusterClass);\n        }\n    }, [instance, clusterClass]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof enableRetinaIcons !== 'undefined' && instance !== null) {\n            updaterMap$e.enableRetinaIcons(instance, enableRetinaIcons);\n        }\n    }, [instance, enableRetinaIcons]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof gridSize !== 'undefined' && instance !== null) {\n            updaterMap$e.gridSize(instance, gridSize);\n        }\n    }, [instance, gridSize]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof ignoreHidden !== 'undefined' && instance !== null) {\n            updaterMap$e.ignoreHidden(instance, ignoreHidden);\n        }\n    }, [instance, ignoreHidden]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof imageExtension !== 'undefined' && instance !== null) {\n            updaterMap$e.imageExtension(instance, imageExtension);\n        }\n    }, [instance, imageExtension]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof imagePath !== 'undefined' && instance !== null) {\n            updaterMap$e.imagePath(instance, imagePath);\n        }\n    }, [instance, imagePath]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof imageSizes !== 'undefined' && instance !== null) {\n            updaterMap$e.imageSizes(instance, imageSizes);\n        }\n    }, [instance, imageSizes]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof maxZoom !== 'undefined' && instance !== null) {\n            updaterMap$e.maxZoom(instance, maxZoom);\n        }\n    }, [instance, maxZoom]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof minimumClusterSize !== 'undefined' && instance !== null) {\n            updaterMap$e.minimumClusterSize(instance, minimumClusterSize);\n        }\n    }, [instance, minimumClusterSize]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof styles !== 'undefined' && instance !== null) {\n            updaterMap$e.styles(instance, styles);\n        }\n    }, [instance, styles]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof title !== 'undefined' && instance !== null) {\n            updaterMap$e.title(instance, title);\n        }\n    }, [instance, title]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof zoomOnClick !== 'undefined' && instance !== null) {\n            updaterMap$e.zoomOnClick(instance, zoomOnClick);\n        }\n    }, [instance, zoomOnClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (!map)\n            return;\n        var clustererOptions = __assign({}, (options || defaultOptions$4));\n        var clusterer = new Clusterer(map, [], clustererOptions);\n        if (averageCenter) {\n            updaterMap$e.averageCenter(clusterer, averageCenter);\n        }\n        if (batchSizeIE) {\n            updaterMap$e.batchSizeIE(clusterer, batchSizeIE);\n        }\n        if (calculator) {\n            updaterMap$e.calculator(clusterer, calculator);\n        }\n        if (clusterClass) {\n            updaterMap$e.clusterClass(clusterer, clusterClass);\n        }\n        if (enableRetinaIcons) {\n            updaterMap$e.enableRetinaIcons(clusterer, enableRetinaIcons);\n        }\n        if (gridSize) {\n            updaterMap$e.gridSize(clusterer, gridSize);\n        }\n        if (ignoreHidden) {\n            updaterMap$e.ignoreHidden(clusterer, ignoreHidden);\n        }\n        if (imageExtension) {\n            updaterMap$e.imageExtension(clusterer, imageExtension);\n        }\n        if (imagePath) {\n            updaterMap$e.imagePath(clusterer, imagePath);\n        }\n        if (imageSizes) {\n            updaterMap$e.imageSizes(clusterer, imageSizes);\n        }\n        if (maxZoom) {\n            updaterMap$e.maxZoom(clusterer, maxZoom);\n        }\n        if (minimumClusterSize) {\n            updaterMap$e.minimumClusterSize(clusterer, minimumClusterSize);\n        }\n        if (styles) {\n            updaterMap$e.styles(clusterer, styles);\n        }\n        if (title) {\n            updaterMap$e.title(clusterer, title);\n        }\n        if (zoomOnClick) {\n            updaterMap$e.zoomOnClick(clusterer, zoomOnClick);\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(clusterer, eventMap$e.onMouseOut, onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(clusterer, eventMap$e.onMouseOver, onMouseOver));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(clusterer, eventMap$e.onClick, onClick));\n        }\n        if (onClusteringBegin) {\n            setClusteringBeginListener(google.maps.event.addListener(clusterer, eventMap$e.onClusteringBegin, onClusteringBegin));\n        }\n        if (onClusteringEnd) {\n            setClusteringEndListener(google.maps.event.addListener(clusterer, eventMap$e.onClusteringEnd, onClusteringEnd));\n        }\n        setInstance(clusterer);\n        if (onLoad) {\n            onLoad(clusterer);\n        }\n        return function () {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (clusteringBeginListener !== null) {\n                google.maps.event.removeListener(clusteringBeginListener);\n            }\n            if (clusteringEndListener !== null) {\n                google.maps.event.removeListener(clusteringEndListener);\n            }\n            if (onUnmount) {\n                onUnmount(clusterer);\n            }\n        };\n    }, []);\n    return instance !== null ? children(instance) || null : null;\n}\nvar MarkerClustererF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerClustererFunctional);\nvar ClustererComponent = /** @class */ (function (_super) {\n    __extends(ClustererComponent, _super);\n    function ClustererComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            markerClusterer: null,\n        };\n        _this.setClustererCallback = function () {\n            if (_this.state.markerClusterer !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.markerClusterer);\n            }\n        };\n        return _this;\n    }\n    ClustererComponent.prototype.componentDidMount = function () {\n        if (this.context) {\n            var markerClusterer_1 = new Clusterer(this.context, [], this.props.options);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$e,\n                eventMap: eventMap$e,\n                prevProps: {},\n                nextProps: this.props,\n                instance: markerClusterer_1,\n            });\n            this.setState(function () {\n                return {\n                    markerClusterer: markerClusterer_1,\n                };\n            }, this.setClustererCallback);\n        }\n    };\n    ClustererComponent.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.markerClusterer) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$e,\n                eventMap: eventMap$e,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.markerClusterer,\n            });\n        }\n    };\n    ClustererComponent.prototype.componentWillUnmount = function () {\n        if (this.state.markerClusterer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.markerClusterer);\n            }\n            unregisterEvents(this.registeredEvents);\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this.state.markerClusterer.setMap(null);\n        }\n    };\n    ClustererComponent.prototype.render = function () {\n        return this.state.markerClusterer !== null\n            ? this.props.children(this.state.markerClusterer)\n            : null;\n    };\n    ClustererComponent.contextType = MapContext;\n    return ClustererComponent;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\n// This handler prevents an event in the InfoBox from being passed on to the map.\nfunction cancelHandler(event) {\n    event.cancelBubble = true;\n    if (event.stopPropagation) {\n        event.stopPropagation();\n    }\n}\nvar InfoBox = /** @class */ (function () {\n    function InfoBox(options) {\n        if (options === void 0) { options = {}; }\n        this.getCloseClickHandler = this.getCloseClickHandler.bind(this);\n        this.closeClickHandler = this.closeClickHandler.bind(this);\n        this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this);\n        this.addClickHandler = this.addClickHandler.bind(this);\n        this.getCloseBoxImg = this.getCloseBoxImg.bind(this);\n        this.getBoxWidths = this.getBoxWidths.bind(this);\n        this.setBoxStyle = this.setBoxStyle.bind(this);\n        this.setPosition = this.setPosition.bind(this);\n        this.getPosition = this.getPosition.bind(this);\n        this.setOptions = this.setOptions.bind(this);\n        this.setContent = this.setContent.bind(this);\n        this.setVisible = this.setVisible.bind(this);\n        this.getContent = this.getContent.bind(this);\n        this.getVisible = this.getVisible.bind(this);\n        this.setZIndex = this.setZIndex.bind(this);\n        this.getZIndex = this.getZIndex.bind(this);\n        this.onRemove = this.onRemove.bind(this);\n        this.panBox = this.panBox.bind(this);\n        this.extend = this.extend.bind(this);\n        this.close = this.close.bind(this);\n        this.draw = this.draw.bind(this);\n        this.show = this.show.bind(this);\n        this.hide = this.hide.bind(this);\n        this.open = this.open.bind(this);\n        this.extend(InfoBox, google.maps.OverlayView);\n        // Standard options (in common with google.maps.InfoWindow):\n        this.content = options.content || '';\n        this.disableAutoPan = options.disableAutoPan || false;\n        this.maxWidth = options.maxWidth || 0;\n        this.pixelOffset = options.pixelOffset || new google.maps.Size(0, 0);\n        this.position = options.position || new google.maps.LatLng(0, 0);\n        this.zIndex = options.zIndex || null;\n        // Additional options (unique to InfoBox):\n        this.boxClass = options.boxClass || 'infoBox';\n        this.boxStyle = options.boxStyle || {};\n        this.closeBoxMargin = options.closeBoxMargin || '2px';\n        this.closeBoxURL = options.closeBoxURL || 'http://www.google.com/intl/en_us/mapfiles/close.gif';\n        if (options.closeBoxURL === '') {\n            this.closeBoxURL = '';\n        }\n        this.infoBoxClearance = options.infoBoxClearance || new google.maps.Size(1, 1);\n        if (typeof options.visible === 'undefined') {\n            if (typeof options.isHidden === 'undefined') {\n                options.visible = true;\n            }\n            else {\n                options.visible = !options.isHidden;\n            }\n        }\n        this.isHidden = !options.visible;\n        this.alignBottom = options.alignBottom || false;\n        this.pane = options.pane || 'floatPane';\n        this.enableEventPropagation = options.enableEventPropagation || false;\n        this.div = null;\n        this.closeListener = null;\n        this.moveListener = null;\n        this.mapListener = null;\n        this.contextListener = null;\n        this.eventListeners = null;\n        this.fixedWidthSet = null;\n    }\n    InfoBox.prototype.createInfoBoxDiv = function () {\n        var _this = this;\n        // This handler ignores the current event in the InfoBox and conditionally prevents\n        // the event from being passed on to the map. It is used for the contextmenu event.\n        var ignoreHandler = function (event) {\n            event.returnValue = false;\n            if (event.preventDefault) {\n                event.preventDefault();\n            }\n            if (!_this.enableEventPropagation) {\n                cancelHandler(event);\n            }\n        };\n        if (!this.div) {\n            this.div = document.createElement('div');\n            this.setBoxStyle();\n            if (typeof this.content === 'string') {\n                this.div.innerHTML = this.getCloseBoxImg() + this.content;\n            }\n            else {\n                this.div.innerHTML = this.getCloseBoxImg();\n                this.div.appendChild(this.content);\n            }\n            var panes = this.getPanes();\n            if (panes !== null) {\n                panes[this.pane].appendChild(this.div); // Add the InfoBox div to the DOM\n            }\n            this.addClickHandler();\n            if (this.div.style.width) {\n                this.fixedWidthSet = true;\n            }\n            else {\n                if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth) {\n                    this.div.style.width = this.maxWidth + 'px';\n                    this.fixedWidthSet = true;\n                }\n                else {\n                    // The following code is needed to overcome problems with MSIE\n                    var bw = this.getBoxWidths();\n                    this.div.style.width = this.div.offsetWidth - bw.left - bw.right + 'px';\n                    this.fixedWidthSet = false;\n                }\n            }\n            this.panBox(this.disableAutoPan);\n            if (!this.enableEventPropagation) {\n                this.eventListeners = [];\n                // Cancel event propagation.\n                // Note: mousemove not included (to resolve Issue 152)\n                var events = [\n                    'mousedown',\n                    'mouseover',\n                    'mouseout',\n                    'mouseup',\n                    'click',\n                    'dblclick',\n                    'touchstart',\n                    'touchend',\n                    'touchmove',\n                ];\n                for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n                    var event_1 = events_1[_i];\n                    this.eventListeners.push(google.maps.event.addListener(this.div, event_1, cancelHandler));\n                }\n                // Workaround for Google bug that causes the cursor to change to a pointer\n                // when the mouse moves over a marker underneath InfoBox.\n                this.eventListeners.push(google.maps.event.addListener(this.div, 'mouseover', function () {\n                    if (_this.div) {\n                        _this.div.style.cursor = 'default';\n                    }\n                }));\n            }\n            this.contextListener = google.maps.event.addListener(this.div, 'contextmenu', ignoreHandler);\n            /**\n             * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.\n             * @name InfoBox#domready\n             * @event\n             */\n            google.maps.event.trigger(this, 'domready');\n        }\n    };\n    InfoBox.prototype.getCloseBoxImg = function () {\n        var img = '';\n        if (this.closeBoxURL !== '') {\n            img = '<img alt=\"\"';\n            img += ' aria-hidden=\"true\"';\n            img += \" src='\" + this.closeBoxURL + \"'\";\n            img += ' align=right'; // Do this because Opera chokes on style='float: right;'\n            img += \" style='\";\n            img += ' position: relative;'; // Required by MSIE\n            img += ' cursor: pointer;';\n            img += ' margin: ' + this.closeBoxMargin + ';';\n            img += \"'>\";\n        }\n        return img;\n    };\n    InfoBox.prototype.addClickHandler = function () {\n        this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== ''\n            ? google.maps.event.addListener(this.div.firstChild, 'click', this.getCloseClickHandler())\n            : null;\n    };\n    InfoBox.prototype.closeClickHandler = function (event) {\n        // 1.0.3 fix: Always prevent propagation of a close box click to the map:\n        event.cancelBubble = true;\n        if (event.stopPropagation) {\n            event.stopPropagation();\n        }\n        /**\n         * This event is fired when the InfoBox's close box is clicked.\n         * @name InfoBox#closeclick\n         * @event\n         */\n        google.maps.event.trigger(this, 'closeclick');\n        this.close();\n    };\n    InfoBox.prototype.getCloseClickHandler = function () {\n        return this.closeClickHandler;\n    };\n    InfoBox.prototype.panBox = function (disablePan) {\n        if (this.div && !disablePan) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            var map = this.getMap();\n            // Only pan if attached to map, not panorama\n            if (map instanceof google.maps.Map) {\n                var xOffset = 0;\n                var yOffset = 0;\n                var bounds = map.getBounds();\n                if (bounds && !bounds.contains(this.position)) {\n                    // Marker not in visible area of map, so set center\n                    // of map to the marker position first.\n                    map.setCenter(this.position);\n                }\n                var mapDiv = map.getDiv();\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                var mapWidth = mapDiv.offsetWidth;\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                var mapHeight = mapDiv.offsetHeight;\n                var iwOffsetX = this.pixelOffset.width;\n                var iwOffsetY = this.pixelOffset.height;\n                var iwWidth = this.div.offsetWidth;\n                var iwHeight = this.div.offsetHeight;\n                var padX = this.infoBoxClearance.width;\n                var padY = this.infoBoxClearance.height;\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                var projection = this.getProjection();\n                var pixPosition = projection.fromLatLngToContainerPixel(this.position);\n                if (pixPosition !== null) {\n                    if (pixPosition.x < -iwOffsetX + padX) {\n                        xOffset = pixPosition.x + iwOffsetX - padX;\n                    }\n                    else if (pixPosition.x + iwWidth + iwOffsetX + padX > mapWidth) {\n                        xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth;\n                    }\n                    if (this.alignBottom) {\n                        if (pixPosition.y < -iwOffsetY + padY + iwHeight) {\n                            yOffset = pixPosition.y + iwOffsetY - padY - iwHeight;\n                        }\n                        else if (pixPosition.y + iwOffsetY + padY > mapHeight) {\n                            yOffset = pixPosition.y + iwOffsetY + padY - mapHeight;\n                        }\n                    }\n                    else {\n                        if (pixPosition.y < -iwOffsetY + padY) {\n                            yOffset = pixPosition.y + iwOffsetY - padY;\n                        }\n                        else if (pixPosition.y + iwHeight + iwOffsetY + padY > mapHeight) {\n                            yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight;\n                        }\n                    }\n                }\n                if (!(xOffset === 0 && yOffset === 0)) {\n                    // Move the map to the shifted center.\n                    map.panBy(xOffset, yOffset);\n                }\n            }\n        }\n    };\n    InfoBox.prototype.setBoxStyle = function () {\n        if (this.div) {\n            // Apply style values from the style sheet defined in the boxClass parameter:\n            this.div.className = this.boxClass;\n            // Clear existing inline style values:\n            this.div.style.cssText = '';\n            // Apply style values defined in the boxStyle parameter:\n            var boxStyle = this.boxStyle;\n            for (var i in boxStyle) {\n                if (Object.prototype.hasOwnProperty.call(boxStyle, i)) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    this.div.style[i] = boxStyle[i];\n                }\n            }\n            // Fix for iOS disappearing InfoBox problem\n            // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad\n            this.div.style.webkitTransform = 'translateZ(0)';\n            // Fix up opacity style for benefit of MSIE\n            if (typeof this.div.style.opacity !== 'undefined' && this.div.style.opacity !== '') {\n                // See http://www.quirksmode.org/css/opacity.html\n                var opacity = parseFloat(this.div.style.opacity || '');\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                this.div.style.msFilter =\n                    '\"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + opacity * 100 + ')\"';\n                this.div.style.filter = 'alpha(opacity=' + opacity * 100 + ')';\n            }\n            // Apply required styles\n            this.div.style.position = 'absolute';\n            this.div.style.visibility = 'hidden';\n            if (this.zIndex !== null) {\n                this.div.style.zIndex = this.zIndex + '';\n            }\n            if (!this.div.style.overflow) {\n                this.div.style.overflow = 'auto';\n            }\n        }\n    };\n    InfoBox.prototype.getBoxWidths = function () {\n        var bw = { top: 0, bottom: 0, left: 0, right: 0 };\n        if (!this.div) {\n            return bw;\n        }\n        if (document.defaultView) {\n            var ownerDocument = this.div.ownerDocument;\n            var computedStyle = ownerDocument && ownerDocument.defaultView\n                ? ownerDocument.defaultView.getComputedStyle(this.div, '')\n                : null;\n            if (computedStyle) {\n                // The computed styles are always in pixel units (good!)\n                bw.top = parseInt(computedStyle.borderTopWidth || '', 10) || 0;\n                bw.bottom = parseInt(computedStyle.borderBottomWidth || '', 10) || 0;\n                bw.left = parseInt(computedStyle.borderLeftWidth || '', 10) || 0;\n                bw.right = parseInt(computedStyle.borderRightWidth || '', 10) || 0;\n            }\n        }\n        else if (\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        document.documentElement.currentStyle // MSIE\n        ) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            var currentStyle = this.div.currentStyle;\n            if (currentStyle) {\n                // The current styles may not be in pixel units, but assume they are (bad!)\n                bw.top = parseInt(currentStyle.borderTopWidth || '', 10) || 0;\n                bw.bottom = parseInt(currentStyle.borderBottomWidth || '', 10) || 0;\n                bw.left = parseInt(currentStyle.borderLeftWidth || '', 10) || 0;\n                bw.right = parseInt(currentStyle.borderRightWidth || '', 10) || 0;\n            }\n        }\n        return bw;\n    };\n    InfoBox.prototype.onRemove = function () {\n        if (this.div && this.div.parentNode) {\n            this.div.parentNode.removeChild(this.div);\n            this.div = null;\n        }\n    };\n    InfoBox.prototype.draw = function () {\n        this.createInfoBoxDiv();\n        if (this.div) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            var projection = this.getProjection();\n            var pixPosition = projection.fromLatLngToDivPixel(this.position);\n            if (pixPosition !== null) {\n                this.div.style.left = pixPosition.x + this.pixelOffset.width + 'px';\n                if (this.alignBottom) {\n                    this.div.style.bottom = -(pixPosition.y + this.pixelOffset.height) + 'px';\n                }\n                else {\n                    this.div.style.top = pixPosition.y + this.pixelOffset.height + 'px';\n                }\n            }\n            if (this.isHidden) {\n                this.div.style.visibility = 'hidden';\n            }\n            else {\n                this.div.style.visibility = 'visible';\n            }\n        }\n    };\n    InfoBox.prototype.setOptions = function (options) {\n        if (options === void 0) { options = {}; }\n        if (typeof options.boxClass !== 'undefined') {\n            // Must be first\n            this.boxClass = options.boxClass;\n            this.setBoxStyle();\n        }\n        if (typeof options.boxStyle !== 'undefined') {\n            // Must be second\n            this.boxStyle = options.boxStyle;\n            this.setBoxStyle();\n        }\n        if (typeof options.content !== 'undefined') {\n            this.setContent(options.content);\n        }\n        if (typeof options.disableAutoPan !== 'undefined') {\n            this.disableAutoPan = options.disableAutoPan;\n        }\n        if (typeof options.maxWidth !== 'undefined') {\n            this.maxWidth = options.maxWidth;\n        }\n        if (typeof options.pixelOffset !== 'undefined') {\n            this.pixelOffset = options.pixelOffset;\n        }\n        if (typeof options.alignBottom !== 'undefined') {\n            this.alignBottom = options.alignBottom;\n        }\n        if (typeof options.position !== 'undefined') {\n            this.setPosition(options.position);\n        }\n        if (typeof options.zIndex !== 'undefined') {\n            this.setZIndex(options.zIndex);\n        }\n        if (typeof options.closeBoxMargin !== 'undefined') {\n            this.closeBoxMargin = options.closeBoxMargin;\n        }\n        if (typeof options.closeBoxURL !== 'undefined') {\n            this.closeBoxURL = options.closeBoxURL;\n        }\n        if (typeof options.infoBoxClearance !== 'undefined') {\n            this.infoBoxClearance = options.infoBoxClearance;\n        }\n        if (typeof options.isHidden !== 'undefined') {\n            this.isHidden = options.isHidden;\n        }\n        if (typeof options.visible !== 'undefined') {\n            this.isHidden = !options.visible;\n        }\n        if (typeof options.enableEventPropagation !== 'undefined') {\n            this.enableEventPropagation = options.enableEventPropagation;\n        }\n        if (this.div) {\n            this.draw();\n        }\n    };\n    InfoBox.prototype.setContent = function (content) {\n        this.content = content;\n        if (this.div) {\n            if (this.closeListener) {\n                google.maps.event.removeListener(this.closeListener);\n                this.closeListener = null;\n            }\n            // Odd code required to make things work with MSIE.\n            if (!this.fixedWidthSet) {\n                this.div.style.width = '';\n            }\n            if (typeof content === 'string') {\n                this.div.innerHTML = this.getCloseBoxImg() + content;\n            }\n            else {\n                this.div.innerHTML = this.getCloseBoxImg();\n                this.div.appendChild(content);\n            }\n            // Perverse code required to make things work with MSIE.\n            // (Ensures the close box does, in fact, float to the right.)\n            if (!this.fixedWidthSet) {\n                this.div.style.width = this.div.offsetWidth + 'px';\n                if (typeof content === 'string') {\n                    this.div.innerHTML = this.getCloseBoxImg() + content;\n                }\n                else {\n                    this.div.innerHTML = this.getCloseBoxImg();\n                    this.div.appendChild(content);\n                }\n            }\n            this.addClickHandler();\n        }\n        /**\n         * This event is fired when the content of the InfoBox changes.\n         * @name InfoBox#content_changed\n         * @event\n         */\n        google.maps.event.trigger(this, 'content_changed');\n    };\n    InfoBox.prototype.setPosition = function (latLng) {\n        this.position = latLng;\n        if (this.div) {\n            this.draw();\n        }\n        /**\n         * This event is fired when the position of the InfoBox changes.\n         * @name InfoBox#position_changed\n         * @event\n         */\n        google.maps.event.trigger(this, 'position_changed');\n    };\n    InfoBox.prototype.setVisible = function (isVisible) {\n        this.isHidden = !isVisible;\n        if (this.div) {\n            this.div.style.visibility = this.isHidden ? 'hidden' : 'visible';\n        }\n    };\n    InfoBox.prototype.setZIndex = function (index) {\n        this.zIndex = index;\n        if (this.div) {\n            this.div.style.zIndex = index + '';\n        }\n        /**\n         * This event is fired when the zIndex of the InfoBox changes.\n         * @name InfoBox#zindex_changed\n         * @event\n         */\n        google.maps.event.trigger(this, 'zindex_changed');\n    };\n    InfoBox.prototype.getContent = function () {\n        return this.content;\n    };\n    InfoBox.prototype.getPosition = function () {\n        return this.position;\n    };\n    InfoBox.prototype.getZIndex = function () {\n        return this.zIndex;\n    };\n    InfoBox.prototype.getVisible = function () {\n        var map = this.getMap();\n        return typeof map === 'undefined' || map === null ? false : !this.isHidden;\n    };\n    InfoBox.prototype.show = function () {\n        this.isHidden = false;\n        if (this.div) {\n            this.div.style.visibility = 'visible';\n        }\n    };\n    InfoBox.prototype.hide = function () {\n        this.isHidden = true;\n        if (this.div) {\n            this.div.style.visibility = 'hidden';\n        }\n    };\n    InfoBox.prototype.open = function (map, anchor) {\n        var _this = this;\n        if (anchor) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            this.position = anchor.getPosition();\n            this.moveListener = google.maps.event.addListener(anchor, 'position_changed', function () {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                var position = anchor.getPosition();\n                _this.setPosition(position);\n            });\n            this.mapListener = google.maps.event.addListener(anchor, 'map_changed', function () {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                _this.setMap(anchor.map);\n            });\n        }\n        this.setMap(map);\n        if (this.div) {\n            this.panBox();\n        }\n    };\n    InfoBox.prototype.close = function () {\n        if (this.closeListener) {\n            google.maps.event.removeListener(this.closeListener);\n            this.closeListener = null;\n        }\n        if (this.eventListeners) {\n            for (var _i = 0, _a = this.eventListeners; _i < _a.length; _i++) {\n                var eventListener = _a[_i];\n                google.maps.event.removeListener(eventListener);\n            }\n            this.eventListeners = null;\n        }\n        if (this.moveListener) {\n            google.maps.event.removeListener(this.moveListener);\n            this.moveListener = null;\n        }\n        if (this.mapListener) {\n            google.maps.event.removeListener(this.mapListener);\n            this.mapListener = null;\n        }\n        if (this.contextListener) {\n            google.maps.event.removeListener(this.contextListener);\n            this.contextListener = null;\n        }\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.setMap(null);\n    };\n    InfoBox.prototype.extend = function (obj1, obj2) {\n        return function applyExtend(object) {\n            for (var property in object.prototype) {\n                if (!Object.prototype.hasOwnProperty.call(this, property)) {\n                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    this.prototype[property] = object.prototype[property];\n                }\n            }\n            return this;\n        }.apply(obj1, [obj2]);\n    };\n    return InfoBox;\n}());\n\nvar eventMap$d = {\n    onCloseClick: 'closeclick',\n    onContentChanged: 'content_changed',\n    onDomReady: 'domready',\n    onPositionChanged: 'position_changed',\n    onZindexChanged: 'zindex_changed',\n};\nvar updaterMap$d = {\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    position: function (instance, position) {\n        if (position instanceof google.maps.LatLng) {\n            instance.setPosition(position);\n        }\n        else {\n            instance.setPosition(new google.maps.LatLng(position.lat, position.lng));\n        }\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n    zIndex: function (instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nvar defaultOptions$3 = {};\nfunction InfoBoxFunctional(_a) {\n    var children = _a.children, anchor = _a.anchor, options = _a.options, position = _a.position, zIndex = _a.zIndex, onCloseClick = _a.onCloseClick, onDomReady = _a.onDomReady, onContentChanged = _a.onContentChanged, onPositionChanged = _a.onPositionChanged, onZindexChanged = _a.onZindexChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), closeClickListener = _c[0], setCloseClickListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), domReadyClickListener = _d[0], setDomReadyClickListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), contentChangedClickListener = _e[0], setContentChangedClickListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), positionChangedClickListener = _f[0], setPositionChangedClickListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), zIndexChangedClickListener = _g[0], setZindexChangedClickListener = _g[1];\n    var containerElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && instance !== null) {\n            instance.close();\n            if (anchor) {\n                instance.open(map, anchor);\n            }\n            else if (instance.getPosition()) {\n                instance.open(map);\n            }\n        }\n    }, [map, instance, anchor]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (position && instance !== null) {\n            var positionLatLng = position instanceof google.maps.LatLng\n                ? position\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                : new google.maps.LatLng(position.lat, position.lng);\n            instance.setPosition(positionLatLng);\n        }\n    }, [position]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof zIndex === 'number' && instance !== null) {\n            instance.setZIndex(zIndex);\n        }\n    }, [zIndex]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onCloseClick) {\n            if (closeClickListener !== null) {\n                google.maps.event.removeListener(closeClickListener);\n            }\n            setCloseClickListener(google.maps.event.addListener(instance, 'closeclick', onCloseClick));\n        }\n    }, [onCloseClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDomReady) {\n            if (domReadyClickListener !== null) {\n                google.maps.event.removeListener(domReadyClickListener);\n            }\n            setDomReadyClickListener(google.maps.event.addListener(instance, 'domready', onDomReady));\n        }\n    }, [onDomReady]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onContentChanged) {\n            if (contentChangedClickListener !== null) {\n                google.maps.event.removeListener(contentChangedClickListener);\n            }\n            setContentChangedClickListener(google.maps.event.addListener(instance, 'content_changed', onContentChanged));\n        }\n    }, [onContentChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onPositionChanged) {\n            if (positionChangedClickListener !== null) {\n                google.maps.event.removeListener(positionChangedClickListener);\n            }\n            setPositionChangedClickListener(google.maps.event.addListener(instance, 'position_changed', onPositionChanged));\n        }\n    }, [onPositionChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onZindexChanged) {\n            if (zIndexChangedClickListener !== null) {\n                google.maps.event.removeListener(zIndexChangedClickListener);\n            }\n            setZindexChangedClickListener(google.maps.event.addListener(instance, 'zindex_changed', onZindexChanged));\n        }\n    }, [onZindexChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map) {\n            var _a = options || defaultOptions$3, position_1 = _a.position, infoBoxOptions = __rest$1(_a, [\"position\"]);\n            var positionLatLng = void 0;\n            if (position_1 && !(position_1 instanceof google.maps.LatLng)) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                positionLatLng = new google.maps.LatLng(position_1.lat, position_1.lng);\n            }\n            var infoBox = new InfoBox(__assign(__assign({}, infoBoxOptions), (positionLatLng ? { position: positionLatLng } : {})));\n            containerElementRef.current = document.createElement('div');\n            setInstance(infoBox);\n            if (onCloseClick) {\n                setCloseClickListener(google.maps.event.addListener(infoBox, 'closeclick', onCloseClick));\n            }\n            if (onDomReady) {\n                setDomReadyClickListener(google.maps.event.addListener(infoBox, 'domready', onDomReady));\n            }\n            if (onContentChanged) {\n                setContentChangedClickListener(google.maps.event.addListener(infoBox, 'content_changed', onContentChanged));\n            }\n            if (onPositionChanged) {\n                setPositionChangedClickListener(google.maps.event.addListener(infoBox, 'position_changed', onPositionChanged));\n            }\n            if (onZindexChanged) {\n                setZindexChangedClickListener(google.maps.event.addListener(infoBox, 'zindex_changed', onZindexChanged));\n            }\n            infoBox.setContent(containerElementRef.current);\n            if (anchor) {\n                infoBox.open(map, anchor);\n            }\n            else if (infoBox.getPosition()) {\n                infoBox.open(map);\n            }\n            else {\n                invariant$1(false, 'You must provide either an anchor or a position prop for <InfoBox>.');\n            }\n            if (onLoad) {\n                onLoad(infoBox);\n            }\n        }\n        return function () {\n            if (instance !== null) {\n                if (closeClickListener) {\n                    google.maps.event.removeListener(closeClickListener);\n                }\n                if (contentChangedClickListener) {\n                    google.maps.event.removeListener(contentChangedClickListener);\n                }\n                if (domReadyClickListener) {\n                    google.maps.event.removeListener(domReadyClickListener);\n                }\n                if (positionChangedClickListener) {\n                    google.maps.event.removeListener(positionChangedClickListener);\n                }\n                if (zIndexChangedClickListener) {\n                    google.maps.event.removeListener(zIndexChangedClickListener);\n                }\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.close();\n            }\n        };\n    }, []);\n    return containerElementRef.current ? (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(react__WEBPACK_IMPORTED_MODULE_1__.Children.only(children), containerElementRef.current) : null;\n}\nvar InfoBoxF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(InfoBoxFunctional);\nvar InfoBoxComponent = /** @class */ (function (_super) {\n    __extends(InfoBoxComponent, _super);\n    function InfoBoxComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.containerElement = null;\n        _this.state = {\n            infoBox: null,\n        };\n        _this.open = function (infoBox, anchor) {\n            if (anchor) {\n                if (_this.context !== null) {\n                    infoBox.open(_this.context, anchor);\n                }\n            }\n            else if (infoBox.getPosition()) {\n                if (_this.context !== null) {\n                    infoBox.open(_this.context);\n                }\n            }\n            else {\n                invariant$1(false, 'You must provide either an anchor or a position prop for <InfoBox>.');\n            }\n        };\n        _this.setInfoBoxCallback = function () {\n            if (_this.state.infoBox !== null && _this.containerElement !== null) {\n                _this.state.infoBox.setContent(_this.containerElement);\n                _this.open(_this.state.infoBox, _this.props.anchor);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.infoBox);\n                }\n            }\n        };\n        return _this;\n    }\n    InfoBoxComponent.prototype.componentDidMount = function () {\n        var _a = this.props.options || {}, position = _a.position, infoBoxOptions = __rest$1(_a, [\"position\"]);\n        var positionLatLng;\n        if (position && !(position instanceof google.maps.LatLng)) {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            positionLatLng = new google.maps.LatLng(position.lat, position.lng);\n        }\n        var infoBox = new InfoBox(__assign(__assign({}, infoBoxOptions), (positionLatLng ? { position: positionLatLng } : {})));\n        this.containerElement = document.createElement('div');\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$d,\n            eventMap: eventMap$d,\n            prevProps: {},\n            nextProps: this.props,\n            instance: infoBox,\n        });\n        this.setState({ infoBox: infoBox }, this.setInfoBoxCallback);\n    };\n    InfoBoxComponent.prototype.componentDidUpdate = function (prevProps) {\n        var infoBox = this.state.infoBox;\n        if (infoBox !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$d,\n                eventMap: eventMap$d,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: infoBox,\n            });\n        }\n    };\n    InfoBoxComponent.prototype.componentWillUnmount = function () {\n        var onUnmount = this.props.onUnmount;\n        var infoBox = this.state.infoBox;\n        if (infoBox !== null) {\n            if (onUnmount) {\n                onUnmount(infoBox);\n            }\n            unregisterEvents(this.registeredEvents);\n            infoBox.close();\n        }\n    };\n    InfoBoxComponent.prototype.render = function () {\n        return this.containerElement ? (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children), this.containerElement) : null;\n    };\n    InfoBoxComponent.contextType = MapContext;\n    return InfoBoxComponent;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nvar fastDeepEqual = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\nvar equal = /*@__PURE__*/getDefaultExportFromCjs(fastDeepEqual);\n\nconst ARRAY_TYPES = [\n    Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array\n];\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nconst VERSION = 1; // serialized format version\nconst HEADER_SIZE = 8;\n\nclass KDBush {\n\n    /**\n     * Creates an index from raw `ArrayBuffer` data.\n     * @param {ArrayBuffer} data\n     */\n    static from(data) {\n        if (!(data instanceof ArrayBuffer)) {\n            throw new Error('Data must be an instance of ArrayBuffer.');\n        }\n        const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n        if (magic !== 0xdb) {\n            throw new Error('Data does not appear to be in a KDBush format.');\n        }\n        const version = versionAndType >> 4;\n        if (version !== VERSION) {\n            throw new Error(`Got v${version} data when expected v${VERSION}.`);\n        }\n        const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n        if (!ArrayType) {\n            throw new Error('Unrecognized array type.');\n        }\n        const [nodeSize] = new Uint16Array(data, 2, 1);\n        const [numItems] = new Uint32Array(data, 4, 1);\n\n        return new KDBush(numItems, nodeSize, ArrayType, data);\n    }\n\n    /**\n     * Creates an index that will hold a given number of items.\n     * @param {number} numItems\n     * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).\n     * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n     * @param {ArrayBuffer} [data] (For internal use only)\n     */\n    constructor(numItems, nodeSize = 64, ArrayType = Float64Array, data) {\n        if (isNaN(numItems) || numItems < 0) throw new Error(`Unpexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numItems < 65536 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const coordsByteSize = numItems * 2 * this.ArrayType.BYTES_PER_ELEMENT;\n        const idsByteSize = numItems * this.IndexArrayType.BYTES_PER_ELEMENT;\n        const padCoords = (8 - idsByteSize % 8) % 8;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        if (data && (data instanceof ArrayBuffer)) { // reconstruct an index from a buffer\n            this.data = data;\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = numItems * 2;\n            this._finished = true;\n        } else { // initialize a new index\n            this.data = new ArrayBuffer(HEADER_SIZE + coordsByteSize + idsByteSize + padCoords);\n            this.ids = new this.IndexArrayType(this.data, HEADER_SIZE, numItems);\n            this.coords = new this.ArrayType(this.data, HEADER_SIZE + idsByteSize + padCoords, numItems * 2);\n            this._pos = 0;\n            this._finished = false;\n\n            // set header\n            new Uint8Array(this.data, 0, 2).set([0xdb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n    }\n\n    /**\n     * Add a point to the index.\n     * @param {number} x\n     * @param {number} y\n     * @returns {number} An incremental index associated with the added item (starting from `0`).\n     */\n    add(x, y) {\n        const index = this._pos >> 1;\n        this.ids[index] = index;\n        this.coords[this._pos++] = x;\n        this.coords[this._pos++] = y;\n        return index;\n    }\n\n    /**\n     * Perform indexing of the added points.\n     */\n    finish() {\n        const numAdded = this._pos >> 1;\n        if (numAdded !== this.numItems) {\n            throw new Error(`Added ${numAdded} items when expected ${this.numItems}.`);\n        }\n        // kd-sort both arrays for efficient search\n        sort(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0);\n\n        this._finished = true;\n        return this;\n    }\n\n    /**\n     * Search the index for items within a given bounding box.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    range(minX, minY, maxX, maxY) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n\n        // recursively search for items in range in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    const x = coords[2 * i];\n                    const y = coords[2 * i + 1];\n                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? minX <= x : minY <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? maxX >= x : maxY >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Search the index for items within a given radius.\n     * @param {number} qx\n     * @param {number} qy\n     * @param {number} r Query radius.\n     * @returns {number[]} An array of indices correponding to the found items.\n     */\n    within(qx, qy, r) {\n        if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');\n\n        const {ids, coords, nodeSize} = this;\n        const stack = [0, ids.length - 1, 0];\n        const result = [];\n        const r2 = r * r;\n\n        // recursively search for items within radius in the kd-sorted arrays\n        while (stack.length) {\n            const axis = stack.pop() || 0;\n            const right = stack.pop() || 0;\n            const left = stack.pop() || 0;\n\n            // if we reached \"tree node\", search linearly\n            if (right - left <= nodeSize) {\n                for (let i = left; i <= right; i++) {\n                    if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n                }\n                continue;\n            }\n\n            // otherwise find the middle index\n            const m = (left + right) >> 1;\n\n            // include the middle item if it's in range\n            const x = coords[2 * m];\n            const y = coords[2 * m + 1];\n            if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n            // queue search in halves that intersect the query\n            if (axis === 0 ? qx - r <= x : qy - r <= y) {\n                stack.push(left);\n                stack.push(m - 1);\n                stack.push(1 - axis);\n            }\n            if (axis === 0 ? qx + r >= x : qy + r >= y) {\n                stack.push(m + 1);\n                stack.push(right);\n                stack.push(1 - axis);\n            }\n        }\n\n        return result;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} nodeSize\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction sort(ids, coords, nodeSize, left, right, axis) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1; // middle index\n\n    // sort ids and coords around the middle index so that the halves lie\n    // either left/right or top/bottom correspondingly (taking turns)\n    select(ids, coords, m, left, right, axis);\n\n    // recursively kd-sort first half and second half on the opposite axis\n    sort(ids, coords, nodeSize, left, m - 1, 1 - axis);\n    sort(ids, coords, nodeSize, m + 1, right, 1 - axis);\n}\n\n/**\n * Custom Floyd-Rivest selection algorithm: sort ids and coords so that\n * [left..k-1] items are smaller than k-th item (on either x or y axis)\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} k\n * @param {number} left\n * @param {number} right\n * @param {number} axis\n */\nfunction select(ids, coords, k, left, right, axis) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, axis);\n        }\n\n        const t = coords[2 * k + axis];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + axis] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + axis] < t) i++;\n            while (coords[2 * j + axis] > t) j--;\n        }\n\n        if (coords[2 * left + axis] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @param {Uint16Array | Uint32Array} ids\n * @param {InstanceType<TypedArrayConstructor>} coords\n * @param {number} i\n * @param {number} j\n */\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\n/**\n * @param {InstanceType<TypedArrayConstructor>} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @param {number} ax\n * @param {number} ay\n * @param {number} bx\n * @param {number} by\n */\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nconst defaultOptions$2 = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nconst OFFSET_ZOOM = 2;\nconst OFFSET_ID = 3;\nconst OFFSET_PARENT = 4;\nconst OFFSET_NUM = 5;\nconst OFFSET_PROP = 6;\n\nclass Supercluster {\n    constructor(options) {\n        this.options = Object.assign(Object.create(defaultOptions$2), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n        this.stride = this.options.reduce ? 7 : 6;\n        this.clusterProps = [];\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        const data = [];\n\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            if (!p.geometry) continue;\n\n            const [lng, lat] = p.geometry.coordinates;\n            const x = fround(lngX(lng));\n            const y = fround(latY(lat));\n            // store internal point/cluster data in flat numeric arrays for performance\n            data.push(\n                x, y, // projected point coordinates\n                Infinity, // the last zoom the point was processed at\n                i, // index of the source feature in the original input array\n                -1, // parent cluster id\n                1 // number of points in a cluster\n            );\n            if (this.options.reduce) data.push(0); // noop\n        }\n        let tree = this.trees[maxZoom + 1] = this._createTree(data);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            tree = this.trees[z] = this._createTree(this._cluster(tree, z));\n\n            if (log) console.log('z%d: %d clusters in %dms', z, tree.numItems, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const data = tree.data;\n        const clusters = [];\n        for (const id of ids) {\n            const k = this.stride * id;\n            clusters.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const tree = this.trees[originZoom];\n        if (!tree) throw new Error(errorMsg);\n\n        const data = tree.data;\n        if (originId * this.stride >= data.length) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const x = data[originId * this.stride];\n        const y = data[originId * this.stride + 1];\n        const ids = tree.within(x, y, r);\n        const children = [];\n        for (const id of ids) {\n            const k = id * this.stride;\n            if (data[k + OFFSET_PARENT] === clusterId) {\n                children.push(data[k + OFFSET_NUM] > 1 ? getClusterJSON(data, k, this.clusterProps) : this.points[data[k + OFFSET_ID]]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.data, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.data, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.data, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _createTree(data) {\n        const tree = new KDBush(data.length / this.stride | 0, this.options.nodeSize, Float32Array);\n        for (let i = 0; i < data.length; i += this.stride) tree.add(data[i], data[i + 1]);\n        tree.finish();\n        tree.data = data;\n        return tree;\n    }\n\n    _addTileFeatures(ids, data, x, y, z2, tile) {\n        for (const i of ids) {\n            const k = i * this.stride;\n            const isCluster = data[k + OFFSET_NUM] > 1;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(data, k, this.clusterProps);\n                px = data[k];\n                py = data[k + 1];\n            } else {\n                const p = this.points[data[k + OFFSET_ID]];\n                tags = p.properties;\n                const [lng, lat] = p.geometry.coordinates;\n                px = lngX(lng);\n                py = latY(lat);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster || this.options.generateId) {\n                // optionally generate id for points\n                id = data[k + OFFSET_ID];\n            } else {\n                // keep id if already assigned\n                id = this.points[data[k + OFFSET_ID]].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(Math.floor(+z), this.options.maxZoom + 1));\n    }\n\n    _cluster(tree, zoom) {\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n        const data = tree.data;\n        const nextData = [];\n        const stride = this.stride;\n\n        // loop through each point\n        for (let i = 0; i < data.length; i += stride) {\n            // if we've already visited the point at this zoom level, skip it\n            if (data[i + OFFSET_ZOOM] <= zoom) continue;\n            data[i + OFFSET_ZOOM] = zoom;\n\n            // find all nearby points\n            const x = data[i];\n            const y = data[i + 1];\n            const neighborIds = tree.within(data[i], data[i + 1], r);\n\n            const numPointsOrigin = data[i + OFFSET_NUM];\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const k = neighborId * stride;\n                // filter out neighbors that are already processed\n                if (data[k + OFFSET_ZOOM] > zoom) numPoints += data[k + OFFSET_NUM];\n            }\n\n            // if there were neighbors to merge, and there are enough points to form a cluster\n            if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n                let wx = x * numPointsOrigin;\n                let wy = y * numPointsOrigin;\n\n                let clusterProperties;\n                let clusterPropIndex = -1;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = ((i / stride | 0) << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const k = neighborId * stride;\n\n                    if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                    data[k + OFFSET_ZOOM] = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = data[k + OFFSET_NUM];\n                    wx += data[k] * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += data[k + 1] * numPoints2;\n\n                    data[k + OFFSET_PARENT] = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) {\n                            clusterProperties = this._map(data, i, true);\n                            clusterPropIndex = this.clusterProps.length;\n                            this.clusterProps.push(clusterProperties);\n                        }\n                        reduce(clusterProperties, this._map(data, k));\n                    }\n                }\n\n                data[i + OFFSET_PARENT] = id;\n                nextData.push(wx / numPoints, wy / numPoints, Infinity, id, -1, numPoints);\n                if (reduce) nextData.push(clusterPropIndex);\n\n            } else { // left points as unclustered\n                for (let j = 0; j < stride; j++) nextData.push(data[i + j]);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const k = neighborId * stride;\n                        if (data[k + OFFSET_ZOOM] <= zoom) continue;\n                        data[k + OFFSET_ZOOM] = zoom;\n                        for (let j = 0; j < stride; j++) nextData.push(data[k + j]);\n                    }\n                }\n            }\n        }\n\n        return nextData;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(data, i, clone) {\n        if (data[i + OFFSET_NUM] > 1) {\n            const props = this.clusterProps[data[i + OFFSET_PROP]];\n            return clone ? Object.assign({}, props) : props;\n        }\n        const original = this.points[data[i + OFFSET_ID]].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? Object.assign({}, result) : result;\n    }\n}\n\nfunction getClusterJSON(data, i, clusterProps) {\n    return {\n        type: 'Feature',\n        id: data[i + OFFSET_ID],\n        properties: getClusterProperties(data, i, clusterProps),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(data[i]), yLat(data[i + 1])]\n        }\n    };\n}\n\nfunction getClusterProperties(data, i, clusterProps) {\n    const count = data[i + OFFSET_NUM];\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    const propIndex = data[i + OFFSET_PROP];\n    const properties = propIndex === -1 ? {} : Object.assign({}, clusterProps[propIndex]);\n    return Object.assign(properties, {\n        cluster: true,\n        cluster_id: data[i + OFFSET_ID],\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\n/**\n * Copyright 2023 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * util class that creates a common set of convenience functions to wrap\n * shared behavior of Advanced Markers and Markers.\n */\nclass MarkerUtils {\n    static isAdvancedMarkerAvailable(map) {\n        return (google.maps.marker &&\n            map.getMapCapabilities().isAdvancedMarkersAvailable === true);\n    }\n    static isAdvancedMarker(marker) {\n        return (google.maps.marker &&\n            marker instanceof google.maps.marker.AdvancedMarkerElement);\n    }\n    static setMap(marker, map) {\n        if (this.isAdvancedMarker(marker)) {\n            marker.map = map;\n        }\n        else {\n            marker.setMap(map);\n        }\n    }\n    static getPosition(marker) {\n        // SuperClusterAlgorithm.calculate expects a LatLng instance so we fake it for Adv Markers\n        if (this.isAdvancedMarker(marker)) {\n            if (marker.position) {\n                if (marker.position instanceof google.maps.LatLng) {\n                    return marker.position;\n                }\n                // since we can't cast to LatLngLiteral for reasons =(\n                if (marker.position.lat && marker.position.lng) {\n                    return new google.maps.LatLng(marker.position.lat, marker.position.lng);\n                }\n            }\n            return new google.maps.LatLng(null);\n        }\n        return marker.getPosition();\n    }\n    static getVisible(marker) {\n        if (this.isAdvancedMarker(marker)) {\n            /**\n             * Always return true for Advanced Markers because the clusterer\n             * uses getVisible as a way to count legacy markers not as an actual\n             * indicator of visibility for some reason. Even when markers are hidden\n             * Marker.getVisible returns `true` and this is used to set the marker count\n             * on the cluster. See the behavior of Cluster.count\n             */\n            return true;\n        }\n        return marker.getVisible();\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nclass Cluster {\n    constructor({ markers, position }) {\n        this.markers = markers;\n        if (position) {\n            if (position instanceof google.maps.LatLng) {\n                this._position = position;\n            }\n            else {\n                this._position = new google.maps.LatLng(position);\n            }\n        }\n    }\n    get bounds() {\n        if (this.markers.length === 0 && !this._position) {\n            return;\n        }\n        const bounds = new google.maps.LatLngBounds(this._position, this._position);\n        for (const marker of this.markers) {\n            bounds.extend(MarkerUtils.getPosition(marker));\n        }\n        return bounds;\n    }\n    get position() {\n        return this._position || this.bounds.getCenter();\n    }\n    /**\n     * Get the count of **visible** markers.\n     */\n    get count() {\n        return this.markers.filter((m) => MarkerUtils.getVisible(m)).length;\n    }\n    /**\n     * Add a marker to the cluster.\n     */\n    push(marker) {\n        this.markers.push(marker);\n    }\n    /**\n     * Cleanup references and remove marker from map.\n     */\n    delete() {\n        if (this.marker) {\n            MarkerUtils.setMap(this.marker, null);\n            this.marker = undefined;\n        }\n        this.markers.length = 0;\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Returns the markers visible in a padded map viewport\n *\n * @param map\n * @param mapCanvasProjection\n * @param markers The list of marker to filter\n * @param viewportPaddingPixels The padding in pixel\n * @returns The list of markers in the padded viewport\n */\nconst filterMarkersToPaddedViewport = (map, mapCanvasProjection, markers, viewportPaddingPixels) => {\n    const extendedMapBounds = extendBoundsToPaddedViewport(map.getBounds(), mapCanvasProjection, viewportPaddingPixels);\n    return markers.filter((marker) => extendedMapBounds.contains(MarkerUtils.getPosition(marker)));\n};\n/**\n * Extends a bounds by a number of pixels in each direction\n */\nconst extendBoundsToPaddedViewport = (bounds, projection, numPixels) => {\n    const { northEast, southWest } = latLngBoundsToPixelBounds(bounds, projection);\n    const extendedPixelBounds = extendPixelBounds({ northEast, southWest }, numPixels);\n    return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\n};\n/**\n * Gets the extended bounds as a bbox [westLng, southLat, eastLng, northLat]\n */\nconst getPaddedViewport = (bounds, projection, pixels) => {\n    const extended = extendBoundsToPaddedViewport(bounds, projection, pixels);\n    const ne = extended.getNorthEast();\n    const sw = extended.getSouthWest();\n    return [sw.lng(), sw.lat(), ne.lng(), ne.lat()];\n};\n/**\n * Returns the distance between 2 positions.\n *\n * @hidden\n */\nconst distanceBetweenPoints = (p1, p2) => {\n    const R = 6371; // Radius of the Earth in km\n    const dLat = ((p2.lat - p1.lat) * Math.PI) / 180;\n    const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;\n    const sinDLat = Math.sin(dLat / 2);\n    const sinDLon = Math.sin(dLon / 2);\n    const a = sinDLat * sinDLat +\n        Math.cos((p1.lat * Math.PI) / 180) *\n            Math.cos((p2.lat * Math.PI) / 180) *\n            sinDLon *\n            sinDLon;\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    return R * c;\n};\n/**\n * Converts a LatLng bound to pixels.\n *\n * @hidden\n */\nconst latLngBoundsToPixelBounds = (bounds, projection) => {\n    return {\n        northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\n        southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest()),\n    };\n};\n/**\n * Extends a pixel bounds by numPixels in all directions.\n *\n * @hidden\n */\nconst extendPixelBounds = ({ northEast, southWest }, numPixels) => {\n    northEast.x += numPixels;\n    northEast.y -= numPixels;\n    southWest.x -= numPixels;\n    southWest.y += numPixels;\n    return { northEast, southWest };\n};\n/**\n * @hidden\n */\nconst pixelBoundsToLatLngBounds = ({ northEast, southWest }, projection) => {\n    const sw = projection.fromDivPixelToLatLng(southWest);\n    const ne = projection.fromDivPixelToLatLng(northEast);\n    return new google.maps.LatLngBounds(sw, ne);\n};\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @hidden\n */\nclass AbstractAlgorithm {\n    constructor({ maxZoom = 16 }) {\n        this.maxZoom = maxZoom;\n    }\n    /**\n     * Helper function to bypass clustering based upon some map state such as\n     * zoom, number of markers, etc.\n     *\n     * ```typescript\n     *  cluster({markers, map}: AlgorithmInput): Cluster[] {\n     *    if (shouldBypassClustering(map)) {\n     *      return this.noop({markers})\n     *    }\n     * }\n     * ```\n     */\n    noop({ markers, }) {\n        return noop$1(markers);\n    }\n}\n/**\n * Abstract viewport algorithm proves a class to filter markers by a padded\n * viewport. This is a common optimization.\n *\n * @hidden\n */\nclass AbstractViewportAlgorithm extends AbstractAlgorithm {\n    constructor(_a) {\n        var { viewportPadding = 60 } = _a, options = __rest(_a, [\"viewportPadding\"]);\n        super(options);\n        this.viewportPadding = 60;\n        this.viewportPadding = viewportPadding;\n    }\n    calculate({ markers, map, mapCanvasProjection, }) {\n        if (map.getZoom() >= this.maxZoom) {\n            return {\n                clusters: this.noop({\n                    markers,\n                }),\n                changed: false,\n            };\n        }\n        return {\n            clusters: this.cluster({\n                markers: filterMarkersToPaddedViewport(map, mapCanvasProjection, markers, this.viewportPadding),\n                map,\n                mapCanvasProjection,\n            }),\n        };\n    }\n}\n/**\n * @hidden\n */\nconst noop$1 = (markers) => {\n    const clusters = markers.map((marker) => new Cluster({\n        position: MarkerUtils.getPosition(marker),\n        markers: [marker],\n    }));\n    return clusters;\n};\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * The default Grid algorithm historically used in Google Maps marker\n * clustering.\n *\n * The Grid algorithm does not implement caching and markers may flash as the\n * viewport changes. Instead use {@link SuperClusterAlgorithm}.\n */\nclass GridAlgorithm extends AbstractViewportAlgorithm {\n    constructor(_a) {\n        var { maxDistance = 40000, gridSize = 40 } = _a, options = __rest(_a, [\"maxDistance\", \"gridSize\"]);\n        super(options);\n        this.clusters = [];\n        this.state = { zoom: -1 };\n        this.maxDistance = maxDistance;\n        this.gridSize = gridSize;\n    }\n    calculate({ markers, map, mapCanvasProjection, }) {\n        const state = { zoom: map.getZoom() };\n        let changed = false;\n        if (this.state.zoom >= this.maxZoom && state.zoom >= this.maxZoom) ;\n        else {\n            changed = !equal(this.state, state);\n        }\n        this.state = state;\n        if (map.getZoom() >= this.maxZoom) {\n            return {\n                clusters: this.noop({\n                    markers,\n                }),\n                changed,\n            };\n        }\n        return {\n            clusters: this.cluster({\n                markers: filterMarkersToPaddedViewport(map, mapCanvasProjection, markers, this.viewportPadding),\n                map,\n                mapCanvasProjection,\n            }),\n        };\n    }\n    cluster({ markers, map, mapCanvasProjection, }) {\n        this.clusters = [];\n        markers.forEach((marker) => {\n            this.addToClosestCluster(marker, map, mapCanvasProjection);\n        });\n        return this.clusters;\n    }\n    addToClosestCluster(marker, map, projection) {\n        let maxDistance = this.maxDistance; // Some large number\n        let cluster = null;\n        for (let i = 0; i < this.clusters.length; i++) {\n            const candidate = this.clusters[i];\n            const distance = distanceBetweenPoints(candidate.bounds.getCenter().toJSON(), MarkerUtils.getPosition(marker).toJSON());\n            if (distance < maxDistance) {\n                maxDistance = distance;\n                cluster = candidate;\n            }\n        }\n        if (cluster &&\n            extendBoundsToPaddedViewport(cluster.bounds, projection, this.gridSize).contains(MarkerUtils.getPosition(marker))) {\n            cluster.push(marker);\n        }\n        else {\n            const cluster = new Cluster({ markers: [marker] });\n            this.clusters.push(cluster);\n        }\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Noop algorithm does not generate any clusters or filter markers by the an extended viewport.\n */\nclass NoopAlgorithm extends AbstractAlgorithm {\n    constructor(_a) {\n        var options = __rest(_a, []);\n        super(options);\n    }\n    calculate({ markers, map, mapCanvasProjection, }) {\n        return {\n            clusters: this.cluster({ markers, map, mapCanvasProjection }),\n            changed: false,\n        };\n    }\n    cluster(input) {\n        return this.noop(input);\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nclass SuperClusterAlgorithm extends AbstractAlgorithm {\n    constructor(_a) {\n        var { maxZoom, radius = 60 } = _a, options = __rest(_a, [\"maxZoom\", \"radius\"]);\n        super({ maxZoom });\n        this.state = { zoom: -1 };\n        this.superCluster = new Supercluster(Object.assign({ maxZoom: this.maxZoom, radius }, options));\n    }\n    calculate(input) {\n        let changed = false;\n        const state = { zoom: input.map.getZoom() };\n        if (!equal(input.markers, this.markers)) {\n            changed = true;\n            // TODO use proxy to avoid copy?\n            this.markers = [...input.markers];\n            const points = this.markers.map((marker) => {\n                const position = MarkerUtils.getPosition(marker);\n                const coordinates = [position.lng(), position.lat()];\n                return {\n                    type: \"Feature\",\n                    geometry: {\n                        type: \"Point\",\n                        coordinates,\n                    },\n                    properties: { marker },\n                };\n            });\n            this.superCluster.load(points);\n        }\n        if (!changed) {\n            if (this.state.zoom <= this.maxZoom || state.zoom <= this.maxZoom) {\n                changed = !equal(this.state, state);\n            }\n        }\n        this.state = state;\n        if (changed) {\n            this.clusters = this.cluster(input);\n        }\n        return { clusters: this.clusters, changed };\n    }\n    cluster({ map }) {\n        return this.superCluster\n            .getClusters([-180, -90, 180, 90], Math.round(map.getZoom()))\n            .map((feature) => this.transformCluster(feature));\n    }\n    transformCluster({ geometry: { coordinates: [lng, lat], }, properties, }) {\n        if (properties.cluster) {\n            return new Cluster({\n                markers: this.superCluster\n                    .getLeaves(properties.cluster_id, Infinity)\n                    .map((leaf) => leaf.properties.marker),\n                position: { lat, lng },\n            });\n        }\n        const marker = properties.marker;\n        return new Cluster({\n            markers: [marker],\n            position: MarkerUtils.getPosition(marker),\n        });\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nclass SuperClusterViewportAlgorithm extends AbstractViewportAlgorithm {\n    constructor(_a) {\n        var { maxZoom, radius = 60, viewportPadding = 60 } = _a, options = __rest(_a, [\"maxZoom\", \"radius\", \"viewportPadding\"]);\n        super({ maxZoom, viewportPadding });\n        this.superCluster = new Supercluster(Object.assign({ maxZoom: this.maxZoom, radius }, options));\n        this.state = { zoom: -1, view: [0, 0, 0, 0] };\n    }\n    calculate(input) {\n        const state = {\n            zoom: Math.round(input.map.getZoom()),\n            view: getPaddedViewport(input.map.getBounds(), input.mapCanvasProjection, this.viewportPadding),\n        };\n        let changed = !equal(this.state, state);\n        if (!equal(input.markers, this.markers)) {\n            changed = true;\n            // TODO use proxy to avoid copy?\n            this.markers = [...input.markers];\n            const points = this.markers.map((marker) => {\n                const position = MarkerUtils.getPosition(marker);\n                const coordinates = [position.lng(), position.lat()];\n                return {\n                    type: \"Feature\",\n                    geometry: {\n                        type: \"Point\",\n                        coordinates,\n                    },\n                    properties: { marker },\n                };\n            });\n            this.superCluster.load(points);\n        }\n        if (changed) {\n            this.clusters = this.cluster(input);\n            this.state = state;\n        }\n        return { clusters: this.clusters, changed };\n    }\n    cluster({ map, mapCanvasProjection }) {\n        /* recalculate new state because we can't use the cached version. */\n        const state = {\n            zoom: Math.round(map.getZoom()),\n            view: getPaddedViewport(map.getBounds(), mapCanvasProjection, this.viewportPadding),\n        };\n        return this.superCluster\n            .getClusters(state.view, state.zoom)\n            .map((feature) => this.transformCluster(feature));\n    }\n    transformCluster({ geometry: { coordinates: [lng, lat], }, properties, }) {\n        if (properties.cluster) {\n            return new Cluster({\n                markers: this.superCluster\n                    .getLeaves(properties.cluster_id, Infinity)\n                    .map((leaf) => leaf.properties.marker),\n                position: { lat, lng },\n            });\n        }\n        const marker = properties.marker;\n        return new Cluster({\n            markers: [marker],\n            position: MarkerUtils.getPosition(marker),\n        });\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\n */\nclass ClusterStats {\n    constructor(markers, clusters) {\n        this.markers = { sum: markers.length };\n        const clusterMarkerCounts = clusters.map((a) => a.count);\n        const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\n        this.clusters = {\n            count: clusters.length,\n            markers: {\n                mean: clusterMarkerSum / clusters.length,\n                sum: clusterMarkerSum,\n                min: Math.min(...clusterMarkerCounts),\n                max: Math.max(...clusterMarkerCounts),\n            },\n        };\n    }\n}\nclass DefaultRenderer {\n    /**\n     * The default render function for the library used by {@link MarkerClusterer}.\n     *\n     * Currently set to use the following:\n     *\n     * ```typescript\n     * // change color if this cluster has more markers than the mean cluster\n     * const color =\n     *   count > Math.max(10, stats.clusters.markers.mean)\n     *     ? \"#ff0000\"\n     *     : \"#0000ff\";\n     *\n     * // create svg url with fill color\n     * const svg = window.btoa(`\n     * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n     *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n     * </svg>`);\n     *\n     * // create marker using svg icon\n     * return new google.maps.Marker({\n     *   position,\n     *   icon: {\n     *     url: `data:image/svg+xml;base64,${svg}`,\n     *     scaledSize: new google.maps.Size(45, 45),\n     *   },\n     *   label: {\n     *     text: String(count),\n     *     color: \"rgba(255,255,255,0.9)\",\n     *     fontSize: \"12px\",\n     *   },\n     *   // adjust zIndex to be above other markers\n     *   zIndex: 1000 + count,\n     * });\n     * ```\n     */\n    render({ count, position }, stats, map) {\n        // change color if this cluster has more markers than the mean cluster\n        const color = count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\n        // create svg literal with fill color\n        const svg = `<svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\" width=\"50\" height=\"50\">\n<circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n<circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n<circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n<text x=\"50%\" y=\"50%\" style=\"fill:#fff\" text-anchor=\"middle\" font-size=\"50\" dominant-baseline=\"middle\" font-family=\"roboto,arial,sans-serif\">${count}</text>\n</svg>`;\n        const title = `Cluster of ${count} markers`, \n        // adjust zIndex to be above other markers\n        zIndex = Number(google.maps.Marker.MAX_ZINDEX) + count;\n        if (MarkerUtils.isAdvancedMarkerAvailable(map)) {\n            // create cluster SVG element\n            const parser = new DOMParser();\n            const svgEl = parser.parseFromString(svg, \"image/svg+xml\").documentElement;\n            svgEl.setAttribute(\"transform\", \"translate(0 25)\");\n            const clusterOptions = {\n                map,\n                position,\n                zIndex,\n                title,\n                content: svgEl,\n            };\n            return new google.maps.marker.AdvancedMarkerElement(clusterOptions);\n        }\n        const clusterOptions = {\n            position,\n            zIndex,\n            title,\n            icon: {\n                url: `data:image/svg+xml;base64,${btoa(svg)}`,\n                anchor: new google.maps.Point(25, 25),\n            },\n        };\n        return new google.maps.Marker(clusterOptions);\n    }\n}\n\n/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1, type2) {\n    /* istanbul ignore next */\n    // eslint-disable-next-line prefer-const\n    for (let property in type2.prototype) {\n        type1.prototype[property] = type2.prototype[property];\n    }\n}\n/**\n * @ignore\n */\nclass OverlayViewSafe {\n    constructor() {\n        // MarkerClusterer implements google.maps.OverlayView interface. We use the\n        // extend function to extend MarkerClusterer with google.maps.OverlayView\n        // because it might not always be available when the code is defined so we\n        // look for it at the last possible moment. If it doesn't exist now then\n        // there is no point going ahead :)\n        extend(OverlayViewSafe, google.maps.OverlayView);\n    }\n}\n\n/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar MarkerClustererEvents;\n(function (MarkerClustererEvents) {\n    MarkerClustererEvents[\"CLUSTERING_BEGIN\"] = \"clusteringbegin\";\n    MarkerClustererEvents[\"CLUSTERING_END\"] = \"clusteringend\";\n    MarkerClustererEvents[\"CLUSTER_CLICK\"] = \"click\";\n})(MarkerClustererEvents || (MarkerClustererEvents = {}));\nconst defaultOnClusterClickHandler = (_, cluster, map) => {\n    map.fitBounds(cluster.bounds);\n};\n/**\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\n * of markers. See {@link MarkerClustererOptions} for more details.\n *\n */\nclass MarkerClusterer extends OverlayViewSafe {\n    constructor({ map, markers = [], algorithmOptions = {}, algorithm = new SuperClusterAlgorithm(algorithmOptions), renderer = new DefaultRenderer(), onClusterClick = defaultOnClusterClickHandler, }) {\n        super();\n        this.markers = [...markers];\n        this.clusters = [];\n        this.algorithm = algorithm;\n        this.renderer = renderer;\n        this.onClusterClick = onClusterClick;\n        if (map) {\n            this.setMap(map);\n        }\n    }\n    addMarker(marker, noDraw) {\n        if (this.markers.includes(marker)) {\n            return;\n        }\n        this.markers.push(marker);\n        if (!noDraw) {\n            this.render();\n        }\n    }\n    addMarkers(markers, noDraw) {\n        markers.forEach((marker) => {\n            this.addMarker(marker, true);\n        });\n        if (!noDraw) {\n            this.render();\n        }\n    }\n    removeMarker(marker, noDraw) {\n        const index = this.markers.indexOf(marker);\n        if (index === -1) {\n            // Marker is not in our list of markers, so do nothing:\n            return false;\n        }\n        MarkerUtils.setMap(marker, null);\n        this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n        if (!noDraw) {\n            this.render();\n        }\n        return true;\n    }\n    removeMarkers(markers, noDraw) {\n        let removed = false;\n        markers.forEach((marker) => {\n            removed = this.removeMarker(marker, true) || removed;\n        });\n        if (removed && !noDraw) {\n            this.render();\n        }\n        return removed;\n    }\n    clearMarkers(noDraw) {\n        this.markers.length = 0;\n        if (!noDraw) {\n            this.render();\n        }\n    }\n    /**\n     * Recalculates and draws all the marker clusters.\n     */\n    render() {\n        const map = this.getMap();\n        if (map instanceof google.maps.Map && map.getProjection()) {\n            google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_BEGIN, this);\n            const { clusters, changed } = this.algorithm.calculate({\n                markers: this.markers,\n                map,\n                mapCanvasProjection: this.getProjection(),\n            });\n            // Allow algorithms to return flag on whether the clusters/markers have changed.\n            if (changed || changed == undefined) {\n                // Accumulate the markers of the clusters composed of a single marker.\n                // Those clusters directly use the marker.\n                // Clusters with more than one markers use a group marker generated by a renderer.\n                const singleMarker = new Set();\n                for (const cluster of clusters) {\n                    if (cluster.markers.length == 1) {\n                        singleMarker.add(cluster.markers[0]);\n                    }\n                }\n                const groupMarkers = [];\n                // Iterate the clusters that are currently rendered.\n                for (const cluster of this.clusters) {\n                    if (cluster.marker == null) {\n                        continue;\n                    }\n                    if (cluster.markers.length == 1) {\n                        if (!singleMarker.has(cluster.marker)) {\n                            // The marker:\n                            // - was previously rendered because it is from a cluster with 1 marker,\n                            // - should no more be rendered as it is not in singleMarker.\n                            MarkerUtils.setMap(cluster.marker, null);\n                        }\n                    }\n                    else {\n                        // Delay the removal of old group markers to avoid flickering.\n                        groupMarkers.push(cluster.marker);\n                    }\n                }\n                this.clusters = clusters;\n                this.renderClusters();\n                // Delayed removal of the markers of the former groups.\n                requestAnimationFrame(() => groupMarkers.forEach((marker) => MarkerUtils.setMap(marker, null)));\n            }\n            google.maps.event.trigger(this, MarkerClustererEvents.CLUSTERING_END, this);\n        }\n    }\n    onAdd() {\n        this.idleListener = this.getMap().addListener(\"idle\", this.render.bind(this));\n        this.render();\n    }\n    onRemove() {\n        google.maps.event.removeListener(this.idleListener);\n        this.reset();\n    }\n    reset() {\n        this.markers.forEach((marker) => MarkerUtils.setMap(marker, null));\n        this.clusters.forEach((cluster) => cluster.delete());\n        this.clusters = [];\n    }\n    renderClusters() {\n        // Generate stats to pass to renderers.\n        const stats = new ClusterStats(this.markers, this.clusters);\n        const map = this.getMap();\n        this.clusters.forEach((cluster) => {\n            if (cluster.markers.length === 1) {\n                cluster.marker = cluster.markers[0];\n            }\n            else {\n                // Generate the marker to represent the group.\n                cluster.marker = this.renderer.render(cluster, stats, map);\n                // Make sure all individual markers are removed from the map.\n                cluster.markers.forEach((marker) => MarkerUtils.setMap(marker, null));\n                if (this.onClusterClick) {\n                    cluster.marker.addListener(\"click\", \n                    /* istanbul ignore next */\n                    (event) => {\n                        google.maps.event.trigger(this, MarkerClustererEvents.CLUSTER_CLICK, cluster);\n                        this.onClusterClick(event, cluster, map);\n                    });\n                }\n            }\n            MarkerUtils.setMap(cluster.marker, map);\n        });\n    }\n}\n\nvar index_esm = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    AbstractAlgorithm: AbstractAlgorithm,\n    AbstractViewportAlgorithm: AbstractViewportAlgorithm,\n    Cluster: Cluster,\n    ClusterStats: ClusterStats,\n    DefaultRenderer: DefaultRenderer,\n    GridAlgorithm: GridAlgorithm,\n    MarkerClusterer: MarkerClusterer,\n    get MarkerClustererEvents () { return MarkerClustererEvents; },\n    MarkerUtils: MarkerUtils,\n    NoopAlgorithm: NoopAlgorithm,\n    SuperClusterAlgorithm: SuperClusterAlgorithm,\n    SuperClusterViewportAlgorithm: SuperClusterViewportAlgorithm,\n    defaultOnClusterClickHandler: defaultOnClusterClickHandler,\n    distanceBetweenPoints: distanceBetweenPoints,\n    extendBoundsToPaddedViewport: extendBoundsToPaddedViewport,\n    extendPixelBounds: extendPixelBounds,\n    filterMarkersToPaddedViewport: filterMarkersToPaddedViewport,\n    getPaddedViewport: getPaddedViewport,\n    noop: noop$1,\n    pixelBoundsToLatLngBounds: pixelBoundsToLatLngBounds\n});\n\nfunction useGoogleMarkerClusterer(options) {\n    var map = useGoogleMap();\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), markerClusterer = _a[0], setMarkerClusterer = _a[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map && markerClusterer === null) {\n            var markerCluster = new MarkerClusterer(__assign(__assign({}, options), { map: map }));\n            setMarkerClusterer(markerCluster);\n        }\n    }, [map]);\n    return markerClusterer;\n}\n/** Wrapper around [@googlemaps/markerclusterer](https://github.com/googlemaps/js-markerclusterer)\n *\n * Accepts {@link  MarkerClustererOptionsSubset} which is a subset of  {@link MarkerClustererOptions}\n */\nfunction GoogleMarkerClusterer(_a) {\n    var children = _a.children, options = _a.options;\n    var markerClusterer = useGoogleMarkerClusterer(options);\n    return markerClusterer !== null ? children(markerClusterer) : null;\n}\nvar GoogleMarkerClusterer$1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GoogleMarkerClusterer);\n\nvar eventMap$c = {\n    onCloseClick: 'closeclick',\n    onContentChanged: 'content_changed',\n    onDomReady: 'domready',\n    onPositionChanged: 'position_changed',\n    onZindexChanged: 'zindex_changed',\n};\nvar updaterMap$c = {\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    position: function (instance, position) {\n        instance.setPosition(position);\n    },\n    zIndex: function (instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nfunction InfoWindowFunctional(_a) {\n    var children = _a.children, anchor = _a.anchor, options = _a.options, position = _a.position, zIndex = _a.zIndex, onCloseClick = _a.onCloseClick, onDomReady = _a.onDomReady, onContentChanged = _a.onContentChanged, onPositionChanged = _a.onPositionChanged, onZindexChanged = _a.onZindexChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), closeclickListener = _c[0], setCloseClickListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), domreadyclickListener = _d[0], setDomReadyClickListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), contentchangedclickListener = _e[0], setContentChangedClickListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), positionchangedclickListener = _f[0], setPositionChangedClickListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), zindexchangedclickListener = _g[0], setZindexChangedClickListener = _g[1];\n    var containerElementRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.close();\n            if (anchor) {\n                instance.open(map, anchor);\n            }\n            else if (instance.getPosition()) {\n                instance.open(map);\n            }\n        }\n    }, [map, instance, anchor]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (position && instance !== null) {\n            instance.setPosition(position);\n        }\n    }, [position]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof zIndex === 'number' && instance !== null) {\n            instance.setZIndex(zIndex);\n        }\n    }, [zIndex]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onCloseClick) {\n            if (closeclickListener !== null) {\n                google.maps.event.removeListener(closeclickListener);\n            }\n            setCloseClickListener(google.maps.event.addListener(instance, 'closeclick', onCloseClick));\n        }\n    }, [onCloseClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDomReady) {\n            if (domreadyclickListener !== null) {\n                google.maps.event.removeListener(domreadyclickListener);\n            }\n            setDomReadyClickListener(google.maps.event.addListener(instance, 'domready', onDomReady));\n        }\n    }, [onDomReady]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onContentChanged) {\n            if (contentchangedclickListener !== null) {\n                google.maps.event.removeListener(contentchangedclickListener);\n            }\n            setContentChangedClickListener(google.maps.event.addListener(instance, 'content_changed', onContentChanged));\n        }\n    }, [onContentChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onPositionChanged) {\n            if (positionchangedclickListener !== null) {\n                google.maps.event.removeListener(positionchangedclickListener);\n            }\n            setPositionChangedClickListener(google.maps.event.addListener(instance, 'position_changed', onPositionChanged));\n        }\n    }, [onPositionChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onZindexChanged) {\n            if (zindexchangedclickListener !== null) {\n                google.maps.event.removeListener(zindexchangedclickListener);\n            }\n            setZindexChangedClickListener(google.maps.event.addListener(instance, 'zindex_changed', onZindexChanged));\n        }\n    }, [onZindexChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var infoWindow = new google.maps.InfoWindow(__assign({}, (options || {})));\n        setInstance(infoWindow);\n        containerElementRef.current = document.createElement('div');\n        if (onCloseClick) {\n            setCloseClickListener(google.maps.event.addListener(infoWindow, 'closeclick', onCloseClick));\n        }\n        if (onDomReady) {\n            setDomReadyClickListener(google.maps.event.addListener(infoWindow, 'domready', onDomReady));\n        }\n        if (onContentChanged) {\n            setContentChangedClickListener(google.maps.event.addListener(infoWindow, 'content_changed', onContentChanged));\n        }\n        if (onPositionChanged) {\n            setPositionChangedClickListener(google.maps.event.addListener(infoWindow, 'position_changed', onPositionChanged));\n        }\n        if (onZindexChanged) {\n            setZindexChangedClickListener(google.maps.event.addListener(infoWindow, 'zindex_changed', onZindexChanged));\n        }\n        infoWindow.setContent(containerElementRef.current);\n        if (position) {\n            infoWindow.setPosition(position);\n        }\n        if (zIndex) {\n            infoWindow.setZIndex(zIndex);\n        }\n        if (anchor) {\n            infoWindow.open(map, anchor);\n        }\n        else if (infoWindow.getPosition()) {\n            infoWindow.open(map);\n        }\n        else {\n            invariant$1(false, \"You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.\");\n        }\n        if (onLoad) {\n            onLoad(infoWindow);\n        }\n        return function () {\n            if (closeclickListener) {\n                google.maps.event.removeListener(closeclickListener);\n            }\n            if (contentchangedclickListener) {\n                google.maps.event.removeListener(contentchangedclickListener);\n            }\n            if (domreadyclickListener) {\n                google.maps.event.removeListener(domreadyclickListener);\n            }\n            if (positionchangedclickListener) {\n                google.maps.event.removeListener(positionchangedclickListener);\n            }\n            if (zindexchangedclickListener) {\n                google.maps.event.removeListener(zindexchangedclickListener);\n            }\n            if (onUnmount) {\n                onUnmount(infoWindow);\n            }\n            infoWindow.close();\n        };\n    }, []);\n    return containerElementRef.current ? ((0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(react__WEBPACK_IMPORTED_MODULE_1__.Children.only(children), containerElementRef.current)) : (null);\n}\nvar InfoWindowF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(InfoWindowFunctional);\nvar InfoWindow = /** @class */ (function (_super) {\n    __extends(InfoWindow, _super);\n    function InfoWindow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.containerElement = null;\n        _this.state = {\n            infoWindow: null,\n        };\n        _this.open = function (infoWindow, anchor) {\n            if (anchor) {\n                infoWindow.open(_this.context, anchor);\n            }\n            else if (infoWindow.getPosition()) {\n                infoWindow.open(_this.context);\n            }\n            else {\n                invariant$1(false, \"You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.\");\n            }\n        };\n        _this.setInfoWindowCallback = function () {\n            if (_this.state.infoWindow !== null && _this.containerElement !== null) {\n                _this.state.infoWindow.setContent(_this.containerElement);\n                _this.open(_this.state.infoWindow, _this.props.anchor);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.infoWindow);\n                }\n            }\n        };\n        return _this;\n    }\n    InfoWindow.prototype.componentDidMount = function () {\n        var infoWindow = new google.maps.InfoWindow(__assign({}, (this.props.options || {})));\n        this.containerElement = document.createElement('div');\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$c,\n            eventMap: eventMap$c,\n            prevProps: {},\n            nextProps: this.props,\n            instance: infoWindow,\n        });\n        this.setState(function () {\n            return {\n                infoWindow: infoWindow,\n            };\n        }, this.setInfoWindowCallback);\n    };\n    InfoWindow.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.infoWindow !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$c,\n                eventMap: eventMap$c,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.infoWindow,\n            });\n        }\n    };\n    InfoWindow.prototype.componentWillUnmount = function () {\n        if (this.state.infoWindow !== null) {\n            unregisterEvents(this.registeredEvents);\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.infoWindow);\n            }\n            this.state.infoWindow.close();\n        }\n    };\n    InfoWindow.prototype.render = function () {\n        return this.containerElement ? ((0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)(react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children), this.containerElement)) : (null);\n    };\n    InfoWindow.contextType = MapContext;\n    return InfoWindow;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$b = {\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nvar updaterMap$b = {\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable: function (instance, editable) {\n        instance.setEditable(editable);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    path: function (instance, path) {\n        instance.setPath(path);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nvar defaultOptions$1 = {};\nfunction PolylineFunctional(_a) {\n    var options = _a.options, draggable = _a.draggable, editable = _a.editable, visible = _a.visible, path = _a.path, onDblClick = _a.onDblClick, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onClick = _a.onClick, onDrag = _a.onDrag, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousemoveListener = _g[0], setMousemoveListener = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoutListener = _h[0], setMouseoutListener = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoverListener = _j[0], setMouseoverListener = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseupListener = _k[0], setMouseupListener = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), rightclickListener = _l[0], setRightclickListener = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clickListener = _m[0], setClickListener = _m[1];\n    var _o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragListener = _o[0], setDragListener = _o[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof editable !== 'undefined' && instance !== null) {\n            instance.setEditable(editable);\n        }\n    }, [instance, editable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof path !== 'undefined' && instance !== null) {\n            instance.setPath(path);\n        }\n    }, [instance, path]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var polyline = new google.maps.Polyline(__assign(__assign({}, (options || defaultOptions$1)), { map: map }));\n        if (path) {\n            polyline.setPath(path);\n        }\n        if (typeof visible !== 'undefined') {\n            polyline.setVisible(visible);\n        }\n        if (typeof editable !== 'undefined') {\n            polyline.setEditable(editable);\n        }\n        if (typeof draggable !== 'undefined') {\n            polyline.setDraggable(draggable);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(polyline, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(polyline, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(polyline, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(polyline, 'mousedown', onMouseDown));\n        }\n        if (onMouseMove) {\n            setMousemoveListener(google.maps.event.addListener(polyline, 'mousemove', onMouseMove));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(polyline, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(polyline, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(polyline, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightclickListener(google.maps.event.addListener(polyline, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(polyline, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(polyline, 'drag', onDrag));\n        }\n        setInstance(polyline);\n        if (onLoad) {\n            onLoad(polyline);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (onUnmount) {\n                onUnmount(polyline);\n            }\n            polyline.setMap(null);\n        };\n    }, []);\n    return null;\n}\nvar PolylineF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(PolylineFunctional);\nvar Polyline = /** @class */ (function (_super) {\n    __extends(Polyline, _super);\n    function Polyline() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            polyline: null,\n        };\n        _this.setPolylineCallback = function () {\n            if (_this.state.polyline !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.polyline);\n            }\n        };\n        return _this;\n    }\n    Polyline.prototype.componentDidMount = function () {\n        var polyline = new google.maps.Polyline(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$b,\n            eventMap: eventMap$b,\n            prevProps: {},\n            nextProps: this.props,\n            instance: polyline,\n        });\n        this.setState(function setPolyline() {\n            return {\n                polyline: polyline,\n            };\n        }, this.setPolylineCallback);\n    };\n    Polyline.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.polyline !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$b,\n                eventMap: eventMap$b,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.polyline,\n            });\n        }\n    };\n    Polyline.prototype.componentWillUnmount = function () {\n        if (this.state.polyline !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.polyline);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.polyline.setMap(null);\n        }\n    };\n    Polyline.prototype.render = function () {\n        return null;\n    };\n    Polyline.contextType = MapContext;\n    return Polyline;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$a = {\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nvar updaterMap$a = {\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable: function (instance, editable) {\n        instance.setEditable(editable);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    path: function (instance, path) {\n        instance.setPath(path);\n    },\n    paths: function (instance, paths) {\n        instance.setPaths(paths);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nfunction PolygonFunctional(_a) {\n    var options = _a.options, draggable = _a.draggable, editable = _a.editable, visible = _a.visible, path = _a.path, paths = _a.paths, onDblClick = _a.onDblClick, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onClick = _a.onClick, onDrag = _a.onDrag, onLoad = _a.onLoad, onUnmount = _a.onUnmount, onEdit = _a.onEdit;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousemoveListener = _g[0], setMousemoveListener = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoutListener = _h[0], setMouseoutListener = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoverListener = _j[0], setMouseoverListener = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseupListener = _k[0], setMouseupListener = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), rightclickListener = _l[0], setRightclickListener = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clickListener = _m[0], setClickListener = _m[1];\n    var _o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragListener = _o[0], setDragListener = _o[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof editable !== 'undefined' && instance !== null) {\n            instance.setEditable(editable);\n        }\n    }, [instance, editable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof path !== 'undefined' && instance !== null) {\n            instance.setPath(path);\n        }\n    }, [instance, path]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof paths !== 'undefined' && instance !== null) {\n            instance.setPaths(paths);\n        }\n    }, [instance, paths]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance) {\n            google.maps.event.addListener(instance.getPath(), 'insert_at', function () {\n                onEdit === null || onEdit === void 0 ? void 0 : onEdit(instance);\n            });\n            google.maps.event.addListener(instance.getPath(), 'set_at', function () {\n                onEdit === null || onEdit === void 0 ? void 0 : onEdit(instance);\n            });\n        }\n    }, [instance, onEdit]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var polygon = new google.maps.Polygon(__assign(__assign({}, (options || {})), { map: map }));\n        if (path) {\n            polygon.setPath(path);\n        }\n        if (paths) {\n            polygon.setPaths(paths);\n        }\n        if (typeof visible !== 'undefined') {\n            polygon.setVisible(visible);\n        }\n        if (typeof editable !== 'undefined') {\n            polygon.setEditable(editable);\n        }\n        if (typeof draggable !== 'undefined') {\n            polygon.setDraggable(draggable);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(polygon, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(polygon, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(polygon, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(polygon, 'mousedown', onMouseDown));\n        }\n        if (onMouseMove) {\n            setMousemoveListener(google.maps.event.addListener(polygon, 'mousemove', onMouseMove));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(polygon, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(polygon, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(polygon, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightclickListener(google.maps.event.addListener(polygon, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(polygon, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(polygon, 'drag', onDrag));\n        }\n        setInstance(polygon);\n        if (onLoad) {\n            onLoad(polygon);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (onUnmount) {\n                onUnmount(polygon);\n            }\n            polygon.setMap(null);\n        };\n    }, []);\n    return null;\n}\nvar PolygonF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(PolygonFunctional);\nvar Polygon = /** @class */ (function (_super) {\n    __extends(Polygon, _super);\n    function Polygon() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            polygon: null,\n        };\n        _this.setPolygonCallback = function () {\n            if (_this.state.polygon !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.polygon);\n            }\n        };\n        return _this;\n    }\n    Polygon.prototype.componentDidMount = function () {\n        var polygon = new google.maps.Polygon(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$a,\n            eventMap: eventMap$a,\n            prevProps: {},\n            nextProps: this.props,\n            instance: polygon,\n        });\n        this.setState(function setPolygon() {\n            return {\n                polygon: polygon,\n            };\n        }, this.setPolygonCallback);\n    };\n    Polygon.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.polygon !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$a,\n                eventMap: eventMap$a,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.polygon,\n            });\n        }\n    };\n    Polygon.prototype.componentWillUnmount = function () {\n        if (this.state.polygon !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.polygon);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.polygon && this.state.polygon.setMap(null);\n        }\n    };\n    Polygon.prototype.render = function () {\n        return null;\n    };\n    Polygon.contextType = MapContext;\n    return Polygon;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$9 = {\n    onBoundsChanged: 'bounds_changed',\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nvar updaterMap$9 = {\n    bounds: function (instance, bounds) {\n        instance.setBounds(bounds);\n    },\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable: function (instance, editable) {\n        instance.setEditable(editable);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nfunction RectangleFunctional(_a) {\n    var options = _a.options, bounds = _a.bounds, draggable = _a.draggable, editable = _a.editable, visible = _a.visible, onDblClick = _a.onDblClick, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onClick = _a.onClick, onDrag = _a.onDrag, onBoundsChanged = _a.onBoundsChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousemoveListener = _g[0], setMousemoveListener = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoutListener = _h[0], setMouseoutListener = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoverListener = _j[0], setMouseoverListener = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseupListener = _k[0], setMouseupListener = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), rightClickListener = _l[0], setRightClickListener = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clickListener = _m[0], setClickListener = _m[1];\n    var _o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragListener = _o[0], setDragListener = _o[1];\n    var _p = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), boundsChangedListener = _p[0], setBoundsChangedListener = _p[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof editable !== 'undefined' && instance !== null) {\n            instance.setEditable(editable);\n        }\n    }, [instance, editable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof bounds !== 'undefined' && instance !== null) {\n            instance.setBounds(bounds);\n        }\n    }, [instance, bounds]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRightClick) {\n            if (rightClickListener !== null) {\n                google.maps.event.removeListener(rightClickListener);\n            }\n            setRightClickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onBoundsChanged) {\n            if (boundsChangedListener !== null) {\n                google.maps.event.removeListener(boundsChangedListener);\n            }\n            setBoundsChangedListener(google.maps.event.addListener(instance, 'bounds_changed', onBoundsChanged));\n        }\n    }, [onBoundsChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var rectangle = new google.maps.Rectangle(__assign(__assign({}, (options || {})), { map: map }));\n        if (typeof visible !== 'undefined') {\n            rectangle.setVisible(visible);\n        }\n        if (typeof editable !== 'undefined') {\n            rectangle.setEditable(editable);\n        }\n        if (typeof draggable !== 'undefined') {\n            rectangle.setDraggable(draggable);\n        }\n        if (typeof bounds !== 'undefined') {\n            rectangle.setBounds(bounds);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(rectangle, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(rectangle, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(rectangle, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(rectangle, 'mousedown', onMouseDown));\n        }\n        if (onMouseMove) {\n            setMousemoveListener(google.maps.event.addListener(rectangle, 'mousemove', onMouseMove));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(rectangle, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(rectangle, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(rectangle, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightClickListener(google.maps.event.addListener(rectangle, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(rectangle, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(rectangle, 'drag', onDrag));\n        }\n        if (onBoundsChanged) {\n            setBoundsChangedListener(google.maps.event.addListener(rectangle, 'bounds_changed', onBoundsChanged));\n        }\n        setInstance(rectangle);\n        if (onLoad) {\n            onLoad(rectangle);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightClickListener !== null) {\n                google.maps.event.removeListener(rightClickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            if (boundsChangedListener !== null) {\n                google.maps.event.removeListener(boundsChangedListener);\n            }\n            if (onUnmount) {\n                onUnmount(rectangle);\n            }\n            rectangle.setMap(null);\n        };\n    }, []);\n    return null;\n}\nvar RectangleF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(RectangleFunctional);\nvar Rectangle = /** @class */ (function (_super) {\n    __extends(Rectangle, _super);\n    function Rectangle() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            rectangle: null,\n        };\n        _this.setRectangleCallback = function () {\n            if (_this.state.rectangle !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.rectangle);\n            }\n        };\n        return _this;\n    }\n    Rectangle.prototype.componentDidMount = function () {\n        var rectangle = new google.maps.Rectangle(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$9,\n            eventMap: eventMap$9,\n            prevProps: {},\n            nextProps: this.props,\n            instance: rectangle,\n        });\n        this.setState(function setRectangle() {\n            return {\n                rectangle: rectangle,\n            };\n        }, this.setRectangleCallback);\n    };\n    Rectangle.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.rectangle !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$9,\n                eventMap: eventMap$9,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.rectangle,\n            });\n        }\n    };\n    Rectangle.prototype.componentWillUnmount = function () {\n        if (this.state.rectangle !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.rectangle);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.rectangle.setMap(null);\n        }\n    };\n    Rectangle.prototype.render = function () {\n        return null;\n    };\n    Rectangle.contextType = MapContext;\n    return Rectangle;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$8 = {\n    onCenterChanged: 'center_changed',\n    onRadiusChanged: 'radius_changed',\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onDrag: 'drag',\n    onDragEnd: 'dragend',\n    onDragStart: 'dragstart',\n    onMouseDown: 'mousedown',\n    onMouseMove: 'mousemove',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n};\nvar updaterMap$8 = {\n    center: function (instance, center) {\n        instance.setCenter(center);\n    },\n    draggable: function (instance, draggable) {\n        instance.setDraggable(draggable);\n    },\n    editable: function (instance, editable) {\n        instance.setEditable(editable);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    radius: function (instance, radius) {\n        instance.setRadius(radius);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n};\nvar defaultOptions = {};\nfunction CircleFunctional(_a) {\n    var options = _a.options, center = _a.center, radius = _a.radius, draggable = _a.draggable, editable = _a.editable, visible = _a.visible, onDblClick = _a.onDblClick, onDragEnd = _a.onDragEnd, onDragStart = _a.onDragStart, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onClick = _a.onClick, onDrag = _a.onDrag, onCenterChanged = _a.onCenterChanged, onRadiusChanged = _a.onRadiusChanged, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragendListener = _d[0], setDragendListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragstartListener = _e[0], setDragstartListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousedownListener = _f[0], setMousedownListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousemoveListener = _g[0], setMousemoveListener = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoutListener = _h[0], setMouseoutListener = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoverListener = _j[0], setMouseoverListener = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseupListener = _k[0], setMouseupListener = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), rightclickListener = _l[0], setRightclickListener = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clickListener = _m[0], setClickListener = _m[1];\n    var _o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dragListener = _o[0], setDragListener = _o[1];\n    var _p = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), centerChangedListener = _p[0], setCenterChangedListener = _p[1];\n    var _q = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), radiusChangedListener = _q[0], setRadiusChangedListener = _q[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof options !== 'undefined' && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof draggable !== 'undefined' && instance !== null) {\n            instance.setDraggable(draggable);\n        }\n    }, [instance, draggable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof editable !== 'undefined' && instance !== null) {\n            instance.setEditable(editable);\n        }\n    }, [instance, editable]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof visible !== 'undefined' && instance !== null) {\n            instance.setVisible(visible);\n        }\n    }, [instance, visible]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof radius === 'number' && instance !== null) {\n            instance.setRadius(radius);\n        }\n    }, [instance, radius]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof center !== 'undefined' && instance !== null) {\n            instance.setCenter(center);\n        }\n    }, [instance, center]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragEnd) {\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            setDragendListener(google.maps.event.addListener(instance, 'dragend', onDragEnd));\n        }\n    }, [onDragEnd]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDragStart) {\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            setDragstartListener(google.maps.event.addListener(instance, 'dragstart', onDragStart));\n        }\n    }, [onDragStart]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDrag) {\n            if (dragListener !== null) {\n                google.maps.event.removeListener(dragListener);\n            }\n            setDragListener(google.maps.event.addListener(instance, 'drag', onDrag));\n        }\n    }, [onDrag]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onCenterChanged) {\n            if (centerChangedListener !== null) {\n                google.maps.event.removeListener(centerChangedListener);\n            }\n            setCenterChangedListener(google.maps.event.addListener(instance, 'center_changed', onCenterChanged));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRadiusChanged) {\n            if (radiusChangedListener !== null) {\n                google.maps.event.removeListener(radiusChangedListener);\n            }\n            setRadiusChangedListener(google.maps.event.addListener(instance, 'radius_changed', onRadiusChanged));\n        }\n    }, [onRadiusChanged]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var circle = new google.maps.Circle(__assign(__assign({}, (options || defaultOptions)), { map: map }));\n        if (typeof radius === 'number') {\n            circle.setRadius(radius);\n        }\n        if (typeof center !== 'undefined') {\n            circle.setCenter(center);\n        }\n        if (typeof radius === 'number') {\n            circle.setRadius(radius);\n        }\n        if (typeof visible !== 'undefined') {\n            circle.setVisible(visible);\n        }\n        if (typeof editable !== 'undefined') {\n            circle.setEditable(editable);\n        }\n        if (typeof draggable !== 'undefined') {\n            circle.setDraggable(draggable);\n        }\n        if (onDblClick) {\n            setDblclickListener(google.maps.event.addListener(circle, 'dblclick', onDblClick));\n        }\n        if (onDragEnd) {\n            setDragendListener(google.maps.event.addListener(circle, 'dragend', onDragEnd));\n        }\n        if (onDragStart) {\n            setDragstartListener(google.maps.event.addListener(circle, 'dragstart', onDragStart));\n        }\n        if (onMouseDown) {\n            setMousedownListener(google.maps.event.addListener(circle, 'mousedown', onMouseDown));\n        }\n        if (onMouseMove) {\n            setMousemoveListener(google.maps.event.addListener(circle, 'mousemove', onMouseMove));\n        }\n        if (onMouseOut) {\n            setMouseoutListener(google.maps.event.addListener(circle, 'mouseout', onMouseOut));\n        }\n        if (onMouseOver) {\n            setMouseoverListener(google.maps.event.addListener(circle, 'mouseover', onMouseOver));\n        }\n        if (onMouseUp) {\n            setMouseupListener(google.maps.event.addListener(circle, 'mouseup', onMouseUp));\n        }\n        if (onRightClick) {\n            setRightclickListener(google.maps.event.addListener(circle, 'rightclick', onRightClick));\n        }\n        if (onClick) {\n            setClickListener(google.maps.event.addListener(circle, 'click', onClick));\n        }\n        if (onDrag) {\n            setDragListener(google.maps.event.addListener(circle, 'drag', onDrag));\n        }\n        if (onCenterChanged) {\n            setCenterChangedListener(google.maps.event.addListener(circle, 'center_changed', onCenterChanged));\n        }\n        if (onRadiusChanged) {\n            setRadiusChangedListener(google.maps.event.addListener(circle, 'radius_changed', onRadiusChanged));\n        }\n        setInstance(circle);\n        if (onLoad) {\n            onLoad(circle);\n        }\n        return function () {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            if (dragendListener !== null) {\n                google.maps.event.removeListener(dragendListener);\n            }\n            if (dragstartListener !== null) {\n                google.maps.event.removeListener(dragstartListener);\n            }\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            if (centerChangedListener !== null) {\n                google.maps.event.removeListener(centerChangedListener);\n            }\n            if (radiusChangedListener !== null) {\n                google.maps.event.removeListener(radiusChangedListener);\n            }\n            if (onUnmount) {\n                onUnmount(circle);\n            }\n            circle.setMap(null);\n        };\n    }, []);\n    return null;\n}\nvar CircleF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(CircleFunctional);\nvar Circle = /** @class */ (function (_super) {\n    __extends(Circle, _super);\n    function Circle() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            circle: null,\n        };\n        _this.setCircleCallback = function () {\n            if (_this.state.circle !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.circle);\n            }\n        };\n        return _this;\n    }\n    Circle.prototype.componentDidMount = function () {\n        var circle = new google.maps.Circle(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$8,\n            eventMap: eventMap$8,\n            prevProps: {},\n            nextProps: this.props,\n            instance: circle,\n        });\n        this.setState(function setCircle() {\n            return {\n                circle: circle,\n            };\n        }, this.setCircleCallback);\n    };\n    Circle.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.circle !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$8,\n                eventMap: eventMap$8,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.circle,\n            });\n        }\n    };\n    Circle.prototype.componentWillUnmount = function () {\n        var _a;\n        if (this.state.circle !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.circle);\n            }\n            unregisterEvents(this.registeredEvents);\n            (_a = this.state.circle) === null || _a === void 0 ? void 0 : _a.setMap(null);\n        }\n    };\n    Circle.prototype.render = function () {\n        return null;\n    };\n    Circle.contextType = MapContext;\n    return Circle;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$7 = {\n    onClick: 'click',\n    onDblClick: 'dblclick',\n    onMouseDown: 'mousedown',\n    onMouseOut: 'mouseout',\n    onMouseOver: 'mouseover',\n    onMouseUp: 'mouseup',\n    onRightClick: 'rightclick',\n    onAddFeature: 'addfeature',\n    onRemoveFeature: 'removefeature',\n    onRemoveProperty: 'removeproperty',\n    onSetGeometry: 'setgeometry',\n    onSetProperty: 'setproperty',\n};\nvar updaterMap$7 = {\n    add: function (instance, feature) {\n        instance.add(feature);\n    },\n    addgeojson: function (instance, geojson, options) {\n        instance.addGeoJson(geojson, options);\n    },\n    contains: function (instance, feature) {\n        instance.contains(feature);\n    },\n    foreach: function (instance, callback) {\n        instance.forEach(callback);\n    },\n    loadgeojson: function (instance, url, options, callback) {\n        instance.loadGeoJson(url, options, callback);\n    },\n    overridestyle: function (instance, feature, style) {\n        instance.overrideStyle(feature, style);\n    },\n    remove: function (instance, feature) {\n        instance.remove(feature);\n    },\n    revertstyle: function (instance, feature) {\n        instance.revertStyle(feature);\n    },\n    controlposition: function (instance, controlPosition) {\n        instance.setControlPosition(controlPosition);\n    },\n    controls: function (instance, controls) {\n        instance.setControls(controls);\n    },\n    drawingmode: function (instance, mode) {\n        instance.setDrawingMode(mode);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    style: function (instance, style) {\n        instance.setStyle(style);\n    },\n    togeojson: function (instance, callback) {\n        instance.toGeoJson(callback);\n    },\n};\nfunction DataFunctional(_a) {\n    var options = _a.options, onClick = _a.onClick, onDblClick = _a.onDblClick, onMouseDown = _a.onMouseDown, onMouseMove = _a.onMouseMove, onMouseOut = _a.onMouseOut, onMouseOver = _a.onMouseOver, onMouseUp = _a.onMouseUp, onRightClick = _a.onRightClick, onAddFeature = _a.onAddFeature, onRemoveFeature = _a.onRemoveFeature, onRemoveProperty = _a.onRemoveProperty, onSetGeometry = _a.onSetGeometry, onSetProperty = _a.onSetProperty, onLoad = _a.onLoad, onUnmount = _a.onUnmount;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    var _c = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), dblclickListener = _c[0], setDblclickListener = _c[1];\n    var _d = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousedownListener = _d[0], setMousedownListener = _d[1];\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mousemoveListener = _e[0], setMousemoveListener = _e[1];\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoutListener = _f[0], setMouseoutListener = _f[1];\n    var _g = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseoverListener = _g[0], setMouseoverListener = _g[1];\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), mouseupListener = _h[0], setMouseupListener = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), rightclickListener = _j[0], setRightclickListener = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), clickListener = _k[0], setClickListener = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), addFeatureListener = _l[0], setAddFeatureListener = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), removeFeatureListener = _m[0], setRemoveFeatureListener = _m[1];\n    var _o = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), removePropertyListener = _o[0], setRemovePropertyListener = _o[1];\n    var _p = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), setGeometryListener = _p[0], setSetGeometryListener = _p[1];\n    var _q = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), setPropertyListener = _q[0], setSetPropertyListener = _q[1];\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onDblClick) {\n            if (dblclickListener !== null) {\n                google.maps.event.removeListener(dblclickListener);\n            }\n            setDblclickListener(google.maps.event.addListener(instance, 'dblclick', onDblClick));\n        }\n    }, [onDblClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseDown) {\n            if (mousedownListener !== null) {\n                google.maps.event.removeListener(mousedownListener);\n            }\n            setMousedownListener(google.maps.event.addListener(instance, 'mousedown', onMouseDown));\n        }\n    }, [onMouseDown]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseMove) {\n            if (mousemoveListener !== null) {\n                google.maps.event.removeListener(mousemoveListener);\n            }\n            setMousemoveListener(google.maps.event.addListener(instance, 'mousemove', onMouseMove));\n        }\n    }, [onMouseMove]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOut) {\n            if (mouseoutListener !== null) {\n                google.maps.event.removeListener(mouseoutListener);\n            }\n            setMouseoutListener(google.maps.event.addListener(instance, 'mouseout', onMouseOut));\n        }\n    }, [onMouseOut]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseOver) {\n            if (mouseoverListener !== null) {\n                google.maps.event.removeListener(mouseoverListener);\n            }\n            setMouseoverListener(google.maps.event.addListener(instance, 'mouseover', onMouseOver));\n        }\n    }, [onMouseOver]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onMouseUp) {\n            if (mouseupListener !== null) {\n                google.maps.event.removeListener(mouseupListener);\n            }\n            setMouseupListener(google.maps.event.addListener(instance, 'mouseup', onMouseUp));\n        }\n    }, [onMouseUp]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRightClick) {\n            if (rightclickListener !== null) {\n                google.maps.event.removeListener(rightclickListener);\n            }\n            setRightclickListener(google.maps.event.addListener(instance, 'rightclick', onRightClick));\n        }\n    }, [onRightClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onClick) {\n            if (clickListener !== null) {\n                google.maps.event.removeListener(clickListener);\n            }\n            setClickListener(google.maps.event.addListener(instance, 'click', onClick));\n        }\n    }, [onClick]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onAddFeature) {\n            if (addFeatureListener !== null) {\n                google.maps.event.removeListener(addFeatureListener);\n            }\n            setAddFeatureListener(google.maps.event.addListener(instance, 'addfeature', onAddFeature));\n        }\n    }, [onAddFeature]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRemoveFeature) {\n            if (removeFeatureListener !== null) {\n                google.maps.event.removeListener(removeFeatureListener);\n            }\n            setRemoveFeatureListener(google.maps.event.addListener(instance, 'removefeature', onRemoveFeature));\n        }\n    }, [onRemoveFeature]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onRemoveProperty) {\n            if (removePropertyListener !== null) {\n                google.maps.event.removeListener(removePropertyListener);\n            }\n            setRemovePropertyListener(google.maps.event.addListener(instance, 'removeproperty', onRemoveProperty));\n        }\n    }, [onRemoveProperty]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onSetGeometry) {\n            if (setGeometryListener !== null) {\n                google.maps.event.removeListener(setGeometryListener);\n            }\n            setSetGeometryListener(google.maps.event.addListener(instance, 'setgeometry', onSetGeometry));\n        }\n    }, [onSetGeometry]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance && onSetProperty) {\n            if (setPropertyListener !== null) {\n                google.maps.event.removeListener(setPropertyListener);\n            }\n            setSetPropertyListener(google.maps.event.addListener(instance, 'setproperty', onSetProperty));\n        }\n    }, [onSetProperty]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (map !== null) {\n            var data = new google.maps.Data(__assign(__assign({}, (options || {})), { map: map }));\n            if (onDblClick) {\n                setDblclickListener(google.maps.event.addListener(data, 'dblclick', onDblClick));\n            }\n            if (onMouseDown) {\n                setMousedownListener(google.maps.event.addListener(data, 'mousedown', onMouseDown));\n            }\n            if (onMouseMove) {\n                setMousemoveListener(google.maps.event.addListener(data, 'mousemove', onMouseMove));\n            }\n            if (onMouseOut) {\n                setMouseoutListener(google.maps.event.addListener(data, 'mouseout', onMouseOut));\n            }\n            if (onMouseOver) {\n                setMouseoverListener(google.maps.event.addListener(data, 'mouseover', onMouseOver));\n            }\n            if (onMouseUp) {\n                setMouseupListener(google.maps.event.addListener(data, 'mouseup', onMouseUp));\n            }\n            if (onRightClick) {\n                setRightclickListener(google.maps.event.addListener(data, 'rightclick', onRightClick));\n            }\n            if (onClick) {\n                setClickListener(google.maps.event.addListener(data, 'click', onClick));\n            }\n            if (onAddFeature) {\n                setAddFeatureListener(google.maps.event.addListener(data, 'addfeature', onAddFeature));\n            }\n            if (onRemoveFeature) {\n                setRemoveFeatureListener(google.maps.event.addListener(data, 'removefeature', onRemoveFeature));\n            }\n            if (onRemoveProperty) {\n                setRemovePropertyListener(google.maps.event.addListener(data, 'removeproperty', onRemoveProperty));\n            }\n            if (onSetGeometry) {\n                setSetGeometryListener(google.maps.event.addListener(data, 'setgeometry', onSetGeometry));\n            }\n            if (onSetProperty) {\n                setSetPropertyListener(google.maps.event.addListener(data, 'setproperty', onSetProperty));\n            }\n            setInstance(data);\n            if (onLoad) {\n                onLoad(data);\n            }\n        }\n        return function () {\n            if (instance) {\n                if (dblclickListener !== null) {\n                    google.maps.event.removeListener(dblclickListener);\n                }\n                if (mousedownListener !== null) {\n                    google.maps.event.removeListener(mousedownListener);\n                }\n                if (mousemoveListener !== null) {\n                    google.maps.event.removeListener(mousemoveListener);\n                }\n                if (mouseoutListener !== null) {\n                    google.maps.event.removeListener(mouseoutListener);\n                }\n                if (mouseoverListener !== null) {\n                    google.maps.event.removeListener(mouseoverListener);\n                }\n                if (mouseupListener !== null) {\n                    google.maps.event.removeListener(mouseupListener);\n                }\n                if (rightclickListener !== null) {\n                    google.maps.event.removeListener(rightclickListener);\n                }\n                if (clickListener !== null) {\n                    google.maps.event.removeListener(clickListener);\n                }\n                if (addFeatureListener !== null) {\n                    google.maps.event.removeListener(addFeatureListener);\n                }\n                if (removeFeatureListener !== null) {\n                    google.maps.event.removeListener(removeFeatureListener);\n                }\n                if (removePropertyListener !== null) {\n                    google.maps.event.removeListener(removePropertyListener);\n                }\n                if (setGeometryListener !== null) {\n                    google.maps.event.removeListener(setGeometryListener);\n                }\n                if (setPropertyListener !== null) {\n                    google.maps.event.removeListener(setPropertyListener);\n                }\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar DataF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(DataFunctional);\nvar Data = /** @class */ (function (_super) {\n    __extends(Data, _super);\n    function Data() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            data: null,\n        };\n        _this.setDataCallback = function () {\n            if (_this.state.data !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.data);\n            }\n        };\n        return _this;\n    }\n    Data.prototype.componentDidMount = function () {\n        if (this.context !== null) {\n            var data_1 = new google.maps.Data(__assign(__assign({}, (this.props.options || {})), { map: this.context }));\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$7,\n                eventMap: eventMap$7,\n                prevProps: {},\n                nextProps: this.props,\n                instance: data_1,\n            });\n            this.setState(function () {\n                return {\n                    data: data_1,\n                };\n            }, this.setDataCallback);\n        }\n    };\n    Data.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.data !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$7,\n                eventMap: eventMap$7,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.data,\n            });\n        }\n    };\n    Data.prototype.componentWillUnmount = function () {\n        if (this.state.data !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.data);\n            }\n            unregisterEvents(this.registeredEvents);\n            if (this.state.data) {\n                this.state.data.setMap(null);\n            }\n        }\n    };\n    Data.prototype.render = function () {\n        return null;\n    };\n    Data.contextType = MapContext;\n    return Data;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$6 = {\n    onClick: 'click',\n    onDefaultViewportChanged: 'defaultviewport_changed',\n    onStatusChanged: 'status_changed',\n};\nvar updaterMap$6 = {\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    url: function (instance, url) {\n        instance.setUrl(url);\n    },\n    zIndex: function (instance, zIndex) {\n        instance.setZIndex(zIndex);\n    },\n};\nvar KmlLayer = /** @class */ (function (_super) {\n    __extends(KmlLayer, _super);\n    function KmlLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            kmlLayer: null,\n        };\n        _this.setKmlLayerCallback = function () {\n            if (_this.state.kmlLayer !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.kmlLayer);\n            }\n        };\n        return _this;\n    }\n    KmlLayer.prototype.componentDidMount = function () {\n        var kmlLayer = new google.maps.KmlLayer(__assign(__assign({}, this.props.options), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$6,\n            eventMap: eventMap$6,\n            prevProps: {},\n            nextProps: this.props,\n            instance: kmlLayer,\n        });\n        this.setState(function setLmlLayer() {\n            return {\n                kmlLayer: kmlLayer,\n            };\n        }, this.setKmlLayerCallback);\n    };\n    KmlLayer.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.kmlLayer !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$6,\n                eventMap: eventMap$6,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.kmlLayer,\n            });\n        }\n    };\n    KmlLayer.prototype.componentWillUnmount = function () {\n        if (this.state.kmlLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.kmlLayer);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.kmlLayer.setMap(null);\n        }\n    };\n    KmlLayer.prototype.render = function () {\n        return null;\n    };\n    KmlLayer.contextType = MapContext;\n    return KmlLayer;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nfunction getOffsetOverride(containerElement, getPixelPositionOffset) {\n    return typeof getPixelPositionOffset === 'function'\n        ? getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight)\n        : {\n            x: 0,\n            y: 0,\n        };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createLatLng(inst, Type) { return new Type(inst.lat, inst.lng); }\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction createLatLngBounds(inst, Type) {\n    return new Type(new google.maps.LatLng(inst.ne.lat, inst.ne.lng), new google.maps.LatLng(inst.sw.lat, inst.sw.lng));\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction ensureOfType(inst, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfactory\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return inst instanceof type ? inst : factory(inst, type);\n}\nfunction ensureOfTypeBounds(inst, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfactory\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) {\n    return inst instanceof type ? inst : factory(inst, type);\n}\nfunction getLayoutStylesByBounds(mapCanvasProjection, offset, bounds) {\n    var ne = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());\n    var sw = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());\n    if (ne && sw) {\n        return {\n            left: \"\".concat(sw.x + offset.x, \"px\"),\n            top: \"\".concat(ne.y + offset.y, \"px\"),\n            width: \"\".concat(ne.x - sw.x - offset.x, \"px\"),\n            height: \"\".concat(sw.y - ne.y - offset.y, \"px\"),\n        };\n    }\n    return {\n        left: '-9999px',\n        top: '-9999px',\n    };\n}\nfunction getLayoutStylesByPosition(mapCanvasProjection, offset, position) {\n    var point = mapCanvasProjection && mapCanvasProjection.fromLatLngToDivPixel(position);\n    if (point) {\n        var x = point.x, y = point.y;\n        return {\n            left: \"\".concat(x + offset.x, \"px\"),\n            top: \"\".concat(y + offset.y, \"px\"),\n        };\n    }\n    return {\n        left: '-9999px',\n        top: '-9999px',\n    };\n}\nfunction getLayoutStyles(mapCanvasProjection, offset, bounds, position) {\n    return bounds !== undefined\n        ? getLayoutStylesByBounds(mapCanvasProjection, offset, ensureOfTypeBounds(bounds, google.maps.LatLngBounds, createLatLngBounds))\n        : getLayoutStylesByPosition(mapCanvasProjection, offset, ensureOfType(position, google.maps.LatLng, createLatLng));\n}\nfunction arePositionsEqual(currentPosition, previousPosition) {\n    return currentPosition.left === previousPosition.left\n        && currentPosition.top === previousPosition.top\n        && currentPosition.width === previousPosition.height\n        && currentPosition.height === previousPosition.height;\n}\n\nfunction createOverlay(container, pane, position, bounds, getPixelPositionOffset) {\n    var Overlay = /** @class */ (function (_super) {\n        __extends(Overlay, _super);\n        function Overlay(container, pane, position, bounds) {\n            var _this = _super.call(this) || this;\n            _this.container = container;\n            _this.pane = pane;\n            _this.position = position;\n            _this.bounds = bounds;\n            return _this;\n        }\n        Overlay.prototype.onAdd = function () {\n            var _a;\n            var pane = (_a = this.getPanes()) === null || _a === void 0 ? void 0 : _a[this.pane];\n            pane === null || pane === void 0 ? void 0 : pane.appendChild(this.container);\n        };\n        Overlay.prototype.draw = function () {\n            var projection = this.getProjection();\n            var offset = __assign({}, (this.container\n                ? getOffsetOverride(this.container, getPixelPositionOffset)\n                : {\n                    x: 0,\n                    y: 0,\n                }));\n            var layoutStyles = getLayoutStyles(projection, offset, this.bounds, this.position);\n            for (var _i = 0, _a = Object.entries(layoutStyles); _i < _a.length; _i++) {\n                var _b = _a[_i], key = _b[0], value = _b[1];\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                this.container.style[key] = value;\n            }\n        };\n        Overlay.prototype.onRemove = function () {\n            if (this.container.parentNode !== null) {\n                this.container.parentNode.removeChild(this.container);\n            }\n        };\n        return Overlay;\n    }(google.maps.OverlayView));\n    return new Overlay(container, pane, position, bounds);\n}\n\nfunction convertToLatLngString(latLngLike) {\n    if (!latLngLike) {\n        return '';\n    }\n    var latLng = latLngLike instanceof google.maps.LatLng\n        ? latLngLike\n        : new google.maps.LatLng(latLngLike.lat, latLngLike.lng);\n    return latLng + '';\n}\nfunction convertToLatLngBoundsString(latLngBoundsLike) {\n    if (!latLngBoundsLike) {\n        return '';\n    }\n    var latLngBounds = latLngBoundsLike instanceof google.maps.LatLngBounds\n        ? latLngBoundsLike\n        : new google.maps.LatLngBounds(new google.maps.LatLng(latLngBoundsLike.south, latLngBoundsLike.east), new google.maps.LatLng(latLngBoundsLike.north, latLngBoundsLike.west));\n    return latLngBounds + '';\n}\nvar FLOAT_PANE = \"floatPane\";\nvar MAP_PANE = \"mapPane\";\nvar MARKER_LAYER = \"markerLayer\";\nvar OVERLAY_LAYER = \"overlayLayer\";\nvar OVERLAY_MOUSE_TARGET = \"overlayMouseTarget\";\nfunction OverlayViewFunctional(_a) {\n    var position = _a.position, bounds = _a.bounds, mapPaneName = _a.mapPaneName, zIndex = _a.zIndex, onLoad = _a.onLoad, onUnmount = _a.onUnmount, getPixelPositionOffset = _a.getPixelPositionOffset, children = _a.children;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        var div = document.createElement('div');\n        div.style.position = 'absolute';\n        return div;\n    }, []);\n    var overlay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        return createOverlay(container, mapPaneName, position, bounds, getPixelPositionOffset);\n    }, [container, mapPaneName, position, bounds]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        onLoad === null || onLoad === void 0 ? void 0 : onLoad(overlay);\n        overlay === null || overlay === void 0 ? void 0 : overlay.setMap(map);\n        return function () {\n            onUnmount === null || onUnmount === void 0 ? void 0 : onUnmount(overlay);\n            overlay === null || overlay === void 0 ? void 0 : overlay.setMap(null);\n        };\n    }, [map, overlay]);\n    // to move the container to the foreground and background\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        container.style.zIndex = \"\".concat(zIndex);\n    }, [zIndex, container]);\n    return react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal(children, container);\n}\nvar OverlayViewF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(OverlayViewFunctional);\nvar OverlayView = /** @class */ (function (_super) {\n    __extends(OverlayView, _super);\n    function OverlayView(props) {\n        var _this = _super.call(this, props) || this;\n        _this.state = {\n            paneEl: null,\n            containerStyle: {\n                // set initial position\n                position: 'absolute',\n            },\n        };\n        _this.updatePane = function () {\n            var mapPaneName = _this.props.mapPaneName;\n            // https://developers.google.com/maps/documentation/javascript/3.exp/reference#MapPanes\n            var mapPanes = _this.overlayView.getPanes();\n            invariant$1(!!mapPaneName, \"OverlayView requires props.mapPaneName but got %s\", mapPaneName);\n            if (mapPanes) {\n                _this.setState({\n                    paneEl: mapPanes[mapPaneName],\n                });\n            }\n            else {\n                _this.setState({\n                    paneEl: null,\n                });\n            }\n        };\n        _this.onAdd = function () {\n            var _a, _b;\n            _this.updatePane();\n            (_b = (_a = _this.props).onLoad) === null || _b === void 0 ? void 0 : _b.call(_a, _this.overlayView);\n        };\n        _this.onPositionElement = function () {\n            var mapCanvasProjection = _this.overlayView.getProjection();\n            var offset = __assign({ x: 0, y: 0 }, (_this.containerRef.current\n                ? getOffsetOverride(_this.containerRef.current, _this.props.getPixelPositionOffset)\n                : {}));\n            var layoutStyles = getLayoutStyles(mapCanvasProjection, offset, _this.props.bounds, _this.props.position);\n            var _a = _this.state.containerStyle, left = _a.left, top = _a.top, width = _a.width, height = _a.height;\n            if (!arePositionsEqual(layoutStyles, { left: left, top: top, width: width, height: height })) {\n                _this.setState({\n                    containerStyle: {\n                        top: layoutStyles.top || 0,\n                        left: layoutStyles.left || 0,\n                        width: layoutStyles.width || 0,\n                        height: layoutStyles.height || 0,\n                        position: 'absolute',\n                    },\n                });\n            }\n        };\n        _this.draw = function () {\n            _this.onPositionElement();\n        };\n        _this.onRemove = function () {\n            var _a, _b;\n            _this.setState(function () { return ({\n                paneEl: null,\n            }); });\n            (_b = (_a = _this.props).onUnmount) === null || _b === void 0 ? void 0 : _b.call(_a, _this.overlayView);\n        };\n        _this.containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        // You must implement three methods: onAdd(), draw(), and onRemove().\n        var overlayView = new google.maps.OverlayView();\n        overlayView.onAdd = _this.onAdd;\n        overlayView.draw = _this.draw;\n        overlayView.onRemove = _this.onRemove;\n        _this.overlayView = overlayView;\n        return _this;\n    }\n    OverlayView.prototype.componentDidMount = function () {\n        this.overlayView.setMap(this.context);\n    };\n    OverlayView.prototype.componentDidUpdate = function (prevProps) {\n        var prevPositionString = convertToLatLngString(prevProps.position);\n        var positionString = convertToLatLngString(this.props.position);\n        var prevBoundsString = convertToLatLngBoundsString(prevProps.bounds);\n        var boundsString = convertToLatLngBoundsString(this.props.bounds);\n        if (prevPositionString !== positionString ||\n            prevBoundsString !== boundsString) {\n            this.overlayView.draw();\n        }\n        if (prevProps.mapPaneName !== this.props.mapPaneName) {\n            this.updatePane();\n        }\n    };\n    OverlayView.prototype.componentWillUnmount = function () {\n        this.overlayView.setMap(null);\n    };\n    OverlayView.prototype.render = function () {\n        var paneEl = this.state.paneEl;\n        if (paneEl) {\n            return react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: this.containerRef, style: this.state.containerStyle, children: react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children) }), paneEl);\n        }\n        else {\n            return null;\n        }\n    };\n    OverlayView.FLOAT_PANE = \"floatPane\";\n    OverlayView.MAP_PANE = \"mapPane\";\n    OverlayView.MARKER_LAYER = \"markerLayer\";\n    OverlayView.OVERLAY_LAYER = \"overlayLayer\";\n    OverlayView.OVERLAY_MOUSE_TARGET = \"overlayMouseTarget\";\n    OverlayView.contextType = MapContext;\n    return OverlayView;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nfunction noop() { return; }\n\nvar eventMap$5 = {\n    onDblClick: 'dblclick',\n    onClick: 'click',\n};\nvar updaterMap$5 = {\n    opacity: function (instance, opacity) {\n        instance.setOpacity(opacity);\n    },\n};\nfunction GroundOverlayFunctional(_a) {\n    var url = _a.url, bounds = _a.bounds, options = _a.options, visible = _a.visible;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var imageBounds = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.south, bounds.west), new google.maps.LatLng(bounds.north, bounds.east));\n    var groundOverlay = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(function () {\n        var overlay = new google.maps.GroundOverlay(url, imageBounds, __assign({}, options));\n        return overlay;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (groundOverlay !== null) {\n            groundOverlay.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof url !== 'undefined' && groundOverlay !== null) {\n            groundOverlay.set(\"url\", url);\n            groundOverlay.setMap(map);\n        }\n    }, [groundOverlay, url]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (typeof visible !== 'undefined' && groundOverlay !== null) {\n            groundOverlay.setOpacity(visible ? 1 : 0);\n        }\n    }, [groundOverlay, visible]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var newBounds = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.south, bounds.west), new google.maps.LatLng(bounds.north, bounds.east));\n        if (typeof bounds !== 'undefined' && groundOverlay !== null) {\n            groundOverlay.set(\"bounds\", newBounds);\n            groundOverlay.setMap(map);\n        }\n    }, [groundOverlay, bounds]);\n    return null;\n}\nvar GroundOverlayF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GroundOverlayFunctional);\nvar GroundOverlay = /** @class */ (function (_super) {\n    __extends(GroundOverlay, _super);\n    function GroundOverlay() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            groundOverlay: null,\n        };\n        _this.setGroundOverlayCallback = function () {\n            if (_this.state.groundOverlay !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.groundOverlay);\n            }\n        };\n        return _this;\n    }\n    GroundOverlay.prototype.componentDidMount = function () {\n        invariant$1(!!this.props.url || !!this.props.bounds, \"For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655\");\n        var groundOverlay = new google.maps.GroundOverlay(this.props.url, this.props.bounds, __assign(__assign({}, this.props.options), { map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$5,\n            eventMap: eventMap$5,\n            prevProps: {},\n            nextProps: this.props,\n            instance: groundOverlay,\n        });\n        this.setState(function setGroundOverlay() {\n            return {\n                groundOverlay: groundOverlay,\n            };\n        }, this.setGroundOverlayCallback);\n    };\n    GroundOverlay.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.groundOverlay !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$5,\n                eventMap: eventMap$5,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.groundOverlay,\n            });\n        }\n    };\n    GroundOverlay.prototype.componentWillUnmount = function () {\n        if (this.state.groundOverlay) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.groundOverlay);\n            }\n            this.state.groundOverlay.setMap(null);\n        }\n    };\n    GroundOverlay.prototype.render = function () {\n        return null;\n    };\n    GroundOverlay.defaultProps = {\n        onLoad: noop,\n    };\n    GroundOverlay.contextType = MapContext;\n    return GroundOverlay;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$4 = {};\nvar updaterMap$4 = {\n    data: function (instance, data) {\n        instance.setData(data);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n};\nfunction HeatmapLayerFunctional(_a) {\n    var data = _a.data, onLoad = _a.onLoad, onUnmount = _a.onUnmount, options = _a.options;\n    var map = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(MapContext);\n    var _b = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), instance = _b[0], setInstance = _b[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (!google.maps.visualization) {\n            invariant$1(!!google.maps.visualization, 'Did you include prop libraries={[\"visualization\"]} in useJsApiScript? %s', google.maps.visualization);\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        invariant$1(!!data, 'data property is required in HeatmapLayer %s', data);\n    }, [data]);\n    // Order does matter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (instance !== null) {\n            instance.setMap(map);\n        }\n    }, [map]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        if (options && instance !== null) {\n            instance.setOptions(options);\n        }\n    }, [instance, options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        var heatmapLayer = new google.maps.visualization.HeatmapLayer(__assign(__assign({}, (options || {})), { data: data, map: map }));\n        setInstance(heatmapLayer);\n        if (onLoad) {\n            onLoad(heatmapLayer);\n        }\n        return function () {\n            if (instance !== null) {\n                if (onUnmount) {\n                    onUnmount(instance);\n                }\n                instance.setMap(null);\n            }\n        };\n    }, []);\n    return null;\n}\nvar HeatmapLayerF = (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(HeatmapLayerFunctional);\nvar HeatmapLayer = /** @class */ (function (_super) {\n    __extends(HeatmapLayer, _super);\n    function HeatmapLayer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            heatmapLayer: null,\n        };\n        _this.setHeatmapLayerCallback = function () {\n            if (_this.state.heatmapLayer !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.heatmapLayer);\n            }\n        };\n        return _this;\n    }\n    HeatmapLayer.prototype.componentDidMount = function () {\n        invariant$1(!!google.maps.visualization, 'Did you include prop libraries={[\"visualization\"]} to <LoadScript />? %s', google.maps.visualization);\n        invariant$1(!!this.props.data, 'data property is required in HeatmapLayer %s', this.props.data);\n        var heatmapLayer = new google.maps.visualization.HeatmapLayer(__assign(__assign({}, (this.props.options || {})), { data: this.props.data, map: this.context }));\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$4,\n            eventMap: eventMap$4,\n            prevProps: {},\n            nextProps: this.props,\n            instance: heatmapLayer,\n        });\n        this.setState(function setHeatmapLayer() {\n            return {\n                heatmapLayer: heatmapLayer,\n            };\n        }, this.setHeatmapLayerCallback);\n    };\n    HeatmapLayer.prototype.componentDidUpdate = function (prevProps) {\n        unregisterEvents(this.registeredEvents);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$4,\n            eventMap: eventMap$4,\n            prevProps: prevProps,\n            nextProps: this.props,\n            instance: this.state.heatmapLayer,\n        });\n    };\n    HeatmapLayer.prototype.componentWillUnmount = function () {\n        if (this.state.heatmapLayer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.heatmapLayer);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.heatmapLayer.setMap(null);\n        }\n    };\n    HeatmapLayer.prototype.render = function () {\n        return null;\n    };\n    HeatmapLayer.contextType = MapContext;\n    return HeatmapLayer;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$3 = {\n    onCloseClick: 'closeclick',\n    onPanoChanged: 'pano_changed',\n    onPositionChanged: 'position_changed',\n    onPovChanged: 'pov_changed',\n    onResize: 'resize',\n    onStatusChanged: 'status_changed',\n    onVisibleChanged: 'visible_changed',\n    onZoomChanged: 'zoom_changed',\n};\nvar updaterMap$3 = {\n    register: function (instance, provider, options) {\n        instance.registerPanoProvider(provider, options);\n    },\n    links: function (instance, links) {\n        instance.setLinks(links);\n    },\n    motionTracking: function (instance, motionTracking) {\n        instance.setMotionTracking(motionTracking);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    pano: function (instance, pano) {\n        instance.setPano(pano);\n    },\n    position: function (instance, position) {\n        instance.setPosition(position);\n    },\n    pov: function (instance, pov) {\n        instance.setPov(pov);\n    },\n    visible: function (instance, visible) {\n        instance.setVisible(visible);\n    },\n    zoom: function (instance, zoom) {\n        instance.setZoom(zoom);\n    },\n};\nvar StreetViewPanorama = /** @class */ (function (_super) {\n    __extends(StreetViewPanorama, _super);\n    function StreetViewPanorama() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            streetViewPanorama: null,\n        };\n        _this.setStreetViewPanoramaCallback = function () {\n            if (_this.state.streetViewPanorama !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.streetViewPanorama);\n            }\n        };\n        return _this;\n    }\n    StreetViewPanorama.prototype.componentDidMount = function () {\n        var _a, _b;\n        var streetViewPanorama = (_b = (_a = this.context) === null || _a === void 0 ? void 0 : _a.getStreetView()) !== null && _b !== void 0 ? _b : null;\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$3,\n            eventMap: eventMap$3,\n            prevProps: {},\n            nextProps: this.props,\n            instance: streetViewPanorama,\n        });\n        this.setState(function () {\n            return {\n                streetViewPanorama: streetViewPanorama,\n            };\n        }, this.setStreetViewPanoramaCallback);\n    };\n    StreetViewPanorama.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.streetViewPanorama !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$3,\n                eventMap: eventMap$3,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.streetViewPanorama,\n            });\n        }\n    };\n    StreetViewPanorama.prototype.componentWillUnmount = function () {\n        if (this.state.streetViewPanorama !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.streetViewPanorama);\n            }\n            unregisterEvents(this.registeredEvents);\n            this.state.streetViewPanorama.setVisible(false);\n        }\n    };\n    StreetViewPanorama.prototype.render = function () {\n        return null;\n    };\n    StreetViewPanorama.contextType = MapContext;\n    return StreetViewPanorama;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar StreetViewService = /** @class */ (function (_super) {\n    __extends(StreetViewService, _super);\n    function StreetViewService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            streetViewService: null,\n        };\n        _this.setStreetViewServiceCallback = function () {\n            if (_this.state.streetViewService !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.streetViewService);\n            }\n        };\n        return _this;\n    }\n    StreetViewService.prototype.componentDidMount = function () {\n        var streetViewService = new google.maps.StreetViewService();\n        this.setState(function setStreetViewService() {\n            return {\n                streetViewService: streetViewService,\n            };\n        }, this.setStreetViewServiceCallback);\n    };\n    StreetViewService.prototype.componentWillUnmount = function () {\n        if (this.state.streetViewService !== null && this.props.onUnmount) {\n            this.props.onUnmount(this.state.streetViewService);\n        }\n    };\n    StreetViewService.prototype.render = function () {\n        return null;\n    };\n    StreetViewService.contextType = MapContext;\n    return StreetViewService;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar DirectionsService = /** @class */ (function (_super) {\n    __extends(DirectionsService, _super);\n    function DirectionsService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            directionsService: null,\n        };\n        _this.setDirectionsServiceCallback = function () {\n            if (_this.state.directionsService !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.directionsService);\n            }\n        };\n        return _this;\n    }\n    DirectionsService.prototype.componentDidMount = function () {\n        invariant$1(!!this.props.options, 'DirectionsService expected options object as parameter, but got %s', this.props.options);\n        var directionsService = new google.maps.DirectionsService();\n        this.setState(function setDirectionsService() {\n            return {\n                directionsService: directionsService,\n            };\n        }, this.setDirectionsServiceCallback);\n    };\n    DirectionsService.prototype.componentDidUpdate = function () {\n        if (this.state.directionsService !== null) {\n            this.state.directionsService.route(this.props.options, this.props.callback);\n        }\n    };\n    DirectionsService.prototype.componentWillUnmount = function () {\n        if (this.state.directionsService !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.directionsService);\n            }\n        }\n    };\n    DirectionsService.prototype.render = function () {\n        return null;\n    };\n    return DirectionsService;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$2 = {\n    onDirectionsChanged: 'directions_changed',\n};\nvar updaterMap$2 = {\n    directions: function (instance, directions) {\n        instance.setDirections(directions);\n    },\n    map: function (instance, map) {\n        instance.setMap(map);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    panel: function (instance, panel) {\n        instance.setPanel(panel);\n    },\n    routeIndex: function (instance, routeIndex) {\n        instance.setRouteIndex(routeIndex);\n    },\n};\nvar DirectionsRenderer = /** @class */ (function (_super) {\n    __extends(DirectionsRenderer, _super);\n    function DirectionsRenderer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.state = {\n            directionsRenderer: null,\n        };\n        _this.setDirectionsRendererCallback = function () {\n            if (_this.state.directionsRenderer !== null) {\n                _this.state.directionsRenderer.setMap(_this.context);\n                if (_this.props.onLoad) {\n                    _this.props.onLoad(_this.state.directionsRenderer);\n                }\n            }\n        };\n        return _this;\n    }\n    DirectionsRenderer.prototype.componentDidMount = function () {\n        var directionsRenderer = new google.maps.DirectionsRenderer(this.props.options);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap$2,\n            eventMap: eventMap$2,\n            prevProps: {},\n            nextProps: this.props,\n            instance: directionsRenderer,\n        });\n        this.setState(function setDirectionsRenderer() {\n            return {\n                directionsRenderer: directionsRenderer,\n            };\n        }, this.setDirectionsRendererCallback);\n    };\n    DirectionsRenderer.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.directionsRenderer !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$2,\n                eventMap: eventMap$2,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.directionsRenderer,\n            });\n        }\n    };\n    DirectionsRenderer.prototype.componentWillUnmount = function () {\n        if (this.state.directionsRenderer !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.directionsRenderer);\n            }\n            unregisterEvents(this.registeredEvents);\n            if (this.state.directionsRenderer) {\n                this.state.directionsRenderer.setMap(null);\n            }\n        }\n    };\n    DirectionsRenderer.prototype.render = function () {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {});\n    };\n    DirectionsRenderer.contextType = MapContext;\n    return DirectionsRenderer;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar DistanceMatrixService = /** @class */ (function (_super) {\n    __extends(DistanceMatrixService, _super);\n    function DistanceMatrixService() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            distanceMatrixService: null,\n        };\n        _this.setDistanceMatrixServiceCallback = function () {\n            if (_this.state.distanceMatrixService !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.distanceMatrixService);\n            }\n        };\n        return _this;\n    }\n    DistanceMatrixService.prototype.componentDidMount = function () {\n        invariant$1(!!this.props.options, 'DistanceMatrixService expected options object as parameter, but go %s', this.props.options);\n        var distanceMatrixService = new google.maps.DistanceMatrixService();\n        this.setState(function setDistanceMatrixService() {\n            return {\n                distanceMatrixService: distanceMatrixService,\n            };\n        }, this.setDistanceMatrixServiceCallback);\n    };\n    DistanceMatrixService.prototype.componentDidUpdate = function () {\n        if (this.state.distanceMatrixService !== null) {\n            this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);\n        }\n    };\n    DistanceMatrixService.prototype.componentWillUnmount = function () {\n        if (this.state.distanceMatrixService !== null && this.props.onUnmount) {\n            this.props.onUnmount(this.state.distanceMatrixService);\n        }\n    };\n    DistanceMatrixService.prototype.render = function () {\n        return null;\n    };\n    return DistanceMatrixService;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap$1 = {\n    onPlacesChanged: 'places_changed',\n};\nvar updaterMap$1 = {\n    bounds: function (instance, bounds) {\n        instance.setBounds(bounds);\n    },\n};\nvar StandaloneSearchBox = /** @class */ (function (_super) {\n    __extends(StandaloneSearchBox, _super);\n    function StandaloneSearchBox() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.containerElement = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.state = {\n            searchBox: null,\n        };\n        _this.setSearchBoxCallback = function () {\n            if (_this.state.searchBox !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.searchBox);\n            }\n        };\n        return _this;\n    }\n    StandaloneSearchBox.prototype.componentDidMount = function () {\n        invariant$1(!!google.maps.places, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places);\n        if (this.containerElement !== null && this.containerElement.current !== null) {\n            var input = this.containerElement.current.querySelector('input');\n            if (input !== null) {\n                var searchBox_1 = new google.maps.places.SearchBox(input, this.props.options);\n                this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                    updaterMap: updaterMap$1,\n                    eventMap: eventMap$1,\n                    prevProps: {},\n                    nextProps: this.props,\n                    instance: searchBox_1,\n                });\n                this.setState(function setSearchBox() {\n                    return {\n                        searchBox: searchBox_1,\n                    };\n                }, this.setSearchBoxCallback);\n            }\n        }\n    };\n    StandaloneSearchBox.prototype.componentDidUpdate = function (prevProps) {\n        if (this.state.searchBox !== null) {\n            unregisterEvents(this.registeredEvents);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap$1,\n                eventMap: eventMap$1,\n                prevProps: prevProps,\n                nextProps: this.props,\n                instance: this.state.searchBox,\n            });\n        }\n    };\n    StandaloneSearchBox.prototype.componentWillUnmount = function () {\n        if (this.state.searchBox !== null) {\n            if (this.props.onUnmount) {\n                this.props.onUnmount(this.state.searchBox);\n            }\n            unregisterEvents(this.registeredEvents);\n        }\n    };\n    StandaloneSearchBox.prototype.render = function () {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: this.containerElement, children: react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children) });\n    };\n    StandaloneSearchBox.contextType = MapContext;\n    return StandaloneSearchBox;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\nvar eventMap = {\n    onPlaceChanged: 'place_changed',\n};\nvar updaterMap = {\n    bounds: function (instance, bounds) {\n        instance.setBounds(bounds);\n    },\n    restrictions: function (instance, restrictions) {\n        instance.setComponentRestrictions(restrictions);\n    },\n    fields: function (instance, fields) {\n        instance.setFields(fields);\n    },\n    options: function (instance, options) {\n        instance.setOptions(options);\n    },\n    types: function (instance, types) {\n        instance.setTypes(types);\n    },\n};\nvar Autocomplete = /** @class */ (function (_super) {\n    __extends(Autocomplete, _super);\n    function Autocomplete() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.registeredEvents = [];\n        _this.containerElement = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.state = {\n            autocomplete: null,\n        };\n        _this.setAutocompleteCallback = function () {\n            if (_this.state.autocomplete !== null && _this.props.onLoad) {\n                _this.props.onLoad(_this.state.autocomplete);\n            }\n        };\n        return _this;\n    }\n    Autocomplete.prototype.componentDidMount = function () {\n        var _a;\n        invariant$1(!!google.maps.places, 'You need to provide libraries={[\"places\"]} prop to <LoadScript /> component %s', google.maps.places);\n        // TODO: why current could be equal null?\n        var input = (_a = this.containerElement.current) === null || _a === void 0 ? void 0 : _a.querySelector('input');\n        if (input) {\n            var autocomplete_1 = new google.maps.places.Autocomplete(input, this.props.options);\n            this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n                updaterMap: updaterMap,\n                eventMap: eventMap,\n                prevProps: {},\n                nextProps: this.props,\n                instance: autocomplete_1,\n            });\n            this.setState(function () {\n                return {\n                    autocomplete: autocomplete_1,\n                };\n            }, this.setAutocompleteCallback);\n        }\n    };\n    Autocomplete.prototype.componentDidUpdate = function (prevProps) {\n        unregisterEvents(this.registeredEvents);\n        this.registeredEvents = applyUpdatersToPropsAndRegisterEvents({\n            updaterMap: updaterMap,\n            eventMap: eventMap,\n            prevProps: prevProps,\n            nextProps: this.props,\n            instance: this.state.autocomplete,\n        });\n    };\n    Autocomplete.prototype.componentWillUnmount = function () {\n        if (this.state.autocomplete !== null) {\n            unregisterEvents(this.registeredEvents);\n        }\n    };\n    Autocomplete.prototype.render = function () {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", { ref: this.containerElement, className: this.props.className, children: react__WEBPACK_IMPORTED_MODULE_1__.Children.only(this.props.children) });\n    };\n    Autocomplete.defaultProps = {\n        className: ''\n    };\n    Autocomplete.contextType = MapContext;\n    return Autocomplete;\n}(react__WEBPACK_IMPORTED_MODULE_1__.PureComponent));\n\n\n//# sourceMappingURL=esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHJlYWN0LWdvb2dsZS1tYXBzL2FwaS9kaXN0L2VzbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDd0c7QUFDMUg7QUFDRzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQs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QTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0JBQWdCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLCtDQUErQztBQUMvQyxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFLGdEQUFnRCxjQUFjO0FBQzlELHNEQUFzRCxjQUFjO0FBQ3BFLGdEQUFnRCxjQUFjO0FBQzlELDRDQUE0QyxjQUFjO0FBQzFELHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLCtDQUErQztBQUMvQyw0Q0FBNEM7QUFDNUMsK0NBQStDO0FBQy9DLDRDQUE0QztBQUM1QyxrREFBa0Q7QUFDbEQsK0NBQStDO0FBQy9DLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFD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LEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUIsMkNBQUk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFhOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzQkFBc0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVEQUF1RDtBQUMxRjtBQUNBLHdDQUF3QyxHQUFHO0FBQzNDLHFDQUFxQztBQUNyQyx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0JBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQVU7QUFDeEIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsOEJBQThCLDZDQUFNO0FBQ3BDO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHVDQUF1QywyQkFBMkIsSUFBSTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUNBQXlDLHVEQUFZLENBQUMsZ0RBQWE7QUFDbkU7QUFDQSxlQUFlLDJDQUFJO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsdUNBQXVDLDJCQUEyQixJQUFJO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsdURBQVksQ0FBQyxnREFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQWE7O0FBRWY7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBLHFCQUFxQixVQUFVO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxtT0FBbU87O0FBRWpQLG1CQUFtQjtBQUNuQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyxzQkFBc0IsUUFBUTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsdUJBQXVCO0FBQ3RDLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0EsNEZBQTRGLFNBQVM7O0FBRXJHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELFVBQVU7QUFDdkU7O0FBRUEscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVSxzQkFBc0IsY0FBYztBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBOztBQUVBLGVBQWUsdUJBQXVCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFlBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxxQ0FBcUM7QUFDaEQsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLHFDQUFxQztBQUNoRCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QyxXQUFXLHFDQUFxQztBQUNoRCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hELFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7O0FBRS9DO0FBQ0Esc0NBQXNDLG9CQUFvQjtBQUMxRDs7QUFFQSxnREFBZ0QsYUFBYSxnQkFBZ0I7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHVCQUF1Qjs7QUFFdEM7O0FBRUEscUNBQXFDLGlCQUFpQjtBQUN0RDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1DQUFtQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQixnQ0FBZ0MsWUFBWTs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RCwyQkFBMkIsK0JBQStCO0FBQzFEO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYiwrREFBK0QsZ0JBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwwQ0FBMEMsdURBQVksQ0FBQyxnREFBYTtBQUNwRTtBQUNBLGtCQUFrQiwyQ0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDJCQUEyQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1REFBWSxDQUFDLGdEQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxnREFBYTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFVO0FBQ3hCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYixvRUFBb0Usb0NBQW9DLFVBQVU7QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2Isa0VBQWtFLGdCQUFnQixNQUFNLFVBQVU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWUsMkNBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsMkJBQTJCLE1BQU0sbUJBQW1CO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFhOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQVU7QUFDeEIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQjtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYixzRUFBc0UsZ0JBQWdCLE1BQU0sVUFBVTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLDJDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLDJCQUEyQixNQUFNLG1CQUFtQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxnREFBYTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFVO0FBQ3hCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQjtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2IsZ0VBQWdFLGtDQUFrQyxVQUFVO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDJDQUFJO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDJCQUEyQixNQUFNLG1CQUFtQjtBQUNwSDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFhOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFVO0FBQ3hCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQixhQUFhLCtDQUFRO0FBQ3JCLGFBQWEsK0NBQVE7QUFDckIsYUFBYSwrQ0FBUTtBQUNyQjtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxnRUFBZ0UsZ0JBQWdCLE1BQU0sVUFBVTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyQ0FBSTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLDJCQUEyQixNQUFNLG1CQUFtQjtBQUN0SDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxnREFBYTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHlCQUF5QixtQkFBbUI7QUFDaEg7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQWE7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGdFQUFnRSxnQkFBZ0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlEQUFVO0FBQ3hCLG9CQUFvQiw4Q0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLDhDQUFPO0FBQ3pCO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsV0FBVyxtREFBcUI7QUFDaEM7QUFDQSxtQkFBbUIsMkNBQUk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsbURBQW1ELG9EQUFvRDtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBLDZCQUE2QixnREFBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQXFCLENBQUMsc0RBQUcsVUFBVSxvRUFBb0UsZ0RBQWEsdUJBQXVCO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxnREFBYTs7QUFFZixrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQVU7QUFDeEI7QUFDQSx3QkFBd0IsOENBQU87QUFDL0IsaUZBQWlGO0FBQ2pGO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQiwyQ0FBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJrQkFBMmtCLElBQUk7QUFDL2tCLGlIQUFpSCx5QkFBeUIsbUJBQW1CO0FBQzdKO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxnREFBYTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpREFBVTtBQUN4QixhQUFhLCtDQUFRO0FBQ3JCLElBQUksZ0RBQVM7QUFDYjtBQUNBLHNGQUFzRixtQkFBbUI7QUFDekc7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYiwwRkFBMEYsZ0JBQWdCLE1BQU0sc0JBQXNCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFJO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLG1CQUFtQjtBQUNyRztBQUNBLDBGQUEwRiwyQkFBMkIsTUFBTSwwQ0FBMEM7QUFDcks7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxnREFBYTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxnREFBYTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQWE7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQWE7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQUcsQ0FBQyx1REFBUSxJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLENBQUMsQ0FBQyxnREFBYTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxDQUFDLGdEQUFhOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0RBQVM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFHLFVBQVUsc0NBQXNDLGdEQUFhLHVCQUF1QjtBQUN0RztBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQWE7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdEQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFHLFVBQVUsdUVBQXVFLGdEQUFhLHVCQUF1QjtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLENBQUMsZ0RBQWE7O0FBRTgxQjtBQUM3MkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1nb29nbGUtbWFwcy9hcGkvZGlzdC9lc20uanM/ODUyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgbWVtbywgdXNlU3RhdGUsIHVzZVJlZiwgdXNlRWZmZWN0LCBQdXJlQ29tcG9uZW50LCBjcmVhdGVSZWYsIHVzZU1lbW8sIENoaWxkcmVuLCBpc1ZhbGlkRWxlbWVudCwgY2xvbmVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gJ3JlYWN0LWRvbSc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0JDEocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlciQxKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgTk9ERV9FTlYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVjtcblxudmFyIGludmFyaWFudCA9IGZ1bmN0aW9uKGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxudmFyIGludmFyaWFudF8xID0gaW52YXJpYW50O1xuXG52YXIgaW52YXJpYW50JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaW52YXJpYW50XzEpO1xuXG52YXIgTWFwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5mdW5jdGlvbiB1c2VHb29nbGVNYXAoKSB7XG4gICAgaW52YXJpYW50JDEoISF1c2VDb250ZXh0LCAndXNlR29vZ2xlTWFwIGlzIFJlYWN0IGhvb2sgYW5kIHJlcXVpcmVzIFJlYWN0IHZlcnNpb24gMTYuOCsnKTtcbiAgICB2YXIgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICBpbnZhcmlhbnQkMSghIW1hcCwgJ3VzZUdvb2dsZU1hcCBuZWVkcyBhIEdvb2dsZU1hcCBhdmFpbGFibGUgdXAgaW4gdGhlIHRyZWUnKTtcbiAgICByZXR1cm4gbWFwO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gcmVkdWNlKG9iaiwgZm4sIGFjYykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiByZWR1Y2VyKG5ld0FjYywga2V5KSB7XG4gICAgICAgIHJldHVybiBmbihuZXdBY2MsIG9ialtrZXldLCBrZXkpO1xuICAgIH0sIGFjYyk7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gZm4ob2JqW2tleV0sIGtleSk7XG4gICAgfSk7XG59XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cbmZ1bmN0aW9uIGFwcGx5VXBkYXRlclRvTmV4dFByb3BzKFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnVwZGF0ZXJNYXAsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnByZXZQcm9wcywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxubmV4dFByb3BzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5pbnN0YW5jZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgdmFyIGl0ZXIgPSBmdW5jdGlvbiAoZm4sIGtleSkge1xuICAgICAgICB2YXIgbmV4dFZhbHVlID0gbmV4dFByb3BzW2tleV07XG4gICAgICAgIGlmIChuZXh0VmFsdWUgIT09IHByZXZQcm9wc1trZXldKSB7XG4gICAgICAgICAgICBtYXBba2V5XSA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgIGZuKGluc3RhbmNlLCBuZXh0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3JFYWNoKHVwZGF0ZXJNYXAsIGl0ZXIpO1xuICAgIHJldHVybiBtYXA7XG59XG5mdW5jdGlvbiByZWdpc3RlckV2ZW50cyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5wcm9wcywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuaW5zdGFuY2UsIGV2ZW50TWFwKSB7XG4gICAgdmFyIHJlZ2lzdGVyZWRMaXN0ID0gcmVkdWNlKGV2ZW50TWFwLCBmdW5jdGlvbiByZWR1Y2VyKGFjYywgZ29vZ2xlRXZlbnROYW1lLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG9uRXZlbnROYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcHNbb25FdmVudE5hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBhY2MucHVzaChnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgZ29vZ2xlRXZlbnROYW1lLCBwcm9wc1tvbkV2ZW50TmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZExpc3Q7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyRXZlbnQocmVnaXN0ZXJlZCkge1xuICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJlZ2lzdGVyZWQpO1xufVxuZnVuY3Rpb24gdW5yZWdpc3RlckV2ZW50cyhldmVudHMpIHtcbiAgICBpZiAoZXZlbnRzID09PSB2b2lkIDApIHsgZXZlbnRzID0gW107IH1cbiAgICBldmVudHMuZm9yRWFjaCh1bnJlZ2lzdGVyRXZlbnQpO1xufVxuZnVuY3Rpb24gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyhfYSkge1xuICAgIHZhciB1cGRhdGVyTWFwID0gX2EudXBkYXRlck1hcCwgZXZlbnRNYXAgPSBfYS5ldmVudE1hcCwgcHJldlByb3BzID0gX2EucHJldlByb3BzLCBuZXh0UHJvcHMgPSBfYS5uZXh0UHJvcHMsIGluc3RhbmNlID0gX2EuaW5zdGFuY2U7XG4gICAgdmFyIHJlZ2lzdGVyZWRFdmVudHMgPSByZWdpc3RlckV2ZW50cyhuZXh0UHJvcHMsIGluc3RhbmNlLCBldmVudE1hcCk7XG4gICAgYXBwbHlVcGRhdGVyVG9OZXh0UHJvcHModXBkYXRlck1hcCwgcHJldlByb3BzLCBuZXh0UHJvcHMsIGluc3RhbmNlKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZEV2ZW50cztcbn1cblxudmFyIGV2ZW50TWFwJGkgPSB7XG4gICAgb25EYmxDbGljazogJ2RibGNsaWNrJyxcbiAgICBvbkRyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgICBvbkRyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gICAgb25NYXBUeXBlSWRDaGFuZ2VkOiAnbWFwdHlwZWlkX2NoYW5nZWQnLFxuICAgIG9uTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICBvbk1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICAgIG9uTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gICAgb25SaWdodENsaWNrOiAncmlnaHRjbGljaycsXG4gICAgb25UaWxlc0xvYWRlZDogJ3RpbGVzbG9hZGVkJyxcbiAgICBvbkJvdW5kc0NoYW5nZWQ6ICdib3VuZHNfY2hhbmdlZCcsXG4gICAgb25DZW50ZXJDaGFuZ2VkOiAnY2VudGVyX2NoYW5nZWQnLFxuICAgIG9uQ2xpY2s6ICdjbGljaycsXG4gICAgb25EcmFnOiAnZHJhZycsXG4gICAgb25IZWFkaW5nQ2hhbmdlZDogJ2hlYWRpbmdfY2hhbmdlZCcsXG4gICAgb25JZGxlOiAnaWRsZScsXG4gICAgb25Qcm9qZWN0aW9uQ2hhbmdlZDogJ3Byb2plY3Rpb25fY2hhbmdlZCcsXG4gICAgb25SZXNpemU6ICdyZXNpemUnLFxuICAgIG9uVGlsdENoYW5nZWQ6ICd0aWx0X2NoYW5nZWQnLFxuICAgIG9uWm9vbUNoYW5nZWQ6ICd6b29tX2NoYW5nZWQnLFxufTtcbnZhciB1cGRhdGVyTWFwJGkgPSB7XG4gICAgZXh0cmFNYXBUeXBlczogZnVuY3Rpb24gKG1hcCwgZXh0cmEpIHtcbiAgICAgICAgZXh0cmEuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoRXh0cmEoaXQsIGkpIHtcbiAgICAgICAgICAgIG1hcC5tYXBUeXBlcy5zZXQoU3RyaW5nKGkpLCBpdCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgY2VudGVyOiBmdW5jdGlvbiAobWFwLCBjZW50ZXIpIHtcbiAgICAgICAgbWFwLnNldENlbnRlcihjZW50ZXIpO1xuICAgIH0sXG4gICAgY2xpY2thYmxlSWNvbnM6IGZ1bmN0aW9uIChtYXAsIGNsaWNrYWJsZSkge1xuICAgICAgICBtYXAuc2V0Q2xpY2thYmxlSWNvbnMoY2xpY2thYmxlKTtcbiAgICB9LFxuICAgIGhlYWRpbmc6IGZ1bmN0aW9uIChtYXAsIGhlYWRpbmcpIHtcbiAgICAgICAgbWFwLnNldEhlYWRpbmcoaGVhZGluZyk7XG4gICAgfSxcbiAgICBtYXBUeXBlSWQ6IGZ1bmN0aW9uIChtYXAsIG1hcFR5cGVJZCkge1xuICAgICAgICBtYXAuc2V0TWFwVHlwZUlkKG1hcFR5cGVJZCk7XG4gICAgfSxcbiAgICBvcHRpb25zOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG4gICAgICAgIG1hcC5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgc3RyZWV0VmlldzogZnVuY3Rpb24gKG1hcCwgc3RyZWV0Vmlldykge1xuICAgICAgICBtYXAuc2V0U3RyZWV0VmlldyhzdHJlZXRWaWV3KTtcbiAgICB9LFxuICAgIHRpbHQ6IGZ1bmN0aW9uIChtYXAsIHRpbHQpIHtcbiAgICAgICAgbWFwLnNldFRpbHQodGlsdCk7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbiAobWFwLCB6b29tKSB7XG4gICAgICAgIG1hcC5zZXRab29tKHpvb20pO1xuICAgIH0sXG59O1xuLy8gVE9ETzogdW5maW5pc2hlZCFcbmZ1bmN0aW9uIEdvb2dsZU1hcEZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGlkID0gX2EuaWQsIG1hcENvbnRhaW5lclN0eWxlID0gX2EubWFwQ29udGFpbmVyU3R5bGUsIG1hcENvbnRhaW5lckNsYXNzTmFtZSA9IF9hLm1hcENvbnRhaW5lckNsYXNzTmFtZSwgY2VudGVyID0gX2EuY2VudGVyLCBcbiAgICAvLyBjbGlja2FibGVJY29ucyxcbiAgICAvLyBleHRyYU1hcFR5cGVzLFxuICAgIC8vIGhlYWRpbmcsXG4gICAgLy8gbWFwVHlwZUlkLFxuICAgIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBvbkRibENsaWNrID0gX2Eub25EYmxDbGljaywgb25EcmFnID0gX2Eub25EcmFnLCBvbkRyYWdFbmQgPSBfYS5vbkRyYWdFbmQsIG9uRHJhZ1N0YXJ0ID0gX2Eub25EcmFnU3RhcnQsIG9uTW91c2VNb3ZlID0gX2Eub25Nb3VzZU1vdmUsIG9uTW91c2VPdXQgPSBfYS5vbk1vdXNlT3V0LCBvbk1vdXNlT3ZlciA9IF9hLm9uTW91c2VPdmVyLCBvbk1vdXNlRG93biA9IF9hLm9uTW91c2VEb3duLCBvbk1vdXNlVXAgPSBfYS5vbk1vdXNlVXAsIG9uUmlnaHRDbGljayA9IF9hLm9uUmlnaHRDbGljaywgXG4gICAgLy8gb25NYXBUeXBlSWRDaGFuZ2VkLFxuICAgIC8vIG9uVGlsZXNMb2FkZWQsXG4gICAgLy8gb25Cb3VuZHNDaGFuZ2VkLFxuICAgIG9uQ2VudGVyQ2hhbmdlZCA9IF9hLm9uQ2VudGVyQ2hhbmdlZCwgXG4gICAgLy8gb25IZWFkaW5nQ2hhbmdlZCxcbiAgICAvLyBvbklkbGUsXG4gICAgLy8gb25Qcm9qZWN0aW9uQ2hhbmdlZCxcbiAgICAvLyBvblJlc2l6ZSxcbiAgICAvLyBvblRpbHRDaGFuZ2VkLFxuICAgIC8vIG9uWm9vbUNoYW5nZWQsXG4gICAgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIF9iID0gdXNlU3RhdGUobnVsbCksIG1hcCA9IF9iWzBdLCBzZXRNYXAgPSBfYlsxXTtcbiAgICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIC8vIGNvbnN0IFtleHRyYU1hcFR5cGVzTGlzdGVuZXIsIHNldEV4dHJhTWFwVHlwZXNMaXN0ZW5lcl0gPSB1c2VTdGF0ZTxnb29nbGUubWFwcy5NYXBzRXZlbnRMaXN0ZW5lciB8IG51bGw+KG51bGwpXG4gICAgdmFyIF9jID0gdXNlU3RhdGUobnVsbCksIGNlbnRlckNoYW5nZWRMaXN0ZW5lciA9IF9jWzBdLCBzZXRDZW50ZXJDaGFuZ2VkTGlzdGVuZXIgPSBfY1sxXTtcbiAgICB2YXIgX2QgPSB1c2VTdGF0ZShudWxsKSwgZGJsY2xpY2tMaXN0ZW5lciA9IF9kWzBdLCBzZXREYmxjbGlja0xpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gdXNlU3RhdGUobnVsbCksIGRyYWdlbmRMaXN0ZW5lciA9IF9lWzBdLCBzZXREcmFnZW5kTGlzdGVuZXIgPSBfZVsxXTtcbiAgICB2YXIgX2YgPSB1c2VTdGF0ZShudWxsKSwgZHJhZ3N0YXJ0TGlzdGVuZXIgPSBfZlswXSwgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIgPSBfZlsxXTtcbiAgICB2YXIgX2cgPSB1c2VTdGF0ZShudWxsKSwgbW91c2Vkb3duTGlzdGVuZXIgPSBfZ1swXSwgc2V0TW91c2Vkb3duTGlzdGVuZXIgPSBfZ1sxXTtcbiAgICB2YXIgX2ggPSB1c2VTdGF0ZShudWxsKSwgbW91c2Vtb3ZlTGlzdGVuZXIgPSBfaFswXSwgc2V0TW91c2Vtb3ZlTGlzdGVuZXIgPSBfaFsxXTtcbiAgICB2YXIgX2ogPSB1c2VTdGF0ZShudWxsKSwgbW91c2VvdXRMaXN0ZW5lciA9IF9qWzBdLCBzZXRNb3VzZW91dExpc3RlbmVyID0gX2pbMV07XG4gICAgdmFyIF9rID0gdXNlU3RhdGUobnVsbCksIG1vdXNlb3Zlckxpc3RlbmVyID0gX2tbMF0sIHNldE1vdXNlb3Zlckxpc3RlbmVyID0gX2tbMV07XG4gICAgdmFyIF9sID0gdXNlU3RhdGUobnVsbCksIG1vdXNldXBMaXN0ZW5lciA9IF9sWzBdLCBzZXRNb3VzZXVwTGlzdGVuZXIgPSBfbFsxXTtcbiAgICB2YXIgX20gPSB1c2VTdGF0ZShudWxsKSwgcmlnaHRjbGlja0xpc3RlbmVyID0gX21bMF0sIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lciA9IF9tWzFdO1xuICAgIHZhciBfbyA9IHVzZVN0YXRlKG51bGwpLCBjbGlja0xpc3RlbmVyID0gX29bMF0sIHNldENsaWNrTGlzdGVuZXIgPSBfb1sxXTtcbiAgICB2YXIgX3AgPSB1c2VTdGF0ZShudWxsKSwgZHJhZ0xpc3RlbmVyID0gX3BbMF0sIHNldERyYWdMaXN0ZW5lciA9IF9wWzFdO1xuICAgIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgbWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgICBtYXAuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXAsIG9wdGlvbnNdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICE9PSBudWxsICYmIHR5cGVvZiBjZW50ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtYXAuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwLCBjZW50ZXJdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICYmIG9uRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREYmxjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uRGJsQ2xpY2tdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICYmIG9uRHJhZ0VuZCkge1xuICAgICAgICAgICAgaWYgKGRyYWdlbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdlbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ0VuZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgb25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnU3RhcnRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICYmIG9uTW91c2VEb3duKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VEb3duXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBvbk1vdXNlTW92ZSkge1xuICAgICAgICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2Vtb3ZlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlTW92ZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnbW91c2VvdXQnLCBvbk1vdXNlT3V0KSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU91dF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgb25Nb3VzZU92ZXIpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU92ZXJdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICYmIG9uTW91c2VVcCkge1xuICAgICAgICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNldXBMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VVcF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SaWdodENsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBvbkNsaWNrKSB7XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBvbkRyYWcpIHtcbiAgICAgICAgICAgIGlmIChkcmFnTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWddKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobWFwICYmIG9uQ2VudGVyQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKGNlbnRlckNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNlbnRlckNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDZW50ZXJDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFwLCAnY2VudGVyX2NoYW5nZWQnLCBvbkNlbnRlckNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcCA9IHJlZi5jdXJyZW50ID09PSBudWxsXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogbmV3IGdvb2dsZS5tYXBzLk1hcChyZWYuY3VycmVudCwgb3B0aW9ucyk7XG4gICAgICAgIHNldE1hcChtYXApO1xuICAgICAgICBpZiAobWFwICE9PSBudWxsICYmIG9uTG9hZCkge1xuICAgICAgICAgICAgb25Mb2FkKG1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uVW5tb3VudChtYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBpZDogaWQsIHJlZjogcmVmLCBzdHlsZTogbWFwQ29udGFpbmVyU3R5bGUsIGNsYXNzTmFtZTogbWFwQ29udGFpbmVyQ2xhc3NOYW1lLCBjaGlsZHJlbjoganN4KE1hcENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG1hcCwgY2hpbGRyZW46IG1hcCAhPT0gbnVsbCA/IGNoaWxkcmVuIDogbnVsbCB9KSB9KSk7XG59XG5tZW1vKEdvb2dsZU1hcEZ1bmN0aW9uYWwpO1xudmFyIEdvb2dsZU1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR29vZ2xlTWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdvb2dsZU1hcCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgbWFwOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLm1hcFJlZiA9IG51bGw7XG4gICAgICAgIF90aGlzLmdldEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLm1hcFJlZiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5NYXAoX3RoaXMubWFwUmVmLCBfdGhpcy5wcm9wcy5vcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucGFuVG8gPSBmdW5jdGlvbiAobGF0TG5nKSB7XG4gICAgICAgICAgICB2YXIgbWFwID0gX3RoaXMuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgICAgICBtYXAucGFuVG8obGF0TG5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0TWFwQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUubWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUubWFwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFJlZiA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIF90aGlzLm1hcFJlZiA9IHJlZjtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHb29nbGVNYXAucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkaSxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRpLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBtYXAsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldE1hcCgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFwOiBtYXAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldE1hcENhbGxiYWNrKTtcbiAgICB9O1xuICAgIEdvb2dsZU1hcC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tYXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkaSxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkaSxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUubWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdvb2dsZU1hcC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLm1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHb29nbGVNYXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBpZDogdGhpcy5wcm9wcy5pZCwgcmVmOiB0aGlzLmdldFJlZiwgc3R5bGU6IHRoaXMucHJvcHMubWFwQ29udGFpbmVyU3R5bGUsIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5tYXBDb250YWluZXJDbGFzc05hbWUsIGNoaWxkcmVuOiBqc3goTWFwQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGhpcy5zdGF0ZS5tYXAsIGNoaWxkcmVuOiB0aGlzLnN0YXRlLm1hcCAhPT0gbnVsbCA/IHRoaXMucHJvcHMuY2hpbGRyZW4gOiBudWxsIH0pIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBHb29nbGVNYXA7XG59KFB1cmVDb21wb25lbnQpKTtcblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBpbmplY3RTY3JpcHQoX2EpIHtcbiAgICB2YXIgdXJsID0gX2EudXJsLCBpZCA9IF9hLmlkLCBub25jZSA9IF9hLm5vbmNlO1xuICAgIGlmICghaXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2RvY3VtZW50IGlzIHVuZGVmaW5lZCcpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGluamVjdFNjcmlwdENhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZXhpc3RpbmdTY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgIHZhciB3aW5kb3dXaXRoR29vZ2xlTWFwID0gd2luZG93O1xuICAgICAgICBpZiAoZXhpc3RpbmdTY3JpcHQpIHtcbiAgICAgICAgICAgIC8vIFNhbWUgc2NyaXB0IGlkL3VybDoga2VlcCBzYW1lIHNjcmlwdFxuICAgICAgICAgICAgdmFyIGRhdGFTdGF0ZUF0dHJpYnV0ZSA9IGV4aXN0aW5nU2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nU2NyaXB0LnNyYyA9PT0gdXJsICYmIGRhdGFTdGF0ZUF0dHJpYnV0ZSAhPT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhU3RhdGVBdHRyaWJ1dGUgPT09ICdyZWFkeScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsSW5pdE1hcF8xID0gd2luZG93V2l0aEdvb2dsZU1hcC5pbml0TWFwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxFcnJvckNhbGxiYWNrXzEgPSBleGlzdGluZ1NjcmlwdC5vbmVycm9yO1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dXaXRoR29vZ2xlTWFwLmluaXRNYXAgPSBmdW5jdGlvbiBpbml0TWFwKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5pdE1hcF8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbml0TWFwXzEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1NjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsRXJyb3JDYWxsYmFja18xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvckNhbGxiYWNrXzEoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2FtZSBzY3JpcHQgaWQsIGJ1dCBlaXRoZXJcbiAgICAgICAgICAgIC8vIDEuIHJlcXVlc3RlZCBVUkwgaXMgZGlmZmVyZW50XG4gICAgICAgICAgICAvLyAyLiBzY3JpcHQgZmFpbGVkIHRvIGxvYWRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nU2NyaXB0LnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgc2NyaXB0LmlkID0gaWQ7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIHNjcmlwdC5ub25jZSA9IG5vbmNlIHx8ICcnO1xuICAgICAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgJ2Vycm9yJyk7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93V2l0aEdvb2dsZU1hcC5pbml0TWFwID0gZnVuY3Rpb24gb25sb2FkKCkge1xuICAgICAgICAgICAgc2NyaXB0LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdyZWFkeScpO1xuICAgICAgICAgICAgcmVzb2x2ZShpZCk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2luamVjdFNjcmlwdCBlcnJvcjogJywgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBpc0dvb2dsZUZvbnRTdHlsZShlbGVtZW50KSB7XG4gICAgLy8gJ1JvYm90bycgb3IgJ0dvb2dsZSBTYW5zIFRleHQnIGZvbnQgZG93bmxvYWRcbiAgICB2YXIgaHJlZiA9IGVsZW1lbnQuaHJlZjtcbiAgICBpZiAoaHJlZiAmJiAoaHJlZi5pbmRleE9mKCdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9Um9ib3RvJykgPT09IDAgfHxcbiAgICAgICAgaHJlZi5pbmRleE9mKCdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9R29vZ2xlK1NhbnMrVGV4dCcpID09PSAwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gZm9udCBzdHlsZSBlbGVtZW50c1xuICAgIGlmIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3R5bGUnICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBlbGVtZW50LnN0eWxlU2hlZXQgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBlbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dC5yZXBsYWNlKCdcXHJcXG4nLCAnJykuaW5kZXhPZignLmdtLXN0eWxlJykgPT09IDApIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gJyc7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBmb250IHN0eWxlIGVsZW1lbnRzIGZvciBvdGhlciBicm93c2Vyc1xuICAgIGlmIChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3R5bGUnICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBlbGVtZW50LmlubmVySFRNTCAmJlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwucmVwbGFjZSgnXFxyXFxuJywgJycpLmluZGV4T2YoJy5nbS1zdHlsZScpID09PSAwKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gd2hlbiBnb29nbGUgdHJpZXMgdG8gYWRkIGVtcHR5IHN0eWxlXG4gICAgaWYgKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzdHlsZScgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICFlbGVtZW50LnN0eWxlU2hlZXQgJiZcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICFlbGVtZW50LmlubmVySFRNTCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gUHJldmVudGluZyB0aGUgR29vZ2xlIE1hcHMgbGlicmFyeSBmcm9tIGRvd25sb2FkaW5nIGFuIGV4dHJhIGZvbnRcbmZ1bmN0aW9uIHByZXZlbnRHb29nbGVGb250cygpIHtcbiAgICAvLyB3ZSBvdmVycmlkZSB0aGVzZSBtZXRob2RzIG9ubHkgZm9yIG9uZSBwYXJ0aWN1bGFyIGhlYWQgZWxlbWVudFxuICAgIC8vIGRlZmF1bHQgbWV0aG9kcyBmb3Igb3RoZXIgZWxlbWVudHMgYXJlIG5vdCBhZmZlY3RlZFxuICAgIHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBpZiAoaGVhZCkge1xuICAgICAgICB2YXIgdHJ1ZUluc2VydEJlZm9yZV8xID0gaGVhZC5pbnNlcnRCZWZvcmUuYmluZChoZWFkKTtcbiAgICAgICAgLy8gVE9ETzogYWRkaW5nIHJldHVybiBiZWZvcmUgcmVmbGVjdCBzb2x2ZXMgdGhlIFRTIGlzc3VlXG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIHJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghaXNHb29nbGVGb250U3R5bGUobmV3RWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmFwcGx5KHRydWVJbnNlcnRCZWZvcmVfMSwgaGVhZCwgW25ld0VsZW1lbnQsIHJlZmVyZW5jZUVsZW1lbnRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdFbGVtZW50O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdHJ1ZUFwcGVuZF8xID0gaGVhZC5hcHBlbmRDaGlsZC5iaW5kKGhlYWQpO1xuICAgICAgICAvLyBUT0RPOiBhZGRpbmcgcmV0dXJuIGJlZm9yZSByZWZsZWN0IHNvbHZlcyB0aGUgVFMgaXNzdWVcbiAgICAgICAgaGVhZC5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIGFwcGVuZENoaWxkKHRleHROb2RlKSB7XG4gICAgICAgICAgICBpZiAoIWlzR29vZ2xlRm9udFN0eWxlKHRleHROb2RlKSkge1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuYXBwbHkodHJ1ZUFwcGVuZF8xLCBoZWFkLCBbdGV4dE5vZGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VMb2FkU2NyaXB0VXJsKF9hKSB7XG4gICAgdmFyIGdvb2dsZU1hcHNBcGlLZXkgPSBfYS5nb29nbGVNYXBzQXBpS2V5LCBnb29nbGVNYXBzQ2xpZW50SWQgPSBfYS5nb29nbGVNYXBzQ2xpZW50SWQsIF9iID0gX2EudmVyc2lvbiwgdmVyc2lvbiA9IF9iID09PSB2b2lkIDAgPyAnd2Vla2x5JyA6IF9iLCBsYW5ndWFnZSA9IF9hLmxhbmd1YWdlLCByZWdpb24gPSBfYS5yZWdpb24sIGxpYnJhcmllcyA9IF9hLmxpYnJhcmllcywgY2hhbm5lbCA9IF9hLmNoYW5uZWwsIG1hcElkcyA9IF9hLm1hcElkcywgYXV0aFJlZmVycmVyUG9saWN5ID0gX2EuYXV0aFJlZmVycmVyUG9saWN5O1xuICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICBpbnZhcmlhbnQkMSgoZ29vZ2xlTWFwc0FwaUtleSAmJiBnb29nbGVNYXBzQ2xpZW50SWQpIHx8ICEoZ29vZ2xlTWFwc0FwaUtleSAmJiBnb29nbGVNYXBzQ2xpZW50SWQpLCAnWW91IG5lZWQgdG8gc3BlY2lmeSBlaXRoZXIgZ29vZ2xlTWFwc0FwaUtleSBvciBnb29nbGVNYXBzQ2xpZW50SWQgZm9yIEByZWFjdC1nb29nbGUtbWFwcy9hcGkgbG9hZCBzY3JpcHQgdG8gd29yay4gWW91IGNhbm5vdCB1c2UgYm90aCBhdCB0aGUgc2FtZSB0aW1lLicpO1xuICAgIGlmIChnb29nbGVNYXBzQXBpS2V5KSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwia2V5PVwiLmNvbmNhdChnb29nbGVNYXBzQXBpS2V5KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGdvb2dsZU1hcHNDbGllbnRJZCkge1xuICAgICAgICBwYXJhbXMucHVzaChcImNsaWVudD1cIi5jb25jYXQoZ29vZ2xlTWFwc0NsaWVudElkKSk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKFwidj1cIi5jb25jYXQodmVyc2lvbikpO1xuICAgIH1cbiAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJsYW5ndWFnZT1cIi5jb25jYXQobGFuZ3VhZ2UpKTtcbiAgICB9XG4gICAgaWYgKHJlZ2lvbikge1xuICAgICAgICBwYXJhbXMucHVzaChcInJlZ2lvbj1cIi5jb25jYXQocmVnaW9uKSk7XG4gICAgfVxuICAgIGlmIChsaWJyYXJpZXMgJiYgbGlicmFyaWVzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMucHVzaChcImxpYnJhcmllcz1cIi5jb25jYXQobGlicmFyaWVzLnNvcnQoKS5qb2luKCcsJykpKTtcbiAgICB9XG4gICAgaWYgKGNoYW5uZWwpIHtcbiAgICAgICAgcGFyYW1zLnB1c2goXCJjaGFubmVsPVwiLmNvbmNhdChjaGFubmVsKSk7XG4gICAgfVxuICAgIGlmIChtYXBJZHMgJiYgbWFwSWRzLmxlbmd0aCkge1xuICAgICAgICBwYXJhbXMucHVzaChcIm1hcF9pZHM9XCIuY29uY2F0KG1hcElkcy5qb2luKCcsJykpKTtcbiAgICB9XG4gICAgaWYgKGF1dGhSZWZlcnJlclBvbGljeSkge1xuICAgICAgICBwYXJhbXMucHVzaChcImF1dGhfcmVmZXJyZXJfcG9saWN5PVwiLmNvbmNhdChhdXRoUmVmZXJyZXJQb2xpY3kpKTtcbiAgICB9XG4gICAgcGFyYW1zLnB1c2goJ2NhbGxiYWNrPWluaXRNYXAnKTtcbiAgICByZXR1cm4gXCJodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanM/XCIuY29uY2F0KHBhcmFtcy5qb2luKCcmJykpO1xufVxuXG52YXIgY2xlYW5pbmdVcCA9IGZhbHNlO1xuZnVuY3Rpb24gRGVmYXVsdExvYWRpbmdFbGVtZW50KCkge1xuICAgIHJldHVybiBqc3goXCJkaXZcIiwgeyBjaGlsZHJlbjogXCJMb2FkaW5nLi4uXCIgfSk7XG59XG52YXIgZGVmYXVsdExvYWRTY3JpcHRQcm9wcyA9IHtcbiAgICBpZDogJ3NjcmlwdC1sb2FkZXInLFxuICAgIHZlcnNpb246ICd3ZWVrbHknLFxufTtcbnZhciBMb2FkU2NyaXB0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMb2FkU2NyaXB0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvYWRTY3JpcHQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jaGVjayA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGxvYWRlZDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNsZWFudXBDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuZ29vZ2xlLm1hcHM7XG4gICAgICAgICAgICBfdGhpcy5pbmplY3RTY3JpcHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNDbGVhbmluZ1VwID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX19hd2FpdGVyJDEoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBwcm9taXNlQ2FsbGJhY2socmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIGlmICghY2xlYW5pbmdVcCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZXJfMSA9IHdpbmRvdy5zZXRJbnRlcnZhbChmdW5jdGlvbiBpbnRlcnZhbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsZWFuaW5nVXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBQcm9taXNlKHByb21pc2VDYWxsYmFjayldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pOyB9O1xuICAgICAgICBfdGhpcy5jbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYW5pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoX3RoaXMucHJvcHMuaWQpO1xuICAgICAgICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICAgICAgICAuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXIoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzY3JpcHQuc3JjID09PSAnc3RyaW5nJyAmJiBzY3JpcHQuc3JjLmluY2x1ZGVzKCdtYXBzLmdvb2dsZWFwaXMnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgICAgICAgICAgIC5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdsaW5rJykpXG4gICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXIobGluaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobGluay5ocmVmID09PSAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVJvYm90bzozMDAsNDAwLDUwMCw3MDB8R29vZ2xlK1NhbnMnKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaChsaW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICAgICAgICAuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlcihzdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoc3R5bGUuaW5uZXJUZXh0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW5uZXJUZXh0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaW5uZXJUZXh0LmluY2x1ZGVzKCcuZ20tJykpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoKHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmluamVjdFNjcmlwdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5wcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgcHJldmVudEdvb2dsZUZvbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSghIV90aGlzLnByb3BzLmlkLCAnTG9hZFNjcmlwdCByZXF1aXJlcyBcImlkXCIgcHJvcCB0byBiZSBhIHN0cmluZzogJXMnLCBfdGhpcy5wcm9wcy5pZCk7XG4gICAgICAgICAgICB2YXIgaW5qZWN0U2NyaXB0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBpZDogX3RoaXMucHJvcHMuaWQsXG4gICAgICAgICAgICAgICAgbm9uY2U6IF90aGlzLnByb3BzLm5vbmNlLFxuICAgICAgICAgICAgICAgIHVybDogbWFrZUxvYWRTY3JpcHRVcmwoX3RoaXMucHJvcHMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGluamVjdFNjcmlwdChpbmplY3RTY3JpcHRPcHRpb25zKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRMb2FkZWQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlxcbiAgICAgICAgICBUaGVyZSBoYXMgYmVlbiBhbiBFcnJvciB3aXRoIGxvYWRpbmcgR29vZ2xlIE1hcHMgQVBJIHNjcmlwdCwgcGxlYXNlIGNoZWNrIHRoYXQgeW91IHByb3ZpZGVkIGNvcnJlY3QgZ29vZ2xlIEFQSSBrZXkgKFwiLmNvbmNhdChfdGhpc1xuICAgICAgICAgICAgICAgICAgICAucHJvcHMuZ29vZ2xlTWFwc0FwaUtleSB8fCAnLScsIFwiKSBvciBDbGllbnQgSUQgKFwiKS5jb25jYXQoX3RoaXMucHJvcHMuZ29vZ2xlTWFwc0NsaWVudElkIHx8XG4gICAgICAgICAgICAgICAgICAgICctJywgXCIpIHRvIDxMb2FkU2NyaXB0IC8+XFxuICAgICAgICAgIE90aGVyd2lzZSBpdCBpcyBhIE5ldHdvcmsgaXNzdWUuXFxuICAgICAgICBcIikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTG9hZFNjcmlwdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuZ29vZ2xlICYmIHdpbmRvdy5nb29nbGUubWFwcyAmJiAhY2xlYW5pbmdVcCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dvb2dsZSBhcGkgaXMgYWxyZWFkeSBwcmVzZW50ZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzQ2xlYW5pbmdVcCgpXG4gICAgICAgICAgICAgICAgLnRoZW4odGhpcy5pbmplY3RTY3JpcHQpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGF0IGluamVjdGluZyBzY3JpcHQgYWZ0ZXIgY2xlYW5pbmcgdXA6ICcsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9hZFNjcmlwdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5saWJyYXJpZXMgIT09IHByZXZQcm9wcy5saWJyYXJpZXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUGVyZm9ybWFuY2Ugd2FybmluZyEgTG9hZFNjcmlwdCBoYXMgYmVlbiByZWxvYWRlZCB1bmludGVudGlvbmFsbHkhIFlvdSBzaG91bGQgbm90IHBhc3MgYGxpYnJhcmllc2AgcHJvcCBhcyBuZXcgYXJyYXkuIFBsZWFzZSBrZWVwIGFuIGFycmF5IG9mIGxpYnJhcmllcyBhcyBzdGF0aWMgY2xhc3MgcHJvcGVydHkgZm9yIENvbXBvbmVudHMgYW5kIFB1cmVDb21wb25lbnRzLCBvciBqdXN0IGEgY29uc3QgdmFyaWFibGUgb3V0c2lkZSBvZiBjb21wb25lbnQsIG9yIHNvbWV3aGVyZSBpbiBjb25maWcgZmlsZXMgb3IgRU5WIHZhcmlhYmxlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Jyb3dzZXIgJiYgcHJldlByb3BzLmxhbmd1YWdlICE9PSB0aGlzLnByb3BzLmxhbmd1YWdlKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIHRvIHVzZSBnRFNGUCBtYXliZS4uLiB3YWl0IGZvciBob29rcyByZWZhY3RvcmluZy5cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0TG9hZGVkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIHRoaXMuY2xlYW51cENhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9hZFNjcmlwdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmNoZWNrLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuZ29vZ2xlO1xuICAgICAgICAgICAgICAgICAgICBjbGVhbmluZ1VwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBMb2FkU2NyaXB0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoanN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW2pzeChcImRpdlwiLCB7IHJlZjogdGhpcy5jaGVjayB9KSwgdGhpcy5zdGF0ZS5sb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5wcm9wcy5sb2FkaW5nRWxlbWVudCB8fCBqc3goRGVmYXVsdExvYWRpbmdFbGVtZW50LCB7fSldIH0pKTtcbiAgICB9O1xuICAgIExvYWRTY3JpcHQuZGVmYXVsdFByb3BzID0gZGVmYXVsdExvYWRTY3JpcHRQcm9wcztcbiAgICByZXR1cm4gTG9hZFNjcmlwdDtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmaWxlbmFtZXMvbWF0Y2gtcmVnZXggKi9cbnZhciBwcmV2aW91c2x5TG9hZGVkVXJsO1xuZnVuY3Rpb24gdXNlTG9hZFNjcmlwdChfYSkge1xuICAgIHZhciBfYiA9IF9hLmlkLCBpZCA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0TG9hZFNjcmlwdFByb3BzLmlkIDogX2IsIF9jID0gX2EudmVyc2lvbiwgdmVyc2lvbiA9IF9jID09PSB2b2lkIDAgPyBkZWZhdWx0TG9hZFNjcmlwdFByb3BzLnZlcnNpb24gOiBfYywgbm9uY2UgPSBfYS5ub25jZSwgZ29vZ2xlTWFwc0FwaUtleSA9IF9hLmdvb2dsZU1hcHNBcGlLZXksIGdvb2dsZU1hcHNDbGllbnRJZCA9IF9hLmdvb2dsZU1hcHNDbGllbnRJZCwgbGFuZ3VhZ2UgPSBfYS5sYW5ndWFnZSwgcmVnaW9uID0gX2EucmVnaW9uLCBsaWJyYXJpZXMgPSBfYS5saWJyYXJpZXMsIHByZXZlbnRHb29nbGVGb250c0xvYWRpbmcgPSBfYS5wcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nLCBjaGFubmVsID0gX2EuY2hhbm5lbCwgbWFwSWRzID0gX2EubWFwSWRzLCBhdXRoUmVmZXJyZXJQb2xpY3kgPSBfYS5hdXRoUmVmZXJyZXJQb2xpY3k7XG4gICAgdmFyIGlzTW91bnRlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdmFyIF9kID0gdXNlU3RhdGUoZmFsc2UpLCBpc0xvYWRlZCA9IF9kWzBdLCBzZXRMb2FkZWQgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSB1c2VTdGF0ZSh1bmRlZmluZWQpLCBsb2FkRXJyb3IgPSBfZVswXSwgc2V0TG9hZEVycm9yID0gX2VbMV07XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uIHRyYWNrTW91bnRlZFN0YXRlKCkge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gYXBwbHlQcmV2ZW50R29vZ2xlRm9udHMoKSB7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIgJiYgcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZykge1xuICAgICAgICAgICAgcHJldmVudEdvb2dsZUZvbnRzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJldmVudEdvb2dsZUZvbnRzTG9hZGluZ10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiB2YWxpZGF0ZUxvYWRlZFN0YXRlKCkge1xuICAgICAgICBpZiAoaXNMb2FkZWQpIHtcbiAgICAgICAgICAgIGludmFyaWFudCQxKCEhd2luZG93Lmdvb2dsZSwgJ3VzZUxvYWRTY3JpcHQgd2FzIG1hcmtlZCBhcyBsb2FkZWQsIGJ1dCB3aW5kb3cuZ29vZ2xlIGlzIG5vdCBwcmVzZW50LiBTb21ldGhpbmcgd2VudCB3cm9uZy4nKTtcbiAgICAgICAgfVxuICAgIH0sIFtpc0xvYWRlZF0pO1xuICAgIHZhciB1cmwgPSBtYWtlTG9hZFNjcmlwdFVybCh7XG4gICAgICAgIHZlcnNpb246IHZlcnNpb24sXG4gICAgICAgIGdvb2dsZU1hcHNBcGlLZXk6IGdvb2dsZU1hcHNBcGlLZXksXG4gICAgICAgIGdvb2dsZU1hcHNDbGllbnRJZDogZ29vZ2xlTWFwc0NsaWVudElkLFxuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG4gICAgICAgIHJlZ2lvbjogcmVnaW9uLFxuICAgICAgICBsaWJyYXJpZXM6IGxpYnJhcmllcyxcbiAgICAgICAgY2hhbm5lbDogY2hhbm5lbCxcbiAgICAgICAgbWFwSWRzOiBtYXBJZHMsXG4gICAgICAgIGF1dGhSZWZlcnJlclBvbGljeTogYXV0aFJlZmVycmVyUG9saWN5XG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uIGxvYWRTY3JpcHRBbmRNb2RpZnlMb2FkZWRTdGF0ZSgpIHtcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXRMb2FkZWRJZk1vdW50ZWQoKSB7XG4gICAgICAgICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNseUxvYWRlZFVybCA9IHVybDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93Lmdvb2dsZSAmJiB3aW5kb3cuZ29vZ2xlLm1hcHMgJiYgcHJldmlvdXNseUxvYWRlZFVybCA9PT0gdXJsKSB7XG4gICAgICAgICAgICBzZXRMb2FkZWRJZk1vdW50ZWQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbmplY3RTY3JpcHQoeyBpZDogaWQsIHVybDogdXJsLCBub25jZTogbm9uY2UgfSlcbiAgICAgICAgICAgIC50aGVuKHNldExvYWRlZElmTW91bnRlZClcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiBoYW5kbGVJbmplY3RFcnJvcihlcnIpIHtcbiAgICAgICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHNldExvYWRFcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiXFxuICAgICAgICBUaGVyZSBoYXMgYmVlbiBhbiBFcnJvciB3aXRoIGxvYWRpbmcgR29vZ2xlIE1hcHMgQVBJIHNjcmlwdCwgcGxlYXNlIGNoZWNrIHRoYXQgeW91IHByb3ZpZGVkIGNvcnJlY3QgZ29vZ2xlIEFQSSBrZXkgKFwiLmNvbmNhdChnb29nbGVNYXBzQXBpS2V5IHx8XG4gICAgICAgICAgICAgICAgJy0nLCBcIikgb3IgQ2xpZW50IElEIChcIikuY29uY2F0KGdvb2dsZU1hcHNDbGllbnRJZCB8fCAnLScsIFwiKVxcbiAgICAgICAgT3RoZXJ3aXNlIGl0IGlzIGEgTmV0d29yayBpc3N1ZS5cXG4gICAgICBcIikpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9LCBbaWQsIHVybCwgbm9uY2VdKTtcbiAgICB2YXIgcHJldkxpYnJhcmllcyA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiBjaGVja1BlcmZvcm1hbmNlKCkge1xuICAgICAgICBpZiAocHJldkxpYnJhcmllcy5jdXJyZW50ICYmIGxpYnJhcmllcyAhPT0gcHJldkxpYnJhcmllcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BlcmZvcm1hbmNlIHdhcm5pbmchIExvYWRTY3JpcHQgaGFzIGJlZW4gcmVsb2FkZWQgdW5pbnRlbnRpb25hbGx5ISBZb3Ugc2hvdWxkIG5vdCBwYXNzIGBsaWJyYXJpZXNgIHByb3AgYXMgbmV3IGFycmF5LiBQbGVhc2Uga2VlcCBhbiBhcnJheSBvZiBsaWJyYXJpZXMgYXMgc3RhdGljIGNsYXNzIHByb3BlcnR5IGZvciBDb21wb25lbnRzIGFuZCBQdXJlQ29tcG9uZW50cywgb3IganVzdCBhIGNvbnN0IHZhcmlhYmxlIG91dHNpZGUgb2YgY29tcG9uZW50LCBvciBzb21ld2hlcmUgaW4gY29uZmlnIGZpbGVzIG9yIEVOViB2YXJpYWJsZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2TGlicmFyaWVzLmN1cnJlbnQgPSBsaWJyYXJpZXM7XG4gICAgfSwgW2xpYnJhcmllc10pO1xuICAgIHJldHVybiB7IGlzTG9hZGVkOiBpc0xvYWRlZCwgbG9hZEVycm9yOiBsb2FkRXJyb3IsIHVybDogdXJsIH07XG59XG5cbnZhciBkZWZhdWx0TG9hZGluZ0VsZW1lbnQgPSBqc3goRGVmYXVsdExvYWRpbmdFbGVtZW50LCB7fSk7XG5mdW5jdGlvbiBMb2FkU2NyaXB0TmV4dChfYSkge1xuICAgIHZhciBsb2FkaW5nRWxlbWVudCA9IF9hLmxvYWRpbmdFbGVtZW50LCBvbkxvYWQgPSBfYS5vbkxvYWQsIG9uRXJyb3IgPSBfYS5vbkVycm9yLCBvblVubW91bnQgPSBfYS5vblVubW91bnQsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGhvb2tPcHRpb25zID0gX19yZXN0JDEoX2EsIFtcImxvYWRpbmdFbGVtZW50XCIsIFwib25Mb2FkXCIsIFwib25FcnJvclwiLCBcIm9uVW5tb3VudFwiLCBcImNoaWxkcmVuXCJdKTtcbiAgICB2YXIgX2IgPSB1c2VMb2FkU2NyaXB0KGhvb2tPcHRpb25zKSwgaXNMb2FkZWQgPSBfYi5pc0xvYWRlZCwgbG9hZEVycm9yID0gX2IubG9hZEVycm9yO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiBoYW5kbGVPbkxvYWQoKSB7XG4gICAgICAgIGlmIChpc0xvYWRlZCAmJiB0eXBlb2Ygb25Mb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvbkxvYWQoKTtcbiAgICAgICAgfVxuICAgIH0sIFtpc0xvYWRlZCwgb25Mb2FkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uIGhhbmRsZU9uRXJyb3IoKSB7XG4gICAgICAgIGlmIChsb2FkRXJyb3IgJiYgdHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uRXJyb3IobG9hZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sIFtsb2FkRXJyb3IsIG9uRXJyb3JdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gaGFuZGxlT25Vbm1vdW50KCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIG9uVW5tb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtvblVubW91bnRdKTtcbiAgICByZXR1cm4gaXNMb2FkZWQgPyBjaGlsZHJlbiA6IGxvYWRpbmdFbGVtZW50IHx8IGRlZmF1bHRMb2FkaW5nRWxlbWVudDtcbn1cbnZhciBMb2FkU2NyaXB0TmV4dCQxID0gbWVtbyhMb2FkU2NyaXB0TmV4dCk7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxudmFyIGZhc3REZWVwRXF1YWwkMSA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdC5cbiAqXG4gKiAgICAgIEh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMC5cbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBERUZBVUxUX0lEID0gXCJfX2dvb2dsZU1hcHNTY3JpcHRJZFwiO1xuLyoqXG4gKiBUaGUgc3RhdHVzIG9mIHRoZSBbW0xvYWRlcl1dLlxuICovXG52YXIgTG9hZGVyU3RhdHVzO1xuKGZ1bmN0aW9uIChMb2FkZXJTdGF0dXMpIHtcbiAgICBMb2FkZXJTdGF0dXNbTG9hZGVyU3RhdHVzW1wiSU5JVElBTElaRURcIl0gPSAwXSA9IFwiSU5JVElBTElaRURcIjtcbiAgICBMb2FkZXJTdGF0dXNbTG9hZGVyU3RhdHVzW1wiTE9BRElOR1wiXSA9IDFdID0gXCJMT0FESU5HXCI7XG4gICAgTG9hZGVyU3RhdHVzW0xvYWRlclN0YXR1c1tcIlNVQ0NFU1NcIl0gPSAyXSA9IFwiU1VDQ0VTU1wiO1xuICAgIExvYWRlclN0YXR1c1tMb2FkZXJTdGF0dXNbXCJGQUlMVVJFXCJdID0gM10gPSBcIkZBSUxVUkVcIjtcbn0pKExvYWRlclN0YXR1cyB8fCAoTG9hZGVyU3RhdHVzID0ge30pKTtcbi8qKlxuICogW1tMb2FkZXJdXSBtYWtlcyBpdCBlYXNpZXIgdG8gYWRkIEdvb2dsZSBNYXBzIEphdmFTY3JpcHQgQVBJIHRvIHlvdXIgYXBwbGljYXRpb25cbiAqIGR5bmFtaWNhbGx5IHVzaW5nXG4gKiBbUHJvbWlzZXNdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1Byb21pc2UpLlxuICogSXQgd29ya3MgYnkgZHluYW1pY2FsbHkgY3JlYXRpbmcgYW5kIGFwcGVuZGluZyBhIHNjcmlwdCBub2RlIHRvIHRoZSB0aGVcbiAqIGRvY3VtZW50IGhlYWQgYW5kIHdyYXBwaW5nIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBzbyBhcyB0byByZXR1cm4gYSBwcm9taXNlLlxuICpcbiAqIGBgYFxuICogY29uc3QgbG9hZGVyID0gbmV3IExvYWRlcih7XG4gKiAgIGFwaUtleTogXCJcIixcbiAqICAgdmVyc2lvbjogXCJ3ZWVrbHlcIixcbiAqICAgbGlicmFyaWVzOiBbXCJwbGFjZXNcIl1cbiAqIH0pO1xuICpcbiAqIGxvYWRlci5sb2FkKCkudGhlbigoZ29vZ2xlKSA9PiB7XG4gKiAgIGNvbnN0IG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoLi4uKVxuICogfSlcbiAqIGBgYFxuICovXG5jbGFzcyBMb2FkZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTG9hZGVyIHVzaW5nIFtbTG9hZGVyT3B0aW9uc11dLiBObyBkZWZhdWx0cyBhcmUgc2V0XG4gICAgICogdXNpbmcgdGhpcyBsaWJyYXJ5LCBpbnN0ZWFkIHRoZSBkZWZhdWx0cyBhcmUgc2V0IGJ5IHRoZSBHb29nbGUgTWFwc1xuICAgICAqIEphdmFTY3JpcHQgQVBJIHNlcnZlci5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGxvYWRlciA9IExvYWRlcih7YXBpS2V5LCB2ZXJzaW9uOiAnd2Vla2x5JywgbGlicmFyaWVzOiBbJ3BsYWNlcyddfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBhcGlLZXksIGF1dGhSZWZlcnJlclBvbGljeSwgY2hhbm5lbCwgY2xpZW50LCBpZCA9IERFRkFVTFRfSUQsIGxhbmd1YWdlLCBsaWJyYXJpZXMgPSBbXSwgbWFwSWRzLCBub25jZSwgcmVnaW9uLCByZXRyaWVzID0gMywgdXJsID0gXCJodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanNcIiwgdmVyc2lvbiwgfSkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgICB0aGlzLmF1dGhSZWZlcnJlclBvbGljeSA9IGF1dGhSZWZlcnJlclBvbGljeTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuaWQgPSBpZCB8fCBERUZBVUxUX0lEOyAvLyBEbyBub3QgYWxsb3cgZW1wdHkgc3RyaW5nXG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5saWJyYXJpZXMgPSBsaWJyYXJpZXM7XG4gICAgICAgIHRoaXMubWFwSWRzID0gbWFwSWRzO1xuICAgICAgICB0aGlzLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgaWYgKExvYWRlci5pbnN0YW5jZSkge1xuICAgICAgICAgICAgaWYgKCFmYXN0RGVlcEVxdWFsJDEodGhpcy5vcHRpb25zLCBMb2FkZXIuaW5zdGFuY2Uub3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExvYWRlciBtdXN0IG5vdCBiZSBjYWxsZWQgYWdhaW4gd2l0aCBkaWZmZXJlbnQgb3B0aW9ucy4gJHtKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMpfSAhPT0gJHtKU09OLnN0cmluZ2lmeShMb2FkZXIuaW5zdGFuY2Uub3B0aW9ucyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTG9hZGVyLmluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIExvYWRlci5pbnN0YW5jZSA9IHRoaXM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGxpYnJhcmllczogdGhpcy5saWJyYXJpZXMsXG4gICAgICAgICAgICBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgICAgICAgIHJlZ2lvbjogdGhpcy5yZWdpb24sXG4gICAgICAgICAgICBtYXBJZHM6IHRoaXMubWFwSWRzLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgYXV0aFJlZmVycmVyUG9saWN5OiB0aGlzLmF1dGhSZWZlcnJlclBvbGljeSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIExvYWRlclN0YXR1cy5GQUlMVVJFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBMb2FkZXJTdGF0dXMuU1VDQ0VTUztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gTG9hZGVyU3RhdHVzLkxPQURJTkc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIExvYWRlclN0YXR1cy5JTklUSUFMSVpFRDtcbiAgICB9XG4gICAgZ2V0IGZhaWxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9uZSAmJiAhdGhpcy5sb2FkaW5nICYmIHRoaXMuZXJyb3JzLmxlbmd0aCA+PSB0aGlzLnJldHJpZXMgKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVVcmwgcmV0dXJucyB0aGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUEkgc2NyaXB0IHVybCBnaXZlbiB0aGUgW1tMb2FkZXJPcHRpb25zXV0uXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBjcmVhdGVVcmwoKSB7XG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnVybDtcbiAgICAgICAgdXJsICs9IGA/Y2FsbGJhY2s9X19nb29nbGVNYXBzQ2FsbGJhY2tgO1xuICAgICAgICBpZiAodGhpcy5hcGlLZXkpIHtcbiAgICAgICAgICAgIHVybCArPSBgJmtleT0ke3RoaXMuYXBpS2V5fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbCkge1xuICAgICAgICAgICAgdXJsICs9IGAmY2hhbm5lbD0ke3RoaXMuY2hhbm5lbH1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNsaWVudCkge1xuICAgICAgICAgICAgdXJsICs9IGAmY2xpZW50PSR7dGhpcy5jbGllbnR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5saWJyYXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdXJsICs9IGAmbGlicmFyaWVzPSR7dGhpcy5saWJyYXJpZXMuam9pbihcIixcIil9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYW5ndWFnZSkge1xuICAgICAgICAgICAgdXJsICs9IGAmbGFuZ3VhZ2U9JHt0aGlzLmxhbmd1YWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVnaW9uKSB7XG4gICAgICAgICAgICB1cmwgKz0gYCZyZWdpb249JHt0aGlzLnJlZ2lvbn1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgICAgIHVybCArPSBgJnY9JHt0aGlzLnZlcnNpb259YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXBJZHMpIHtcbiAgICAgICAgICAgIHVybCArPSBgJm1hcF9pZHM9JHt0aGlzLm1hcElkcy5qb2luKFwiLFwiKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dGhSZWZlcnJlclBvbGljeSkge1xuICAgICAgICAgICAgdXJsICs9IGAmYXV0aF9yZWZlcnJlcl9wb2xpY3k9JHt0aGlzLmF1dGhSZWZlcnJlclBvbGljeX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGRlbGV0ZVNjcmlwdCgpIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCk7XG4gICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBzY3JpcHQgYW5kIHJldHVybiBhIFByb21pc2UuXG4gICAgICogQGRlcHJlY2F0ZWQsIHVzZSBpbXBvcnRMaWJyYXJ5KCkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkUHJvbWlzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBzY3JpcHQgYW5kIHJldHVybiBhIFByb21pc2UuXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICogQGRlcHJlY2F0ZWQsIHVzZSBpbXBvcnRMaWJyYXJ5KCkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBsb2FkUHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZENhbGxiYWNrKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHdpbmRvdy5nb29nbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVyci5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbXBvcnRMaWJyYXJ5KG5hbWUpIHtcbiAgICAgICAgdGhpcy5leGVjdXRlKCk7XG4gICAgICAgIHJldHVybiBnb29nbGUubWFwcy5pbXBvcnRMaWJyYXJ5KG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSBzY3JpcHQgd2l0aCBhIGNhbGxiYWNrLlxuICAgICAqIEBkZXByZWNhdGVkLCB1c2UgaW1wb3J0TGlicmFyeSgpIGluc3RlYWQuXG4gICAgICovXG4gICAgbG9hZENhbGxiYWNrKGZuKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goZm4pO1xuICAgICAgICB0aGlzLmV4ZWN1dGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzY3JpcHQgb24gZG9jdW1lbnQuXG4gICAgICovXG4gICAgc2V0U2NyaXB0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCkpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gd3JhcCBvbmVycm9yIGNhbGxiYWNrIGZvciBjYXNlcyB3aGVyZSB0aGUgc2NyaXB0IHdhcyBsb2FkZWQgZWxzZXdoZXJlXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAga2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcbiAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICBsaWJyYXJpZXM6IHRoaXMubGlicmFyaWVzLmxlbmd0aCAmJiB0aGlzLmxpYnJhcmllcyxcbiAgICAgICAgICAgIHY6IHRoaXMudmVyc2lvbixcbiAgICAgICAgICAgIG1hcElkczogdGhpcy5tYXBJZHMsXG4gICAgICAgICAgICBsYW5ndWFnZTogdGhpcy5sYW5ndWFnZSxcbiAgICAgICAgICAgIHJlZ2lvbjogdGhpcy5yZWdpb24sXG4gICAgICAgICAgICBhdXRoUmVmZXJyZXJQb2xpY3k6IHRoaXMuYXV0aFJlZmVycmVyUG9saWN5LFxuICAgICAgICB9O1xuICAgICAgICAvLyBrZWVwIHRoZSBVUkwgbWluaW1hbDpcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAoa2V5KSA9PiAhcGFyYW1zW2tleV0gJiYgZGVsZXRlIHBhcmFtc1trZXldKTtcbiAgICAgICAgaWYgKCEoKF9iID0gKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93Lmdvb2dsZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pbXBvcnRMaWJyYXJ5KSkge1xuICAgICAgICAgICAgLy8gdHdlYWtlZCBjb3B5IG9mIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L2xvYWQtbWFwcy1qcy1hcGkjZHluYW1pYy1saWJyYXJ5LWltcG9ydFxuICAgICAgICAgICAgLy8gd2hpY2ggYWxzbyBzZXRzIHRoZSBiYXNlIHVybCwgdGhlIGlkLCBhbmQgdGhlIG5vbmNlXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgICAgICAgKChnKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxldCBoLCBhLCBrLCBwID0gXCJUaGUgR29vZ2xlIE1hcHMgSmF2YVNjcmlwdCBBUElcIiwgYyA9IFwiZ29vZ2xlXCIsIGwgPSBcImltcG9ydExpYnJhcnlcIiwgcSA9IFwiX19pYl9fXCIsIG0gPSBkb2N1bWVudCwgYiA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgYiA9IGJbY10gfHwgKGJbY10gPSB7fSk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGNvbnN0IGQgPSBiLm1hcHMgfHwgKGIubWFwcyA9IHt9KSwgciA9IG5ldyBTZXQoKSwgZSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKSwgdSA9ICgpID0+IFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBoIHx8IChoID0gbmV3IFByb21pc2UoKGYsIG4pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCAoYSA9IG0uY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGEuaWQgPSB0aGlzLmlkO1xuICAgICAgICAgICAgICAgICAgICBlLnNldChcImxpYnJhcmllc1wiLCBbLi4ucl0gKyBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gZylcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc2V0KGsucmVwbGFjZSgvW0EtWl0vZywgKHQpID0+IFwiX1wiICsgdFswXS50b0xvd2VyQ2FzZSgpKSwgZ1trXSk7XG4gICAgICAgICAgICAgICAgICAgIGUuc2V0KFwiY2FsbGJhY2tcIiwgYyArIFwiLm1hcHMuXCIgKyBxKTtcbiAgICAgICAgICAgICAgICAgICAgYS5zcmMgPSB0aGlzLnVybCArIGA/YCArIGU7XG4gICAgICAgICAgICAgICAgICAgIGRbcV0gPSBmO1xuICAgICAgICAgICAgICAgICAgICBhLm9uZXJyb3IgPSAoKSA9PiAoaCA9IG4oRXJyb3IocCArIFwiIGNvdWxkIG5vdCBsb2FkLlwiKSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGEubm9uY2UgPSB0aGlzLm5vbmNlIHx8ICgoX2EgPSBtLnF1ZXJ5U2VsZWN0b3IoXCJzY3JpcHRbbm9uY2VdXCIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9uY2UpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIG0uaGVhZC5hcHBlbmQoYSk7XG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZFtsXSA/IGNvbnNvbGUud2FybihwICsgXCIgb25seSBsb2FkcyBvbmNlLiBJZ25vcmluZzpcIiwgZykgOiAoZFtsXSA9IChmLCAuLi5uKSA9PiByLmFkZChmKSAmJiB1KCkudGhlbigoKSA9PiBkW2xdKGYsIC4uLm4pKSk7XG4gICAgICAgICAgICB9KShwYXJhbXMpO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoaWxlIG1vc3QgbGlicmFyaWVzIHBvcHVsYXRlIHRoZSBnbG9iYWwgbmFtZXNwYWNlIHdoZW4gbG9hZGVkIHZpYSBib290c3RyYXAgcGFyYW1zLFxuICAgICAgICAvLyB0aGlzIGlzIG5vdCB0aGUgY2FzZSBmb3IgXCJtYXJrZXJcIiB3aGVuIHVzZWQgd2l0aCB0aGUgaW5saW5lIGJvb3RzdHJhcCBsb2FkZXJcbiAgICAgICAgLy8gKGFuZCBtYXliZSBvdGhlcnMgaW4gdGhlIGZ1dHVyZSkuIFNvIGVuc3VyZSB0aGVyZSBpcyBhbiBpbXBvcnRMaWJyYXJ5IGZvciBlYWNoOlxuICAgICAgICBjb25zdCBsaWJyYXJ5UHJvbWlzZXMgPSB0aGlzLmxpYnJhcmllcy5tYXAoKGxpYnJhcnkpID0+IHRoaXMuaW1wb3J0TGlicmFyeShsaWJyYXJ5KSk7XG4gICAgICAgIC8vIGVuc3VyZSBhdCBsZWFzdCBvbmUgbGlicmFyeSwgdG8ga2ljayBvZmYgbG9hZGluZy4uLlxuICAgICAgICBpZiAoIWxpYnJhcnlQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpYnJhcnlQcm9taXNlcy5wdXNoKHRoaXMuaW1wb3J0TGlicmFyeShcImNvcmVcIikpO1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UuYWxsKGxpYnJhcnlQcm9taXNlcykudGhlbigoKSA9PiB0aGlzLmNhbGxiYWNrKCksIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudChcImVycm9yXCIsIHsgZXJyb3IgfSk7IC8vIGZvciBiYWNrd2FyZHMgY29tcGF0XG4gICAgICAgICAgICB0aGlzLmxvYWRFcnJvckNhbGxiYWNrKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBsb2FkZXIgc3RhdGUuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZGVsZXRlU2NyaXB0KCk7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5vbmVycm9yRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICByZXNldElmUmV0cnlpbmdGYWlsZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZhaWxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvYWRFcnJvckNhbGxiYWNrKGUpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlKTtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3JzLmxlbmd0aCA8PSB0aGlzLnJldHJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5lcnJvcnMubGVuZ3RoICogTWF0aC5wb3coMiwgdGhpcy5lcnJvcnMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIEdvb2dsZSBNYXBzIHNjcmlwdCwgcmV0cnlpbmcgaW4gJHtkZWxheX0gbXMuYCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVNjcmlwdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2NyaXB0KCk7XG4gICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3JFdmVudCA9IGU7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2soKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKChjYikgPT4ge1xuICAgICAgICAgICAgY2IodGhpcy5vbmVycm9yRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgZXhlY3V0ZSgpIHtcbiAgICAgICAgdGhpcy5yZXNldElmUmV0cnlpbmdGYWlsZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc2hvcnQgY2lyY3VpdCBhbmQgd2FybiBpZiBnb29nbGUubWFwcyBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgICAgaWYgKHdpbmRvdy5nb29nbGUgJiYgd2luZG93Lmdvb2dsZS5tYXBzICYmIHdpbmRvdy5nb29nbGUubWFwcy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiR29vZ2xlIE1hcHMgYWxyZWFkeSBsb2FkZWQgb3V0c2lkZSBAZ29vZ2xlbWFwcy9qcy1hcGktbG9hZGVyLlwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJUaGlzIG1heSByZXN1bHQgaW4gdW5kZXNpcmFibGUgYmVoYXZpb3IgYXMgb3B0aW9ucyBhbmQgc2NyaXB0IHBhcmFtZXRlcnMgbWF5IG5vdCBtYXRjaC5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRpbmcpIDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTY3JpcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIGRlZmF1bHRMaWJyYXJpZXMgPSBbJ21hcHMnXTtcbmZ1bmN0aW9uIHVzZUpzQXBpTG9hZGVyKF9hKSB7XG4gICAgdmFyIF9iID0gX2EuaWQsIGlkID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHRMb2FkU2NyaXB0UHJvcHMuaWQgOiBfYiwgX2MgPSBfYS52ZXJzaW9uLCB2ZXJzaW9uID0gX2MgPT09IHZvaWQgMCA/IGRlZmF1bHRMb2FkU2NyaXB0UHJvcHMudmVyc2lvbiA6IF9jLCBub25jZSA9IF9hLm5vbmNlLCBnb29nbGVNYXBzQXBpS2V5ID0gX2EuZ29vZ2xlTWFwc0FwaUtleSwgXG4gICAgLy8gZ29vZ2xlTWFwc0NsaWVudElkLFxuICAgIGxhbmd1YWdlID0gX2EubGFuZ3VhZ2UsIHJlZ2lvbiA9IF9hLnJlZ2lvbiwgX2QgPSBfYS5saWJyYXJpZXMsIGxpYnJhcmllcyA9IF9kID09PSB2b2lkIDAgPyBkZWZhdWx0TGlicmFyaWVzIDogX2QsIHByZXZlbnRHb29nbGVGb250c0xvYWRpbmcgPSBfYS5wcmV2ZW50R29vZ2xlRm9udHNMb2FkaW5nLCBcbiAgICAvLyBjaGFubmVsLFxuICAgIG1hcElkcyA9IF9hLm1hcElkcywgYXV0aFJlZmVycmVyUG9saWN5ID0gX2EuYXV0aFJlZmVycmVyUG9saWN5O1xuICAgIHZhciBpc01vdW50ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHZhciBfZSA9IHVzZVN0YXRlKGZhbHNlKSwgaXNMb2FkZWQgPSBfZVswXSwgc2V0TG9hZGVkID0gX2VbMV07XG4gICAgdmFyIF9mID0gdXNlU3RhdGUodW5kZWZpbmVkKSwgbG9hZEVycm9yID0gX2ZbMF0sIHNldExvYWRFcnJvciA9IF9mWzFdO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiB0cmFja01vdW50ZWRTdGF0ZSgpIHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGxvYWRlciA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IExvYWRlcih7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBhcGlLZXk6IGdvb2dsZU1hcHNBcGlLZXksXG4gICAgICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICAgICAgbGlicmFyaWVzOiBsaWJyYXJpZXMsXG4gICAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2UgfHwgJ2VuJyxcbiAgICAgICAgICAgIHJlZ2lvbjogcmVnaW9uIHx8ICdVUycsXG4gICAgICAgICAgICBtYXBJZHM6IG1hcElkcyB8fCBbXSxcbiAgICAgICAgICAgIG5vbmNlOiBub25jZSB8fCAnJyxcbiAgICAgICAgICAgIGF1dGhSZWZlcnJlclBvbGljeTogYXV0aFJlZmVycmVyUG9saWN5IHx8ICdvcmlnaW4nLFxuICAgICAgICB9KTtcbiAgICB9LCBbaWQsIGdvb2dsZU1hcHNBcGlLZXksIHZlcnNpb24sIGxpYnJhcmllcywgbGFuZ3VhZ2UsIHJlZ2lvbiwgbWFwSWRzLCBub25jZSwgYXV0aFJlZmVycmVyUG9saWN5XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uIGVmZmVjdCgpIHtcbiAgICAgICAgaWYgKGlzTG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2FkZXIubG9hZCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHNldExvYWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNCcm93c2VyICYmIHByZXZlbnRHb29nbGVGb250c0xvYWRpbmcpIHtcbiAgICAgICAgICAgIHByZXZlbnRHb29nbGVGb250cygpO1xuICAgICAgICB9XG4gICAgfSwgW3ByZXZlbnRHb29nbGVGb250c0xvYWRpbmddKTtcbiAgICB2YXIgcHJldkxpYnJhcmllcyA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcmV2TGlicmFyaWVzLmN1cnJlbnQgJiYgbGlicmFyaWVzICE9PSBwcmV2TGlicmFyaWVzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUGVyZm9ybWFuY2Ugd2FybmluZyEgTG9hZFNjcmlwdCBoYXMgYmVlbiByZWxvYWRlZCB1bmludGVudGlvbmFsbHkhIFlvdSBzaG91bGQgbm90IHBhc3MgYGxpYnJhcmllc2AgcHJvcCBhcyBuZXcgYXJyYXkuIFBsZWFzZSBrZWVwIGFuIGFycmF5IG9mIGxpYnJhcmllcyBhcyBzdGF0aWMgY2xhc3MgcHJvcGVydHkgZm9yIENvbXBvbmVudHMgYW5kIFB1cmVDb21wb25lbnRzLCBvciBqdXN0IGEgY29uc3QgdmFyaWFibGUgb3V0c2lkZSBvZiBjb21wb25lbnQsIG9yIHNvbWV3aGVyZSBpbiBjb25maWcgZmlsZXMgb3IgRU5WIHZhcmlhYmxlcycpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZMaWJyYXJpZXMuY3VycmVudCA9IGxpYnJhcmllcztcbiAgICB9LCBbbGlicmFyaWVzXSk7XG4gICAgcmV0dXJuIHsgaXNMb2FkZWQ6IGlzTG9hZGVkLCBsb2FkRXJyb3I6IGxvYWRFcnJvciB9O1xufVxuXG52YXIgZXZlbnRNYXAkaCA9IHt9O1xudmFyIHVwZGF0ZXJNYXAkaCA9IHtcbiAgICBvcHRpb25zOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIFRyYWZmaWNMYXllckZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIG9uTG9hZCA9IF9hLm9uTG9hZCwgb25Vbm1vdW50ID0gX2Eub25Vbm1vdW50O1xuICAgIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICAgIHZhciBfYiA9IHVzZVN0YXRlKG51bGwpLCBpbnN0YW5jZSA9IF9iWzBdLCBzZXRJbnN0YW5jZSA9IF9iWzFdO1xuICAgIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXBdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0cmFmZmljTGF5ZXIgPSBuZXcgZ29vZ2xlLm1hcHMuVHJhZmZpY0xheWVyKF9fYXNzaWduKF9fYXNzaWduKHt9LCAob3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogbWFwIH0pKTtcbiAgICAgICAgc2V0SW5zdGFuY2UodHJhZmZpY0xheWVyKTtcbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgb25Mb2FkKHRyYWZmaWNMYXllcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Vbm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBUcmFmZmljTGF5ZXJGID0gbWVtbyhUcmFmZmljTGF5ZXJGdW5jdGlvbmFsKTtcbnZhciBUcmFmZmljTGF5ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYWZmaWNMYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUcmFmZmljTGF5ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRyYWZmaWNMYXllcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0VHJhZmZpY0xheWVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUudHJhZmZpY0xheWVyICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS50cmFmZmljTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVHJhZmZpY0xheWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYWZmaWNMYXllciA9IG5ldyBnb29nbGUubWFwcy5UcmFmZmljTGF5ZXIoX19hc3NpZ24oX19hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRoLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGgsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRyYWZmaWNMYXllcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0VHJhZmZpY0xheWVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0cmFmZmljTGF5ZXI6IHRyYWZmaWNMYXllcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0VHJhZmZpY0xheWVyQ2FsbGJhY2spO1xuICAgIH07XG4gICAgVHJhZmZpY0xheWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnRyYWZmaWNMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRoLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRoLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5zdGF0ZS50cmFmZmljTGF5ZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhZmZpY0xheWVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUudHJhZmZpY0xheWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnRyYWZmaWNMYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnRyYWZmaWNMYXllci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYWZmaWNMYXllci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFRyYWZmaWNMYXllci5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIFRyYWZmaWNMYXllcjtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBCaWN5Y2xpbmdMYXllckZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gdXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgICAgICB9XG4gICAgfSwgW21hcF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiaWN5Y2xpbmdMYXllciA9IG5ldyBnb29nbGUubWFwcy5CaWN5Y2xpbmdMYXllcigpO1xuICAgICAgICBzZXRJbnN0YW5jZShiaWN5Y2xpbmdMYXllcik7XG4gICAgICAgIGJpY3ljbGluZ0xheWVyLnNldE1hcChtYXApO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQoYmljeWNsaW5nTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoYmljeWNsaW5nTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uVW5tb3VudChiaWN5Y2xpbmdMYXllcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJpY3ljbGluZ0xheWVyLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgQmljeWNsaW5nTGF5ZXJGID0gbWVtbyhCaWN5Y2xpbmdMYXllckZ1bmN0aW9uYWwpO1xudmFyIEJpY3ljbGluZ0xheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaWN5Y2xpbmdMYXllciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCaWN5Y2xpbmdMYXllcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgYmljeWNsaW5nTGF5ZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEJpY3ljbGluZ0xheWVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuYmljeWNsaW5nTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGF0ZS5iaWN5Y2xpbmdMYXllci5zZXRNYXAoX3RoaXMuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUuYmljeWNsaW5nTGF5ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCaWN5Y2xpbmdMYXllci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiaWN5Y2xpbmdMYXllciA9IG5ldyBnb29nbGUubWFwcy5CaWN5Y2xpbmdMYXllcigpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmljeWNsaW5nTGF5ZXI6IGJpY3ljbGluZ0xheWVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRCaWN5Y2xpbmdMYXllckNhbGxiYWNrKTtcbiAgICB9O1xuICAgIEJpY3ljbGluZ0xheWVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuYmljeWNsaW5nTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuYmljeWNsaW5nTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5iaWN5Y2xpbmdMYXllci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEJpY3ljbGluZ0xheWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQmljeWNsaW5nTGF5ZXIuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBCaWN5Y2xpbmdMYXllcjtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBUcmFuc2l0TGF5ZXJGdW5jdGlvbmFsKF9hKSB7XG4gICAgdmFyIG9uTG9hZCA9IF9hLm9uTG9hZCwgb25Vbm1vdW50ID0gX2Eub25Vbm1vdW50O1xuICAgIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICAgIHZhciBfYiA9IHVzZVN0YXRlKG51bGwpLCBpbnN0YW5jZSA9IF9iWzBdLCBzZXRJbnN0YW5jZSA9IF9iWzFdO1xuICAgIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXBdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhbnNpdExheWVyID0gbmV3IGdvb2dsZS5tYXBzLlRyYW5zaXRMYXllcigpO1xuICAgICAgICBzZXRJbnN0YW5jZSh0cmFuc2l0TGF5ZXIpO1xuICAgICAgICB0cmFuc2l0TGF5ZXIuc2V0TWFwKG1hcCk7XG4gICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgIG9uTG9hZCh0cmFuc2l0TGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uVW5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgVHJhbnNpdExheWVyRiA9IG1lbW8oVHJhbnNpdExheWVyRnVuY3Rpb25hbCk7XG52YXIgVHJhbnNpdExheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUcmFuc2l0TGF5ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhbnNpdExheWVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB0cmFuc2l0TGF5ZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFRyYW5zaXRMYXllckNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnRyYW5zaXRMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLnRyYW5zaXRMYXllci5zZXRNYXAoX3RoaXMuY29udGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUudHJhbnNpdExheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVHJhbnNpdExheWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRMYXllciA9IG5ldyBnb29nbGUubWFwcy5UcmFuc2l0TGF5ZXIoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRUcmFuc2l0TGF5ZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRMYXllcjogdHJhbnNpdExheWVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRUcmFuc2l0TGF5ZXJDYWxsYmFjayk7XG4gICAgfTtcbiAgICBUcmFuc2l0TGF5ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS50cmFuc2l0TGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUudHJhbnNpdExheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUudHJhbnNpdExheWVyLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNpdExheWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVHJhbnNpdExheWVyLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcbiAgICByZXR1cm4gVHJhbnNpdExheWVyO1xufShQdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCRnID0ge1xuICAgIG9uQ2lyY2xlQ29tcGxldGU6ICdjaXJjbGVjb21wbGV0ZScsXG4gICAgb25NYXJrZXJDb21wbGV0ZTogJ21hcmtlcmNvbXBsZXRlJyxcbiAgICBvbk92ZXJsYXlDb21wbGV0ZTogJ292ZXJsYXljb21wbGV0ZScsXG4gICAgb25Qb2x5Z29uQ29tcGxldGU6ICdwb2x5Z29uY29tcGxldGUnLFxuICAgIG9uUG9seWxpbmVDb21wbGV0ZTogJ3BvbHlsaW5lY29tcGxldGUnLFxuICAgIG9uUmVjdGFuZ2xlQ29tcGxldGU6ICdyZWN0YW5nbGVjb21wbGV0ZScsXG59O1xudmFyIHVwZGF0ZXJNYXAkZyA9IHtcbiAgICBkcmF3aW5nTW9kZTogZnVuY3Rpb24gKGluc3RhbmNlLCBkcmF3aW5nTW9kZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmF3aW5nTW9kZShkcmF3aW5nTW9kZSk7XG4gICAgfSxcbiAgICBvcHRpb25zOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIERyYXdpbmdNYW5hZ2VyRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucywgZHJhd2luZ01vZGUgPSBfYS5kcmF3aW5nTW9kZSwgb25DaXJjbGVDb21wbGV0ZSA9IF9hLm9uQ2lyY2xlQ29tcGxldGUsIG9uTWFya2VyQ29tcGxldGUgPSBfYS5vbk1hcmtlckNvbXBsZXRlLCBvbk92ZXJsYXlDb21wbGV0ZSA9IF9hLm9uT3ZlcmxheUNvbXBsZXRlLCBvblBvbHlnb25Db21wbGV0ZSA9IF9hLm9uUG9seWdvbkNvbXBsZXRlLCBvblBvbHlsaW5lQ29tcGxldGUgPSBfYS5vblBvbHlsaW5lQ29tcGxldGUsIG9uUmVjdGFuZ2xlQ29tcGxldGUgPSBfYS5vblJlY3RhbmdsZUNvbXBsZXRlLCBvbkxvYWQgPSBfYS5vbkxvYWQsIG9uVW5tb3VudCA9IF9hLm9uVW5tb3VudDtcbiAgICB2YXIgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICB2YXIgX2IgPSB1c2VTdGF0ZShudWxsKSwgaW5zdGFuY2UgPSBfYlswXSwgc2V0SW5zdGFuY2UgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSB1c2VTdGF0ZShudWxsKSwgY2lyY2xlY29tcGxldGVMaXN0ZW5lciA9IF9jWzBdLCBzZXRDaXJjbGVDb21wbGV0ZUxpc3RlbmVyID0gX2NbMV07XG4gICAgdmFyIF9kID0gdXNlU3RhdGUobnVsbCksIG1hcmtlcmNvbXBsZXRlTGlzdGVuZXIgPSBfZFswXSwgc2V0TWFya2VyQ29tcGxldGVMaXN0ZW5lciA9IF9kWzFdO1xuICAgIHZhciBfZSA9IHVzZVN0YXRlKG51bGwpLCBvdmVybGF5Y29tcGxldGVMaXN0ZW5lciA9IF9lWzBdLCBzZXRPdmVybGF5Q29tcGxldGVMaXN0ZW5lciA9IF9lWzFdO1xuICAgIHZhciBfZiA9IHVzZVN0YXRlKG51bGwpLCBwb2x5Z29uY29tcGxldGVMaXN0ZW5lciA9IF9mWzBdLCBzZXRQb2x5Z29uQ29tcGxldGVMaXN0ZW5lciA9IF9mWzFdO1xuICAgIHZhciBfZyA9IHVzZVN0YXRlKG51bGwpLCBwb2x5bGluZWNvbXBsZXRlTGlzdGVuZXIgPSBfZ1swXSwgc2V0UG9seWxpbmVDb21wbGV0ZUxpc3RlbmVyID0gX2dbMV07XG4gICAgdmFyIF9oID0gdXNlU3RhdGUobnVsbCksIHJlY3RhbmdsZWNvbXBsZXRlTGlzdGVuZXIgPSBfaFswXSwgc2V0UmVjdGFuZ2xlQ29tcGxldGVMaXN0ZW5lciA9IF9oWzFdO1xuICAgIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXBdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0RHJhd2luZ01vZGUoZHJhd2luZ01vZGUgIT09IG51bGwgJiYgZHJhd2luZ01vZGUgIT09IHZvaWQgMCA/IGRyYXdpbmdNb2RlIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGRyYXdpbmdNb2RlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2lyY2xlQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGlmIChjaXJjbGVjb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2lyY2xlY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDaXJjbGVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY2lyY2xlY29tcGxldGUnLCBvbkNpcmNsZUNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIG9uQ2lyY2xlQ29tcGxldGVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25NYXJrZXJDb21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKG1hcmtlcmNvbXBsZXRlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtYXJrZXJjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1hcmtlckNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtYXJrZXJjb21wbGV0ZScsIG9uTWFya2VyQ29tcGxldGUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb25NYXJrZXJDb21wbGV0ZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk92ZXJsYXlDb21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKG92ZXJsYXljb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIob3ZlcmxheWNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0T3ZlcmxheUNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdvdmVybGF5Y29tcGxldGUnLCBvbk92ZXJsYXlDb21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvbk92ZXJsYXlDb21wbGV0ZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblBvbHlnb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25jb21wbGV0ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocG9seWdvbmNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UG9seWdvbkNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdwb2x5Z29uY29tcGxldGUnLCBvblBvbHlnb25Db21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvblBvbHlnb25Db21wbGV0ZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblBvbHlsaW5lQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGlmIChwb2x5bGluZWNvbXBsZXRlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb2x5bGluZWNvbXBsZXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UG9seWxpbmVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncG9seWxpbmVjb21wbGV0ZScsIG9uUG9seWxpbmVDb21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvblBvbHlsaW5lQ29tcGxldGVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SZWN0YW5nbGVDb21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKHJlY3RhbmdsZWNvbXBsZXRlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyZWN0YW5nbGVjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJlY3RhbmdsZUNvbXBsZXRlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyZWN0YW5nbGVjb21wbGV0ZScsIG9uUmVjdGFuZ2xlQ29tcGxldGUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb25SZWN0YW5nbGVDb21wbGV0ZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudCQxKCEhZ29vZ2xlLm1hcHMuZHJhd2luZywgXCJEaWQgeW91IGluY2x1ZGUgcHJvcCBsaWJyYXJpZXM9e1snZHJhd2luZyddfSBpbiB0aGUgVVJMPyAlc1wiLCBnb29nbGUubWFwcy5kcmF3aW5nKTtcbiAgICAgICAgdmFyIGRyYXdpbmdNYW5hZ2VyID0gbmV3IGdvb2dsZS5tYXBzLmRyYXdpbmcuRHJhd2luZ01hbmFnZXIoX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSksIHsgbWFwOiBtYXAgfSkpO1xuICAgICAgICBpZiAoZHJhd2luZ01vZGUpIHtcbiAgICAgICAgICAgIGRyYXdpbmdNYW5hZ2VyLnNldERyYXdpbmdNb2RlKGRyYXdpbmdNb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DaXJjbGVDb21wbGV0ZSkge1xuICAgICAgICAgICAgc2V0Q2lyY2xlQ29tcGxldGVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkcmF3aW5nTWFuYWdlciwgJ2NpcmNsZWNvbXBsZXRlJywgb25DaXJjbGVDb21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1hcmtlckNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZXRNYXJrZXJDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAnbWFya2VyY29tcGxldGUnLCBvbk1hcmtlckNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uT3ZlcmxheUNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZXRPdmVybGF5Q29tcGxldGVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkcmF3aW5nTWFuYWdlciwgJ292ZXJsYXljb21wbGV0ZScsIG9uT3ZlcmxheUNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUG9seWdvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZXRQb2x5Z29uQ29tcGxldGVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkcmF3aW5nTWFuYWdlciwgJ3BvbHlnb25jb21wbGV0ZScsIG9uUG9seWdvbkNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUG9seWxpbmVDb21wbGV0ZSkge1xuICAgICAgICAgICAgc2V0UG9seWxpbmVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAncG9seWxpbmVjb21wbGV0ZScsIG9uUG9seWxpbmVDb21wbGV0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblJlY3RhbmdsZUNvbXBsZXRlKSB7XG4gICAgICAgICAgICBzZXRSZWN0YW5nbGVDb21wbGV0ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRyYXdpbmdNYW5hZ2VyLCAncmVjdGFuZ2xlY29tcGxldGUnLCBvblJlY3RhbmdsZUNvbXBsZXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW5zdGFuY2UoZHJhd2luZ01hbmFnZXIpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQoZHJhd2luZ01hbmFnZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2lyY2xlY29tcGxldGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjaXJjbGVjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlcmNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobWFya2VyY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5Y29tcGxldGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihvdmVybGF5Y29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb2x5Z29uY29tcGxldGVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb2x5Z29uY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb2x5bGluZWNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocG9seWxpbmVjb21wbGV0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RhbmdsZWNvbXBsZXRlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmVjdGFuZ2xlY29tcGxldGVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Vbm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbnZhciBEcmF3aW5nTWFuYWdlckYgPSBtZW1vKERyYXdpbmdNYW5hZ2VyRnVuY3Rpb25hbCk7XG52YXIgRHJhd2luZ01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYXdpbmdNYW5hZ2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERyYXdpbmdNYW5hZ2VyKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZHJhd2luZ01hbmFnZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldERyYXdpbmdNYW5hZ2VyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuZHJhd2luZ01hbmFnZXIgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaW52YXJpYW50JDEoISFnb29nbGUubWFwcy5kcmF3aW5nLCBcIkRpZCB5b3UgaW5jbHVkZSBwcm9wIGxpYnJhcmllcz17WydkcmF3aW5nJ119IGluIHRoZSBVUkw/ICVzXCIsIGdvb2dsZS5tYXBzLmRyYXdpbmcpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERyYXdpbmdNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRyYXdpbmdNYW5hZ2VyID0gbmV3IGdvb2dsZS5tYXBzLmRyYXdpbmcuRHJhd2luZ01hbmFnZXIoX19hc3NpZ24oX19hc3NpZ24oe30sICh0aGlzLnByb3BzLm9wdGlvbnMgfHwge30pKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRnLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGcsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGRyYXdpbmdNYW5hZ2VyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXREcmF3aW5nTWFuYWdlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHJhd2luZ01hbmFnZXI6IGRyYXdpbmdNYW5hZ2VyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXREcmF3aW5nTWFuYWdlckNhbGxiYWNrKTtcbiAgICB9O1xuICAgIERyYXdpbmdNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGcsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGcsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmRyYXdpbmdNYW5hZ2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYXdpbmdNYW5hZ2VyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZHJhd2luZ01hbmFnZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZHJhd2luZ01hbmFnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5kcmF3aW5nTWFuYWdlci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERyYXdpbmdNYW5hZ2VyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRHJhd2luZ01hbmFnZXIuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBEcmF3aW5nTWFuYWdlcjtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgZXZlbnRNYXAkZiA9IHtcbiAgICBvbkFuaW1hdGlvbkNoYW5nZWQ6ICdhbmltYXRpb25fY2hhbmdlZCcsXG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkNsaWNrYWJsZUNoYW5nZWQ6ICdjbGlja2FibGVfY2hhbmdlZCcsXG4gICAgb25DdXJzb3JDaGFuZ2VkOiAnY3Vyc29yX2NoYW5nZWQnLFxuICAgIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gICAgb25EcmFnOiAnZHJhZycsXG4gICAgb25EcmFnRW5kOiAnZHJhZ2VuZCcsXG4gICAgb25EcmFnZ2FibGVDaGFuZ2VkOiAnZHJhZ2dhYmxlX2NoYW5nZWQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbkZsYXRDaGFuZ2VkOiAnZmxhdF9jaGFuZ2VkJyxcbiAgICBvbkljb25DaGFuZ2VkOiAnaWNvbl9jaGFuZ2VkJyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gICAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gICAgb25Qb3NpdGlvbkNoYW5nZWQ6ICdwb3NpdGlvbl9jaGFuZ2VkJyxcbiAgICBvblJpZ2h0Q2xpY2s6ICdyaWdodGNsaWNrJyxcbiAgICBvblNoYXBlQ2hhbmdlZDogJ3NoYXBlX2NoYW5nZWQnLFxuICAgIG9uVGl0bGVDaGFuZ2VkOiAndGl0bGVfY2hhbmdlZCcsXG4gICAgb25WaXNpYmxlQ2hhbmdlZDogJ3Zpc2libGVfY2hhbmdlZCcsXG4gICAgb25aaW5kZXhDaGFuZ2VkOiAnemluZGV4X2NoYW5nZWQnLFxufTtcbnZhciB1cGRhdGVyTWFwJGYgPSB7XG4gICAgYW5pbWF0aW9uOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGFuaW1hdGlvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRBbmltYXRpb24oYW5pbWF0aW9uKTtcbiAgICB9LFxuICAgIGNsaWNrYWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBjbGlja2FibGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q2xpY2thYmxlKGNsaWNrYWJsZSk7XG4gICAgfSxcbiAgICBjdXJzb3I6IGZ1bmN0aW9uIChpbnN0YW5jZSwgY3Vyc29yKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEN1cnNvcihjdXJzb3IpO1xuICAgIH0sXG4gICAgZHJhZ2dhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9LFxuICAgIGljb246IGZ1bmN0aW9uIChpbnN0YW5jZSwgaWNvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRJY29uKGljb24pO1xuICAgIH0sXG4gICAgbGFiZWw6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbGFiZWwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TGFiZWwobGFiZWwpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG1hcCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9LFxuICAgIG9wYWNpdHk6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3BhY2l0eSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcGFjaXR5KG9wYWNpdHkpO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBwb3NpdGlvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgfSxcbiAgICBzaGFwZTogZnVuY3Rpb24gKGluc3RhbmNlLCBzaGFwZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRTaGFwZShzaGFwZSk7XG4gICAgfSxcbiAgICB0aXRsZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0aXRsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRUaXRsZSh0aXRsZSk7XG4gICAgfSxcbiAgICB2aXNpYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHZpc2libGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICB9LFxuICAgIHpJbmRleDogZnVuY3Rpb24gKGluc3RhbmNlLCB6SW5kZXgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMkNSA9IHt9O1xuZnVuY3Rpb24gTWFya2VyRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uLCBvcHRpb25zID0gX2Eub3B0aW9ucywgY2x1c3RlcmVyID0gX2EuY2x1c3RlcmVyLCBub0NsdXN0ZXJlclJlZHJhdyA9IF9hLm5vQ2x1c3RlcmVyUmVkcmF3LCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBkcmFnZ2FibGUgPSBfYS5kcmFnZ2FibGUsIHZpc2libGUgPSBfYS52aXNpYmxlLCBhbmltYXRpb24gPSBfYS5hbmltYXRpb24sIGNsaWNrYWJsZSA9IF9hLmNsaWNrYWJsZSwgY3Vyc29yID0gX2EuY3Vyc29yLCBpY29uID0gX2EuaWNvbiwgbGFiZWwgPSBfYS5sYWJlbCwgb3BhY2l0eSA9IF9hLm9wYWNpdHksIHNoYXBlID0gX2Euc2hhcGUsIHRpdGxlID0gX2EudGl0bGUsIHpJbmRleCA9IF9hLnpJbmRleCwgb25DbGljayA9IF9hLm9uQ2xpY2ssIG9uRGJsQ2xpY2sgPSBfYS5vbkRibENsaWNrLCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uRHJhZ0VuZCA9IF9hLm9uRHJhZ0VuZCwgb25EcmFnU3RhcnQgPSBfYS5vbkRyYWdTdGFydCwgb25Nb3VzZU91dCA9IF9hLm9uTW91c2VPdXQsIG9uTW91c2VPdmVyID0gX2Eub25Nb3VzZU92ZXIsIG9uTW91c2VVcCA9IF9hLm9uTW91c2VVcCwgb25Nb3VzZURvd24gPSBfYS5vbk1vdXNlRG93biwgb25SaWdodENsaWNrID0gX2Eub25SaWdodENsaWNrLCBvbkNsaWNrYWJsZUNoYW5nZWQgPSBfYS5vbkNsaWNrYWJsZUNoYW5nZWQsIG9uQ3Vyc29yQ2hhbmdlZCA9IF9hLm9uQ3Vyc29yQ2hhbmdlZCwgb25BbmltYXRpb25DaGFuZ2VkID0gX2Eub25BbmltYXRpb25DaGFuZ2VkLCBvbkRyYWdnYWJsZUNoYW5nZWQgPSBfYS5vbkRyYWdnYWJsZUNoYW5nZWQsIG9uRmxhdENoYW5nZWQgPSBfYS5vbkZsYXRDaGFuZ2VkLCBvbkljb25DaGFuZ2VkID0gX2Eub25JY29uQ2hhbmdlZCwgb25Qb3NpdGlvbkNoYW5nZWQgPSBfYS5vblBvc2l0aW9uQ2hhbmdlZCwgb25TaGFwZUNoYW5nZWQgPSBfYS5vblNoYXBlQ2hhbmdlZCwgb25UaXRsZUNoYW5nZWQgPSBfYS5vblRpdGxlQ2hhbmdlZCwgb25WaXNpYmxlQ2hhbmdlZCA9IF9hLm9uVmlzaWJsZUNoYW5nZWQsIG9uWmluZGV4Q2hhbmdlZCA9IF9hLm9uWmluZGV4Q2hhbmdlZCwgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gdXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gdXNlU3RhdGUobnVsbCksIGRibGNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0RGJsY2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHVzZVN0YXRlKG51bGwpLCBkcmFnZW5kTGlzdGVuZXIgPSBfZFswXSwgc2V0RHJhZ2VuZExpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gdXNlU3RhdGUobnVsbCksIGRyYWdzdGFydExpc3RlbmVyID0gX2VbMF0sIHNldERyYWdzdGFydExpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gdXNlU3RhdGUobnVsbCksIG1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMV07XG4gICAgdmFyIF9nID0gdXNlU3RhdGUobnVsbCksIG1vdXNlb3V0TGlzdGVuZXIgPSBfZ1swXSwgc2V0TW91c2VvdXRMaXN0ZW5lciA9IF9nWzFdO1xuICAgIHZhciBfaCA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZW92ZXJMaXN0ZW5lciA9IF9oWzBdLCBzZXRNb3VzZW92ZXJMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZXVwTGlzdGVuZXIgPSBfalswXSwgc2V0TW91c2V1cExpc3RlbmVyID0gX2pbMV07XG4gICAgdmFyIF9rID0gdXNlU3RhdGUobnVsbCksIHJpZ2h0Y2xpY2tMaXN0ZW5lciA9IF9rWzBdLCBzZXRSaWdodGNsaWNrTGlzdGVuZXIgPSBfa1sxXTtcbiAgICB2YXIgX2wgPSB1c2VTdGF0ZShudWxsKSwgY2xpY2tMaXN0ZW5lciA9IF9sWzBdLCBzZXRDbGlja0xpc3RlbmVyID0gX2xbMV07XG4gICAgdmFyIF9tID0gdXNlU3RhdGUobnVsbCksIGRyYWdMaXN0ZW5lciA9IF9tWzBdLCBzZXREcmFnTGlzdGVuZXIgPSBfbVsxXTtcbiAgICB2YXIgX28gPSB1c2VTdGF0ZShudWxsKSwgY2xpY2thYmxlQ2hhbmdlZExpc3RlbmVyID0gX29bMF0sIHNldENsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lciA9IF9vWzFdO1xuICAgIHZhciBfcCA9IHVzZVN0YXRlKG51bGwpLCBjdXJzb3JDaGFuZ2VkTGlzdGVuZXIgPSBfcFswXSwgc2V0Q3Vyc29yQ2hhbmdlZExpc3RlbmVyID0gX3BbMV07XG4gICAgdmFyIF9xID0gdXNlU3RhdGUobnVsbCksIGFuaW1hdGlvbkNoYW5nZWRMaXN0ZW5lciA9IF9xWzBdLCBzZXRBbmltYXRpb25DaGFuZ2VkTGlzdGVuZXIgPSBfcVsxXTtcbiAgICB2YXIgX3IgPSB1c2VTdGF0ZShudWxsKSwgZHJhZ2dhYmxlQ2hhbmdlZExpc3RlbmVyID0gX3JbMF0sIHNldERyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lciA9IF9yWzFdO1xuICAgIHZhciBfcyA9IHVzZVN0YXRlKG51bGwpLCBmbGF0Q2hhbmdlZExpc3RlbmVyID0gX3NbMF0sIHNldEZsYXRDaGFuZ2VkTGlzdGVuZXIgPSBfc1sxXTtcbiAgICB2YXIgX3QgPSB1c2VTdGF0ZShudWxsKSwgaWNvbkNoYW5nZWRMaXN0ZW5lciA9IF90WzBdLCBzZXRJY29uQ2hhbmdlZExpc3RlbmVyID0gX3RbMV07XG4gICAgdmFyIF91ID0gdXNlU3RhdGUobnVsbCksIHBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyID0gX3VbMF0sIHNldFBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyID0gX3VbMV07XG4gICAgdmFyIF92ID0gdXNlU3RhdGUobnVsbCksIHNoYXBlQ2hhbmdlZExpc3RlbmVyID0gX3ZbMF0sIHNldFNoYXBlQ2hhbmdlZExpc3RlbmVyID0gX3ZbMV07XG4gICAgdmFyIF93ID0gdXNlU3RhdGUobnVsbCksIHRpdGxlQ2hhbmdlZExpc3RlbmVyID0gX3dbMF0sIHNldFRpdGxlQ2hhbmdlZExpc3RlbmVyID0gX3dbMV07XG4gICAgdmFyIF94ID0gdXNlU3RhdGUobnVsbCksIHZpc2libGVDaGFuZ2VkTGlzdGVuZXIgPSBfeFswXSwgc2V0VmlzaWJsZUNoYW5nZWRMaXN0ZW5lciA9IF94WzFdO1xuICAgIHZhciBfeSA9IHVzZVN0YXRlKG51bGwpLCB6SW5kZXhDaGFuZ2VkTGlzdGVuZXIgPSBfeVswXSwgc2V0WmluZGV4Q2hhbmdlZExpc3RlbmVyID0gX3lbMV07XG4gICAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgICAgICB9XG4gICAgfSwgW21hcF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBkcmFnZ2FibGVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocG9zaXRpb24gJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgcG9zaXRpb25dKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCB2aXNpYmxlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2UgPT09IG51bGwgfHwgaW5zdGFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbmNlLnNldEFuaW1hdGlvbihhbmltYXRpb24pO1xuICAgIH0sIFtpbnN0YW5jZSwgYW5pbWF0aW9uXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIGNsaWNrYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRDbGlja2FibGUoY2xpY2thYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgY2xpY2thYmxlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIGN1cnNvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgY3Vyc29yXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIGljb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0SWNvbihpY29uKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgaWNvbl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBsYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRMYWJlbChsYWJlbCk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGxhYmVsXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3BhY2l0eV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBzaGFwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRTaGFwZShzaGFwZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIHNoYXBlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIHRpdGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFRpdGxlKHRpdGxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgdGl0bGVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgekluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFpJbmRleCh6SW5kZXgpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCB6SW5kZXhdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EYmxDbGljaykge1xuICAgICAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRibENsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZ0VuZCkge1xuICAgICAgICAgICAgaWYgKGRyYWdlbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdlbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnZW5kJywgb25EcmFnRW5kKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnRW5kXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoZHJhZ3N0YXJ0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnc3RhcnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnU3RhcnRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlRG93bl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3V0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VPdXRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU92ZXIpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlVXApIHtcbiAgICAgICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VVcF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UmlnaHRjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncmlnaHRjbGljaycsIG9uUmlnaHRDbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uUmlnaHRDbGlja10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkNsaWNrKSB7XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2tdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWddKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGlja2FibGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoY2xpY2thYmxlQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2thYmxlQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NsaWNrYWJsZV9jaGFuZ2VkJywgb25DbGlja2FibGVDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbGlja2FibGVDaGFuZ2VkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ3Vyc29yQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKGN1cnNvckNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGN1cnNvckNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDdXJzb3JDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjdXJzb3JfY2hhbmdlZCcsIG9uQ3Vyc29yQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ3Vyc29yQ2hhbmdlZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkFuaW1hdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25DaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihhbmltYXRpb25DaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0QW5pbWF0aW9uQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnYW5pbWF0aW9uX2NoYW5nZWQnLCBvbkFuaW1hdGlvbkNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkFuaW1hdGlvbkNoYW5nZWRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnZ2FibGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ2dhYmxlQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2dhYmxlQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdnYWJsZV9jaGFuZ2VkJywgb25EcmFnZ2FibGVDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnZ2FibGVDaGFuZ2VkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRmxhdENoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmIChmbGF0Q2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZmxhdENoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRGbGF0Q2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZmxhdF9jaGFuZ2VkJywgb25GbGF0Q2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uRmxhdENoYW5nZWRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25JY29uQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKGljb25DaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihpY29uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEljb25DaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdpY29uX2NoYW5nZWQnLCBvbkljb25DaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25JY29uQ2hhbmdlZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocG9zaXRpb25DaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UG9zaXRpb25DaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdwb3NpdGlvbl9jaGFuZ2VkJywgb25Qb3NpdGlvbkNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblBvc2l0aW9uQ2hhbmdlZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblNoYXBlQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHNoYXBlQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoc2hhcGVDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0U2hhcGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdzaGFwZV9jaGFuZ2VkJywgb25TaGFwZUNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblNoYXBlQ2hhbmdlZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblRpdGxlQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHRpdGxlQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGl0bGVDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGl0bGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICd0aXRsZV9jaGFuZ2VkJywgb25UaXRsZUNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblRpdGxlQ2hhbmdlZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblZpc2libGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAodmlzaWJsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHZpc2libGVDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VmlzaWJsZUNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3Zpc2libGVfY2hhbmdlZCcsIG9uVmlzaWJsZUNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblZpc2libGVDaGFuZ2VkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uWmluZGV4Q2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHpJbmRleENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHpJbmRleENoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRaaW5kZXhDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICd6aW5kZXhfY2hhbmdlZCcsIG9uWmluZGV4Q2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uWmluZGV4Q2hhbmdlZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXJrZXJPcHRpb25zID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zJDUpKSwgKGNsdXN0ZXJlciA/IGRlZmF1bHRPcHRpb25zJDUgOiB7IG1hcDogbWFwIH0pKSwgeyBwb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gICAgICAgIHZhciBtYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKG1hcmtlck9wdGlvbnMpO1xuICAgICAgICBpZiAoY2x1c3RlcmVyKSB7XG4gICAgICAgICAgICBjbHVzdGVyZXIuYWRkTWFya2VyKG1hcmtlciwgISFub0NsdXN0ZXJlclJlZHJhdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmlzaWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG1hcmtlci5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWFya2VyLnNldERyYWdnYWJsZShkcmFnZ2FibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2xpY2thYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWFya2VyLnNldENsaWNrYWJsZShjbGlja2FibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3Vyc29yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbWFya2VyLnNldEN1cnNvcihjdXJzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpY29uKSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0SWNvbihpY29uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGxhYmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbWFya2VyLnNldExhYmVsKGxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0T3BhY2l0eShvcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgIG1hcmtlci5zZXRTaGFwZShzaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aXRsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIG1hcmtlci5zZXRUaXRsZSh0aXRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB6SW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZ0VuZCkge1xuICAgICAgICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VEb3duKSB7XG4gICAgICAgICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZykge1xuICAgICAgICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DbGlja2FibGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRDbGlja2FibGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnY2xpY2thYmxlX2NoYW5nZWQnLCBvbkNsaWNrYWJsZUNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DdXJzb3JDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRDdXJzb3JDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnY3Vyc29yX2NoYW5nZWQnLCBvbkN1cnNvckNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25BbmltYXRpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRBbmltYXRpb25DaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnYW5pbWF0aW9uX2NoYW5nZWQnLCBvbkFuaW1hdGlvbkNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnZ2FibGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXREcmFnZ2FibGVDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnZHJhZ2dhYmxlX2NoYW5nZWQnLCBvbkRyYWdnYWJsZUNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25GbGF0Q2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0RmxhdENoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdmbGF0X2NoYW5nZWQnLCBvbkZsYXRDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uSWNvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldEljb25DaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnaWNvbl9jaGFuZ2VkJywgb25JY29uQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgc2V0UG9zaXRpb25DaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAncG9zaXRpb25fY2hhbmdlZCcsIG9uUG9zaXRpb25DaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uU2hhcGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRTaGFwZUNoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdzaGFwZV9jaGFuZ2VkJywgb25TaGFwZUNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25UaXRsZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFRpdGxlQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ3RpdGxlX2NoYW5nZWQnLCBvblRpdGxlQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblZpc2libGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRWaXNpYmxlQ2hhbmdlZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcmtlciwgJ3Zpc2libGVfY2hhbmdlZCcsIG9uVmlzaWJsZUNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25aaW5kZXhDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRaaW5kZXhDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnemluZGV4X2NoYW5nZWQnLCBvblppbmRleENoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnN0YW5jZShtYXJrZXIpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQobWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0Y2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrYWJsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3Vyc29yQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY3Vyc29yQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbmltYXRpb25DaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihhbmltYXRpb25DaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdnYWJsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhdENoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGZsYXRDaGFuZ2VkTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGljb25DaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihpY29uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NpdGlvbkNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvc2l0aW9uQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aXRsZUNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRpdGxlQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aXNpYmxlQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodmlzaWJsZUNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoekluZGV4Q2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoekluZGV4Q2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQobWFya2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbHVzdGVyZXIpIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyZXIucmVtb3ZlTWFya2VyKG1hcmtlciwgISFub0NsdXN0ZXJlclJlZHJhdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgY2h4ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlblxuICAgICAgICAgICAgPyBDaGlsZHJlbi5tYXAoY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRDaGlsZCA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZUVsZW1lbnQoZWxlbWVudENoaWxkLCB7IGFuY2hvcjogaW5zdGFuY2UgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH0sIFtjaGlsZHJlbiwgaW5zdGFuY2VdKTtcbiAgICByZXR1cm4ganN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiBjaHggfSkgfHwgbnVsbDtcbn1cbnZhciBNYXJrZXJGID0gbWVtbyhNYXJrZXJGdW5jdGlvbmFsKTtcbnZhciBNYXJrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcmtlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXJrZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWFya2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hcmtlck9wdGlvbnMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucyQ1KSksICh0aGlzLnByb3BzLmNsdXN0ZXJlciA/IGRlZmF1bHRPcHRpb25zJDUgOiB7IG1hcDogdGhpcy5jb250ZXh0IH0pKSwgeyBwb3NpdGlvbjogdGhpcy5wcm9wcy5wb3NpdGlvbiB9KTtcbiAgICAgICAgLy8gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndCBqdXN0IGRvIHRoaXMgaW4gdGhlIGNvbnRzdHJ1Y3RvciwgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gYE1hcENvbnRleHRgIG1pZ2h0IG5vdCBiZSBmaWxsZWQgaW4geWV0LlxuICAgICAgICB0aGlzLm1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIobWFya2VyT3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLmNsdXN0ZXJlcikge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5jbHVzdGVyZXIuYWRkTWFya2VyKHRoaXMubWFya2VyLCAhIXRoaXMucHJvcHMubm9DbHVzdGVyZXJSZWRyYXcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXJrZXIuc2V0TWFwKHRoaXMuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGYsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkZixcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5tYXJrZXIsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkKHRoaXMubWFya2VyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtlcikge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRmLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRmLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogdGhpcy5tYXJrZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWFya2VyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2VyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLm1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5jbHVzdGVyZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLmNsdXN0ZXJlci5yZW1vdmVNYXJrZXIodGhpcy5tYXJrZXIsICEhdGhpcy5wcm9wcy5ub0NsdXN0ZXJlclJlZHJhdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtlciAmJiB0aGlzLm1hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hcmtlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBDaGlsZHJlbi5tYXAodGhpcy5wcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChlbGVtZW50Q2hpbGQsIHsgYW5jaG9yOiBfdGhpcy5tYXJrZXIgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW4gfHwgbnVsbDtcbiAgICB9O1xuICAgIE1hcmtlci5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIE1hcmtlcjtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgQ2x1c3Rlckljb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2x1c3Rlckljb24oY2x1c3Rlciwgc3R5bGVzKSB7XG4gICAgICAgIGNsdXN0ZXIuZ2V0Q2x1c3RlcmVyKCkuZXh0ZW5kKENsdXN0ZXJJY29uLCBnb29nbGUubWFwcy5PdmVybGF5Vmlldyk7XG4gICAgICAgIHRoaXMuY2x1c3RlciA9IGNsdXN0ZXI7XG4gICAgICAgIHRoaXMuY2x1c3RlckNsYXNzTmFtZSA9IHRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKS5nZXRDbHVzdGVyQ2xhc3MoKTtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsdXN0ZXJDbGFzc05hbWU7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB0aGlzLmNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kaXYgPSBudWxsO1xuICAgICAgICB0aGlzLnN1bXMgPSBudWxsO1xuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ib3VuZHNDaGFuZ2VkTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnVybCA9ICcnO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmFuY2hvclRleHQgPSBbMCwgMF07XG4gICAgICAgIHRoaXMuYW5jaG9ySWNvbiA9IFswLCAwXTtcbiAgICAgICAgdGhpcy50ZXh0Q29sb3IgPSAnYmxhY2snO1xuICAgICAgICB0aGlzLnRleHRTaXplID0gMTE7XG4gICAgICAgIHRoaXMudGV4dERlY29yYXRpb24gPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgdGhpcy5mb250U3R5bGUgPSAnbm9ybWFsJztcbiAgICAgICAgdGhpcy5mb250RmFtaWx5ID0gJ0FyaWFsLHNhbnMtc2VyaWYnO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRQb3NpdGlvbiA9ICcwIDAnO1xuICAgICAgICB0aGlzLmNNb3VzZURvd25JbkNsdXN0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNEcmFnZ2luZ01hcEJ5Q2x1c3RlciA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZU91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2V0TWFwKGNsdXN0ZXIuZ2V0TWFwKCkpOyAvLyBOb3RlOiB0aGlzIGNhdXNlcyBvbkFkZCB0byBiZSBjYWxsZWRcbiAgICAgICAgdGhpcy5vbkJvdW5kc0NoYW5nZWQgPSB0aGlzLm9uQm91bmRzQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uTW91c2VEb3duID0gdGhpcy5vbk1vdXNlRG93bi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlT3ZlciA9IHRoaXMub25Nb3VzZU92ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbk1vdXNlT3V0ID0gdGhpcy5vbk1vdXNlT3V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25BZGQgPSB0aGlzLm9uQWRkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZW1vdmUgPSB0aGlzLm9uUmVtb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZHJhdyA9IHRoaXMuZHJhdy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhpZGUgPSB0aGlzLmhpZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zaG93ID0gdGhpcy5zaG93LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudXNlU3R5bGUgPSB0aGlzLnVzZVN0eWxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Q2VudGVyID0gdGhpcy5zZXRDZW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRQb3NGcm9tTGF0TG5nID0gdGhpcy5nZXRQb3NGcm9tTGF0TG5nLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIENsdXN0ZXJJY29uLnByb3RvdHlwZS5vbkJvdW5kc0NoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY0RyYWdnaW5nTWFwQnlDbHVzdGVyID0gdGhpcy5jTW91c2VEb3duSW5DbHVzdGVyO1xuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uTW91c2VEb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNNb3VzZURvd25JbkNsdXN0ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLmNEcmFnZ2luZ01hcEJ5Q2x1c3RlciA9IGZhbHNlO1xuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5jTW91c2VEb3duSW5DbHVzdGVyID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5jRHJhZ2dpbmdNYXBCeUNsdXN0ZXIpIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXJDbHVzdGVyZXJfMSA9IHRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIGEgY2x1c3RlciBtYXJrZXIgaXMgY2xpY2tlZC5cbiAgICAgICAgICAgICAqIEBuYW1lIE1hcmtlckNsdXN0ZXJlciNjbGlja1xuICAgICAgICAgICAgICogQHBhcmFtIHtDbHVzdGVyfSBjIFRoZSBjbHVzdGVyIHRoYXQgd2FzIGNsaWNrZWQuXG4gICAgICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYXJrZXJDbHVzdGVyZXJfMSwgJ2NsaWNrJywgdGhpcy5jbHVzdGVyKTtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIobWFya2VyQ2x1c3RlcmVyXzEsICdjbHVzdGVyY2xpY2snLCB0aGlzLmNsdXN0ZXIpOyAvLyBkZXByZWNhdGVkIG5hbWVcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGNsaWNrIGhhbmRsZXIgZm9sbG93cy4gRGlzYWJsZSBpdCBieSBzZXR0aW5nXG4gICAgICAgICAgICAvLyB0aGUgem9vbU9uQ2xpY2sgcHJvcGVydHkgdG8gZmFsc2UuXG4gICAgICAgICAgICBpZiAobWFya2VyQ2x1c3RlcmVyXzEuZ2V0Wm9vbU9uQ2xpY2soKSkge1xuICAgICAgICAgICAgICAgIC8vIFpvb20gaW50byB0aGUgY2x1c3Rlci5cbiAgICAgICAgICAgICAgICB2YXIgbWF4Wm9vbV8xID0gbWFya2VyQ2x1c3RlcmVyXzEuZ2V0TWF4Wm9vbSgpO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZHNfMSA9IHRoaXMuY2x1c3Rlci5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gbWFya2VyQ2x1c3RlcmVyXzEuZ2V0TWFwKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcCAhPT0gbnVsbCAmJiAnZml0Qm91bmRzJyBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLmZpdEJvdW5kcyhib3VuZHNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgZml4IGZvciBJc3N1ZSAxNzAgaGVyZTpcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVPdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBtYXJrZXJDbHVzdGVyZXJfMS5nZXRNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdmaXRCb3VuZHMnIGluIG1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5maXRCb3VuZHMoYm91bmRzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHpvb20gPSBtYXAuZ2V0Wm9vbSgpIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCB6b29tIGJleW9uZCB0aGUgbWF4IHpvb20gbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhab29tXzEgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b29tID4gbWF4Wm9vbV8xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLnNldFpvb20obWF4Wm9vbV8xICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJldmVudCBldmVudCBwcm9wYWdhdGlvbiB0byB0aGUgbWFwOlxuICAgICAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uTW91c2VPdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBvdmVyIGEgY2x1c3RlciBtYXJrZXIuXG4gICAgICAgICAqIEBuYW1lIE1hcmtlckNsdXN0ZXJlciNtb3VzZW92ZXJcbiAgICAgICAgICogQHBhcmFtIHtDbHVzdGVyfSBjIFRoZSBjbHVzdGVyIHRoYXQgdGhlIG1vdXNlIG1vdmVkIG92ZXIuXG4gICAgICAgICAqIEBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLmNsdXN0ZXIuZ2V0Q2x1c3RlcmVyKCksICdtb3VzZW92ZXInLCB0aGlzLmNsdXN0ZXIpO1xuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uTW91c2VPdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIG1vdXNlIG1vdmVzIG91dCBvZiBhIGNsdXN0ZXIgbWFya2VyLlxuICAgICAgICAgKiBAbmFtZSBNYXJrZXJDbHVzdGVyZXIjbW91c2VvdXRcbiAgICAgICAgICogQHBhcmFtIHtDbHVzdGVyfSBjIFRoZSBjbHVzdGVyIHRoYXQgdGhlIG1vdXNlIG1vdmVkIG91dCBvZi5cbiAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKSwgJ21vdXNlb3V0JywgdGhpcy5jbHVzdGVyKTtcbiAgICB9O1xuICAgIENsdXN0ZXJJY29uLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmRpdi5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5nZXRQYW5lcygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3ZlcmxheU1vdXNlVGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuZGl2KTtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICAgIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZpeCBmb3IgSXNzdWUgMTU3XG4gICAgICAgICAgICB0aGlzLmJvdW5kc0NoYW5nZWRMaXN0ZW5lciA9IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2JvdW5kc19jaGFuZ2VkJywgdGhpcy5vbkJvdW5kc0NoYW5nZWQpO1xuICAgICAgICAgICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2VPdmVyKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5vbk1vdXNlT3V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXYgJiYgdGhpcy5kaXYucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ib3VuZHNDaGFuZ2VkTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmJvdW5kc0NoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Nb3VzZU92ZXIpO1xuICAgICAgICAgICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm9uTW91c2VPdXQpO1xuICAgICAgICAgICAgdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lT3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnRpbWVPdXQpO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZU91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJJY29uLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy52aXNpYmxlICYmIHRoaXMuZGl2ICE9PSBudWxsICYmIHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3NGcm9tTGF0TG5nKHRoaXMuY2VudGVyKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9IHBvcyAhPT0gbnVsbCA/IFwiXCIuY29uY2F0KHBvcy55LCBcInB4XCIpIDogJzAnO1xuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUubGVmdCA9IHBvcyAhPT0gbnVsbCA/IFwiXCIuY29uY2F0KHBvcy54LCBcInB4XCIpIDogJzAnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVySWNvbi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBpZiAodGhpcy5kaXYgJiYgdGhpcy5jZW50ZXIpIHtcbiAgICAgICAgICAgIHZhciBkaXZUaXRsZSA9IHRoaXMuc3VtcyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiB0aGlzLnN1bXMudGl0bGUgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdW1zLnRpdGxlID09PSAnJyA/IHRoaXMuY2x1c3Rlci5nZXRDbHVzdGVyZXIoKS5nZXRUaXRsZSgpIDogdGhpcy5zdW1zLnRpdGxlO1xuICAgICAgICAgICAgLy8gTk9URTogdmFsdWVzIG11c3QgYmUgc3BlY2lmaWVkIGluIHB4IHVuaXRzXG4gICAgICAgICAgICB2YXIgYnAgPSB0aGlzLmJhY2tncm91bmRQb3NpdGlvbi5zcGxpdCgnICcpO1xuICAgICAgICAgICAgdmFyIHNwcml0ZUggPSBwYXJzZUludCgoKF9hID0gYnBbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykpIHx8ICcwJywgMTApO1xuICAgICAgICAgICAgdmFyIHNwcml0ZVYgPSBwYXJzZUludCgoKF9iID0gYnBbMV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJykpIHx8ICcwJywgMTApO1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0UG9zRnJvbUxhdExuZyh0aGlzLmNlbnRlcik7XG4gICAgICAgICAgICB0aGlzLmRpdi5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBcImN1cnNvcjogcG9pbnRlcjsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IFwiLmNvbmNhdChwb3MgIT09IG51bGwgPyBcIlwiLmNvbmNhdChwb3MueSwgXCJweFwiKSA6ICcwJywgXCI7IGxlZnQ6IFwiKS5jb25jYXQocG9zICE9PSBudWxsID8gXCJcIi5jb25jYXQocG9zLngsIFwicHhcIikgOiAnMCcsIFwiOyB3aWR0aDogXCIpLmNvbmNhdCh0aGlzLndpZHRoLCBcInB4OyBoZWlnaHQ6IFwiKS5jb25jYXQodGhpcy5oZWlnaHQsIFwicHg7IFwiKSk7XG4gICAgICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICBpbWcuYWx0ID0gZGl2VGl0bGU7XG4gICAgICAgICAgICBpbWcuc3JjID0gdGhpcy51cmw7XG4gICAgICAgICAgICBpbWcud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICAgICAgaW1nLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiBcIi5jb25jYXQoc3ByaXRlViwgXCJweDsgbGVmdDogXCIpLmNvbmNhdChzcHJpdGVILCBcInB4XCIpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbHVzdGVyLmdldENsdXN0ZXJlcigpLmVuYWJsZVJldGluYUljb25zKSB7XG4gICAgICAgICAgICAgICAgaW1nLnN0eWxlLmNsaXAgPSBcInJlY3QoLVwiLmNvbmNhdChzcHJpdGVWLCBcInB4LCAtXCIpLmNvbmNhdChzcHJpdGVIICsgdGhpcy53aWR0aCwgXCJweCwgLVwiKS5jb25jYXQoc3ByaXRlViArIHRoaXMuaGVpZ2h0LCBcIiwgLVwiKS5jb25jYXQoc3ByaXRlSCwgXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRleHRFbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRleHRFbG0uc2V0QXR0cmlidXRlKCdzdHlsZScsIFwicG9zaXRpb246IGFic29sdXRlOyB0b3A6IFwiLmNvbmNhdCh0aGlzLmFuY2hvclRleHRbMF0sIFwicHg7IGxlZnQ6IFwiKS5jb25jYXQodGhpcy5hbmNob3JUZXh0WzFdLCBcInB4OyBjb2xvcjogXCIpLmNvbmNhdCh0aGlzLnRleHRDb2xvciwgXCI7IGZvbnQtc2l6ZTogXCIpLmNvbmNhdCh0aGlzLnRleHRTaXplLCBcInB4OyBmb250LWZhbWlseTogXCIpLmNvbmNhdCh0aGlzLmZvbnRGYW1pbHksIFwiOyBmb250LXdlaWdodDogXCIpLmNvbmNhdCh0aGlzLmZvbnRXZWlnaHQsIFwiOyBmb250U3R5bGU6IFwiKS5jb25jYXQodGhpcy5mb250U3R5bGUsIFwiOyB0ZXh0LWRlY29yYXRpb246IFwiKS5jb25jYXQodGhpcy50ZXh0RGVjb3JhdGlvbiwgXCI7IHRleHQtYWxpZ246IGNlbnRlcjsgd2lkdGg6IFwiKS5jb25jYXQodGhpcy53aWR0aCwgXCJweDsgbGluZS1oZWlnaHQ6IFwiKS5jb25jYXQodGhpcy5oZWlnaHQsIFwicHhcIikpO1xuICAgICAgICAgICAgaWYgKChfYyA9IHRoaXMuc3VtcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRleHQpXG4gICAgICAgICAgICAgICAgdGV4dEVsbS5pbm5lclRleHQgPSBcIlwiLmNvbmNhdCgoX2QgPSB0aGlzLnN1bXMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50ZXh0KTtcbiAgICAgICAgICAgIGlmICgoX2UgPSB0aGlzLnN1bXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5odG1sKVxuICAgICAgICAgICAgICAgIHRleHRFbG0uaW5uZXJIVE1MID0gXCJcIi5jb25jYXQoKF9mID0gdGhpcy5zdW1zKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuaHRtbCk7XG4gICAgICAgICAgICB0aGlzLmRpdi5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZCh0ZXh0RWxtKTtcbiAgICAgICAgICAgIHRoaXMuZGl2LnRpdGxlID0gZGl2VGl0bGU7XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB9O1xuICAgIENsdXN0ZXJJY29uLnByb3RvdHlwZS51c2VTdHlsZSA9IGZ1bmN0aW9uIChzdW1zKSB7XG4gICAgICAgIHRoaXMuc3VtcyA9IHN1bXM7XG4gICAgICAgIHZhciBzdHlsZXMgPSB0aGlzLmNsdXN0ZXIuZ2V0Q2x1c3RlcmVyKCkuZ2V0U3R5bGVzKCk7XG4gICAgICAgIHZhciBzdHlsZSA9IHN0eWxlc1tNYXRoLm1pbihzdHlsZXMubGVuZ3RoIC0gMSwgTWF0aC5tYXgoMCwgc3Vtcy5pbmRleCAtIDEpKV07XG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgICAgdGhpcy51cmwgPSBzdHlsZS51cmw7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgICAgICAgIGlmIChzdHlsZS5jbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFwiXCIuY29uY2F0KHRoaXMuY2x1c3RlckNsYXNzTmFtZSwgXCIgXCIpLmNvbmNhdChzdHlsZS5jbGFzc05hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbmNob3JUZXh0ID0gc3R5bGUuYW5jaG9yVGV4dCB8fCBbMCwgMF07XG4gICAgICAgICAgICB0aGlzLmFuY2hvckljb24gPSBzdHlsZS5hbmNob3JJY29uIHx8IFt0aGlzLmhlaWdodCAvIDIsIHRoaXMud2lkdGggLyAyXTtcbiAgICAgICAgICAgIHRoaXMudGV4dENvbG9yID0gc3R5bGUudGV4dENvbG9yIHx8ICdibGFjayc7XG4gICAgICAgICAgICB0aGlzLnRleHRTaXplID0gc3R5bGUudGV4dFNpemUgfHwgMTE7XG4gICAgICAgICAgICB0aGlzLnRleHREZWNvcmF0aW9uID0gc3R5bGUudGV4dERlY29yYXRpb24gfHwgJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5mb250V2VpZ2h0ID0gc3R5bGUuZm9udFdlaWdodCB8fCAnYm9sZCc7XG4gICAgICAgICAgICB0aGlzLmZvbnRTdHlsZSA9IHN0eWxlLmZvbnRTdHlsZSB8fCAnbm9ybWFsJztcbiAgICAgICAgICAgIHRoaXMuZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkgfHwgJ0FyaWFsLHNhbnMtc2VyaWYnO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kUG9zaXRpb24gPSBzdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gfHwgJzAgMCc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJJY29uLnByb3RvdHlwZS5zZXRDZW50ZXIgPSBmdW5jdGlvbiAoY2VudGVyKSB7XG4gICAgICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xuICAgIH07XG4gICAgQ2x1c3Rlckljb24ucHJvdG90eXBlLmdldFBvc0Zyb21MYXRMbmcgPSBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmdldFByb2plY3Rpb24oKS5mcm9tTGF0TG5nVG9EaXZQaXhlbChsYXRsbmcpO1xuICAgICAgICBpZiAocG9zICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MueCAtPSB0aGlzLmFuY2hvckljb25bMV07XG4gICAgICAgICAgICBwb3MueSAtPSB0aGlzLmFuY2hvckljb25bMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIHJldHVybiBDbHVzdGVySWNvbjtcbn0oKSk7XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cbnZhciBDbHVzdGVyJDEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2x1c3RlcihtYXJrZXJDbHVzdGVyZXIpIHtcbiAgICAgICAgdGhpcy5tYXJrZXJDbHVzdGVyZXIgPSBtYXJrZXJDbHVzdGVyZXI7XG4gICAgICAgIHRoaXMubWFwID0gdGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0TWFwKCk7XG4gICAgICAgIHRoaXMuZ3JpZFNpemUgPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRHcmlkU2l6ZSgpO1xuICAgICAgICB0aGlzLm1pbkNsdXN0ZXJTaXplID0gdGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0TWluaW11bUNsdXN0ZXJTaXplKCk7XG4gICAgICAgIHRoaXMuYXZlcmFnZUNlbnRlciA9IHRoaXMubWFya2VyQ2x1c3RlcmVyLmdldEF2ZXJhZ2VDZW50ZXIoKTtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIHRoaXMuY2VudGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMuY2x1c3Rlckljb24gPSBuZXcgQ2x1c3Rlckljb24odGhpcywgdGhpcy5tYXJrZXJDbHVzdGVyZXIuZ2V0U3R5bGVzKCkpO1xuICAgICAgICB0aGlzLmdldFNpemUgPSB0aGlzLmdldFNpemUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRNYXJrZXJzID0gdGhpcy5nZXRNYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Q2VudGVyID0gdGhpcy5nZXRDZW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRNYXAgPSB0aGlzLmdldE1hcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldENsdXN0ZXJlciA9IHRoaXMuZ2V0Q2x1c3RlcmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Qm91bmRzID0gdGhpcy5nZXRCb3VuZHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmUgPSB0aGlzLnJlbW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFkZE1hcmtlciA9IHRoaXMuYWRkTWFya2VyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNNYXJrZXJJbkNsdXN0ZXJCb3VuZHMgPSB0aGlzLmlzTWFya2VySW5DbHVzdGVyQm91bmRzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gdGhpcy5jYWxjdWxhdGVCb3VuZHMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVJY29uID0gdGhpcy51cGRhdGVJY29uLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNNYXJrZXJBbHJlYWR5QWRkZWQgPSB0aGlzLmlzTWFya2VyQWxyZWFkeUFkZGVkLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIENsdXN0ZXIucHJvdG90eXBlLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtlcnMubGVuZ3RoO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuZ2V0TWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2VycztcbiAgICB9O1xuICAgIENsdXN0ZXIucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VudGVyO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuZ2V0TWFwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXA7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5nZXRDbHVzdGVyZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtlckNsdXN0ZXJlcjtcbiAgICB9O1xuICAgIENsdXN0ZXIucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHModGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyKTtcbiAgICAgICAgdmFyIG1hcmtlcnMgPSB0aGlzLmdldE1hcmtlcnMoKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBtYXJrZXJzXzEgPSBtYXJrZXJzOyBfaSA8IG1hcmtlcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBib3VuZHMuZXh0ZW5kKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsdXN0ZXJJY29uLnNldE1hcChudWxsKTtcbiAgICAgICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkZWxldGUgdGhpcy5tYXJrZXJzO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuYWRkTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmlzTWFya2VyQWxyZWFkeUFkZGVkKG1hcmtlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF2ZXJhZ2VDZW50ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gdGhpcy5tYXJrZXJzLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2VudGVyID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZygodGhpcy5jZW50ZXIubGF0KCkgKiAobGVuZ3RoXzEgLSAxKSArIHBvc2l0aW9uLmxhdCgpKSAvIGxlbmd0aF8xLCAodGhpcy5jZW50ZXIubG5nKCkgKiAobGVuZ3RoXzEgLSAxKSArIHBvc2l0aW9uLmxuZygpKSAvIGxlbmd0aF8xKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyLmlzQWRkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xuICAgICAgICB2YXIgbUNvdW50ID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIG1heFpvb20gPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRNYXhab29tKCk7XG4gICAgICAgIHZhciB6b29tID0gKF9hID0gdGhpcy5tYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRab29tKCk7XG4gICAgICAgIGlmIChtYXhab29tICE9PSBudWxsICYmIHR5cGVvZiB6b29tICE9PSAndW5kZWZpbmVkJyAmJiB6b29tID4gbWF4Wm9vbSkge1xuICAgICAgICAgICAgLy8gWm9vbWVkIGluIHBhc3QgbWF4IHpvb20sIHNvIHNob3cgdGhlIG1hcmtlci5cbiAgICAgICAgICAgIGlmIChtYXJrZXIuZ2V0TWFwKCkgIT09IHRoaXMubWFwKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcCh0aGlzLm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobUNvdW50IDwgdGhpcy5taW5DbHVzdGVyU2l6ZSkge1xuICAgICAgICAgICAgLy8gTWluIGNsdXN0ZXIgc2l6ZSBub3QgcmVhY2hlZCBzbyBzaG93IHRoZSBtYXJrZXIuXG4gICAgICAgICAgICBpZiAobWFya2VyLmdldE1hcCgpICE9PSB0aGlzLm1hcCkge1xuICAgICAgICAgICAgICAgIG1hcmtlci5zZXRNYXAodGhpcy5tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1Db3VudCA9PT0gdGhpcy5taW5DbHVzdGVyU2l6ZSkge1xuICAgICAgICAgICAgLy8gSGlkZSB0aGUgbWFya2VycyB0aGF0IHdlcmUgc2hvd2luZy5cbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2IgPSB0aGlzLm1hcmtlcnM7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlckVsZW1lbnQgPSBfYltfaV07XG4gICAgICAgICAgICAgICAgbWFya2VyRWxlbWVudC5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUuaXNNYXJrZXJJbkNsdXN0ZXJCb3VuZHMgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmJvdW5kcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gbWFya2VyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHMuY29udGFpbnMocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIENsdXN0ZXIucHJvdG90eXBlLmNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ib3VuZHMgPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRFeHRlbmRlZEJvdW5kcyhuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlcikpO1xuICAgIH07XG4gICAgQ2x1c3Rlci5wcm90b3R5cGUudXBkYXRlSWNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgbUNvdW50ID0gdGhpcy5tYXJrZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIG1heFpvb20gPSB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRNYXhab29tKCk7XG4gICAgICAgIHZhciB6b29tID0gKF9hID0gdGhpcy5tYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRab29tKCk7XG4gICAgICAgIGlmIChtYXhab29tICE9PSBudWxsICYmIHR5cGVvZiB6b29tICE9PSAndW5kZWZpbmVkJyAmJiB6b29tID4gbWF4Wm9vbSkge1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVySWNvbi5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1Db3VudCA8IHRoaXMubWluQ2x1c3RlclNpemUpIHtcbiAgICAgICAgICAgIC8vIE1pbiBjbHVzdGVyIHNpemUgbm90IHlldCByZWFjaGVkLlxuICAgICAgICAgICAgdGhpcy5jbHVzdGVySWNvbi5oaWRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2VudGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNsdXN0ZXJJY29uLnNldENlbnRlcih0aGlzLmNlbnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbHVzdGVySWNvbi51c2VTdHlsZSh0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRDYWxjdWxhdG9yKCkodGhpcy5tYXJrZXJzLCB0aGlzLm1hcmtlckNsdXN0ZXJlci5nZXRTdHlsZXMoKS5sZW5ndGgpKTtcbiAgICAgICAgdGhpcy5jbHVzdGVySWNvbi5zaG93KCk7XG4gICAgfTtcbiAgICBDbHVzdGVyLnByb3RvdHlwZS5pc01hcmtlckFscmVhZHlBZGRlZCA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2Vycy5pbmNsdWRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFya2Vycy5pbmNsdWRlcyhtYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWFya2VyID09PSB0aGlzLm1hcmtlcnNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICByZXR1cm4gQ2x1c3Rlcjtcbn0oKSk7XG5cbi8qIGdsb2JhbCBnb29nbGUgKi9cbi8qKlxuICogU3VwcG9ydHMgdXAgdG8gOTAwNzE5OTI1NDc0MDk5MSAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIG1hcmtlcnNcbiAqIHdoaWNoIGlzIG5vdCBhIHByb2JsZW0gYXMgbWF4IGFycmF5IGxlbmd0aCBpcyA0Mjk0OTY3Mjk2ICgyKiozMilcbiAqL1xuZnVuY3Rpb24gQ0FMQ1VMQVRPUihtYXJrZXJzLCBudW1TdHlsZXMpIHtcbiAgICB2YXIgY291bnQgPSBtYXJrZXJzLmxlbmd0aDtcbiAgICB2YXIgbnVtYmVyT2ZEaWdpdHMgPSBjb3VudC50b1N0cmluZygpLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSBNYXRoLm1pbihudW1iZXJPZkRpZ2l0cywgbnVtU3R5bGVzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiBjb3VudC50b1N0cmluZygpLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHRpdGxlOiAnJyxcbiAgICB9O1xufVxudmFyIEJBVENIX1NJWkUgPSAyMDAwO1xudmFyIEJBVENIX1NJWkVfSUUgPSA1MDA7XG52YXIgSU1BR0VfUEFUSCA9ICdodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9leGFtcGxlcy9tYXJrZXJjbHVzdGVyZXIvbSc7XG52YXIgSU1BR0VfRVhURU5TSU9OID0gJ3BuZyc7XG52YXIgSU1BR0VfU0laRVMgPSBbNTMsIDU2LCA2NiwgNzgsIDkwXTtcbnZhciBDTFVTVEVSRVJfQ0xBU1MgPSAnY2x1c3Rlcic7XG52YXIgQ2x1c3RlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENsdXN0ZXJlcihtYXAsIG9wdE1hcmtlcnMsIG9wdE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdE1hcmtlcnMgPT09IHZvaWQgMCkgeyBvcHRNYXJrZXJzID0gW107IH1cbiAgICAgICAgaWYgKG9wdE9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRPcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5nZXRNaW5pbXVtQ2x1c3RlclNpemUgPSB0aGlzLmdldE1pbmltdW1DbHVzdGVyU2l6ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldE1pbmltdW1DbHVzdGVyU2l6ZSA9IHRoaXMuc2V0TWluaW11bUNsdXN0ZXJTaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0RW5hYmxlUmV0aW5hSWNvbnMgPSB0aGlzLmdldEVuYWJsZVJldGluYUljb25zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0RW5hYmxlUmV0aW5hSWNvbnMgPSB0aGlzLnNldEVuYWJsZVJldGluYUljb25zLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkVG9DbG9zZXN0Q2x1c3RlciA9IHRoaXMuYWRkVG9DbG9zZXN0Q2x1c3Rlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEltYWdlRXh0ZW5zaW9uID0gdGhpcy5nZXRJbWFnZUV4dGVuc2lvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEltYWdlRXh0ZW5zaW9uID0gdGhpcy5zZXRJbWFnZUV4dGVuc2lvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEV4dGVuZGVkQm91bmRzID0gdGhpcy5nZXRFeHRlbmRlZEJvdW5kcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEF2ZXJhZ2VDZW50ZXIgPSB0aGlzLmdldEF2ZXJhZ2VDZW50ZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRBdmVyYWdlQ2VudGVyID0gdGhpcy5zZXRBdmVyYWdlQ2VudGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0VG90YWxDbHVzdGVycyA9IHRoaXMuZ2V0VG90YWxDbHVzdGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmZpdE1hcFRvTWFya2VycyA9IHRoaXMuZml0TWFwVG9NYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0SWdub3JlSGlkZGVuID0gdGhpcy5nZXRJZ25vcmVIaWRkZW4uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRJZ25vcmVIaWRkZW4gPSB0aGlzLnNldElnbm9yZUhpZGRlbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldENsdXN0ZXJDbGFzcyA9IHRoaXMuZ2V0Q2x1c3RlckNsYXNzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0Q2x1c3RlckNsYXNzID0gdGhpcy5zZXRDbHVzdGVyQ2xhc3MuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRUb3RhbE1hcmtlcnMgPSB0aGlzLmdldFRvdGFsTWFya2Vycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFpvb21PbkNsaWNrID0gdGhpcy5nZXRab29tT25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFpvb21PbkNsaWNrID0gdGhpcy5zZXRab29tT25DbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldEJhdGNoU2l6ZUlFID0gdGhpcy5nZXRCYXRjaFNpemVJRS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEJhdGNoU2l6ZUlFID0gdGhpcy5zZXRCYXRjaFNpemVJRS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNsdXN0ZXJzID0gdGhpcy5jcmVhdGVDbHVzdGVycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uWm9vbUNoYW5nZWQgPSB0aGlzLm9uWm9vbUNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRJbWFnZVNpemVzID0gdGhpcy5nZXRJbWFnZVNpemVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0SW1hZ2VTaXplcyA9IHRoaXMuc2V0SW1hZ2VTaXplcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldENhbGN1bGF0b3IgPSB0aGlzLmdldENhbGN1bGF0b3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRDYWxjdWxhdG9yID0gdGhpcy5zZXRDYWxjdWxhdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlTWFya2VycyA9IHRoaXMucmVtb3ZlTWFya2Vycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlc2V0Vmlld3BvcnQgPSB0aGlzLnJlc2V0Vmlld3BvcnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRJbWFnZVBhdGggPSB0aGlzLmdldEltYWdlUGF0aC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEltYWdlUGF0aCA9IHRoaXMuc2V0SW1hZ2VQYXRoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHVzaE1hcmtlclRvID0gdGhpcy5wdXNoTWFya2VyVG8uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVNYXJrZXIgPSB0aGlzLnJlbW92ZU1hcmtlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNsZWFyTWFya2VycyA9IHRoaXMuY2xlYXJNYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0dXBTdHlsZXMgPSB0aGlzLnNldHVwU3R5bGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0R3JpZFNpemUgPSB0aGlzLmdldEdyaWRTaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0R3JpZFNpemUgPSB0aGlzLnNldEdyaWRTaXplLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0Q2x1c3RlcnMgPSB0aGlzLmdldENsdXN0ZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0TWF4Wm9vbSA9IHRoaXMuZ2V0TWF4Wm9vbS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldE1heFpvb20gPSB0aGlzLnNldE1heFpvb20uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRNYXJrZXJzID0gdGhpcy5nZXRNYXJrZXJzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkTWFya2VycyA9IHRoaXMuYWRkTWFya2Vycy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFN0eWxlcyA9IHRoaXMuZ2V0U3R5bGVzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0U3R5bGVzID0gdGhpcy5zZXRTdHlsZXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRNYXJrZXIgPSB0aGlzLmFkZE1hcmtlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVtb3ZlID0gdGhpcy5vblJlbW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFRpdGxlID0gdGhpcy5nZXRUaXRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRpdGxlID0gdGhpcy5zZXRUaXRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlcGFpbnQgPSB0aGlzLnJlcGFpbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbklkbGUgPSB0aGlzLm9uSWRsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZHJhdyA9IHRoaXMucmVkcmF3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25BZGQgPSB0aGlzLm9uQWRkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZHJhdyA9IHRoaXMuZHJhdy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmV4dGVuZCA9IHRoaXMuZXh0ZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZXh0ZW5kKENsdXN0ZXJlciwgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcpO1xuICAgICAgICB0aGlzLm1hcmtlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IFtdO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZU1hcCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ncmlkU2l6ZSA9IG9wdE9wdGlvbnMuZ3JpZFNpemUgfHwgNjA7XG4gICAgICAgIHRoaXMubWluQ2x1c3RlclNpemUgPSBvcHRPcHRpb25zLm1pbmltdW1DbHVzdGVyU2l6ZSB8fCAyO1xuICAgICAgICB0aGlzLm1heFpvb20gPSBvcHRPcHRpb25zLm1heFpvb20gfHwgbnVsbDtcbiAgICAgICAgdGhpcy5zdHlsZXMgPSBvcHRPcHRpb25zLnN0eWxlcyB8fCBbXTtcbiAgICAgICAgdGhpcy50aXRsZSA9IG9wdE9wdGlvbnMudGl0bGUgfHwgJyc7XG4gICAgICAgIHRoaXMuem9vbU9uQ2xpY2sgPSB0cnVlO1xuICAgICAgICBpZiAob3B0T3B0aW9ucy56b29tT25DbGljayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnpvb21PbkNsaWNrID0gb3B0T3B0aW9ucy56b29tT25DbGljaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF2ZXJhZ2VDZW50ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdE9wdGlvbnMuYXZlcmFnZUNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmF2ZXJhZ2VDZW50ZXIgPSBvcHRPcHRpb25zLmF2ZXJhZ2VDZW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZ25vcmVIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKG9wdE9wdGlvbnMuaWdub3JlSGlkZGVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlSGlkZGVuID0gb3B0T3B0aW9ucy5pZ25vcmVIaWRkZW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmFibGVSZXRpbmFJY29ucyA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0T3B0aW9ucy5lbmFibGVSZXRpbmFJY29ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZVJldGluYUljb25zID0gb3B0T3B0aW9ucy5lbmFibGVSZXRpbmFJY29ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmltYWdlUGF0aCA9IG9wdE9wdGlvbnMuaW1hZ2VQYXRoIHx8IElNQUdFX1BBVEg7XG4gICAgICAgIHRoaXMuaW1hZ2VFeHRlbnNpb24gPSBvcHRPcHRpb25zLmltYWdlRXh0ZW5zaW9uIHx8IElNQUdFX0VYVEVOU0lPTjtcbiAgICAgICAgdGhpcy5pbWFnZVNpemVzID0gb3B0T3B0aW9ucy5pbWFnZVNpemVzIHx8IElNQUdFX1NJWkVTO1xuICAgICAgICB0aGlzLmNhbGN1bGF0b3IgPSBvcHRPcHRpb25zLmNhbGN1bGF0b3IgfHwgQ0FMQ1VMQVRPUjtcbiAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBvcHRPcHRpb25zLmJhdGNoU2l6ZSB8fCBCQVRDSF9TSVpFO1xuICAgICAgICB0aGlzLmJhdGNoU2l6ZUlFID0gb3B0T3B0aW9ucy5iYXRjaFNpemVJRSB8fCBCQVRDSF9TSVpFX0lFO1xuICAgICAgICB0aGlzLmNsdXN0ZXJDbGFzcyA9IG9wdE9wdGlvbnMuY2x1c3RlckNsYXNzIHx8IENMVVNURVJFUl9DTEFTUztcbiAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdtc2llJykgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gYXZvaWQgSUUgdGltZW91dCB3aGVuIHByb2Nlc3NpbmcgYSBodWdlIG51bWJlciBvZiBtYXJrZXJzOlxuICAgICAgICAgICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmJhdGNoU2l6ZUlFO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXJSZWZTdGF0aWMgPSBudWxsO1xuICAgICAgICB0aGlzLnNldHVwU3R5bGVzKCk7XG4gICAgICAgIHRoaXMuYWRkTWFya2VycyhvcHRNYXJrZXJzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zZXRNYXAobWFwKTsgLy8gTm90ZTogdGhpcyBjYXVzZXMgb25BZGQgdG8gYmUgY2FsbGVkXG4gICAgfVxuICAgIENsdXN0ZXJlci5wcm90b3R5cGUub25ab29tQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5yZXNldFZpZXdwb3J0KGZhbHNlKTtcbiAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgdGhpcyBHb29nbGUgYnVnOiB3aGVuIG1hcCBpcyBhdCBsZXZlbCAwIGFuZCBcIi1cIiBvZlxuICAgICAgICAvLyB6b29tIHNsaWRlciBpcyBjbGlja2VkLCBhIFwiem9vbV9jaGFuZ2VkXCIgZXZlbnQgaXMgZmlyZWQgZXZlbiB0aG91Z2hcbiAgICAgICAgLy8gdGhlIG1hcCBkb2Vzbid0IHpvb20gb3V0IGFueSBmdXJ0aGVyLiBJbiB0aGlzIHNpdHVhdGlvbiwgbm8gXCJpZGxlXCJcbiAgICAgICAgLy8gZXZlbnQgaXMgdHJpZ2dlcmVkIHNvIHRoZSBjbHVzdGVyIG1hcmtlcnMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAgICAvLyBkbyBub3QgZ2V0IHJlZHJhd24uIFNhbWUgZ29lcyBmb3IgYSB6b29tIGluIGF0IG1heFpvb20uXG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5nZXRNYXAoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFpvb20oKSkgPT09ICh0aGlzLmdldCgnbWluWm9vbScpIHx8IDApIHx8XG4gICAgICAgICAgICAoKF9iID0gdGhpcy5nZXRNYXAoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFpvb20oKSkgPT09IHRoaXMuZ2V0KCdtYXhab29tJykpIHtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ2lkbGUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5vbklkbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVNYXAgPSBtYXA7XG4gICAgICAgIHRoaXMucmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBtYXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXAsICd6b29tX2NoYW5nZWQnLCB0aGlzLm9uWm9vbUNoYW5nZWQpLFxuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKG1hcCwgJ2lkbGUnLCB0aGlzLm9uSWRsZSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQdXQgYWxsIHRoZSBtYW5hZ2VkIG1hcmtlcnMgYmFjayBvbiB0aGUgbWFwOlxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5tYXJrZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IF9hW19pXTtcbiAgICAgICAgICAgIGlmIChtYXJrZXIuZ2V0TWFwKCkgIT09IHRoaXMuYWN0aXZlTWFwKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE1hcCh0aGlzLmFjdGl2ZU1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBjbHVzdGVyczpcbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMuY2x1c3RlcnM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICB2YXIgY2x1c3RlciA9IF9jW19iXTtcbiAgICAgICAgICAgIGNsdXN0ZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IFtdO1xuICAgICAgICAvLyBSZW1vdmUgbWFwIGV2ZW50IGxpc3RlbmVyczpcbiAgICAgICAgZm9yICh2YXIgX2QgPSAwLCBfZSA9IHRoaXMubGlzdGVuZXJzOyBfZCA8IF9lLmxlbmd0aDsgX2QrKykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX2VbX2RdO1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlTWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRNYXAgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0UGFuZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0UHJvamVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb21Db250YWluZXJQaXhlbFRvTGF0TG5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZnJvbURpdlBpeGVsVG9MYXRMbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgICAgICBmcm9tTGF0TG5nVG9Db250YWluZXJQaXhlbDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGZyb21MYXRMbmdUb0RpdlBpeGVsOiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICAgICAgZ2V0VmlzaWJsZVJlZ2lvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgICAgIGdldFdvcmxkV2lkdGg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0TWFwID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkgeyByZXR1cm47IH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuYmluZFRvID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRWYWx1ZXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUudW5iaW5kQWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXR1cFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW1hZ2VTaXplcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdXJsOiBcIlwiLmNvbmNhdCh0aGlzLmltYWdlUGF0aCArIChpICsgMSksIFwiLlwiKS5jb25jYXQodGhpcy5pbWFnZUV4dGVuc2lvbiksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmltYWdlU2l6ZXNbaV0gfHwgMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5pbWFnZVNpemVzW2ldIHx8IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5maXRNYXBUb01hcmtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXJrZXJzID0gdGhpcy5nZXRNYXJrZXJzKCk7XG4gICAgICAgIHZhciBib3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgbWFya2Vyc18xID0gbWFya2VyczsgX2kgPCBtYXJrZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gbWFya2Vyc18xW19pXTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgYm91bmRzLmV4dGVuZChwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICAgIGlmIChtYXAgIT09IG51bGwgJiYgJ2ZpdEJvdW5kcycgaW4gbWFwKSB7XG4gICAgICAgICAgICBtYXAuZml0Qm91bmRzKGJvdW5kcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0R3JpZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRTaXplO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRHcmlkU2l6ZSA9IGZ1bmN0aW9uIChncmlkU2l6ZSkge1xuICAgICAgICB0aGlzLmdyaWRTaXplID0gZ3JpZFNpemU7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldE1pbmltdW1DbHVzdGVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluQ2x1c3RlclNpemU7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldE1pbmltdW1DbHVzdGVyU2l6ZSA9IGZ1bmN0aW9uIChtaW5pbXVtQ2x1c3RlclNpemUpIHtcbiAgICAgICAgdGhpcy5taW5DbHVzdGVyU2l6ZSA9IG1pbmltdW1DbHVzdGVyU2l6ZTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0TWF4Wm9vbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4Wm9vbTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0TWF4Wm9vbSA9IGZ1bmN0aW9uIChtYXhab29tKSB7XG4gICAgICAgIHRoaXMubWF4Wm9vbSA9IG1heFpvb207XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVzKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRUaXRsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGl0bGU7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0Wm9vbU9uQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpvb21PbkNsaWNrO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRab29tT25DbGljayA9IGZ1bmN0aW9uICh6b29tT25DbGljaykge1xuICAgICAgICB0aGlzLnpvb21PbkNsaWNrID0gem9vbU9uQ2xpY2s7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldEF2ZXJhZ2VDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF2ZXJhZ2VDZW50ZXI7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldEF2ZXJhZ2VDZW50ZXIgPSBmdW5jdGlvbiAoYXZlcmFnZUNlbnRlcikge1xuICAgICAgICB0aGlzLmF2ZXJhZ2VDZW50ZXIgPSBhdmVyYWdlQ2VudGVyO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRJZ25vcmVIaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlnbm9yZUhpZGRlbjtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0SWdub3JlSGlkZGVuID0gZnVuY3Rpb24gKGlnbm9yZUhpZGRlbikge1xuICAgICAgICB0aGlzLmlnbm9yZUhpZGRlbiA9IGlnbm9yZUhpZGRlbjtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0RW5hYmxlUmV0aW5hSWNvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuYWJsZVJldGluYUljb25zO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5zZXRFbmFibGVSZXRpbmFJY29ucyA9IGZ1bmN0aW9uIChlbmFibGVSZXRpbmFJY29ucykge1xuICAgICAgICB0aGlzLmVuYWJsZVJldGluYUljb25zID0gZW5hYmxlUmV0aW5hSWNvbnM7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldEltYWdlRXh0ZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUV4dGVuc2lvbjtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0SW1hZ2VFeHRlbnNpb24gPSBmdW5jdGlvbiAoaW1hZ2VFeHRlbnNpb24pIHtcbiAgICAgICAgdGhpcy5pbWFnZUV4dGVuc2lvbiA9IGltYWdlRXh0ZW5zaW9uO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRJbWFnZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlUGF0aDtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0SW1hZ2VQYXRoID0gZnVuY3Rpb24gKGltYWdlUGF0aCkge1xuICAgICAgICB0aGlzLmltYWdlUGF0aCA9IGltYWdlUGF0aDtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0SW1hZ2VTaXplcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VTaXplcztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuc2V0SW1hZ2VTaXplcyA9IGZ1bmN0aW9uIChpbWFnZVNpemVzKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VTaXplcyA9IGltYWdlU2l6ZXM7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldENhbGN1bGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0b3I7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldENhbGN1bGF0b3IgPSBmdW5jdGlvbiAoY2FsY3VsYXRvcikge1xuICAgICAgICB0aGlzLmNhbGN1bGF0b3IgPSBjYWxjdWxhdG9yO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRCYXRjaFNpemVJRSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmF0Y2hTaXplSUU7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldEJhdGNoU2l6ZUlFID0gZnVuY3Rpb24gKGJhdGNoU2l6ZUlFKSB7XG4gICAgICAgIHRoaXMuYmF0Y2hTaXplSUUgPSBiYXRjaFNpemVJRTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0Q2x1c3RlckNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbHVzdGVyQ2xhc3M7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLnNldENsdXN0ZXJDbGFzcyA9IGZ1bmN0aW9uIChjbHVzdGVyQ2xhc3MpIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyQ2xhc3MgPSBjbHVzdGVyQ2xhc3M7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldE1hcmtlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtlcnM7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldFRvdGFsTWFya2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya2Vycy5sZW5ndGg7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmdldENsdXN0ZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbHVzdGVycztcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuZ2V0VG90YWxDbHVzdGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcnMubGVuZ3RoO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5hZGRNYXJrZXIgPSBmdW5jdGlvbiAobWFya2VyLCBvcHROb0RyYXcpIHtcbiAgICAgICAgdGhpcy5wdXNoTWFya2VyVG8obWFya2VyKTtcbiAgICAgICAgaWYgKCFvcHROb0RyYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuYWRkTWFya2VycyA9IGZ1bmN0aW9uIChtYXJrZXJzLCBvcHROb0RyYXcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcmtlcnMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFya2Vycywga2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXJrZXIgPSBtYXJrZXJzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hNYXJrZXJUbyhtYXJrZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdE5vRHJhdykge1xuICAgICAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5wdXNoTWFya2VyVG8gPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIElmIHRoZSBtYXJrZXIgaXMgZHJhZ2dhYmxlIGFkZCBhIGxpc3RlbmVyIHNvIHdlIGNhbiB1cGRhdGUgdGhlIGNsdXN0ZXJzIG9uIHRoZSBkcmFnZW5kOlxuICAgICAgICBpZiAobWFya2VyLmdldERyYWdnYWJsZSgpKSB7XG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihtYXJrZXIsICdkcmFnZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuaXNBZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBhaW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya2VyLmlzQWRkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUucmVtb3ZlTWFya2VyXyA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGlmICh0aGlzLm1hcmtlcnMuaW5kZXhPZikge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLm1hcmtlcnMuaW5kZXhPZihtYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyID09PSB0aGlzLm1hcmtlcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gTWFya2VyIGlzIG5vdCBpbiBvdXIgbGlzdCBvZiBtYXJrZXJzLCBzbyBkbyBub3RoaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtlci5zZXRNYXAobnVsbCk7XG4gICAgICAgIHRoaXMubWFya2Vycy5zcGxpY2UoaW5kZXgsIDEpOyAvLyBSZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBsaXN0IG9mIG1hbmFnZWQgbWFya2Vyc1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUucmVtb3ZlTWFya2VyID0gZnVuY3Rpb24gKG1hcmtlciwgb3B0Tm9EcmF3KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gdGhpcy5yZW1vdmVNYXJrZXJfKG1hcmtlcik7XG4gICAgICAgIGlmICghb3B0Tm9EcmF3ICYmIHJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZW1vdmVNYXJrZXJzID0gZnVuY3Rpb24gKG1hcmtlcnMsIG9wdE5vRHJhdykge1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG1hcmtlcnNfMiA9IG1hcmtlcnM7IF9pIDwgbWFya2Vyc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlcnNfMltfaV07XG4gICAgICAgICAgICByZW1vdmVkID0gcmVtb3ZlZCB8fCB0aGlzLnJlbW92ZU1hcmtlcl8obWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdE5vRHJhdyAmJiByZW1vdmVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuY2xlYXJNYXJrZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlc2V0Vmlld3BvcnQodHJ1ZSk7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFtdO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZXBhaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2xkQ2x1c3RlcnMgPSB0aGlzLmNsdXN0ZXJzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZXNldFZpZXdwb3J0KGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgY2x1c3RlcnMuXG4gICAgICAgIC8vIERvIGl0IGluIGEgdGltZW91dCB0byBwcmV2ZW50IGJsaW5raW5nIGVmZmVjdC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBvbGRDbHVzdGVyc18xID0gb2xkQ2x1c3RlcnM7IF9pIDwgb2xkQ2x1c3RlcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkQ2x1c3RlciA9IG9sZENsdXN0ZXJzXzFbX2ldO1xuICAgICAgICAgICAgICAgIG9sZENsdXN0ZXIucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5nZXRFeHRlbmRlZEJvdW5kcyA9IGZ1bmN0aW9uIChib3VuZHMpIHtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgcG9pbnRzIHRvIHBpeGVscyBhbmQgdGhlIGV4dGVuZCBvdXQgYnkgdGhlIGdyaWQgc2l6ZS5cbiAgICAgICAgdmFyIHRyUGl4ID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChcbiAgICAgICAgLy8gVHVybiB0aGUgYm91bmRzIGludG8gbGF0bG5nLlxuICAgICAgICBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGJvdW5kcy5nZXROb3J0aEVhc3QoKS5sYXQoKSwgYm91bmRzLmdldE5vcnRoRWFzdCgpLmxuZygpKSk7XG4gICAgICAgIGlmICh0clBpeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJQaXgueCArPSB0aGlzLmdyaWRTaXplO1xuICAgICAgICAgICAgdHJQaXgueSAtPSB0aGlzLmdyaWRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBibFBpeCA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoXG4gICAgICAgIC8vIFR1cm4gdGhlIGJvdW5kcyBpbnRvIGxhdGxuZy5cbiAgICAgICAgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMuZ2V0U291dGhXZXN0KCkubGF0KCksIGJvdW5kcy5nZXRTb3V0aFdlc3QoKS5sbmcoKSkpO1xuICAgICAgICBpZiAoYmxQaXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGJsUGl4LnggLT0gdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgICAgIGJsUGl4LnkgKz0gdGhpcy5ncmlkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBuZXcgYm91bmRzLlxuICAgICAgICBpZiAodHJQaXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHBpeGVsIHBvaW50cyBiYWNrIHRvIExhdExuZyBud1xuICAgICAgICAgICAgdmFyIHBvaW50MSA9IHByb2plY3Rpb24uZnJvbURpdlBpeGVsVG9MYXRMbmcodHJQaXgpO1xuICAgICAgICAgICAgaWYgKHBvaW50MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5leHRlbmQocG9pbnQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxQaXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHBpeGVsIHBvaW50cyBiYWNrIHRvIExhdExuZyBzd1xuICAgICAgICAgICAgdmFyIHBvaW50MiA9IHByb2plY3Rpb24uZnJvbURpdlBpeGVsVG9MYXRMbmcoYmxQaXgpO1xuICAgICAgICAgICAgaWYgKHBvaW50MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJvdW5kcy5leHRlbmQocG9pbnQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyLnByb3RvdHlwZS5yZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlZHJhd3MgYWxsIHRoZSBjbHVzdGVycy5cbiAgICAgICAgdGhpcy5jcmVhdGVDbHVzdGVycygwKTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUucmVzZXRWaWV3cG9ydCA9IGZ1bmN0aW9uIChvcHRIaWRlKSB7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgdGhlIGNsdXN0ZXJzXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNsdXN0ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGNsdXN0ZXIgPSBfYVtfaV07XG4gICAgICAgICAgICBjbHVzdGVyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgLy8gUmVzZXQgdGhlIG1hcmtlcnMgdG8gbm90IGJlIGFkZGVkIGFuZCB0byBiZSByZW1vdmVkIGZyb20gdGhlIG1hcC5cbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IHRoaXMubWFya2VyczsgX2IgPCBfYy5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSBfY1tfYl07XG4gICAgICAgICAgICBtYXJrZXIuaXNBZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG9wdEhpZGUpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmRpc3RhbmNlQmV0d2VlblBvaW50cyA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgICAgdmFyIFIgPSA2MzcxOyAvLyBSYWRpdXMgb2YgdGhlIEVhcnRoIGluIGttXG4gICAgICAgIHZhciBkTGF0ID0gKChwMi5sYXQoKSAtIHAxLmxhdCgpKSAqIE1hdGguUEkpIC8gMTgwO1xuICAgICAgICB2YXIgZExvbiA9ICgocDIubG5nKCkgLSBwMS5sbmcoKSkgKiBNYXRoLlBJKSAvIDE4MDtcbiAgICAgICAgdmFyIGEgPSBNYXRoLnNpbihkTGF0IC8gMikgKiBNYXRoLnNpbihkTGF0IC8gMikgK1xuICAgICAgICAgICAgTWF0aC5jb3MoKHAxLmxhdCgpICogTWF0aC5QSSkgLyAxODApICpcbiAgICAgICAgICAgICAgICBNYXRoLmNvcygocDIubGF0KCkgKiBNYXRoLlBJKSAvIDE4MCkgKlxuICAgICAgICAgICAgICAgIE1hdGguc2luKGRMb24gLyAyKSAqXG4gICAgICAgICAgICAgICAgTWF0aC5zaW4oZExvbiAvIDIpO1xuICAgICAgICByZXR1cm4gUiAqICgyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpKTtcbiAgICB9O1xuICAgIENsdXN0ZXJlci5wcm90b3R5cGUuaXNNYXJrZXJJbkJvdW5kcyA9IGZ1bmN0aW9uIChtYXJrZXIsIGJvdW5kcykge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRzLmNvbnRhaW5zKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmFkZFRvQ2xvc2VzdENsdXN0ZXIgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHZhciBjbHVzdGVyO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSA0MDAwMDsgLy8gU29tZSBsYXJnZSBudW1iZXJcbiAgICAgICAgdmFyIGNsdXN0ZXJUb0FkZFRvID0gbnVsbDtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuY2x1c3RlcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2x1c3RlckVsZW1lbnQgPSBfYVtfaV07XG4gICAgICAgICAgICBjbHVzdGVyID0gY2x1c3RlckVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gY2x1c3Rlci5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG1hcmtlci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgaWYgKGNlbnRlciAmJiBwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBkID0gdGhpcy5kaXN0YW5jZUJldHdlZW5Qb2ludHMoY2VudGVyLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGQgPCBkaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJUb0FkZFRvID0gY2x1c3RlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsdXN0ZXJUb0FkZFRvICYmIGNsdXN0ZXJUb0FkZFRvLmlzTWFya2VySW5DbHVzdGVyQm91bmRzKG1hcmtlcikpIHtcbiAgICAgICAgICAgIGNsdXN0ZXJUb0FkZFRvLmFkZE1hcmtlcihtYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2x1c3RlciA9IG5ldyBDbHVzdGVyJDEodGhpcyk7XG4gICAgICAgICAgICBjbHVzdGVyLmFkZE1hcmtlcihtYXJrZXIpO1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVycy5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmNyZWF0ZUNsdXN0ZXJzID0gZnVuY3Rpb24gKGlGaXJzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMucmVhZHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDYW5jZWwgcHJldmlvdXMgYmF0Y2ggcHJvY2Vzc2luZyBpZiB3ZSdyZSB3b3JraW5nIG9uIHRoZSBmaXJzdCBiYXRjaDpcbiAgICAgICAgaWYgKGlGaXJzdCA9PT0gMCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIDxjb2RlPkNsdXN0ZXJlcjwvY29kZT4gYmVnaW5zXG4gICAgICAgICAgICAgKiAgY2x1c3RlcmluZyBtYXJrZXJzLlxuICAgICAgICAgICAgICogQG5hbWUgQ2x1c3RlcmVyI2NsdXN0ZXJpbmdiZWdpblxuICAgICAgICAgICAgICogQHBhcmFtIHtDbHVzdGVyZXJ9IG1jIFRoZSBDbHVzdGVyZXIgd2hvc2UgbWFya2VycyBhcmUgYmVpbmcgY2x1c3RlcmVkLlxuICAgICAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ2NsdXN0ZXJpbmdiZWdpbicsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJSZWZTdGF0aWMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZXJSZWZTdGF0aWMpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudGltZXJSZWZTdGF0aWM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICAgIHZhciBib3VuZHMgPSBtYXAgIT09IG51bGwgJiYgJ2dldEJvdW5kcycgaW4gbWFwID8gbWFwLmdldEJvdW5kcygpIDogbnVsbDtcbiAgICAgICAgdmFyIHpvb20gPSAobWFwID09PSBudWxsIHx8IG1hcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFwLmdldFpvb20oKSkgfHwgMDtcbiAgICAgICAgLy8gR2V0IG91ciBjdXJyZW50IG1hcCB2aWV3IGJvdW5kcy5cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGJvdW5kcyBvYmplY3Qgc28gd2UgZG9uJ3QgYWZmZWN0IHRoZSBtYXAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlZSBDb21tZW50cyA5ICYgMTEgb24gSXNzdWUgMzY1MSByZWxhdGluZyB0byB0aGlzIHdvcmthcm91bmQgZm9yIGEgR29vZ2xlIE1hcHMgYnVnOlxuICAgICAgICB2YXIgbWFwQm91bmRzID0gem9vbSA+IDNcbiAgICAgICAgICAgID8gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcyhib3VuZHMgPT09IG51bGwgfHwgYm91bmRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBib3VuZHMuZ2V0U291dGhXZXN0KCksIGJvdW5kcyA9PT0gbnVsbCB8fCBib3VuZHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvdW5kcy5nZXROb3J0aEVhc3QoKSlcbiAgICAgICAgICAgIDogbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcyhuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKDg1LjAyMDcwNzcxNzQzNDcyLCAtMTc4LjQ4Mzg4NDM0Mzc1KSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZygtODUuMDgxMzY0NDQzODQ1NDQsIDE3OC4wMDA0ODg2NTYyNSkpO1xuICAgICAgICB2YXIgZXh0ZW5kZWRNYXBCb3VuZHMgPSB0aGlzLmdldEV4dGVuZGVkQm91bmRzKG1hcEJvdW5kcyk7XG4gICAgICAgIHZhciBpTGFzdCA9IE1hdGgubWluKGlGaXJzdCArIHRoaXMuYmF0Y2hTaXplLCB0aGlzLm1hcmtlcnMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IGlGaXJzdDsgaSA8IGlMYXN0OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLm1hcmtlcnNbaV07XG4gICAgICAgICAgICBpZiAobWFya2VyICYmICFtYXJrZXIuaXNBZGRlZCAmJiB0aGlzLmlzTWFya2VySW5Cb3VuZHMobWFya2VyLCBleHRlbmRlZE1hcEJvdW5kcykgJiYgKCF0aGlzLmlnbm9yZUhpZGRlbiB8fCAodGhpcy5pZ25vcmVIaWRkZW4gJiYgbWFya2VyLmdldFZpc2libGUoKSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb0Nsb3Nlc3RDbHVzdGVyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlMYXN0IDwgdGhpcy5tYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50aW1lclJlZlN0YXRpYyA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVDbHVzdGVycyhpTGFzdCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGltZXJSZWZTdGF0aWMgPSBudWxsO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIDxjb2RlPkNsdXN0ZXJlcjwvY29kZT4gc3RvcHNcbiAgICAgICAgICAgICAqICBjbHVzdGVyaW5nIG1hcmtlcnMuXG4gICAgICAgICAgICAgKiBAbmFtZSBDbHVzdGVyZXIjY2x1c3RlcmluZ2VuZFxuICAgICAgICAgICAgICogQHBhcmFtIHtDbHVzdGVyZXJ9IG1jIFRoZSBDbHVzdGVyZXIgd2hvc2UgbWFya2VycyBhcmUgYmVpbmcgY2x1c3RlcmVkLlxuICAgICAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnRyaWdnZXIodGhpcywgJ2NsdXN0ZXJpbmdlbmQnLCB0aGlzKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmNsdXN0ZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBjbHVzdGVyID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgIGNsdXN0ZXIudXBkYXRlSWNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChvYmoxLCBvYmoyKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBhcHBseUV4dGVuZChvYmplY3QpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5IGluIG9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gcHJvcGVydHk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvdHlwZVtwcm9wXSA9IG9iamVjdC5wcm90b3R5cGVbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfS5hcHBseShvYmoxLCBbb2JqMl0pO1xuICAgIH07XG4gICAgcmV0dXJuIENsdXN0ZXJlcjtcbn0oKSk7XG5cbnZhciBldmVudE1hcCRlID0ge1xuICAgIG9uQ2xpY2s6ICdjbGljaycsXG4gICAgb25DbHVzdGVyaW5nQmVnaW46ICdjbHVzdGVyaW5nYmVnaW4nLFxuICAgIG9uQ2x1c3RlcmluZ0VuZDogJ2NsdXN0ZXJpbmdlbmQnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxufTtcbnZhciB1cGRhdGVyTWFwJGUgPSB7XG4gICAgYXZlcmFnZUNlbnRlcjogZnVuY3Rpb24gKGluc3RhbmNlLCBhdmVyYWdlQ2VudGVyKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEF2ZXJhZ2VDZW50ZXIoYXZlcmFnZUNlbnRlcik7XG4gICAgfSxcbiAgICBiYXRjaFNpemVJRTogZnVuY3Rpb24gKGluc3RhbmNlLCBiYXRjaFNpemVJRSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRCYXRjaFNpemVJRShiYXRjaFNpemVJRSk7XG4gICAgfSxcbiAgICBjYWxjdWxhdG9yOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNhbGN1bGF0b3IpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q2FsY3VsYXRvcihjYWxjdWxhdG9yKTtcbiAgICB9LFxuICAgIGNsdXN0ZXJDbGFzczogZnVuY3Rpb24gKGluc3RhbmNlLCBjbHVzdGVyQ2xhc3MpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q2x1c3RlckNsYXNzKGNsdXN0ZXJDbGFzcyk7XG4gICAgfSxcbiAgICBlbmFibGVSZXRpbmFJY29uczogZnVuY3Rpb24gKGluc3RhbmNlLCBlbmFibGVSZXRpbmFJY29ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRFbmFibGVSZXRpbmFJY29ucyhlbmFibGVSZXRpbmFJY29ucyk7XG4gICAgfSxcbiAgICBncmlkU2l6ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBncmlkU2l6ZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRHcmlkU2l6ZShncmlkU2l6ZSk7XG4gICAgfSxcbiAgICBpZ25vcmVIaWRkZW46IGZ1bmN0aW9uIChpbnN0YW5jZSwgaWdub3JlSGlkZGVuKSB7XG4gICAgICAgIGluc3RhbmNlLnNldElnbm9yZUhpZGRlbihpZ25vcmVIaWRkZW4pO1xuICAgIH0sXG4gICAgaW1hZ2VFeHRlbnNpb246IGZ1bmN0aW9uIChpbnN0YW5jZSwgaW1hZ2VFeHRlbnNpb24pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0SW1hZ2VFeHRlbnNpb24oaW1hZ2VFeHRlbnNpb24pO1xuICAgIH0sXG4gICAgaW1hZ2VQYXRoOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGltYWdlUGF0aCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRJbWFnZVBhdGgoaW1hZ2VQYXRoKTtcbiAgICB9LFxuICAgIGltYWdlU2l6ZXM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgaW1hZ2VTaXplcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRJbWFnZVNpemVzKGltYWdlU2l6ZXMpO1xuICAgIH0sXG4gICAgbWF4Wm9vbTogZnVuY3Rpb24gKGluc3RhbmNlLCBtYXhab29tKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1heFpvb20obWF4Wm9vbSk7XG4gICAgfSxcbiAgICBtaW5pbXVtQ2x1c3RlclNpemU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbWluaW11bUNsdXN0ZXJTaXplKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1pbmltdW1DbHVzdGVyU2l6ZShtaW5pbXVtQ2x1c3RlclNpemUpO1xuICAgIH0sXG4gICAgc3R5bGVzOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHN0eWxlcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRTdHlsZXMoc3R5bGVzKTtcbiAgICB9LFxuICAgIHRpdGxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHRpdGxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFRpdGxlKHRpdGxlKTtcbiAgICB9LFxuICAgIHpvb21PbkNsaWNrOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHpvb21PbkNsaWNrKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFpvb21PbkNsaWNrKHpvb21PbkNsaWNrKTtcbiAgICB9LFxufTtcbnZhciBkZWZhdWx0T3B0aW9ucyQ0ID0ge307XG5mdW5jdGlvbiBNYXJrZXJDbHVzdGVyZXJGdW5jdGlvbmFsKHByb3BzKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sIG9wdGlvbnMgPSBwcm9wcy5vcHRpb25zLCBhdmVyYWdlQ2VudGVyID0gcHJvcHMuYXZlcmFnZUNlbnRlciwgYmF0Y2hTaXplSUUgPSBwcm9wcy5iYXRjaFNpemVJRSwgY2FsY3VsYXRvciA9IHByb3BzLmNhbGN1bGF0b3IsIGNsdXN0ZXJDbGFzcyA9IHByb3BzLmNsdXN0ZXJDbGFzcywgZW5hYmxlUmV0aW5hSWNvbnMgPSBwcm9wcy5lbmFibGVSZXRpbmFJY29ucywgZ3JpZFNpemUgPSBwcm9wcy5ncmlkU2l6ZSwgaWdub3JlSGlkZGVuID0gcHJvcHMuaWdub3JlSGlkZGVuLCBpbWFnZUV4dGVuc2lvbiA9IHByb3BzLmltYWdlRXh0ZW5zaW9uLCBpbWFnZVBhdGggPSBwcm9wcy5pbWFnZVBhdGgsIGltYWdlU2l6ZXMgPSBwcm9wcy5pbWFnZVNpemVzLCBtYXhab29tID0gcHJvcHMubWF4Wm9vbSwgbWluaW11bUNsdXN0ZXJTaXplID0gcHJvcHMubWluaW11bUNsdXN0ZXJTaXplLCBzdHlsZXMgPSBwcm9wcy5zdHlsZXMsIHRpdGxlID0gcHJvcHMudGl0bGUsIHpvb21PbkNsaWNrID0gcHJvcHMuem9vbU9uQ2xpY2ssIG9uQ2xpY2sgPSBwcm9wcy5vbkNsaWNrLCBvbkNsdXN0ZXJpbmdCZWdpbiA9IHByb3BzLm9uQ2x1c3RlcmluZ0JlZ2luLCBvbkNsdXN0ZXJpbmdFbmQgPSBwcm9wcy5vbkNsdXN0ZXJpbmdFbmQsIG9uTW91c2VPdmVyID0gcHJvcHMub25Nb3VzZU92ZXIsIG9uTW91c2VPdXQgPSBwcm9wcy5vbk1vdXNlT3V0LCBvbkxvYWQgPSBwcm9wcy5vbkxvYWQsIG9uVW5tb3VudCA9IHByb3BzLm9uVW5tb3VudDtcbiAgICB2YXIgX2EgPSB1c2VTdGF0ZShudWxsKSwgaW5zdGFuY2UgPSBfYVswXSwgc2V0SW5zdGFuY2UgPSBfYVsxXTtcbiAgICB2YXIgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICB2YXIgX2IgPSB1c2VTdGF0ZShudWxsKSwgY2xpY2tMaXN0ZW5lciA9IF9iWzBdLCBzZXRDbGlja0xpc3RlbmVyID0gX2JbMV07XG4gICAgdmFyIF9jID0gdXNlU3RhdGUobnVsbCksIGNsdXN0ZXJpbmdCZWdpbkxpc3RlbmVyID0gX2NbMF0sIHNldENsdXN0ZXJpbmdCZWdpbkxpc3RlbmVyID0gX2NbMV07XG4gICAgdmFyIF9kID0gdXNlU3RhdGUobnVsbCksIGNsdXN0ZXJpbmdFbmRMaXN0ZW5lciA9IF9kWzBdLCBzZXRDbHVzdGVyaW5nRW5kTGlzdGVuZXIgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSB1c2VTdGF0ZShudWxsKSwgbW91c2VvdXRMaXN0ZW5lciA9IF9lWzBdLCBzZXRNb3VzZW91dExpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gdXNlU3RhdGUobnVsbCksIG1vdXNlb3Zlckxpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlb3Zlckxpc3RlbmVyID0gX2ZbMV07XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdXQpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW91dExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCBldmVudE1hcCRlLm9uTW91c2VPdXQsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgZXZlbnRNYXAkZS5vbk1vdXNlT3Zlciwgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkNsaWNrKSB7XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgZXZlbnRNYXAkZS5vbkNsaWNrLCBvbkNsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbGlja10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkNsdXN0ZXJpbmdCZWdpbikge1xuICAgICAgICAgICAgaWYgKGNsdXN0ZXJpbmdCZWdpbkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2x1c3RlcmluZ0JlZ2luTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2x1c3RlcmluZ0JlZ2luTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsIGV2ZW50TWFwJGUub25DbHVzdGVyaW5nQmVnaW4sIG9uQ2x1c3RlcmluZ0JlZ2luKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbHVzdGVyaW5nQmVnaW5dKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbHVzdGVyaW5nRW5kKSB7XG4gICAgICAgICAgICBpZiAoY2x1c3RlcmluZ0VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2x1c3RlcmluZ0VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsdXN0ZXJpbmdCZWdpbkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCBldmVudE1hcCRlLm9uQ2x1c3RlcmluZ0VuZCwgb25DbHVzdGVyaW5nRW5kKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbHVzdGVyaW5nRW5kXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhdmVyYWdlQ2VudGVyICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmF2ZXJhZ2VDZW50ZXIoaW5zdGFuY2UsIGF2ZXJhZ2VDZW50ZXIpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBhdmVyYWdlQ2VudGVyXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiYXRjaFNpemVJRSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5iYXRjaFNpemVJRShpbnN0YW5jZSwgYmF0Y2hTaXplSUUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBiYXRjaFNpemVJRV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsY3VsYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5jYWxjdWxhdG9yKGluc3RhbmNlLCBjYWxjdWxhdG9yKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgY2FsY3VsYXRvcl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2x1c3RlckNsYXNzICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmNsdXN0ZXJDbGFzcyhpbnN0YW5jZSwgY2x1c3RlckNsYXNzKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgY2x1c3RlckNsYXNzXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmFibGVSZXRpbmFJY29ucyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5lbmFibGVSZXRpbmFJY29ucyhpbnN0YW5jZSwgZW5hYmxlUmV0aW5hSWNvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBlbmFibGVSZXRpbmFJY29uc10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ3JpZFNpemUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuZ3JpZFNpemUoaW5zdGFuY2UsIGdyaWRTaXplKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgZ3JpZFNpemVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGlnbm9yZUhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5pZ25vcmVIaWRkZW4oaW5zdGFuY2UsIGlnbm9yZUhpZGRlbik7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGlnbm9yZUhpZGRlbl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW1hZ2VFeHRlbnNpb24gIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuaW1hZ2VFeHRlbnNpb24oaW5zdGFuY2UsIGltYWdlRXh0ZW5zaW9uKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgaW1hZ2VFeHRlbnNpb25dKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIGltYWdlUGF0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5pbWFnZVBhdGgoaW5zdGFuY2UsIGltYWdlUGF0aCk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGltYWdlUGF0aF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW1hZ2VTaXplcyAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5pbWFnZVNpemVzKGluc3RhbmNlLCBpbWFnZVNpemVzKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgaW1hZ2VTaXplc10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWF4Wm9vbSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5tYXhab29tKGluc3RhbmNlLCBtYXhab29tKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgbWF4Wm9vbV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWluaW11bUNsdXN0ZXJTaXplICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLm1pbmltdW1DbHVzdGVyU2l6ZShpbnN0YW5jZSwgbWluaW11bUNsdXN0ZXJTaXplKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgbWluaW11bUNsdXN0ZXJTaXplXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHlsZXMgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuc3R5bGVzKGluc3RhbmNlLCBzdHlsZXMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBzdHlsZXNdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRpdGxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLnRpdGxlKGluc3RhbmNlLCB0aXRsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIHRpdGxlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB6b29tT25DbGljayAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS56b29tT25DbGljayhpbnN0YW5jZSwgem9vbU9uQ2xpY2spO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCB6b29tT25DbGlja10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghbWFwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgY2x1c3RlcmVyT3B0aW9ucyA9IF9fYXNzaWduKHt9LCAob3B0aW9ucyB8fCBkZWZhdWx0T3B0aW9ucyQ0KSk7XG4gICAgICAgIHZhciBjbHVzdGVyZXIgPSBuZXcgQ2x1c3RlcmVyKG1hcCwgW10sIGNsdXN0ZXJlck9wdGlvbnMpO1xuICAgICAgICBpZiAoYXZlcmFnZUNlbnRlcikge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmF2ZXJhZ2VDZW50ZXIoY2x1c3RlcmVyLCBhdmVyYWdlQ2VudGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmF0Y2hTaXplSUUpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5iYXRjaFNpemVJRShjbHVzdGVyZXIsIGJhdGNoU2l6ZUlFKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsY3VsYXRvcikge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmNhbGN1bGF0b3IoY2x1c3RlcmVyLCBjYWxjdWxhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2x1c3RlckNsYXNzKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuY2x1c3RlckNsYXNzKGNsdXN0ZXJlciwgY2x1c3RlckNsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5hYmxlUmV0aW5hSWNvbnMpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5lbmFibGVSZXRpbmFJY29ucyhjbHVzdGVyZXIsIGVuYWJsZVJldGluYUljb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZFNpemUpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5ncmlkU2l6ZShjbHVzdGVyZXIsIGdyaWRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWdub3JlSGlkZGVuKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuaWdub3JlSGlkZGVuKGNsdXN0ZXJlciwgaWdub3JlSGlkZGVuKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2VFeHRlbnNpb24pIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS5pbWFnZUV4dGVuc2lvbihjbHVzdGVyZXIsIGltYWdlRXh0ZW5zaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2VQYXRoKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuaW1hZ2VQYXRoKGNsdXN0ZXJlciwgaW1hZ2VQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1hZ2VTaXplcykge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLmltYWdlU2l6ZXMoY2x1c3RlcmVyLCBpbWFnZVNpemVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4Wm9vbSkge1xuICAgICAgICAgICAgdXBkYXRlck1hcCRlLm1heFpvb20oY2x1c3RlcmVyLCBtYXhab29tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWluaW11bUNsdXN0ZXJTaXplKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUubWluaW11bUNsdXN0ZXJTaXplKGNsdXN0ZXJlciwgbWluaW11bUNsdXN0ZXJTaXplKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgICAgICB1cGRhdGVyTWFwJGUuc3R5bGVzKGNsdXN0ZXJlciwgc3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS50aXRsZShjbHVzdGVyZXIsIHRpdGxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoem9vbU9uQ2xpY2spIHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXAkZS56b29tT25DbGljayhjbHVzdGVyZXIsIHpvb21PbkNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZU91dCkge1xuICAgICAgICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjbHVzdGVyZXIsIGV2ZW50TWFwJGUub25Nb3VzZU91dCwgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2x1c3RlcmVyLCBldmVudE1hcCRlLm9uTW91c2VPdmVyLCBvbk1vdXNlT3ZlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNsdXN0ZXJlciwgZXZlbnRNYXAkZS5vbkNsaWNrLCBvbkNsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2x1c3RlcmluZ0JlZ2luKSB7XG4gICAgICAgICAgICBzZXRDbHVzdGVyaW5nQmVnaW5MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjbHVzdGVyZXIsIGV2ZW50TWFwJGUub25DbHVzdGVyaW5nQmVnaW4sIG9uQ2x1c3RlcmluZ0JlZ2luKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2x1c3RlcmluZ0VuZCkge1xuICAgICAgICAgICAgc2V0Q2x1c3RlcmluZ0VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNsdXN0ZXJlciwgZXZlbnRNYXAkZS5vbkNsdXN0ZXJpbmdFbmQsIG9uQ2x1c3RlcmluZ0VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldEluc3RhbmNlKGNsdXN0ZXJlcik7XG4gICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgIG9uTG9hZChjbHVzdGVyZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3V0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbHVzdGVyaW5nQmVnaW5MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsdXN0ZXJpbmdCZWdpbkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbHVzdGVyaW5nRW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbHVzdGVyaW5nRW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIG9uVW5tb3VudChjbHVzdGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gaW5zdGFuY2UgIT09IG51bGwgPyBjaGlsZHJlbihpbnN0YW5jZSkgfHwgbnVsbCA6IG51bGw7XG59XG52YXIgTWFya2VyQ2x1c3RlcmVyRiA9IG1lbW8oTWFya2VyQ2x1c3RlcmVyRnVuY3Rpb25hbCk7XG52YXIgQ2x1c3RlcmVyQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDbHVzdGVyZXJDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2x1c3RlcmVyQ29tcG9uZW50KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIG1hcmtlckNsdXN0ZXJlcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0Q2x1c3RlcmVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENsdXN0ZXJlckNvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciBtYXJrZXJDbHVzdGVyZXJfMSA9IG5ldyBDbHVzdGVyZXIodGhpcy5jb250ZXh0LCBbXSwgdGhpcy5wcm9wcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkZSxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkZSxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbWFya2VyQ2x1c3RlcmVyXzEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlckNsdXN0ZXJlcjogbWFya2VyQ2x1c3RlcmVyXzEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIHRoaXMuc2V0Q2x1c3RlcmVyQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXJDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGUsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGUsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDbHVzdGVyZXJDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tYXJrZXJDbHVzdGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2x1c3RlcmVyQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLm1hcmtlckNsdXN0ZXJlciAhPT0gbnVsbFxuICAgICAgICAgICAgPyB0aGlzLnByb3BzLmNoaWxkcmVuKHRoaXMuc3RhdGUubWFya2VyQ2x1c3RlcmVyKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH07XG4gICAgQ2x1c3RlcmVyQ29tcG9uZW50LmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcbiAgICByZXR1cm4gQ2x1c3RlcmVyQ29tcG9uZW50O1xufShQdXJlQ29tcG9uZW50KSk7XG5cbi8vIFRoaXMgaGFuZGxlciBwcmV2ZW50cyBhbiBldmVudCBpbiB0aGUgSW5mb0JveCBmcm9tIGJlaW5nIHBhc3NlZCBvbiB0byB0aGUgbWFwLlxuZnVuY3Rpb24gY2FuY2VsSGFuZGxlcihldmVudCkge1xuICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG59XG52YXIgSW5mb0JveCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbmZvQm94KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy5nZXRDbG9zZUNsaWNrSGFuZGxlciA9IHRoaXMuZ2V0Q2xvc2VDbGlja0hhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZUNsaWNrSGFuZGxlciA9IHRoaXMuY2xvc2VDbGlja0hhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVJbmZvQm94RGl2ID0gdGhpcy5jcmVhdGVJbmZvQm94RGl2LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYWRkQ2xpY2tIYW5kbGVyID0gdGhpcy5hZGRDbGlja0hhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRDbG9zZUJveEltZyA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWcuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRCb3hXaWR0aHMgPSB0aGlzLmdldEJveFdpZHRocy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldEJveFN0eWxlID0gdGhpcy5zZXRCb3hTdHlsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uID0gdGhpcy5zZXRQb3NpdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMgPSB0aGlzLnNldE9wdGlvbnMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZW50ID0gdGhpcy5zZXRDb250ZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0VmlzaWJsZSA9IHRoaXMuc2V0VmlzaWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldENvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRWaXNpYmxlID0gdGhpcy5nZXRWaXNpYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0WkluZGV4ID0gdGhpcy5zZXRaSW5kZXguYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXRaSW5kZXggPSB0aGlzLmdldFpJbmRleC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uUmVtb3ZlID0gdGhpcy5vblJlbW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhbkJveCA9IHRoaXMucGFuQm94LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZXh0ZW5kID0gdGhpcy5leHRlbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kcmF3ID0gdGhpcy5kcmF3LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2hvdyA9IHRoaXMuc2hvdy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhpZGUgPSB0aGlzLmhpZGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcGVuID0gdGhpcy5vcGVuLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZXh0ZW5kKEluZm9Cb3gsIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3KTtcbiAgICAgICAgLy8gU3RhbmRhcmQgb3B0aW9ucyAoaW4gY29tbW9uIHdpdGggZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyk6XG4gICAgICAgIHRoaXMuY29udGVudCA9IG9wdGlvbnMuY29udGVudCB8fCAnJztcbiAgICAgICAgdGhpcy5kaXNhYmxlQXV0b1BhbiA9IG9wdGlvbnMuZGlzYWJsZUF1dG9QYW4gfHwgZmFsc2U7XG4gICAgICAgIHRoaXMubWF4V2lkdGggPSBvcHRpb25zLm1heFdpZHRoIHx8IDA7XG4gICAgICAgIHRoaXMucGl4ZWxPZmZzZXQgPSBvcHRpb25zLnBpeGVsT2Zmc2V0IHx8IG5ldyBnb29nbGUubWFwcy5TaXplKDAsIDApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbiB8fCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKDAsIDApO1xuICAgICAgICB0aGlzLnpJbmRleCA9IG9wdGlvbnMuekluZGV4IHx8IG51bGw7XG4gICAgICAgIC8vIEFkZGl0aW9uYWwgb3B0aW9ucyAodW5pcXVlIHRvIEluZm9Cb3gpOlxuICAgICAgICB0aGlzLmJveENsYXNzID0gb3B0aW9ucy5ib3hDbGFzcyB8fCAnaW5mb0JveCc7XG4gICAgICAgIHRoaXMuYm94U3R5bGUgPSBvcHRpb25zLmJveFN0eWxlIHx8IHt9O1xuICAgICAgICB0aGlzLmNsb3NlQm94TWFyZ2luID0gb3B0aW9ucy5jbG9zZUJveE1hcmdpbiB8fCAnMnB4JztcbiAgICAgICAgdGhpcy5jbG9zZUJveFVSTCA9IG9wdGlvbnMuY2xvc2VCb3hVUkwgfHwgJ2h0dHA6Ly93d3cuZ29vZ2xlLmNvbS9pbnRsL2VuX3VzL21hcGZpbGVzL2Nsb3NlLmdpZic7XG4gICAgICAgIGlmIChvcHRpb25zLmNsb3NlQm94VVJMID09PSAnJykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUJveFVSTCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5mb0JveENsZWFyYW5jZSA9IG9wdGlvbnMuaW5mb0JveENsZWFyYW5jZSB8fCBuZXcgZ29vZ2xlLm1hcHMuU2l6ZSgxLCAxKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnZpc2libGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuaXNIaWRkZW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlzaWJsZSA9ICFvcHRpb25zLmlzSGlkZGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSAhb3B0aW9ucy52aXNpYmxlO1xuICAgICAgICB0aGlzLmFsaWduQm90dG9tID0gb3B0aW9ucy5hbGlnbkJvdHRvbSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5wYW5lID0gb3B0aW9ucy5wYW5lIHx8ICdmbG9hdFBhbmUnO1xuICAgICAgICB0aGlzLmVuYWJsZUV2ZW50UHJvcGFnYXRpb24gPSBvcHRpb25zLmVuYWJsZUV2ZW50UHJvcGFnYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jbG9zZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3ZlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm1hcExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZXh0TGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXhlZFdpZHRoU2V0ID0gbnVsbDtcbiAgICB9XG4gICAgSW5mb0JveC5wcm90b3R5cGUuY3JlYXRlSW5mb0JveERpdiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVyIGlnbm9yZXMgdGhlIGN1cnJlbnQgZXZlbnQgaW4gdGhlIEluZm9Cb3ggYW5kIGNvbmRpdGlvbmFsbHkgcHJldmVudHNcbiAgICAgICAgLy8gdGhlIGV2ZW50IGZyb20gYmVpbmcgcGFzc2VkIG9uIHRvIHRoZSBtYXAuIEl0IGlzIHVzZWQgZm9yIHRoZSBjb250ZXh0bWVudSBldmVudC5cbiAgICAgICAgdmFyIGlnbm9yZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfdGhpcy5lbmFibGVFdmVudFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsSGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aGlzLnNldEJveFN0eWxlKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5pbm5lckhUTUwgPSB0aGlzLmdldENsb3NlQm94SW1nKCkgKyB0aGlzLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5pbm5lckhUTUwgPSB0aGlzLmdldENsb3NlQm94SW1nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYW5lcyA9IHRoaXMuZ2V0UGFuZXMoKTtcbiAgICAgICAgICAgIGlmIChwYW5lcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhbmVzW3RoaXMucGFuZV0uYXBwZW5kQ2hpbGQodGhpcy5kaXYpOyAvLyBBZGQgdGhlIEluZm9Cb3ggZGl2IHRvIHRoZSBET01cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkQ2xpY2tIYW5kbGVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXYuc3R5bGUud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeGVkV2lkdGhTZXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4V2lkdGggIT09IDAgJiYgdGhpcy5kaXYub2Zmc2V0V2lkdGggPiB0aGlzLm1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gdGhpcy5tYXhXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZml4ZWRXaWR0aFNldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgaXMgbmVlZGVkIHRvIG92ZXJjb21lIHByb2JsZW1zIHdpdGggTVNJRVxuICAgICAgICAgICAgICAgICAgICB2YXIgYncgPSB0aGlzLmdldEJveFdpZHRocygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS53aWR0aCA9IHRoaXMuZGl2Lm9mZnNldFdpZHRoIC0gYncubGVmdCAtIGJ3LnJpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXhlZFdpZHRoU2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYW5Cb3godGhpcy5kaXNhYmxlQXV0b1Bhbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBDYW5jZWwgZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogbW91c2Vtb3ZlIG5vdCBpbmNsdWRlZCAodG8gcmVzb2x2ZSBJc3N1ZSAxNTIpXG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50cyA9IFtcbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgICAgICdtb3VzZW92ZXInLFxuICAgICAgICAgICAgICAgICAgICAnbW91c2VvdXQnLFxuICAgICAgICAgICAgICAgICAgICAnbW91c2V1cCcsXG4gICAgICAgICAgICAgICAgICAgICdjbGljaycsXG4gICAgICAgICAgICAgICAgICAgICdkYmxjbGljaycsXG4gICAgICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGV2ZW50c18xID0gZXZlbnRzOyBfaSA8IGV2ZW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRfMSA9IGV2ZW50c18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5wdXNoKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZGl2LCBldmVudF8xLCBjYW5jZWxIYW5kbGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdvcmthcm91bmQgZm9yIEdvb2dsZSBidWcgdGhhdCBjYXVzZXMgdGhlIGN1cnNvciB0byBjaGFuZ2UgdG8gYSBwb2ludGVyXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0aGUgbW91c2UgbW92ZXMgb3ZlciBhIG1hcmtlciB1bmRlcm5lYXRoIEluZm9Cb3guXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5wdXNoKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZGl2LCAnbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGl2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXYuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250ZXh0TGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcih0aGlzLmRpdiwgJ2NvbnRleHRtZW51JywgaWdub3JlSGFuZGxlcik7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgRElWIGNvbnRhaW5pbmcgdGhlIEluZm9Cb3gncyBjb250ZW50IGlzIGF0dGFjaGVkIHRvIHRoZSBET00uXG4gICAgICAgICAgICAgKiBAbmFtZSBJbmZvQm94I2RvbXJlYWR5XG4gICAgICAgICAgICAgKiBAZXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAnZG9tcmVhZHknKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuZ2V0Q2xvc2VCb3hJbWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbWcgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VCb3hVUkwgIT09ICcnKSB7XG4gICAgICAgICAgICBpbWcgPSAnPGltZyBhbHQ9XCJcIic7XG4gICAgICAgICAgICBpbWcgKz0gJyBhcmlhLWhpZGRlbj1cInRydWVcIic7XG4gICAgICAgICAgICBpbWcgKz0gXCIgc3JjPSdcIiArIHRoaXMuY2xvc2VCb3hVUkwgKyBcIidcIjtcbiAgICAgICAgICAgIGltZyArPSAnIGFsaWduPXJpZ2h0JzsgLy8gRG8gdGhpcyBiZWNhdXNlIE9wZXJhIGNob2tlcyBvbiBzdHlsZT0nZmxvYXQ6IHJpZ2h0OydcbiAgICAgICAgICAgIGltZyArPSBcIiBzdHlsZT0nXCI7XG4gICAgICAgICAgICBpbWcgKz0gJyBwb3NpdGlvbjogcmVsYXRpdmU7JzsgLy8gUmVxdWlyZWQgYnkgTVNJRVxuICAgICAgICAgICAgaW1nICs9ICcgY3Vyc29yOiBwb2ludGVyOyc7XG4gICAgICAgICAgICBpbWcgKz0gJyBtYXJnaW46ICcgKyB0aGlzLmNsb3NlQm94TWFyZ2luICsgJzsnO1xuICAgICAgICAgICAgaW1nICs9IFwiJz5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW1nO1xuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuYWRkQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsb3NlTGlzdGVuZXIgPSB0aGlzLmRpdiAmJiB0aGlzLmRpdi5maXJzdENoaWxkICYmIHRoaXMuY2xvc2VCb3hVUkwgIT09ICcnXG4gICAgICAgICAgICA/IGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHRoaXMuZGl2LmZpcnN0Q2hpbGQsICdjbGljaycsIHRoaXMuZ2V0Q2xvc2VDbGlja0hhbmRsZXIoKSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmNsb3NlQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIDEuMC4zIGZpeDogQWx3YXlzIHByZXZlbnQgcHJvcGFnYXRpb24gb2YgYSBjbG9zZSBib3ggY2xpY2sgdG8gdGhlIG1hcDpcbiAgICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiB0aGUgSW5mb0JveCdzIGNsb3NlIGJveCBpcyBjbGlja2VkLlxuICAgICAgICAgKiBAbmFtZSBJbmZvQm94I2Nsb3NlY2xpY2tcbiAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsICdjbG9zZWNsaWNrJyk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmdldENsb3NlQ2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUNsaWNrSGFuZGxlcjtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLnBhbkJveCA9IGZ1bmN0aW9uIChkaXNhYmxlUGFuKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdiAmJiAhZGlzYWJsZVBhbikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICAgICAgICAvLyBPbmx5IHBhbiBpZiBhdHRhY2hlZCB0byBtYXAsIG5vdCBwYW5vcmFtYVxuICAgICAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLk1hcCkge1xuICAgICAgICAgICAgICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgeU9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGJvdW5kcyA9IG1hcC5nZXRCb3VuZHMoKTtcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRzICYmICFib3VuZHMuY29udGFpbnModGhpcy5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFya2VyIG5vdCBpbiB2aXNpYmxlIGFyZWEgb2YgbWFwLCBzbyBzZXQgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIG1hcCB0byB0aGUgbWFya2VyIHBvc2l0aW9uIGZpcnN0LlxuICAgICAgICAgICAgICAgICAgICBtYXAuc2V0Q2VudGVyKHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWFwRGl2ID0gbWFwLmdldERpdigpO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdmFyIG1hcFdpZHRoID0gbWFwRGl2Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdmFyIG1hcEhlaWdodCA9IG1hcERpdi5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIGl3T2Zmc2V0WCA9IHRoaXMucGl4ZWxPZmZzZXQud2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGl3T2Zmc2V0WSA9IHRoaXMucGl4ZWxPZmZzZXQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBpd1dpZHRoID0gdGhpcy5kaXYub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgdmFyIGl3SGVpZ2h0ID0gdGhpcy5kaXYub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBwYWRYID0gdGhpcy5pbmZvQm94Q2xlYXJhbmNlLndpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBwYWRZID0gdGhpcy5pbmZvQm94Q2xlYXJhbmNlLmhlaWdodDtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBpeFBvc2l0aW9uID0gcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9Db250YWluZXJQaXhlbCh0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBpZiAocGl4UG9zaXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpeFBvc2l0aW9uLnggPCAtaXdPZmZzZXRYICsgcGFkWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeE9mZnNldCA9IHBpeFBvc2l0aW9uLnggKyBpd09mZnNldFggLSBwYWRYO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBpeFBvc2l0aW9uLnggKyBpd1dpZHRoICsgaXdPZmZzZXRYICsgcGFkWCA+IG1hcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gcGl4UG9zaXRpb24ueCArIGl3V2lkdGggKyBpd09mZnNldFggKyBwYWRYIC0gbWFwV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxpZ25Cb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhQb3NpdGlvbi55IDwgLWl3T2Zmc2V0WSArIHBhZFkgKyBpd0hlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlPZmZzZXQgPSBwaXhQb3NpdGlvbi55ICsgaXdPZmZzZXRZIC0gcGFkWSAtIGl3SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGl4UG9zaXRpb24ueSArIGl3T2Zmc2V0WSArIHBhZFkgPiBtYXBIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0ID0gcGl4UG9zaXRpb24ueSArIGl3T2Zmc2V0WSArIHBhZFkgLSBtYXBIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4UG9zaXRpb24ueSA8IC1pd09mZnNldFkgKyBwYWRZKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeU9mZnNldCA9IHBpeFBvc2l0aW9uLnkgKyBpd09mZnNldFkgLSBwYWRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGl4UG9zaXRpb24ueSArIGl3SGVpZ2h0ICsgaXdPZmZzZXRZICsgcGFkWSA+IG1hcEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlPZmZzZXQgPSBwaXhQb3NpdGlvbi55ICsgaXdIZWlnaHQgKyBpd09mZnNldFkgKyBwYWRZIC0gbWFwSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKHhPZmZzZXQgPT09IDAgJiYgeU9mZnNldCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgbWFwIHRvIHRoZSBzaGlmdGVkIGNlbnRlci5cbiAgICAgICAgICAgICAgICAgICAgbWFwLnBhbkJ5KHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb0JveC5wcm90b3R5cGUuc2V0Qm94U3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgICAgICAgLy8gQXBwbHkgc3R5bGUgdmFsdWVzIGZyb20gdGhlIHN0eWxlIHNoZWV0IGRlZmluZWQgaW4gdGhlIGJveENsYXNzIHBhcmFtZXRlcjpcbiAgICAgICAgICAgIHRoaXMuZGl2LmNsYXNzTmFtZSA9IHRoaXMuYm94Q2xhc3M7XG4gICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyBpbmxpbmUgc3R5bGUgdmFsdWVzOlxuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuY3NzVGV4dCA9ICcnO1xuICAgICAgICAgICAgLy8gQXBwbHkgc3R5bGUgdmFsdWVzIGRlZmluZWQgaW4gdGhlIGJveFN0eWxlIHBhcmFtZXRlcjpcbiAgICAgICAgICAgIHZhciBib3hTdHlsZSA9IHRoaXMuYm94U3R5bGU7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGJveFN0eWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChib3hTdHlsZSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlW2ldID0gYm94U3R5bGVbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4IGZvciBpT1MgZGlzYXBwZWFyaW5nIEluZm9Cb3ggcHJvYmxlbVxuICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTIyOTUzNS9nb29nbGUtbWFwcy1tYXJrZXJzLWRpc2FwcGVhci1hdC1jZXJ0YWluLXpvb20tbGV2ZWwtb25seS1vbi1pcGhvbmUtaXBhZFxuICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVooMCknO1xuICAgICAgICAgICAgLy8gRml4IHVwIG9wYWNpdHkgc3R5bGUgZm9yIGJlbmVmaXQgb2YgTVNJRVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpdi5zdHlsZS5vcGFjaXR5ICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLmRpdi5zdHlsZS5vcGFjaXR5ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Nzcy9vcGFjaXR5Lmh0bWxcbiAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eSA9IHBhcnNlRmxvYXQodGhpcy5kaXYuc3R5bGUub3BhY2l0eSB8fCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5tc0ZpbHRlciA9XG4gICAgICAgICAgICAgICAgICAgICdcInByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5BbHBoYShPcGFjaXR5PScgKyBvcGFjaXR5ICogMTAwICsgJylcIic7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUuZmlsdGVyID0gJ2FscGhhKG9wYWNpdHk9JyArIG9wYWNpdHkgKiAxMDAgKyAnKSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBseSByZXF1aXJlZCBzdHlsZXNcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGlmICh0aGlzLnpJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IHRoaXMuekluZGV4ICsgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGl2LnN0eWxlLm92ZXJmbG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmdldEJveFdpZHRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ3ID0geyB0b3A6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgcmlnaHQ6IDAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmRpdikge1xuICAgICAgICAgICAgcmV0dXJuIGJ3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgICAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSB0aGlzLmRpdi5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSBvd25lckRvY3VtZW50ICYmIG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXdcbiAgICAgICAgICAgICAgICA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmRpdiwgJycpXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29tcHV0ZWQgc3R5bGVzIGFyZSBhbHdheXMgaW4gcGl4ZWwgdW5pdHMgKGdvb2QhKVxuICAgICAgICAgICAgICAgIGJ3LnRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGggfHwgJycsIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIGJ3LmJvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGggfHwgJycsIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIGJ3LmxlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgYncucmlnaHQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGggfHwgJycsIDEwKSB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmN1cnJlbnRTdHlsZSAvLyBNU0lFXG4gICAgICAgICkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdHlsZSA9IHRoaXMuZGl2LmN1cnJlbnRTdHlsZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3R5bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY3VycmVudCBzdHlsZXMgbWF5IG5vdCBiZSBpbiBwaXhlbCB1bml0cywgYnV0IGFzc3VtZSB0aGV5IGFyZSAoYmFkISlcbiAgICAgICAgICAgICAgICBidy50b3AgPSBwYXJzZUludChjdXJyZW50U3R5bGUuYm9yZGVyVG9wV2lkdGggfHwgJycsIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIGJ3LmJvdHRvbSA9IHBhcnNlSW50KGN1cnJlbnRTdHlsZS5ib3JkZXJCb3R0b21XaWR0aCB8fCAnJywgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgYncubGVmdCA9IHBhcnNlSW50KGN1cnJlbnRTdHlsZS5ib3JkZXJMZWZ0V2lkdGggfHwgJycsIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIGJ3LnJpZ2h0ID0gcGFyc2VJbnQoY3VycmVudFN0eWxlLmJvcmRlclJpZ2h0V2lkdGggfHwgJycsIDEwKSB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidztcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXYgJiYgdGhpcy5kaXYucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7XG4gICAgICAgICAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY3JlYXRlSW5mb0JveERpdigpO1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgcGl4UG9zaXRpb24gPSBwcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKHBpeFBvc2l0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUubGVmdCA9IHBpeFBvc2l0aW9uLnggKyB0aGlzLnBpeGVsT2Zmc2V0LndpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGlnbkJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS5ib3R0b20gPSAtKHBpeFBvc2l0aW9uLnkgKyB0aGlzLnBpeGVsT2Zmc2V0LmhlaWdodCkgKyAncHgnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuc3R5bGUudG9wID0gcGl4UG9zaXRpb24ueSArIHRoaXMucGl4ZWxPZmZzZXQuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYm94Q2xhc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBNdXN0IGJlIGZpcnN0XG4gICAgICAgICAgICB0aGlzLmJveENsYXNzID0gb3B0aW9ucy5ib3hDbGFzcztcbiAgICAgICAgICAgIHRoaXMuc2V0Qm94U3R5bGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYm94U3R5bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBNdXN0IGJlIHNlY29uZFxuICAgICAgICAgICAgdGhpcy5ib3hTdHlsZSA9IG9wdGlvbnMuYm94U3R5bGU7XG4gICAgICAgICAgICB0aGlzLnNldEJveFN0eWxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbnRlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRlbnQob3B0aW9ucy5jb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGlzYWJsZUF1dG9QYW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVBdXRvUGFuID0gb3B0aW9ucy5kaXNhYmxlQXV0b1BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubWF4V2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLm1heFdpZHRoID0gb3B0aW9ucy5tYXhXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucGl4ZWxPZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnBpeGVsT2Zmc2V0ID0gb3B0aW9ucy5waXhlbE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxpZ25Cb3R0b20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmFsaWduQm90dG9tID0gb3B0aW9ucy5hbGlnbkJvdHRvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucG9zaXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKG9wdGlvbnMucG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy56SW5kZXggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFpJbmRleChvcHRpb25zLnpJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNsb3NlQm94TWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUJveE1hcmdpbiA9IG9wdGlvbnMuY2xvc2VCb3hNYXJnaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmNsb3NlQm94VVJMICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUJveFVSTCA9IG9wdGlvbnMuY2xvc2VCb3hVUkw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmluZm9Cb3hDbGVhcmFuY2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmluZm9Cb3hDbGVhcmFuY2UgPSBvcHRpb25zLmluZm9Cb3hDbGVhcmFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmlzSGlkZGVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IG9wdGlvbnMuaXNIaWRkZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gIW9wdGlvbnMudmlzaWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbiA9IG9wdGlvbnMuZW5hYmxlRXZlbnRQcm9wYWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5jbG9zZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT2RkIGNvZGUgcmVxdWlyZWQgdG8gbWFrZSB0aGluZ3Mgd29yayB3aXRoIE1TSUUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuZml4ZWRXaWR0aFNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpICsgY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LmlubmVySFRNTCA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBlcnZlcnNlIGNvZGUgcmVxdWlyZWQgdG8gbWFrZSB0aGluZ3Mgd29yayB3aXRoIE1TSUUuXG4gICAgICAgICAgICAvLyAoRW5zdXJlcyB0aGUgY2xvc2UgYm94IGRvZXMsIGluIGZhY3QsIGZsb2F0IHRvIHRoZSByaWdodC4pXG4gICAgICAgICAgICBpZiAoIXRoaXMuZml4ZWRXaWR0aFNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gdGhpcy5kaXYub2Zmc2V0V2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuaW5uZXJIVE1MID0gdGhpcy5nZXRDbG9zZUJveEltZygpICsgY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGl2LmlubmVySFRNTCA9IHRoaXMuZ2V0Q2xvc2VCb3hJbWcoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRDbGlja0hhbmRsZXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBjb250ZW50IG9mIHRoZSBJbmZvQm94IGNoYW5nZXMuXG4gICAgICAgICAqIEBuYW1lIEluZm9Cb3gjY29udGVudF9jaGFuZ2VkXG4gICAgICAgICAqIEBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAnY29udGVudF9jaGFuZ2VkJyk7XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChsYXRMbmcpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGxhdExuZztcbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBldmVudCBpcyBmaXJlZCB3aGVuIHRoZSBwb3NpdGlvbiBvZiB0aGUgSW5mb0JveCBjaGFuZ2VzLlxuICAgICAgICAgKiBAbmFtZSBJbmZvQm94I3Bvc2l0aW9uX2NoYW5nZWRcbiAgICAgICAgICogQGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsICdwb3NpdGlvbl9jaGFuZ2VkJyk7XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5zZXRWaXNpYmxlID0gZnVuY3Rpb24gKGlzVmlzaWJsZSkge1xuICAgICAgICB0aGlzLmlzSGlkZGVuID0gIWlzVmlzaWJsZTtcbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gdGhpcy5pc0hpZGRlbiA/ICdoaWRkZW4nIDogJ3Zpc2libGUnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5zZXRaSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdGhpcy56SW5kZXggPSBpbmRleDtcbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSBpbmRleCArICcnO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gdGhlIHpJbmRleCBvZiB0aGUgSW5mb0JveCBjaGFuZ2VzLlxuICAgICAgICAgKiBAbmFtZSBJbmZvQm94I3ppbmRleF9jaGFuZ2VkXG4gICAgICAgICAqIEBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCAnemluZGV4X2NoYW5nZWQnKTtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmdldENvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb247XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5nZXRaSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnpJbmRleDtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmdldFZpc2libGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1hcCA9PT0gJ3VuZGVmaW5lZCcgfHwgbWFwID09PSBudWxsID8gZmFsc2UgOiAhdGhpcy5pc0hpZGRlbjtcbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICAgICAgICB0aGlzLmRpdi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAobWFwLCBhbmNob3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IGFuY2hvci5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5tb3ZlTGlzdGVuZXIgPSBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihhbmNob3IsICdwb3NpdGlvbl9jaGFuZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gYW5jaG9yLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1hcExpc3RlbmVyID0gZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoYW5jaG9yLCAnbWFwX2NoYW5nZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRNYXAoYW5jaG9yLm1hcCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE1hcChtYXApO1xuICAgICAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgICAgICAgIHRoaXMucGFuQm94KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3gucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmNsb3NlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMuZXZlbnRMaXN0ZW5lcnM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50TGlzdGVuZXIgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMubW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMubW92ZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXBMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIodGhpcy5tYXBMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLm1hcExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZXh0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHRoaXMuY29udGV4dExpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dExpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5zZXRNYXAobnVsbCk7XG4gICAgfTtcbiAgICBJbmZvQm94LnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAob2JqMSwgb2JqMikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlFeHRlbmQob2JqZWN0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBvYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3RvdHlwZVtwcm9wZXJ0eV0gPSBvYmplY3QucHJvdG90eXBlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfS5hcHBseShvYmoxLCBbb2JqMl0pO1xuICAgIH07XG4gICAgcmV0dXJuIEluZm9Cb3g7XG59KCkpO1xuXG52YXIgZXZlbnRNYXAkZCA9IHtcbiAgICBvbkNsb3NlQ2xpY2s6ICdjbG9zZWNsaWNrJyxcbiAgICBvbkNvbnRlbnRDaGFuZ2VkOiAnY29udGVudF9jaGFuZ2VkJyxcbiAgICBvbkRvbVJlYWR5OiAnZG9tcmVhZHknLFxuICAgIG9uUG9zaXRpb25DaGFuZ2VkOiAncG9zaXRpb25fY2hhbmdlZCcsXG4gICAgb25aaW5kZXhDaGFuZ2VkOiAnemluZGV4X2NoYW5nZWQnLFxufTtcbnZhciB1cGRhdGVyTWFwJGQgPSB7XG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKG5ldyBnb29nbGUubWFwcy5MYXRMbmcocG9zaXRpb24ubGF0LCBwb3NpdGlvbi5sbmcpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdmlzaWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbiAgICB6SW5kZXg6IGZ1bmN0aW9uIChpbnN0YW5jZSwgekluZGV4KSB7XG4gICAgICAgIGluc3RhbmNlLnNldFpJbmRleCh6SW5kZXgpO1xuICAgIH0sXG59O1xudmFyIGRlZmF1bHRPcHRpb25zJDMgPSB7fTtcbmZ1bmN0aW9uIEluZm9Cb3hGdW5jdGlvbmFsKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGFuY2hvciA9IF9hLmFuY2hvciwgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIHBvc2l0aW9uID0gX2EucG9zaXRpb24sIHpJbmRleCA9IF9hLnpJbmRleCwgb25DbG9zZUNsaWNrID0gX2Eub25DbG9zZUNsaWNrLCBvbkRvbVJlYWR5ID0gX2Eub25Eb21SZWFkeSwgb25Db250ZW50Q2hhbmdlZCA9IF9hLm9uQ29udGVudENoYW5nZWQsIG9uUG9zaXRpb25DaGFuZ2VkID0gX2Eub25Qb3NpdGlvbkNoYW5nZWQsIG9uWmluZGV4Q2hhbmdlZCA9IF9hLm9uWmluZGV4Q2hhbmdlZCwgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gdXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gdXNlU3RhdGUobnVsbCksIGNsb3NlQ2xpY2tMaXN0ZW5lciA9IF9jWzBdLCBzZXRDbG9zZUNsaWNrTGlzdGVuZXIgPSBfY1sxXTtcbiAgICB2YXIgX2QgPSB1c2VTdGF0ZShudWxsKSwgZG9tUmVhZHlDbGlja0xpc3RlbmVyID0gX2RbMF0sIHNldERvbVJlYWR5Q2xpY2tMaXN0ZW5lciA9IF9kWzFdO1xuICAgIHZhciBfZSA9IHVzZVN0YXRlKG51bGwpLCBjb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXIgPSBfZVswXSwgc2V0Q29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gdXNlU3RhdGUobnVsbCksIHBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIgPSBfZlswXSwgc2V0UG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lciA9IF9mWzFdO1xuICAgIHZhciBfZyA9IHVzZVN0YXRlKG51bGwpLCB6SW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lciA9IF9nWzBdLCBzZXRaaW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lciA9IF9nWzFdO1xuICAgIHZhciBjb250YWluZXJFbGVtZW50UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5vcGVuKG1hcCwgYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmdldFBvc2l0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5vcGVuKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbWFwLCBpbnN0YW5jZSwgYW5jaG9yXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocG9zaXRpb24gJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkxhdExuZyA9IHBvc2l0aW9uIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nXG4gICAgICAgICAgICAgICAgPyBwb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgOiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHBvc2l0aW9uLmxhdCwgcG9zaXRpb24ubG5nKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uTGF0TG5nKTtcbiAgICAgICAgfVxuICAgIH0sIFtwb3NpdGlvbl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgekluZGV4ID09PSAnbnVtYmVyJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgICAgIH1cbiAgICB9LCBbekluZGV4XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2xvc2VDbGljaykge1xuICAgICAgICAgICAgaWYgKGNsb3NlQ2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsb3NlQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDbG9zZUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbG9zZWNsaWNrJywgb25DbG9zZUNsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbG9zZUNsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRG9tUmVhZHkpIHtcbiAgICAgICAgICAgIGlmIChkb21SZWFkeUNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkb21SZWFkeUNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RG9tUmVhZHlDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZG9tcmVhZHknLCBvbkRvbVJlYWR5KSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Eb21SZWFkeV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkNvbnRlbnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NvbnRlbnRfY2hhbmdlZCcsIG9uQ29udGVudENoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNvbnRlbnRDaGFuZ2VkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uUG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3Bvc2l0aW9uX2NoYW5nZWQnLCBvblBvc2l0aW9uQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uUG9zaXRpb25DaGFuZ2VkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uWmluZGV4Q2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHpJbmRleENoYW5nZWRDbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoekluZGV4Q2hhbmdlZENsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0WmluZGV4Q2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICd6aW5kZXhfY2hhbmdlZCcsIG9uWmluZGV4Q2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uWmluZGV4Q2hhbmdlZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgIHZhciBfYSA9IG9wdGlvbnMgfHwgZGVmYXVsdE9wdGlvbnMkMywgcG9zaXRpb25fMSA9IF9hLnBvc2l0aW9uLCBpbmZvQm94T3B0aW9ucyA9IF9fcmVzdCQxKF9hLCBbXCJwb3NpdGlvblwiXSk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25MYXRMbmcgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25fMSAmJiAhKHBvc2l0aW9uXzEgaW5zdGFuY2VvZiBnb29nbGUubWFwcy5MYXRMbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkxhdExuZyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmcocG9zaXRpb25fMS5sYXQsIHBvc2l0aW9uXzEubG5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmZvQm94ID0gbmV3IEluZm9Cb3goX19hc3NpZ24oX19hc3NpZ24oe30sIGluZm9Cb3hPcHRpb25zKSwgKHBvc2l0aW9uTGF0TG5nID8geyBwb3NpdGlvbjogcG9zaXRpb25MYXRMbmcgfSA6IHt9KSkpO1xuICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudFJlZi5jdXJyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzZXRJbnN0YW5jZShpbmZvQm94KTtcbiAgICAgICAgICAgIGlmIChvbkNsb3NlQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBzZXRDbG9zZUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb0JveCwgJ2Nsb3NlY2xpY2snLCBvbkNsb3NlQ2xpY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkRvbVJlYWR5KSB7XG4gICAgICAgICAgICAgICAgc2V0RG9tUmVhZHlDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9Cb3gsICdkb21yZWFkeScsIG9uRG9tUmVhZHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNvbnRlbnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgc2V0Q29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9Cb3gsICdjb250ZW50X2NoYW5nZWQnLCBvbkNvbnRlbnRDaGFuZ2VkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Qb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRQb3NpdGlvbkNoYW5nZWRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9Cb3gsICdwb3NpdGlvbl9jaGFuZ2VkJywgb25Qb3NpdGlvbkNoYW5nZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblppbmRleENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRaaW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvQm94LCAnemluZGV4X2NoYW5nZWQnLCBvblppbmRleENoYW5nZWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZm9Cb3guc2V0Q29udGVudChjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgICAgIGluZm9Cb3gub3BlbihtYXAsIGFuY2hvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpbmZvQm94LmdldFBvc2l0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBpbmZvQm94Lm9wZW4obWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmFyaWFudCQxKGZhbHNlLCAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gYW5jaG9yIG9yIGEgcG9zaXRpb24gcHJvcCBmb3IgPEluZm9Cb3g+LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgICAgIG9uTG9hZChpbmZvQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3NlQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbG9zZUNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudENoYW5nZWRDbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkb21SZWFkeUNsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZG9tUmVhZHlDbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh6SW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih6SW5kZXhDaGFuZ2VkQ2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Vbm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lckVsZW1lbnRSZWYuY3VycmVudCA/IGNyZWF0ZVBvcnRhbChDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKSwgY29udGFpbmVyRWxlbWVudFJlZi5jdXJyZW50KSA6IG51bGw7XG59XG52YXIgSW5mb0JveEYgPSBtZW1vKEluZm9Cb3hGdW5jdGlvbmFsKTtcbnZhciBJbmZvQm94Q29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbmZvQm94Q29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluZm9Cb3hDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLmNvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGluZm9Cb3g6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9wZW4gPSBmdW5jdGlvbiAoaW5mb0JveCwgYW5jaG9yKSB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mb0JveC5vcGVuKF90aGlzLmNvbnRleHQsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5mb0JveC5nZXRQb3NpdGlvbigpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5mb0JveC5vcGVuKF90aGlzLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmFyaWFudCQxKGZhbHNlLCAnWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gYW5jaG9yIG9yIGEgcG9zaXRpb24gcHJvcCBmb3IgPEluZm9Cb3g+LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRJbmZvQm94Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuaW5mb0JveCAhPT0gbnVsbCAmJiBfdGhpcy5jb250YWluZXJFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUuaW5mb0JveC5zZXRDb250ZW50KF90aGlzLmNvbnRhaW5lckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9wZW4oX3RoaXMuc3RhdGUuaW5mb0JveCwgX3RoaXMucHJvcHMuYW5jaG9yKTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5pbmZvQm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSW5mb0JveENvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSwgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgaW5mb0JveE9wdGlvbnMgPSBfX3Jlc3QkMShfYSwgW1wicG9zaXRpb25cIl0pO1xuICAgICAgICB2YXIgcG9zaXRpb25MYXRMbmc7XG4gICAgICAgIGlmIChwb3NpdGlvbiAmJiAhKHBvc2l0aW9uIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcG9zaXRpb25MYXRMbmcgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHBvc2l0aW9uLmxhdCwgcG9zaXRpb24ubG5nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5mb0JveCA9IG5ldyBJbmZvQm94KF9fYXNzaWduKF9fYXNzaWduKHt9LCBpbmZvQm94T3B0aW9ucyksIChwb3NpdGlvbkxhdExuZyA/IHsgcG9zaXRpb246IHBvc2l0aW9uTGF0TG5nIH0gOiB7fSkpKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRkLFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGQsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluZm9Cb3gsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaW5mb0JveDogaW5mb0JveCB9LCB0aGlzLnNldEluZm9Cb3hDYWxsYmFjayk7XG4gICAgfTtcbiAgICBJbmZvQm94Q29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBpbmZvQm94ID0gdGhpcy5zdGF0ZS5pbmZvQm94O1xuICAgICAgICBpZiAoaW5mb0JveCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCRkLFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRkLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5mb0JveCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBJbmZvQm94Q29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9uVW5tb3VudCA9IHRoaXMucHJvcHMub25Vbm1vdW50O1xuICAgICAgICB2YXIgaW5mb0JveCA9IHRoaXMuc3RhdGUuaW5mb0JveDtcbiAgICAgICAgaWYgKGluZm9Cb3ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQoaW5mb0JveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICBpbmZvQm94LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEluZm9Cb3hDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyRWxlbWVudCA/IGNyZWF0ZVBvcnRhbChDaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB0aGlzLmNvbnRhaW5lckVsZW1lbnQpIDogbnVsbDtcbiAgICB9O1xuICAgIEluZm9Cb3hDb21wb25lbnQuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBJbmZvQm94Q29tcG9uZW50O1xufShQdXJlQ29tcG9uZW50KSk7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxudmFyIGZhc3REZWVwRXF1YWwgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcblxudmFyIGVxdWFsID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZhc3REZWVwRXF1YWwpO1xuXG5jb25zdCBBUlJBWV9UWVBFUyA9IFtcbiAgICBJbnQ4QXJyYXksIFVpbnQ4QXJyYXksIFVpbnQ4Q2xhbXBlZEFycmF5LCBJbnQxNkFycmF5LCBVaW50MTZBcnJheSxcbiAgICBJbnQzMkFycmF5LCBVaW50MzJBcnJheSwgRmxvYXQzMkFycmF5LCBGbG9hdDY0QXJyYXlcbl07XG5cbi8qKiBAdHlwZWRlZiB7SW50OEFycmF5Q29uc3RydWN0b3IgfCBVaW50OEFycmF5Q29uc3RydWN0b3IgfCBVaW50OENsYW1wZWRBcnJheUNvbnN0cnVjdG9yIHwgSW50MTZBcnJheUNvbnN0cnVjdG9yIHwgVWludDE2QXJyYXlDb25zdHJ1Y3RvciB8IEludDMyQXJyYXlDb25zdHJ1Y3RvciB8IFVpbnQzMkFycmF5Q29uc3RydWN0b3IgfCBGbG9hdDMyQXJyYXlDb25zdHJ1Y3RvciB8IEZsb2F0NjRBcnJheUNvbnN0cnVjdG9yfSBUeXBlZEFycmF5Q29uc3RydWN0b3IgKi9cblxuY29uc3QgVkVSU0lPTiA9IDE7IC8vIHNlcmlhbGl6ZWQgZm9ybWF0IHZlcnNpb25cbmNvbnN0IEhFQURFUl9TSVpFID0gODtcblxuY2xhc3MgS0RCdXNoIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5kZXggZnJvbSByYXcgYEFycmF5QnVmZmVyYCBkYXRhLlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShkYXRhKSB7XG4gICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGF0YSBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIEFycmF5QnVmZmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFttYWdpYywgdmVyc2lvbkFuZFR5cGVdID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSwgMCwgMik7XG4gICAgICAgIGlmIChtYWdpYyAhPT0gMHhkYikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGRvZXMgbm90IGFwcGVhciB0byBiZSBpbiBhIEtEQnVzaCBmb3JtYXQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHZlcnNpb25BbmRUeXBlID4+IDQ7XG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBWRVJTSU9OKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB2JHt2ZXJzaW9ufSBkYXRhIHdoZW4gZXhwZWN0ZWQgdiR7VkVSU0lPTn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgQXJyYXlUeXBlID0gQVJSQVlfVFlQRVNbdmVyc2lvbkFuZFR5cGUgJiAweDBmXTtcbiAgICAgICAgaWYgKCFBcnJheVR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGFycmF5IHR5cGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW25vZGVTaXplXSA9IG5ldyBVaW50MTZBcnJheShkYXRhLCAyLCAxKTtcbiAgICAgICAgY29uc3QgW251bUl0ZW1zXSA9IG5ldyBVaW50MzJBcnJheShkYXRhLCA0LCAxKTtcblxuICAgICAgICByZXR1cm4gbmV3IEtEQnVzaChudW1JdGVtcywgbm9kZVNpemUsIEFycmF5VHlwZSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbmRleCB0aGF0IHdpbGwgaG9sZCBhIGdpdmVuIG51bWJlciBvZiBpdGVtcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtSXRlbXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW25vZGVTaXplPTY0XSBTaXplIG9mIHRoZSBLRC10cmVlIG5vZGUgKDY0IGJ5IGRlZmF1bHQpLlxuICAgICAqIEBwYXJhbSB7VHlwZWRBcnJheUNvbnN0cnVjdG9yfSBbQXJyYXlUeXBlPUZsb2F0NjRBcnJheV0gVGhlIGFycmF5IHR5cGUgdXNlZCBmb3IgY29vcmRpbmF0ZXMgc3RvcmFnZSAoYEZsb2F0NjRBcnJheWAgYnkgZGVmYXVsdCkuXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gW2RhdGFdIChGb3IgaW50ZXJuYWwgdXNlIG9ubHkpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobnVtSXRlbXMsIG5vZGVTaXplID0gNjQsIEFycmF5VHlwZSA9IEZsb2F0NjRBcnJheSwgZGF0YSkge1xuICAgICAgICBpZiAoaXNOYU4obnVtSXRlbXMpIHx8IG51bUl0ZW1zIDwgMCkgdGhyb3cgbmV3IEVycm9yKGBVbnBleHBlY3RlZCBudW1JdGVtcyB2YWx1ZTogJHtudW1JdGVtc30uYCk7XG5cbiAgICAgICAgdGhpcy5udW1JdGVtcyA9ICtudW1JdGVtcztcbiAgICAgICAgdGhpcy5ub2RlU2l6ZSA9IE1hdGgubWluKE1hdGgubWF4KCtub2RlU2l6ZSwgMiksIDY1NTM1KTtcbiAgICAgICAgdGhpcy5BcnJheVR5cGUgPSBBcnJheVR5cGU7XG4gICAgICAgIHRoaXMuSW5kZXhBcnJheVR5cGUgPSBudW1JdGVtcyA8IDY1NTM2ID8gVWludDE2QXJyYXkgOiBVaW50MzJBcnJheTtcblxuICAgICAgICBjb25zdCBhcnJheVR5cGVJbmRleCA9IEFSUkFZX1RZUEVTLmluZGV4T2YodGhpcy5BcnJheVR5cGUpO1xuICAgICAgICBjb25zdCBjb29yZHNCeXRlU2l6ZSA9IG51bUl0ZW1zICogMiAqIHRoaXMuQXJyYXlUeXBlLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICBjb25zdCBpZHNCeXRlU2l6ZSA9IG51bUl0ZW1zICogdGhpcy5JbmRleEFycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgY29uc3QgcGFkQ29vcmRzID0gKDggLSBpZHNCeXRlU2l6ZSAlIDgpICUgODtcblxuICAgICAgICBpZiAoYXJyYXlUeXBlSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZWQgYXJyYXkgY2xhc3M6ICR7QXJyYXlUeXBlfS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhICYmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7IC8vIHJlY29uc3RydWN0IGFuIGluZGV4IGZyb20gYSBidWZmZXJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLmlkcyA9IG5ldyB0aGlzLkluZGV4QXJyYXlUeXBlKHRoaXMuZGF0YSwgSEVBREVSX1NJWkUsIG51bUl0ZW1zKTtcbiAgICAgICAgICAgIHRoaXMuY29vcmRzID0gbmV3IHRoaXMuQXJyYXlUeXBlKHRoaXMuZGF0YSwgSEVBREVSX1NJWkUgKyBpZHNCeXRlU2l6ZSArIHBhZENvb3JkcywgbnVtSXRlbXMgKiAyKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcyA9IG51bUl0ZW1zICogMjtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHsgLy8gaW5pdGlhbGl6ZSBhIG5ldyBpbmRleFxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEFycmF5QnVmZmVyKEhFQURFUl9TSVpFICsgY29vcmRzQnl0ZVNpemUgKyBpZHNCeXRlU2l6ZSArIHBhZENvb3Jkcyk7XG4gICAgICAgICAgICB0aGlzLmlkcyA9IG5ldyB0aGlzLkluZGV4QXJyYXlUeXBlKHRoaXMuZGF0YSwgSEVBREVSX1NJWkUsIG51bUl0ZW1zKTtcbiAgICAgICAgICAgIHRoaXMuY29vcmRzID0gbmV3IHRoaXMuQXJyYXlUeXBlKHRoaXMuZGF0YSwgSEVBREVSX1NJWkUgKyBpZHNCeXRlU2l6ZSArIHBhZENvb3JkcywgbnVtSXRlbXMgKiAyKTtcbiAgICAgICAgICAgIHRoaXMuX3BvcyA9IDA7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAvLyBzZXQgaGVhZGVyXG4gICAgICAgICAgICBuZXcgVWludDhBcnJheSh0aGlzLmRhdGEsIDAsIDIpLnNldChbMHhkYiwgKFZFUlNJT04gPDwgNCkgKyBhcnJheVR5cGVJbmRleF0pO1xuICAgICAgICAgICAgbmV3IFVpbnQxNkFycmF5KHRoaXMuZGF0YSwgMiwgMSlbMF0gPSBub2RlU2l6ZTtcbiAgICAgICAgICAgIG5ldyBVaW50MzJBcnJheSh0aGlzLmRhdGEsIDQsIDEpWzBdID0gbnVtSXRlbXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBwb2ludCB0byB0aGUgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEFuIGluY3JlbWVudGFsIGluZGV4IGFzc29jaWF0ZWQgd2l0aCB0aGUgYWRkZWQgaXRlbSAoc3RhcnRpbmcgZnJvbSBgMGApLlxuICAgICAqL1xuICAgIGFkZCh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcG9zID4+IDE7XG4gICAgICAgIHRoaXMuaWRzW2luZGV4XSA9IGluZGV4O1xuICAgICAgICB0aGlzLmNvb3Jkc1t0aGlzLl9wb3MrK10gPSB4O1xuICAgICAgICB0aGlzLmNvb3Jkc1t0aGlzLl9wb3MrK10gPSB5O1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBpbmRleGluZyBvZiB0aGUgYWRkZWQgcG9pbnRzLlxuICAgICAqL1xuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgY29uc3QgbnVtQWRkZWQgPSB0aGlzLl9wb3MgPj4gMTtcbiAgICAgICAgaWYgKG51bUFkZGVkICE9PSB0aGlzLm51bUl0ZW1zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZGVkICR7bnVtQWRkZWR9IGl0ZW1zIHdoZW4gZXhwZWN0ZWQgJHt0aGlzLm51bUl0ZW1zfS5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZC1zb3J0IGJvdGggYXJyYXlzIGZvciBlZmZpY2llbnQgc2VhcmNoXG4gICAgICAgIHNvcnQodGhpcy5pZHMsIHRoaXMuY29vcmRzLCB0aGlzLm5vZGVTaXplLCAwLCB0aGlzLm51bUl0ZW1zIC0gMSwgMCk7XG5cbiAgICAgICAgdGhpcy5fZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggdGhlIGluZGV4IGZvciBpdGVtcyB3aXRoaW4gYSBnaXZlbiBib3VuZGluZyBib3guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWluWVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhYXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heFlcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IEFuIGFycmF5IG9mIGluZGljZXMgY29ycmVwb25kaW5nIHRvIHRoZSBmb3VuZCBpdGVtcy5cbiAgICAgKi9cbiAgICByYW5nZShtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHRocm93IG5ldyBFcnJvcignRGF0YSBub3QgeWV0IGluZGV4ZWQgLSBjYWxsIGluZGV4LmZpbmlzaCgpLicpO1xuXG4gICAgICAgIGNvbnN0IHtpZHMsIGNvb3Jkcywgbm9kZVNpemV9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbMCwgaWRzLmxlbmd0aCAtIDEsIDBdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgICAvLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIGl0ZW1zIGluIHJhbmdlIGluIHRoZSBrZC1zb3J0ZWQgYXJyYXlzXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGF4aXMgPSBzdGFjay5wb3AoKSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBzdGFjay5wb3AoKSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHN0YWNrLnBvcCgpIHx8IDA7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgXCJ0cmVlIG5vZGVcIiwgc2VhcmNoIGxpbmVhcmx5XG4gICAgICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG5vZGVTaXplKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4ID0gY29vcmRzWzIgKiBpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IGNvb3Jkc1syICogaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeCA+PSBtaW5YICYmIHggPD0gbWF4WCAmJiB5ID49IG1pblkgJiYgeSA8PSBtYXhZKSByZXN1bHQucHVzaChpZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZpbmQgdGhlIG1pZGRsZSBpbmRleFxuICAgICAgICAgICAgY29uc3QgbSA9IChsZWZ0ICsgcmlnaHQpID4+IDE7XG5cbiAgICAgICAgICAgIC8vIGluY2x1ZGUgdGhlIG1pZGRsZSBpdGVtIGlmIGl0J3MgaW4gcmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IHggPSBjb29yZHNbMiAqIG1dO1xuICAgICAgICAgICAgY29uc3QgeSA9IGNvb3Jkc1syICogbSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPj0gbWluWCAmJiB4IDw9IG1heFggJiYgeSA+PSBtaW5ZICYmIHkgPD0gbWF4WSkgcmVzdWx0LnB1c2goaWRzW21dKTtcblxuICAgICAgICAgICAgLy8gcXVldWUgc2VhcmNoIGluIGhhbHZlcyB0aGF0IGludGVyc2VjdCB0aGUgcXVlcnlcbiAgICAgICAgICAgIGlmIChheGlzID09PSAwID8gbWluWCA8PSB4IDogbWluWSA8PSB5KSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChsZWZ0KTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG0gLSAxKTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKDEgLSBheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChheGlzID09PSAwID8gbWF4WCA+PSB4IDogbWF4WSA+PSB5KSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChtICsgMSk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChyaWdodCk7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCgxIC0gYXhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCB0aGUgaW5kZXggZm9yIGl0ZW1zIHdpdGhpbiBhIGdpdmVuIHJhZGl1cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gciBRdWVyeSByYWRpdXMuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBBbiBhcnJheSBvZiBpbmRpY2VzIGNvcnJlcG9uZGluZyB0byB0aGUgZm91bmQgaXRlbXMuXG4gICAgICovXG4gICAgd2l0aGluKHF4LCBxeSwgcikge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpbmlzaGVkKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgbm90IHlldCBpbmRleGVkIC0gY2FsbCBpbmRleC5maW5pc2goKS4nKTtcblxuICAgICAgICBjb25zdCB7aWRzLCBjb29yZHMsIG5vZGVTaXplfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gWzAsIGlkcy5sZW5ndGggLSAxLCAwXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IHIyID0gciAqIHI7XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBpdGVtcyB3aXRoaW4gcmFkaXVzIGluIHRoZSBrZC1zb3J0ZWQgYXJyYXlzXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGF4aXMgPSBzdGFjay5wb3AoKSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBzdGFjay5wb3AoKSB8fCAwO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHN0YWNrLnBvcCgpIHx8IDA7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIHJlYWNoZWQgXCJ0cmVlIG5vZGVcIiwgc2VhcmNoIGxpbmVhcmx5XG4gICAgICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG5vZGVTaXplKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxlZnQ7IGkgPD0gcmlnaHQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3FEaXN0KGNvb3Jkc1syICogaV0sIGNvb3Jkc1syICogaSArIDFdLCBxeCwgcXkpIDw9IHIyKSByZXN1bHQucHVzaChpZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZpbmQgdGhlIG1pZGRsZSBpbmRleFxuICAgICAgICAgICAgY29uc3QgbSA9IChsZWZ0ICsgcmlnaHQpID4+IDE7XG5cbiAgICAgICAgICAgIC8vIGluY2x1ZGUgdGhlIG1pZGRsZSBpdGVtIGlmIGl0J3MgaW4gcmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IHggPSBjb29yZHNbMiAqIG1dO1xuICAgICAgICAgICAgY29uc3QgeSA9IGNvb3Jkc1syICogbSArIDFdO1xuICAgICAgICAgICAgaWYgKHNxRGlzdCh4LCB5LCBxeCwgcXkpIDw9IHIyKSByZXN1bHQucHVzaChpZHNbbV0pO1xuXG4gICAgICAgICAgICAvLyBxdWV1ZSBzZWFyY2ggaW4gaGFsdmVzIHRoYXQgaW50ZXJzZWN0IHRoZSBxdWVyeVxuICAgICAgICAgICAgaWYgKGF4aXMgPT09IDAgPyBxeCAtIHIgPD0geCA6IHF5IC0gciA8PSB5KSB7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChsZWZ0KTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG0gLSAxKTtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKDEgLSBheGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChheGlzID09PSAwID8gcXggKyByID49IHggOiBxeSArIHIgPj0geSkge1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gobSArIDEpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2gocmlnaHQpO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goMSAtIGF4aXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50MTZBcnJheSB8IFVpbnQzMkFycmF5fSBpZHNcbiAqIEBwYXJhbSB7SW5zdGFuY2VUeXBlPFR5cGVkQXJyYXlDb25zdHJ1Y3Rvcj59IGNvb3Jkc1xuICogQHBhcmFtIHtudW1iZXJ9IG5vZGVTaXplXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdFxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gYXhpc1xuICovXG5mdW5jdGlvbiBzb3J0KGlkcywgY29vcmRzLCBub2RlU2l6ZSwgbGVmdCwgcmlnaHQsIGF4aXMpIHtcbiAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG5vZGVTaXplKSByZXR1cm47XG5cbiAgICBjb25zdCBtID0gKGxlZnQgKyByaWdodCkgPj4gMTsgLy8gbWlkZGxlIGluZGV4XG5cbiAgICAvLyBzb3J0IGlkcyBhbmQgY29vcmRzIGFyb3VuZCB0aGUgbWlkZGxlIGluZGV4IHNvIHRoYXQgdGhlIGhhbHZlcyBsaWVcbiAgICAvLyBlaXRoZXIgbGVmdC9yaWdodCBvciB0b3AvYm90dG9tIGNvcnJlc3BvbmRpbmdseSAodGFraW5nIHR1cm5zKVxuICAgIHNlbGVjdChpZHMsIGNvb3JkcywgbSwgbGVmdCwgcmlnaHQsIGF4aXMpO1xuXG4gICAgLy8gcmVjdXJzaXZlbHkga2Qtc29ydCBmaXJzdCBoYWxmIGFuZCBzZWNvbmQgaGFsZiBvbiB0aGUgb3Bwb3NpdGUgYXhpc1xuICAgIHNvcnQoaWRzLCBjb29yZHMsIG5vZGVTaXplLCBsZWZ0LCBtIC0gMSwgMSAtIGF4aXMpO1xuICAgIHNvcnQoaWRzLCBjb29yZHMsIG5vZGVTaXplLCBtICsgMSwgcmlnaHQsIDEgLSBheGlzKTtcbn1cblxuLyoqXG4gKiBDdXN0b20gRmxveWQtUml2ZXN0IHNlbGVjdGlvbiBhbGdvcml0aG06IHNvcnQgaWRzIGFuZCBjb29yZHMgc28gdGhhdFxuICogW2xlZnQuLmstMV0gaXRlbXMgYXJlIHNtYWxsZXIgdGhhbiBrLXRoIGl0ZW0gKG9uIGVpdGhlciB4IG9yIHkgYXhpcylcbiAqIEBwYXJhbSB7VWludDE2QXJyYXkgfCBVaW50MzJBcnJheX0gaWRzXG4gKiBAcGFyYW0ge0luc3RhbmNlVHlwZTxUeXBlZEFycmF5Q29uc3RydWN0b3I+fSBjb29yZHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdFxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gYXhpc1xuICovXG5mdW5jdGlvbiBzZWxlY3QoaWRzLCBjb29yZHMsIGssIGxlZnQsIHJpZ2h0LCBheGlzKSB7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgY29uc3QgbSA9IGsgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgY29uc3Qgc2QgPSAwLjUgKiBNYXRoLnNxcnQoeiAqIHMgKiAobiAtIHMpIC8gbikgKiAobSAtIG4gLyAyIDwgMCA/IC0xIDogMSk7XG4gICAgICAgICAgICBjb25zdCBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBzZWxlY3QoaWRzLCBjb29yZHMsIGssIG5ld0xlZnQsIG5ld1JpZ2h0LCBheGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHQgPSBjb29yZHNbMiAqIGsgKyBheGlzXTtcbiAgICAgICAgbGV0IGkgPSBsZWZ0O1xuICAgICAgICBsZXQgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXBJdGVtKGlkcywgY29vcmRzLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvb3Jkc1syICogcmlnaHQgKyBheGlzXSA+IHQpIHN3YXBJdGVtKGlkcywgY29vcmRzLCBsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBqKSB7XG4gICAgICAgICAgICBzd2FwSXRlbShpZHMsIGNvb3JkcywgaSwgaik7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB3aGlsZSAoY29vcmRzWzIgKiBpICsgYXhpc10gPCB0KSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29vcmRzWzIgKiBqICsgYXhpc10gPiB0KSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29vcmRzWzIgKiBsZWZ0ICsgYXhpc10gPT09IHQpIHN3YXBJdGVtKGlkcywgY29vcmRzLCBsZWZ0LCBqKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBzd2FwSXRlbShpZHMsIGNvb3JkcywgaiwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGogPD0gaykgbGVmdCA9IGogKyAxO1xuICAgICAgICBpZiAoayA8PSBqKSByaWdodCA9IGogLSAxO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQxNkFycmF5IHwgVWludDMyQXJyYXl9IGlkc1xuICogQHBhcmFtIHtJbnN0YW5jZVR5cGU8VHlwZWRBcnJheUNvbnN0cnVjdG9yPn0gY29vcmRzXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICogQHBhcmFtIHtudW1iZXJ9IGpcbiAqL1xuZnVuY3Rpb24gc3dhcEl0ZW0oaWRzLCBjb29yZHMsIGksIGopIHtcbiAgICBzd2FwKGlkcywgaSwgaik7XG4gICAgc3dhcChjb29yZHMsIDIgKiBpLCAyICogaik7XG4gICAgc3dhcChjb29yZHMsIDIgKiBpICsgMSwgMiAqIGogKyAxKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0luc3RhbmNlVHlwZTxUeXBlZEFycmF5Q29uc3RydWN0b3I+fSBhcnJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKiBAcGFyYW0ge251bWJlcn0galxuICovXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIGNvbnN0IHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBheFxuICogQHBhcmFtIHtudW1iZXJ9IGF5XG4gKiBAcGFyYW0ge251bWJlcn0gYnhcbiAqIEBwYXJhbSB7bnVtYmVyfSBieVxuICovXG5mdW5jdGlvbiBzcURpc3QoYXgsIGF5LCBieCwgYnkpIHtcbiAgICBjb25zdCBkeCA9IGF4IC0gYng7XG4gICAgY29uc3QgZHkgPSBheSAtIGJ5O1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuY29uc3QgZGVmYXVsdE9wdGlvbnMkMiA9IHtcbiAgICBtaW5ab29tOiAwLCAgIC8vIG1pbiB6b29tIHRvIGdlbmVyYXRlIGNsdXN0ZXJzIG9uXG4gICAgbWF4Wm9vbTogMTYsICAvLyBtYXggem9vbSBsZXZlbCB0byBjbHVzdGVyIHRoZSBwb2ludHMgb25cbiAgICBtaW5Qb2ludHM6IDIsIC8vIG1pbmltdW0gcG9pbnRzIHRvIGZvcm0gYSBjbHVzdGVyXG4gICAgcmFkaXVzOiA0MCwgICAvLyBjbHVzdGVyIHJhZGl1cyBpbiBwaXhlbHNcbiAgICBleHRlbnQ6IDUxMiwgIC8vIHRpbGUgZXh0ZW50IChyYWRpdXMgaXMgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byBpdClcbiAgICBub2RlU2l6ZTogNjQsIC8vIHNpemUgb2YgdGhlIEtELXRyZWUgbGVhZiBub2RlLCBhZmZlY3RzIHBlcmZvcm1hbmNlXG4gICAgbG9nOiBmYWxzZSwgICAvLyB3aGV0aGVyIHRvIGxvZyB0aW1pbmcgaW5mb1xuXG4gICAgLy8gd2hldGhlciB0byBnZW5lcmF0ZSBudW1lcmljIGlkcyBmb3IgaW5wdXQgZmVhdHVyZXMgKGluIHZlY3RvciB0aWxlcylcbiAgICBnZW5lcmF0ZUlkOiBmYWxzZSxcblxuICAgIC8vIGEgcmVkdWNlIGZ1bmN0aW9uIGZvciBjYWxjdWxhdGluZyBjdXN0b20gY2x1c3RlciBwcm9wZXJ0aWVzXG4gICAgcmVkdWNlOiBudWxsLCAvLyAoYWNjdW11bGF0ZWQsIHByb3BzKSA9PiB7IGFjY3VtdWxhdGVkLnN1bSArPSBwcm9wcy5zdW07IH1cblxuICAgIC8vIHByb3BlcnRpZXMgdG8gdXNlIGZvciBpbmRpdmlkdWFsIHBvaW50cyB3aGVuIHJ1bm5pbmcgdGhlIHJlZHVjZXJcbiAgICBtYXA6IHByb3BzID0+IHByb3BzIC8vIHByb3BzID0+ICh7c3VtOiBwcm9wcy5teV92YWx1ZX0pXG59O1xuXG5jb25zdCBmcm91bmQgPSBNYXRoLmZyb3VuZCB8fCAodG1wID0+ICgoeCkgPT4geyB0bXBbMF0gPSAreDsgcmV0dXJuIHRtcFswXTsgfSkpKG5ldyBGbG9hdDMyQXJyYXkoMSkpO1xuXG5jb25zdCBPRkZTRVRfWk9PTSA9IDI7XG5jb25zdCBPRkZTRVRfSUQgPSAzO1xuY29uc3QgT0ZGU0VUX1BBUkVOVCA9IDQ7XG5jb25zdCBPRkZTRVRfTlVNID0gNTtcbmNvbnN0IE9GRlNFVF9QUk9QID0gNjtcblxuY2xhc3MgU3VwZXJjbHVzdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShkZWZhdWx0T3B0aW9ucyQyKSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHJlZXMgPSBuZXcgQXJyYXkodGhpcy5vcHRpb25zLm1heFpvb20gKyAxKTtcbiAgICAgICAgdGhpcy5zdHJpZGUgPSB0aGlzLm9wdGlvbnMucmVkdWNlID8gNyA6IDY7XG4gICAgICAgIHRoaXMuY2x1c3RlclByb3BzID0gW107XG4gICAgfVxuXG4gICAgbG9hZChwb2ludHMpIHtcbiAgICAgICAgY29uc3Qge2xvZywgbWluWm9vbSwgbWF4Wm9vbX0gPSB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgaWYgKGxvZykgY29uc29sZS50aW1lKCd0b3RhbCB0aW1lJyk7XG5cbiAgICAgICAgY29uc3QgdGltZXJJZCA9IGBwcmVwYXJlICR7ICBwb2ludHMubGVuZ3RoICB9IHBvaW50c2A7XG4gICAgICAgIGlmIChsb2cpIGNvbnNvbGUudGltZSh0aW1lcklkKTtcblxuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcblxuICAgICAgICAvLyBnZW5lcmF0ZSBhIGNsdXN0ZXIgb2JqZWN0IGZvciBlYWNoIHBvaW50IGFuZCBpbmRleCBpbnB1dCBwb2ludHMgaW50byBhIEtELXRyZWVcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgaWYgKCFwLmdlb21ldHJ5KSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3QgW2xuZywgbGF0XSA9IHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBjb25zdCB4ID0gZnJvdW5kKGxuZ1gobG5nKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gZnJvdW5kKGxhdFkobGF0KSk7XG4gICAgICAgICAgICAvLyBzdG9yZSBpbnRlcm5hbCBwb2ludC9jbHVzdGVyIGRhdGEgaW4gZmxhdCBudW1lcmljIGFycmF5cyBmb3IgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIGRhdGEucHVzaChcbiAgICAgICAgICAgICAgICB4LCB5LCAvLyBwcm9qZWN0ZWQgcG9pbnQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICBJbmZpbml0eSwgLy8gdGhlIGxhc3Qgem9vbSB0aGUgcG9pbnQgd2FzIHByb2Nlc3NlZCBhdFxuICAgICAgICAgICAgICAgIGksIC8vIGluZGV4IG9mIHRoZSBzb3VyY2UgZmVhdHVyZSBpbiB0aGUgb3JpZ2luYWwgaW5wdXQgYXJyYXlcbiAgICAgICAgICAgICAgICAtMSwgLy8gcGFyZW50IGNsdXN0ZXIgaWRcbiAgICAgICAgICAgICAgICAxIC8vIG51bWJlciBvZiBwb2ludHMgaW4gYSBjbHVzdGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWR1Y2UpIGRhdGEucHVzaCgwKTsgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICAgIGxldCB0cmVlID0gdGhpcy50cmVlc1ttYXhab29tICsgMV0gPSB0aGlzLl9jcmVhdGVUcmVlKGRhdGEpO1xuXG4gICAgICAgIGlmIChsb2cpIGNvbnNvbGUudGltZUVuZCh0aW1lcklkKTtcblxuICAgICAgICAvLyBjbHVzdGVyIHBvaW50cyBvbiBtYXggem9vbSwgdGhlbiBjbHVzdGVyIHRoZSByZXN1bHRzIG9uIHByZXZpb3VzIHpvb20sIGV0Yy47XG4gICAgICAgIC8vIHJlc3VsdHMgaW4gYSBjbHVzdGVyIGhpZXJhcmNoeSBhY3Jvc3Mgem9vbSBsZXZlbHNcbiAgICAgICAgZm9yIChsZXQgeiA9IG1heFpvb207IHogPj0gbWluWm9vbTsgei0tKSB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSArRGF0ZS5ub3coKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHNldCBvZiBjbHVzdGVycyBmb3IgdGhlIHpvb20gYW5kIGluZGV4IHRoZW0gd2l0aCBhIEtELXRyZWVcbiAgICAgICAgICAgIHRyZWUgPSB0aGlzLnRyZWVzW3pdID0gdGhpcy5fY3JlYXRlVHJlZSh0aGlzLl9jbHVzdGVyKHRyZWUsIHopKTtcblxuICAgICAgICAgICAgaWYgKGxvZykgY29uc29sZS5sb2coJ3olZDogJWQgY2x1c3RlcnMgaW4gJWRtcycsIHosIHRyZWUubnVtSXRlbXMsICtEYXRlLm5vdygpIC0gbm93KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2cpIGNvbnNvbGUudGltZUVuZCgndG90YWwgdGltZScpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldENsdXN0ZXJzKGJib3gsIHpvb20pIHtcbiAgICAgICAgbGV0IG1pbkxuZyA9ICgoYmJveFswXSArIDE4MCkgJSAzNjAgKyAzNjApICUgMzYwIC0gMTgwO1xuICAgICAgICBjb25zdCBtaW5MYXQgPSBNYXRoLm1heCgtOTAsIE1hdGgubWluKDkwLCBiYm94WzFdKSk7XG4gICAgICAgIGxldCBtYXhMbmcgPSBiYm94WzJdID09PSAxODAgPyAxODAgOiAoKGJib3hbMl0gKyAxODApICUgMzYwICsgMzYwKSAlIDM2MCAtIDE4MDtcbiAgICAgICAgY29uc3QgbWF4TGF0ID0gTWF0aC5tYXgoLTkwLCBNYXRoLm1pbig5MCwgYmJveFszXSkpO1xuXG4gICAgICAgIGlmIChiYm94WzJdIC0gYmJveFswXSA+PSAzNjApIHtcbiAgICAgICAgICAgIG1pbkxuZyA9IC0xODA7XG4gICAgICAgICAgICBtYXhMbmcgPSAxODA7XG4gICAgICAgIH0gZWxzZSBpZiAobWluTG5nID4gbWF4TG5nKSB7XG4gICAgICAgICAgICBjb25zdCBlYXN0ZXJuSGVtID0gdGhpcy5nZXRDbHVzdGVycyhbbWluTG5nLCBtaW5MYXQsIDE4MCwgbWF4TGF0XSwgem9vbSk7XG4gICAgICAgICAgICBjb25zdCB3ZXN0ZXJuSGVtID0gdGhpcy5nZXRDbHVzdGVycyhbLTE4MCwgbWluTGF0LCBtYXhMbmcsIG1heExhdF0sIHpvb20pO1xuICAgICAgICAgICAgcmV0dXJuIGVhc3Rlcm5IZW0uY29uY2F0KHdlc3Rlcm5IZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJlZSA9IHRoaXMudHJlZXNbdGhpcy5fbGltaXRab29tKHpvb20pXTtcbiAgICAgICAgY29uc3QgaWRzID0gdHJlZS5yYW5nZShsbmdYKG1pbkxuZyksIGxhdFkobWF4TGF0KSwgbG5nWChtYXhMbmcpLCBsYXRZKG1pbkxhdCkpO1xuICAgICAgICBjb25zdCBkYXRhID0gdHJlZS5kYXRhO1xuICAgICAgICBjb25zdCBjbHVzdGVycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuc3RyaWRlICogaWQ7XG4gICAgICAgICAgICBjbHVzdGVycy5wdXNoKGRhdGFbayArIE9GRlNFVF9OVU1dID4gMSA/IGdldENsdXN0ZXJKU09OKGRhdGEsIGssIHRoaXMuY2x1c3RlclByb3BzKSA6IHRoaXMucG9pbnRzW2RhdGFbayArIE9GRlNFVF9JRF1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2x1c3RlcnM7XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRyZW4oY2x1c3RlcklkKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbklkID0gdGhpcy5fZ2V0T3JpZ2luSWQoY2x1c3RlcklkKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luWm9vbSA9IHRoaXMuX2dldE9yaWdpblpvb20oY2x1c3RlcklkKTtcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPSAnTm8gY2x1c3RlciB3aXRoIHRoZSBzcGVjaWZpZWQgaWQuJztcblxuICAgICAgICBjb25zdCB0cmVlID0gdGhpcy50cmVlc1tvcmlnaW5ab29tXTtcbiAgICAgICAgaWYgKCF0cmVlKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0cmVlLmRhdGE7XG4gICAgICAgIGlmIChvcmlnaW5JZCAqIHRoaXMuc3RyaWRlID49IGRhdGEubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuXG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLm9wdGlvbnMucmFkaXVzIC8gKHRoaXMub3B0aW9ucy5leHRlbnQgKiBNYXRoLnBvdygyLCBvcmlnaW5ab29tIC0gMSkpO1xuICAgICAgICBjb25zdCB4ID0gZGF0YVtvcmlnaW5JZCAqIHRoaXMuc3RyaWRlXTtcbiAgICAgICAgY29uc3QgeSA9IGRhdGFbb3JpZ2luSWQgKiB0aGlzLnN0cmlkZSArIDFdO1xuICAgICAgICBjb25zdCBpZHMgPSB0cmVlLndpdGhpbih4LCB5LCByKTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBpZCAqIHRoaXMuc3RyaWRlO1xuICAgICAgICAgICAgaWYgKGRhdGFbayArIE9GRlNFVF9QQVJFTlRdID09PSBjbHVzdGVySWQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGRhdGFbayArIE9GRlNFVF9OVU1dID4gMSA/IGdldENsdXN0ZXJKU09OKGRhdGEsIGssIHRoaXMuY2x1c3RlclByb3BzKSA6IHRoaXMucG9pbnRzW2RhdGFbayArIE9GRlNFVF9JRF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cblxuICAgIGdldExlYXZlcyhjbHVzdGVySWQsIGxpbWl0LCBvZmZzZXQpIHtcbiAgICAgICAgbGltaXQgPSBsaW1pdCB8fCAxMDtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgICAgY29uc3QgbGVhdmVzID0gW107XG4gICAgICAgIHRoaXMuX2FwcGVuZExlYXZlcyhsZWF2ZXMsIGNsdXN0ZXJJZCwgbGltaXQsIG9mZnNldCwgMCk7XG5cbiAgICAgICAgcmV0dXJuIGxlYXZlcztcbiAgICB9XG5cbiAgICBnZXRUaWxlKHosIHgsIHkpIHtcbiAgICAgICAgY29uc3QgdHJlZSA9IHRoaXMudHJlZXNbdGhpcy5fbGltaXRab29tKHopXTtcbiAgICAgICAgY29uc3QgejIgPSBNYXRoLnBvdygyLCB6KTtcbiAgICAgICAgY29uc3Qge2V4dGVudCwgcmFkaXVzfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgcCA9IHJhZGl1cyAvIGV4dGVudDtcbiAgICAgICAgY29uc3QgdG9wID0gKHkgLSBwKSAvIHoyO1xuICAgICAgICBjb25zdCBib3R0b20gPSAoeSArIDEgKyBwKSAvIHoyO1xuXG4gICAgICAgIGNvbnN0IHRpbGUgPSB7XG4gICAgICAgICAgICBmZWF0dXJlczogW11cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9hZGRUaWxlRmVhdHVyZXMoXG4gICAgICAgICAgICB0cmVlLnJhbmdlKCh4IC0gcCkgLyB6MiwgdG9wLCAoeCArIDEgKyBwKSAvIHoyLCBib3R0b20pLFxuICAgICAgICAgICAgdHJlZS5kYXRhLCB4LCB5LCB6MiwgdGlsZSk7XG5cbiAgICAgICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRpbGVGZWF0dXJlcyhcbiAgICAgICAgICAgICAgICB0cmVlLnJhbmdlKDEgLSBwIC8gejIsIHRvcCwgMSwgYm90dG9tKSxcbiAgICAgICAgICAgICAgICB0cmVlLmRhdGEsIHoyLCB5LCB6MiwgdGlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09IHoyIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5fYWRkVGlsZUZlYXR1cmVzKFxuICAgICAgICAgICAgICAgIHRyZWUucmFuZ2UoMCwgdG9wLCBwIC8gejIsIGJvdHRvbSksXG4gICAgICAgICAgICAgICAgdHJlZS5kYXRhLCAtMSwgeSwgejIsIHRpbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRpbGUuZmVhdHVyZXMubGVuZ3RoID8gdGlsZSA6IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0Q2x1c3RlckV4cGFuc2lvblpvb20oY2x1c3RlcklkKSB7XG4gICAgICAgIGxldCBleHBhbnNpb25ab29tID0gdGhpcy5fZ2V0T3JpZ2luWm9vbShjbHVzdGVySWQpIC0gMTtcbiAgICAgICAgd2hpbGUgKGV4cGFuc2lvblpvb20gPD0gdGhpcy5vcHRpb25zLm1heFpvb20pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbihjbHVzdGVySWQpO1xuICAgICAgICAgICAgZXhwYW5zaW9uWm9vbSsrO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMSkgYnJlYWs7XG4gICAgICAgICAgICBjbHVzdGVySWQgPSBjaGlsZHJlblswXS5wcm9wZXJ0aWVzLmNsdXN0ZXJfaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cGFuc2lvblpvb207XG4gICAgfVxuXG4gICAgX2FwcGVuZExlYXZlcyhyZXN1bHQsIGNsdXN0ZXJJZCwgbGltaXQsIG9mZnNldCwgc2tpcHBlZCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oY2x1c3RlcklkKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IGNoaWxkLnByb3BlcnRpZXM7XG5cbiAgICAgICAgICAgIGlmIChwcm9wcyAmJiBwcm9wcy5jbHVzdGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQgKyBwcm9wcy5wb2ludF9jb3VudCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCB0aGUgd2hvbGUgY2x1c3RlclxuICAgICAgICAgICAgICAgICAgICBza2lwcGVkICs9IHByb3BzLnBvaW50X2NvdW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVudGVyIHRoZSBjbHVzdGVyXG4gICAgICAgICAgICAgICAgICAgIHNraXBwZWQgPSB0aGlzLl9hcHBlbmRMZWF2ZXMocmVzdWx0LCBwcm9wcy5jbHVzdGVyX2lkLCBsaW1pdCwgb2Zmc2V0LCBza2lwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhpdCB0aGUgY2x1c3RlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2tpcHBlZCA8IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgYSBzaW5nbGUgcG9pbnRcbiAgICAgICAgICAgICAgICBza2lwcGVkKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBhIHNpbmdsZSBwb2ludFxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSBsaW1pdCkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2tpcHBlZDtcbiAgICB9XG5cbiAgICBfY3JlYXRlVHJlZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBuZXcgS0RCdXNoKGRhdGEubGVuZ3RoIC8gdGhpcy5zdHJpZGUgfCAwLCB0aGlzLm9wdGlvbnMubm9kZVNpemUsIEZsb2F0MzJBcnJheSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gdGhpcy5zdHJpZGUpIHRyZWUuYWRkKGRhdGFbaV0sIGRhdGFbaSArIDFdKTtcbiAgICAgICAgdHJlZS5maW5pc2goKTtcbiAgICAgICAgdHJlZS5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRyZWU7XG4gICAgfVxuXG4gICAgX2FkZFRpbGVGZWF0dXJlcyhpZHMsIGRhdGEsIHgsIHksIHoyLCB0aWxlKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBpZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBpICogdGhpcy5zdHJpZGU7XG4gICAgICAgICAgICBjb25zdCBpc0NsdXN0ZXIgPSBkYXRhW2sgKyBPRkZTRVRfTlVNXSA+IDE7XG5cbiAgICAgICAgICAgIGxldCB0YWdzLCBweCwgcHk7XG4gICAgICAgICAgICBpZiAoaXNDbHVzdGVyKSB7XG4gICAgICAgICAgICAgICAgdGFncyA9IGdldENsdXN0ZXJQcm9wZXJ0aWVzKGRhdGEsIGssIHRoaXMuY2x1c3RlclByb3BzKTtcbiAgICAgICAgICAgICAgICBweCA9IGRhdGFba107XG4gICAgICAgICAgICAgICAgcHkgPSBkYXRhW2sgKyAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHRoaXMucG9pbnRzW2RhdGFbayArIE9GRlNFVF9JRF1dO1xuICAgICAgICAgICAgICAgIHRhZ3MgPSBwLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xuZywgbGF0XSA9IHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICAgICAgcHggPSBsbmdYKGxuZyk7XG4gICAgICAgICAgICAgICAgcHkgPSBsYXRZKGxhdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGYgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogMSxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogW1tcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMuZXh0ZW50ICogKHB4ICogejIgLSB4KSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5vcHRpb25zLmV4dGVudCAqIChweSAqIHoyIC0geSkpXG4gICAgICAgICAgICAgICAgXV0sXG4gICAgICAgICAgICAgICAgdGFnc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gYXNzaWduIGlkXG4gICAgICAgICAgICBsZXQgaWQ7XG4gICAgICAgICAgICBpZiAoaXNDbHVzdGVyIHx8IHRoaXMub3B0aW9ucy5nZW5lcmF0ZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gb3B0aW9uYWxseSBnZW5lcmF0ZSBpZCBmb3IgcG9pbnRzXG4gICAgICAgICAgICAgICAgaWQgPSBkYXRhW2sgKyBPRkZTRVRfSURdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBrZWVwIGlkIGlmIGFscmVhZHkgYXNzaWduZWRcbiAgICAgICAgICAgICAgICBpZCA9IHRoaXMucG9pbnRzW2RhdGFbayArIE9GRlNFVF9JRF1dLmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkgZi5pZCA9IGlkO1xuXG4gICAgICAgICAgICB0aWxlLmZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbGltaXRab29tKHopIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMub3B0aW9ucy5taW5ab29tLCBNYXRoLm1pbihNYXRoLmZsb29yKCt6KSwgdGhpcy5vcHRpb25zLm1heFpvb20gKyAxKSk7XG4gICAgfVxuXG4gICAgX2NsdXN0ZXIodHJlZSwgem9vbSkge1xuICAgICAgICBjb25zdCB7cmFkaXVzLCBleHRlbnQsIHJlZHVjZSwgbWluUG9pbnRzfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgciA9IHJhZGl1cyAvIChleHRlbnQgKiBNYXRoLnBvdygyLCB6b29tKSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0cmVlLmRhdGE7XG4gICAgICAgIGNvbnN0IG5leHREYXRhID0gW107XG4gICAgICAgIGNvbnN0IHN0cmlkZSA9IHRoaXMuc3RyaWRlO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIHBvaW50XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlIHBvaW50IGF0IHRoaXMgem9vbSBsZXZlbCwgc2tpcCBpdFxuICAgICAgICAgICAgaWYgKGRhdGFbaSArIE9GRlNFVF9aT09NXSA8PSB6b29tKSBjb250aW51ZTtcbiAgICAgICAgICAgIGRhdGFbaSArIE9GRlNFVF9aT09NXSA9IHpvb207XG5cbiAgICAgICAgICAgIC8vIGZpbmQgYWxsIG5lYXJieSBwb2ludHNcbiAgICAgICAgICAgIGNvbnN0IHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgY29uc3QgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgY29uc3QgbmVpZ2hib3JJZHMgPSB0cmVlLndpdGhpbihkYXRhW2ldLCBkYXRhW2kgKyAxXSwgcik7XG5cbiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50c09yaWdpbiA9IGRhdGFbaSArIE9GRlNFVF9OVU1dO1xuICAgICAgICAgICAgbGV0IG51bVBvaW50cyA9IG51bVBvaW50c09yaWdpbjtcblxuICAgICAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBwb2ludHMgaW4gYSBwb3RlbnRpYWwgY2x1c3RlclxuICAgICAgICAgICAgZm9yIChjb25zdCBuZWlnaGJvcklkIG9mIG5laWdoYm9ySWRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgayA9IG5laWdoYm9ySWQgKiBzdHJpZGU7XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIG91dCBuZWlnaGJvcnMgdGhhdCBhcmUgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtrICsgT0ZGU0VUX1pPT01dID4gem9vbSkgbnVtUG9pbnRzICs9IGRhdGFbayArIE9GRlNFVF9OVU1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSB3ZXJlIG5laWdoYm9ycyB0byBtZXJnZSwgYW5kIHRoZXJlIGFyZSBlbm91Z2ggcG9pbnRzIHRvIGZvcm0gYSBjbHVzdGVyXG4gICAgICAgICAgICBpZiAobnVtUG9pbnRzID4gbnVtUG9pbnRzT3JpZ2luICYmIG51bVBvaW50cyA+PSBtaW5Qb2ludHMpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3ggPSB4ICogbnVtUG9pbnRzT3JpZ2luO1xuICAgICAgICAgICAgICAgIGxldCB3eSA9IHkgKiBudW1Qb2ludHNPcmlnaW47XG5cbiAgICAgICAgICAgICAgICBsZXQgY2x1c3RlclByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgbGV0IGNsdXN0ZXJQcm9wSW5kZXggPSAtMTtcblxuICAgICAgICAgICAgICAgIC8vIGVuY29kZSBib3RoIHpvb20gYW5kIHBvaW50IGluZGV4IG9uIHdoaWNoIHRoZSBjbHVzdGVyIG9yaWdpbmF0ZWQgLS0gb2Zmc2V0IGJ5IHRvdGFsIGxlbmd0aCBvZiBmZWF0dXJlc1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gKChpIC8gc3RyaWRlIHwgMCkgPDwgNSkgKyAoem9vbSArIDEpICsgdGhpcy5wb2ludHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZWlnaGJvcklkIG9mIG5laWdoYm9ySWRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGsgPSBuZWlnaGJvcklkICogc3RyaWRlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2sgKyBPRkZTRVRfWk9PTV0gPD0gem9vbSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbayArIE9GRlNFVF9aT09NXSA9IHpvb207IC8vIHNhdmUgdGhlIHpvb20gKHNvIGl0IGRvZXNuJ3QgZ2V0IHByb2Nlc3NlZCB0d2ljZSlcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBudW1Qb2ludHMyID0gZGF0YVtrICsgT0ZGU0VUX05VTV07XG4gICAgICAgICAgICAgICAgICAgIHd4ICs9IGRhdGFba10gKiBudW1Qb2ludHMyOyAvLyBhY2N1bXVsYXRlIGNvb3JkaW5hdGVzIGZvciBjYWxjdWxhdGluZyB3ZWlnaHRlZCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgd3kgKz0gZGF0YVtrICsgMV0gKiBudW1Qb2ludHMyO1xuXG4gICAgICAgICAgICAgICAgICAgIGRhdGFbayArIE9GRlNFVF9QQVJFTlRdID0gaWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZHVjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbHVzdGVyUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJQcm9wZXJ0aWVzID0gdGhpcy5fbWFwKGRhdGEsIGksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJQcm9wSW5kZXggPSB0aGlzLmNsdXN0ZXJQcm9wcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbHVzdGVyUHJvcHMucHVzaChjbHVzdGVyUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWR1Y2UoY2x1c3RlclByb3BlcnRpZXMsIHRoaXMuX21hcChkYXRhLCBrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkYXRhW2kgKyBPRkZTRVRfUEFSRU5UXSA9IGlkO1xuICAgICAgICAgICAgICAgIG5leHREYXRhLnB1c2god3ggLyBudW1Qb2ludHMsIHd5IC8gbnVtUG9pbnRzLCBJbmZpbml0eSwgaWQsIC0xLCBudW1Qb2ludHMpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2UpIG5leHREYXRhLnB1c2goY2x1c3RlclByb3BJbmRleCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGxlZnQgcG9pbnRzIGFzIHVuY2x1c3RlcmVkXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHJpZGU7IGorKykgbmV4dERhdGEucHVzaChkYXRhW2kgKyBqXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAobnVtUG9pbnRzID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG5laWdoYm9ySWQgb2YgbmVpZ2hib3JJZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGsgPSBuZWlnaGJvcklkICogc3RyaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbayArIE9GRlNFVF9aT09NXSA8PSB6b29tKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbayArIE9GRlNFVF9aT09NXSA9IHpvb207XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0cmlkZTsgaisrKSBuZXh0RGF0YS5wdXNoKGRhdGFbayArIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0RGF0YTtcbiAgICB9XG5cbiAgICAvLyBnZXQgaW5kZXggb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdGhlIGNsdXN0ZXIgb3JpZ2luYXRlZFxuICAgIF9nZXRPcmlnaW5JZChjbHVzdGVySWQpIHtcbiAgICAgICAgcmV0dXJuIChjbHVzdGVySWQgLSB0aGlzLnBvaW50cy5sZW5ndGgpID4+IDU7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHpvb20gb2YgdGhlIHBvaW50IGZyb20gd2hpY2ggdGhlIGNsdXN0ZXIgb3JpZ2luYXRlZFxuICAgIF9nZXRPcmlnaW5ab29tKGNsdXN0ZXJJZCkge1xuICAgICAgICByZXR1cm4gKGNsdXN0ZXJJZCAtIHRoaXMucG9pbnRzLmxlbmd0aCkgJSAzMjtcbiAgICB9XG5cbiAgICBfbWFwKGRhdGEsIGksIGNsb25lKSB7XG4gICAgICAgIGlmIChkYXRhW2kgKyBPRkZTRVRfTlVNXSA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5jbHVzdGVyUHJvcHNbZGF0YVtpICsgT0ZGU0VUX1BST1BdXTtcbiAgICAgICAgICAgIHJldHVybiBjbG9uZSA/IE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSA6IHByb3BzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gdGhpcy5wb2ludHNbZGF0YVtpICsgT0ZGU0VUX0lEXV0ucHJvcGVydGllcztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5vcHRpb25zLm1hcChvcmlnaW5hbCk7XG4gICAgICAgIHJldHVybiBjbG9uZSAmJiByZXN1bHQgPT09IG9yaWdpbmFsID8gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KSA6IHJlc3VsdDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldENsdXN0ZXJKU09OKGRhdGEsIGksIGNsdXN0ZXJQcm9wcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgaWQ6IGRhdGFbaSArIE9GRlNFVF9JRF0sXG4gICAgICAgIHByb3BlcnRpZXM6IGdldENsdXN0ZXJQcm9wZXJ0aWVzKGRhdGEsIGksIGNsdXN0ZXJQcm9wcyksXG4gICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IFt4TG5nKGRhdGFbaV0pLCB5TGF0KGRhdGFbaSArIDFdKV1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldENsdXN0ZXJQcm9wZXJ0aWVzKGRhdGEsIGksIGNsdXN0ZXJQcm9wcykge1xuICAgIGNvbnN0IGNvdW50ID0gZGF0YVtpICsgT0ZGU0VUX05VTV07XG4gICAgY29uc3QgYWJicmV2ID1cbiAgICAgICAgY291bnQgPj0gMTAwMDAgPyBgJHtNYXRoLnJvdW5kKGNvdW50IC8gMTAwMCkgIH1rYCA6XG4gICAgICAgIGNvdW50ID49IDEwMDAgPyBgJHtNYXRoLnJvdW5kKGNvdW50IC8gMTAwKSAvIDEwICB9a2AgOiBjb3VudDtcbiAgICBjb25zdCBwcm9wSW5kZXggPSBkYXRhW2kgKyBPRkZTRVRfUFJPUF07XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHByb3BJbmRleCA9PT0gLTEgPyB7fSA6IE9iamVjdC5hc3NpZ24oe30sIGNsdXN0ZXJQcm9wc1twcm9wSW5kZXhdKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9wZXJ0aWVzLCB7XG4gICAgICAgIGNsdXN0ZXI6IHRydWUsXG4gICAgICAgIGNsdXN0ZXJfaWQ6IGRhdGFbaSArIE9GRlNFVF9JRF0sXG4gICAgICAgIHBvaW50X2NvdW50OiBjb3VudCxcbiAgICAgICAgcG9pbnRfY291bnRfYWJicmV2aWF0ZWQ6IGFiYnJldlxuICAgIH0pO1xufVxuXG4vLyBsb25naXR1ZGUvbGF0aXR1ZGUgdG8gc3BoZXJpY2FsIG1lcmNhdG9yIGluIFswLi4xXSByYW5nZVxuZnVuY3Rpb24gbG5nWChsbmcpIHtcbiAgICByZXR1cm4gbG5nIC8gMzYwICsgMC41O1xufVxuZnVuY3Rpb24gbGF0WShsYXQpIHtcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihsYXQgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICBjb25zdCB5ID0gKDAuNSAtIDAuMjUgKiBNYXRoLmxvZygoMSArIHNpbikgLyAoMSAtIHNpbikpIC8gTWF0aC5QSSk7XG4gICAgcmV0dXJuIHkgPCAwID8gMCA6IHkgPiAxID8gMSA6IHk7XG59XG5cbi8vIHNwaGVyaWNhbCBtZXJjYXRvciB0byBsb25naXR1ZGUvbGF0aXR1ZGVcbmZ1bmN0aW9uIHhMbmcoeCkge1xuICAgIHJldHVybiAoeCAtIDAuNSkgKiAzNjA7XG59XG5mdW5jdGlvbiB5TGF0KHkpIHtcbiAgICBjb25zdCB5MiA9ICgxODAgLSB5ICogMzYwKSAqIE1hdGguUEkgLyAxODA7XG4gICAgcmV0dXJuIDM2MCAqIE1hdGguYXRhbihNYXRoLmV4cCh5MikpIC8gTWF0aC5QSSAtIDkwO1xufVxuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjMgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogdXRpbCBjbGFzcyB0aGF0IGNyZWF0ZXMgYSBjb21tb24gc2V0IG9mIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyB0byB3cmFwXG4gKiBzaGFyZWQgYmVoYXZpb3Igb2YgQWR2YW5jZWQgTWFya2VycyBhbmQgTWFya2Vycy5cbiAqL1xuY2xhc3MgTWFya2VyVXRpbHMge1xuICAgIHN0YXRpYyBpc0FkdmFuY2VkTWFya2VyQXZhaWxhYmxlKG1hcCkge1xuICAgICAgICByZXR1cm4gKGdvb2dsZS5tYXBzLm1hcmtlciAmJlxuICAgICAgICAgICAgbWFwLmdldE1hcENhcGFiaWxpdGllcygpLmlzQWR2YW5jZWRNYXJrZXJzQXZhaWxhYmxlID09PSB0cnVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQWR2YW5jZWRNYXJrZXIobWFya2VyKSB7XG4gICAgICAgIHJldHVybiAoZ29vZ2xlLm1hcHMubWFya2VyICYmXG4gICAgICAgICAgICBtYXJrZXIgaW5zdGFuY2VvZiBnb29nbGUubWFwcy5tYXJrZXIuQWR2YW5jZWRNYXJrZXJFbGVtZW50KTtcbiAgICB9XG4gICAgc3RhdGljIHNldE1hcChtYXJrZXIsIG1hcCkge1xuICAgICAgICBpZiAodGhpcy5pc0FkdmFuY2VkTWFya2VyKG1hcmtlcikpIHtcbiAgICAgICAgICAgIG1hcmtlci5tYXAgPSBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXJrZXIuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldFBvc2l0aW9uKG1hcmtlcikge1xuICAgICAgICAvLyBTdXBlckNsdXN0ZXJBbGdvcml0aG0uY2FsY3VsYXRlIGV4cGVjdHMgYSBMYXRMbmcgaW5zdGFuY2Ugc28gd2UgZmFrZSBpdCBmb3IgQWR2IE1hcmtlcnNcbiAgICAgICAgaWYgKHRoaXMuaXNBZHZhbmNlZE1hcmtlcihtYXJrZXIpKSB7XG4gICAgICAgICAgICBpZiAobWFya2VyLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlci5wb3NpdGlvbiBpbnN0YW5jZW9mIGdvb2dsZS5tYXBzLkxhdExuZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSBjYW4ndCBjYXN0IHRvIExhdExuZ0xpdGVyYWwgZm9yIHJlYXNvbnMgPShcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyLnBvc2l0aW9uLmxhdCAmJiBtYXJrZXIucG9zaXRpb24ubG5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKG1hcmtlci5wb3NpdGlvbi5sYXQsIG1hcmtlci5wb3NpdGlvbi5sbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXIuZ2V0UG9zaXRpb24oKTtcbiAgICB9XG4gICAgc3RhdGljIGdldFZpc2libGUobWFya2VyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWR2YW5jZWRNYXJrZXIobWFya2VyKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbHdheXMgcmV0dXJuIHRydWUgZm9yIEFkdmFuY2VkIE1hcmtlcnMgYmVjYXVzZSB0aGUgY2x1c3RlcmVyXG4gICAgICAgICAgICAgKiB1c2VzIGdldFZpc2libGUgYXMgYSB3YXkgdG8gY291bnQgbGVnYWN5IG1hcmtlcnMgbm90IGFzIGFuIGFjdHVhbFxuICAgICAgICAgICAgICogaW5kaWNhdG9yIG9mIHZpc2liaWxpdHkgZm9yIHNvbWUgcmVhc29uLiBFdmVuIHdoZW4gbWFya2VycyBhcmUgaGlkZGVuXG4gICAgICAgICAgICAgKiBNYXJrZXIuZ2V0VmlzaWJsZSByZXR1cm5zIGB0cnVlYCBhbmQgdGhpcyBpcyB1c2VkIHRvIHNldCB0aGUgbWFya2VyIGNvdW50XG4gICAgICAgICAgICAgKiBvbiB0aGUgY2x1c3Rlci4gU2VlIHRoZSBiZWhhdmlvciBvZiBDbHVzdGVyLmNvdW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXIuZ2V0VmlzaWJsZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY2xhc3MgQ2x1c3RlciB7XG4gICAgY29uc3RydWN0b3IoeyBtYXJrZXJzLCBwb3NpdGlvbiB9KSB7XG4gICAgICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGJvdW5kcygpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya2Vycy5sZW5ndGggPT09IDAgJiYgIXRoaXMuX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm91bmRzID0gbmV3IGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcyh0aGlzLl9wb3NpdGlvbiwgdGhpcy5fcG9zaXRpb24pO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcmtlciBvZiB0aGlzLm1hcmtlcnMpIHtcbiAgICAgICAgICAgIGJvdW5kcy5leHRlbmQoTWFya2VyVXRpbHMuZ2V0UG9zaXRpb24obWFya2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICB9XG4gICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb24gfHwgdGhpcy5ib3VuZHMuZ2V0Q2VudGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY291bnQgb2YgKip2aXNpYmxlKiogbWFya2Vycy5cbiAgICAgKi9cbiAgICBnZXQgY291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcmtlcnMuZmlsdGVyKChtKSA9PiBNYXJrZXJVdGlscy5nZXRWaXNpYmxlKG0pKS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG1hcmtlciB0byB0aGUgY2x1c3Rlci5cbiAgICAgKi9cbiAgICBwdXNoKG1hcmtlcikge1xuICAgICAgICB0aGlzLm1hcmtlcnMucHVzaChtYXJrZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnVwIHJlZmVyZW5jZXMgYW5kIHJlbW92ZSBtYXJrZXIgZnJvbSBtYXAuXG4gICAgICovXG4gICAgZGVsZXRlKCkge1xuICAgICAgICBpZiAodGhpcy5tYXJrZXIpIHtcbiAgICAgICAgICAgIE1hcmtlclV0aWxzLnNldE1hcCh0aGlzLm1hcmtlciwgbnVsbCk7XG4gICAgICAgICAgICB0aGlzLm1hcmtlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtlcnMubGVuZ3RoID0gMDtcbiAgICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyB0aGUgbWFya2VycyB2aXNpYmxlIGluIGEgcGFkZGVkIG1hcCB2aWV3cG9ydFxuICpcbiAqIEBwYXJhbSBtYXBcbiAqIEBwYXJhbSBtYXBDYW52YXNQcm9qZWN0aW9uXG4gKiBAcGFyYW0gbWFya2VycyBUaGUgbGlzdCBvZiBtYXJrZXIgdG8gZmlsdGVyXG4gKiBAcGFyYW0gdmlld3BvcnRQYWRkaW5nUGl4ZWxzIFRoZSBwYWRkaW5nIGluIHBpeGVsXG4gKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBtYXJrZXJzIGluIHRoZSBwYWRkZWQgdmlld3BvcnRcbiAqL1xuY29uc3QgZmlsdGVyTWFya2Vyc1RvUGFkZGVkVmlld3BvcnQgPSAobWFwLCBtYXBDYW52YXNQcm9qZWN0aW9uLCBtYXJrZXJzLCB2aWV3cG9ydFBhZGRpbmdQaXhlbHMpID0+IHtcbiAgICBjb25zdCBleHRlbmRlZE1hcEJvdW5kcyA9IGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQobWFwLmdldEJvdW5kcygpLCBtYXBDYW52YXNQcm9qZWN0aW9uLCB2aWV3cG9ydFBhZGRpbmdQaXhlbHMpO1xuICAgIHJldHVybiBtYXJrZXJzLmZpbHRlcigobWFya2VyKSA9PiBleHRlbmRlZE1hcEJvdW5kcy5jb250YWlucyhNYXJrZXJVdGlscy5nZXRQb3NpdGlvbihtYXJrZXIpKSk7XG59O1xuLyoqXG4gKiBFeHRlbmRzIGEgYm91bmRzIGJ5IGEgbnVtYmVyIG9mIHBpeGVscyBpbiBlYWNoIGRpcmVjdGlvblxuICovXG5jb25zdCBleHRlbmRCb3VuZHNUb1BhZGRlZFZpZXdwb3J0ID0gKGJvdW5kcywgcHJvamVjdGlvbiwgbnVtUGl4ZWxzKSA9PiB7XG4gICAgY29uc3QgeyBub3J0aEVhc3QsIHNvdXRoV2VzdCB9ID0gbGF0TG5nQm91bmRzVG9QaXhlbEJvdW5kcyhib3VuZHMsIHByb2plY3Rpb24pO1xuICAgIGNvbnN0IGV4dGVuZGVkUGl4ZWxCb3VuZHMgPSBleHRlbmRQaXhlbEJvdW5kcyh7IG5vcnRoRWFzdCwgc291dGhXZXN0IH0sIG51bVBpeGVscyk7XG4gICAgcmV0dXJuIHBpeGVsQm91bmRzVG9MYXRMbmdCb3VuZHMoZXh0ZW5kZWRQaXhlbEJvdW5kcywgcHJvamVjdGlvbik7XG59O1xuLyoqXG4gKiBHZXRzIHRoZSBleHRlbmRlZCBib3VuZHMgYXMgYSBiYm94IFt3ZXN0TG5nLCBzb3V0aExhdCwgZWFzdExuZywgbm9ydGhMYXRdXG4gKi9cbmNvbnN0IGdldFBhZGRlZFZpZXdwb3J0ID0gKGJvdW5kcywgcHJvamVjdGlvbiwgcGl4ZWxzKSA9PiB7XG4gICAgY29uc3QgZXh0ZW5kZWQgPSBleHRlbmRCb3VuZHNUb1BhZGRlZFZpZXdwb3J0KGJvdW5kcywgcHJvamVjdGlvbiwgcGl4ZWxzKTtcbiAgICBjb25zdCBuZSA9IGV4dGVuZGVkLmdldE5vcnRoRWFzdCgpO1xuICAgIGNvbnN0IHN3ID0gZXh0ZW5kZWQuZ2V0U291dGhXZXN0KCk7XG4gICAgcmV0dXJuIFtzdy5sbmcoKSwgc3cubGF0KCksIG5lLmxuZygpLCBuZS5sYXQoKV07XG59O1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9zaXRpb25zLlxuICpcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gKHAxLCBwMikgPT4ge1xuICAgIGNvbnN0IFIgPSA2MzcxOyAvLyBSYWRpdXMgb2YgdGhlIEVhcnRoIGluIGttXG4gICAgY29uc3QgZExhdCA9ICgocDIubGF0IC0gcDEubGF0KSAqIE1hdGguUEkpIC8gMTgwO1xuICAgIGNvbnN0IGRMb24gPSAoKHAyLmxuZyAtIHAxLmxuZykgKiBNYXRoLlBJKSAvIDE4MDtcbiAgICBjb25zdCBzaW5ETGF0ID0gTWF0aC5zaW4oZExhdCAvIDIpO1xuICAgIGNvbnN0IHNpbkRMb24gPSBNYXRoLnNpbihkTG9uIC8gMik7XG4gICAgY29uc3QgYSA9IHNpbkRMYXQgKiBzaW5ETGF0ICtcbiAgICAgICAgTWF0aC5jb3MoKHAxLmxhdCAqIE1hdGguUEkpIC8gMTgwKSAqXG4gICAgICAgICAgICBNYXRoLmNvcygocDIubGF0ICogTWF0aC5QSSkgLyAxODApICpcbiAgICAgICAgICAgIHNpbkRMb24gKlxuICAgICAgICAgICAgc2luRExvbjtcbiAgICBjb25zdCBjID0gMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcbiAgICByZXR1cm4gUiAqIGM7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIExhdExuZyBib3VuZCB0byBwaXhlbHMuXG4gKlxuICogQGhpZGRlblxuICovXG5jb25zdCBsYXRMbmdCb3VuZHNUb1BpeGVsQm91bmRzID0gKGJvdW5kcywgcHJvamVjdGlvbikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vcnRoRWFzdDogcHJvamVjdGlvbi5mcm9tTGF0TG5nVG9EaXZQaXhlbChib3VuZHMuZ2V0Tm9ydGhFYXN0KCkpLFxuICAgICAgICBzb3V0aFdlc3Q6IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoYm91bmRzLmdldFNvdXRoV2VzdCgpKSxcbiAgICB9O1xufTtcbi8qKlxuICogRXh0ZW5kcyBhIHBpeGVsIGJvdW5kcyBieSBudW1QaXhlbHMgaW4gYWxsIGRpcmVjdGlvbnMuXG4gKlxuICogQGhpZGRlblxuICovXG5jb25zdCBleHRlbmRQaXhlbEJvdW5kcyA9ICh7IG5vcnRoRWFzdCwgc291dGhXZXN0IH0sIG51bVBpeGVscykgPT4ge1xuICAgIG5vcnRoRWFzdC54ICs9IG51bVBpeGVscztcbiAgICBub3J0aEVhc3QueSAtPSBudW1QaXhlbHM7XG4gICAgc291dGhXZXN0LnggLT0gbnVtUGl4ZWxzO1xuICAgIHNvdXRoV2VzdC55ICs9IG51bVBpeGVscztcbiAgICByZXR1cm4geyBub3J0aEVhc3QsIHNvdXRoV2VzdCB9O1xufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBwaXhlbEJvdW5kc1RvTGF0TG5nQm91bmRzID0gKHsgbm9ydGhFYXN0LCBzb3V0aFdlc3QgfSwgcHJvamVjdGlvbikgPT4ge1xuICAgIGNvbnN0IHN3ID0gcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyhzb3V0aFdlc3QpO1xuICAgIGNvbnN0IG5lID0gcHJvamVjdGlvbi5mcm9tRGl2UGl4ZWxUb0xhdExuZyhub3J0aEVhc3QpO1xuICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKHN3LCBuZSk7XG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQWJzdHJhY3RBbGdvcml0aG0ge1xuICAgIGNvbnN0cnVjdG9yKHsgbWF4Wm9vbSA9IDE2IH0pIHtcbiAgICAgICAgdGhpcy5tYXhab29tID0gbWF4Wm9vbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGJ5cGFzcyBjbHVzdGVyaW5nIGJhc2VkIHVwb24gc29tZSBtYXAgc3RhdGUgc3VjaCBhc1xuICAgICAqIHpvb20sIG51bWJlciBvZiBtYXJrZXJzLCBldGMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogIGNsdXN0ZXIoe21hcmtlcnMsIG1hcH06IEFsZ29yaXRobUlucHV0KTogQ2x1c3RlcltdIHtcbiAgICAgKiAgICBpZiAoc2hvdWxkQnlwYXNzQ2x1c3RlcmluZyhtYXApKSB7XG4gICAgICogICAgICByZXR1cm4gdGhpcy5ub29wKHttYXJrZXJzfSlcbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIG5vb3AoeyBtYXJrZXJzLCB9KSB7XG4gICAgICAgIHJldHVybiBub29wJDEobWFya2Vycyk7XG4gICAgfVxufVxuLyoqXG4gKiBBYnN0cmFjdCB2aWV3cG9ydCBhbGdvcml0aG0gcHJvdmVzIGEgY2xhc3MgdG8gZmlsdGVyIG1hcmtlcnMgYnkgYSBwYWRkZWRcbiAqIHZpZXdwb3J0LiBUaGlzIGlzIGEgY29tbW9uIG9wdGltaXphdGlvbi5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEFic3RyYWN0Vmlld3BvcnRBbGdvcml0aG0gZXh0ZW5kcyBBYnN0cmFjdEFsZ29yaXRobSB7XG4gICAgY29uc3RydWN0b3IoX2EpIHtcbiAgICAgICAgdmFyIHsgdmlld3BvcnRQYWRkaW5nID0gNjAgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJ2aWV3cG9ydFBhZGRpbmdcIl0pO1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydFBhZGRpbmcgPSA2MDtcbiAgICAgICAgdGhpcy52aWV3cG9ydFBhZGRpbmcgPSB2aWV3cG9ydFBhZGRpbmc7XG4gICAgfVxuICAgIGNhbGN1bGF0ZSh7IG1hcmtlcnMsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiwgfSkge1xuICAgICAgICBpZiAobWFwLmdldFpvb20oKSA+PSB0aGlzLm1heFpvb20pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2x1c3RlcnM6IHRoaXMubm9vcCh7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlcnMsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2hhbmdlZDogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbHVzdGVyczogdGhpcy5jbHVzdGVyKHtcbiAgICAgICAgICAgICAgICBtYXJrZXJzOiBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydChtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24sIG1hcmtlcnMsIHRoaXMudmlld3BvcnRQYWRkaW5nKSxcbiAgICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgICAgbWFwQ2FudmFzUHJvamVjdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBub29wJDEgPSAobWFya2VycykgPT4ge1xuICAgIGNvbnN0IGNsdXN0ZXJzID0gbWFya2Vycy5tYXAoKG1hcmtlcikgPT4gbmV3IENsdXN0ZXIoe1xuICAgICAgICBwb3NpdGlvbjogTWFya2VyVXRpbHMuZ2V0UG9zaXRpb24obWFya2VyKSxcbiAgICAgICAgbWFya2VyczogW21hcmtlcl0sXG4gICAgfSkpO1xuICAgIHJldHVybiBjbHVzdGVycztcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVGhlIGRlZmF1bHQgR3JpZCBhbGdvcml0aG0gaGlzdG9yaWNhbGx5IHVzZWQgaW4gR29vZ2xlIE1hcHMgbWFya2VyXG4gKiBjbHVzdGVyaW5nLlxuICpcbiAqIFRoZSBHcmlkIGFsZ29yaXRobSBkb2VzIG5vdCBpbXBsZW1lbnQgY2FjaGluZyBhbmQgbWFya2VycyBtYXkgZmxhc2ggYXMgdGhlXG4gKiB2aWV3cG9ydCBjaGFuZ2VzLiBJbnN0ZWFkIHVzZSB7QGxpbmsgU3VwZXJDbHVzdGVyQWxnb3JpdGhtfS5cbiAqL1xuY2xhc3MgR3JpZEFsZ29yaXRobSBleHRlbmRzIEFic3RyYWN0Vmlld3BvcnRBbGdvcml0aG0ge1xuICAgIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgICAgIHZhciB7IG1heERpc3RhbmNlID0gNDAwMDAsIGdyaWRTaXplID0gNDAgfSA9IF9hLCBvcHRpb25zID0gX19yZXN0KF9hLCBbXCJtYXhEaXN0YW5jZVwiLCBcImdyaWRTaXplXCJdKTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHsgem9vbTogLTEgfTtcbiAgICAgICAgdGhpcy5tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuICAgICAgICB0aGlzLmdyaWRTaXplID0gZ3JpZFNpemU7XG4gICAgfVxuICAgIGNhbGN1bGF0ZSh7IG1hcmtlcnMsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiwgfSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHsgem9vbTogbWFwLmdldFpvb20oKSB9O1xuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS56b29tID49IHRoaXMubWF4Wm9vbSAmJiBzdGF0ZS56b29tID49IHRoaXMubWF4Wm9vbSkgO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoYW5nZWQgPSAhZXF1YWwodGhpcy5zdGF0ZSwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgaWYgKG1hcC5nZXRab29tKCkgPj0gdGhpcy5tYXhab29tKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJzOiB0aGlzLm5vb3Aoe1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGNoYW5nZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbHVzdGVyczogdGhpcy5jbHVzdGVyKHtcbiAgICAgICAgICAgICAgICBtYXJrZXJzOiBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydChtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24sIG1hcmtlcnMsIHRoaXMudmlld3BvcnRQYWRkaW5nKSxcbiAgICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgICAgbWFwQ2FudmFzUHJvamVjdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjbHVzdGVyKHsgbWFya2VycywgbWFwLCBtYXBDYW52YXNQcm9qZWN0aW9uLCB9KSB7XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSBbXTtcbiAgICAgICAgbWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRkVG9DbG9zZXN0Q2x1c3RlcihtYXJrZXIsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jbHVzdGVycztcbiAgICB9XG4gICAgYWRkVG9DbG9zZXN0Q2x1c3RlcihtYXJrZXIsIG1hcCwgcHJvamVjdGlvbikge1xuICAgICAgICBsZXQgbWF4RGlzdGFuY2UgPSB0aGlzLm1heERpc3RhbmNlOyAvLyBTb21lIGxhcmdlIG51bWJlclxuICAgICAgICBsZXQgY2x1c3RlciA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdGhpcy5jbHVzdGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGNhbmRpZGF0ZS5ib3VuZHMuZ2V0Q2VudGVyKCkudG9KU09OKCksIE1hcmtlclV0aWxzLmdldFBvc2l0aW9uKG1hcmtlcikudG9KU09OKCkpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWF4RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGNsdXN0ZXIgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsdXN0ZXIgJiZcbiAgICAgICAgICAgIGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQoY2x1c3Rlci5ib3VuZHMsIHByb2plY3Rpb24sIHRoaXMuZ3JpZFNpemUpLmNvbnRhaW5zKE1hcmtlclV0aWxzLmdldFBvc2l0aW9uKG1hcmtlcikpKSB7XG4gICAgICAgICAgICBjbHVzdGVyLnB1c2gobWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBuZXcgQ2x1c3Rlcih7IG1hcmtlcnM6IFttYXJrZXJdIH0pO1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVycy5wdXNoKGNsdXN0ZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIE5vb3AgYWxnb3JpdGhtIGRvZXMgbm90IGdlbmVyYXRlIGFueSBjbHVzdGVycyBvciBmaWx0ZXIgbWFya2VycyBieSB0aGUgYW4gZXh0ZW5kZWQgdmlld3BvcnQuXG4gKi9cbmNsYXNzIE5vb3BBbGdvcml0aG0gZXh0ZW5kcyBBYnN0cmFjdEFsZ29yaXRobSB7XG4gICAgY29uc3RydWN0b3IoX2EpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtdKTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZSh7IG1hcmtlcnMsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiwgfSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2x1c3RlcnM6IHRoaXMuY2x1c3Rlcih7IG1hcmtlcnMsIG1hcCwgbWFwQ2FudmFzUHJvamVjdGlvbiB9KSxcbiAgICAgICAgICAgIGNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjbHVzdGVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vb3AoaW5wdXQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBIHZlcnkgZmFzdCBKYXZhU2NyaXB0IGFsZ29yaXRobSBmb3IgZ2Vvc3BhdGlhbCBwb2ludCBjbHVzdGVyaW5nIHVzaW5nIEtEIHRyZWVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc3VwZXJjbHVzdGVyIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIG9wdGlvbnMuXG4gKi9cbmNsYXNzIFN1cGVyQ2x1c3RlckFsZ29yaXRobSBleHRlbmRzIEFic3RyYWN0QWxnb3JpdGhtIHtcbiAgICBjb25zdHJ1Y3RvcihfYSkge1xuICAgICAgICB2YXIgeyBtYXhab29tLCByYWRpdXMgPSA2MCB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcIm1heFpvb21cIiwgXCJyYWRpdXNcIl0pO1xuICAgICAgICBzdXBlcih7IG1heFpvb20gfSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IHpvb206IC0xIH07XG4gICAgICAgIHRoaXMuc3VwZXJDbHVzdGVyID0gbmV3IFN1cGVyY2x1c3RlcihPYmplY3QuYXNzaWduKHsgbWF4Wm9vbTogdGhpcy5tYXhab29tLCByYWRpdXMgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBjYWxjdWxhdGUoaW5wdXQpIHtcbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7IHpvb206IGlucHV0Lm1hcC5nZXRab29tKCkgfTtcbiAgICAgICAgaWYgKCFlcXVhbChpbnB1dC5tYXJrZXJzLCB0aGlzLm1hcmtlcnMpKSB7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFRPRE8gdXNlIHByb3h5IHRvIGF2b2lkIGNvcHk/XG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSBbLi4uaW5wdXQubWFya2Vyc107XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLm1hcmtlcnMubWFwKChtYXJrZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IE1hcmtlclV0aWxzLmdldFBvc2l0aW9uKG1hcmtlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBbcG9zaXRpb24ubG5nKCksIHBvc2l0aW9uLmxhdCgpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7IG1hcmtlciB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3VwZXJDbHVzdGVyLmxvYWQocG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnpvb20gPD0gdGhpcy5tYXhab29tIHx8IHN0YXRlLnpvb20gPD0gdGhpcy5tYXhab29tKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9ICFlcXVhbCh0aGlzLnN0YXRlLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVycyA9IHRoaXMuY2x1c3RlcihpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2x1c3RlcnM6IHRoaXMuY2x1c3RlcnMsIGNoYW5nZWQgfTtcbiAgICB9XG4gICAgY2x1c3Rlcih7IG1hcCB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1cGVyQ2x1c3RlclxuICAgICAgICAgICAgLmdldENsdXN0ZXJzKFstMTgwLCAtOTAsIDE4MCwgOTBdLCBNYXRoLnJvdW5kKG1hcC5nZXRab29tKCkpKVxuICAgICAgICAgICAgLm1hcCgoZmVhdHVyZSkgPT4gdGhpcy50cmFuc2Zvcm1DbHVzdGVyKGZlYXR1cmUpKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtQ2x1c3Rlcih7IGdlb21ldHJ5OiB7IGNvb3JkaW5hdGVzOiBbbG5nLCBsYXRdLCB9LCBwcm9wZXJ0aWVzLCB9KSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzLmNsdXN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2x1c3Rlcih7XG4gICAgICAgICAgICAgICAgbWFya2VyczogdGhpcy5zdXBlckNsdXN0ZXJcbiAgICAgICAgICAgICAgICAgICAgLmdldExlYXZlcyhwcm9wZXJ0aWVzLmNsdXN0ZXJfaWQsIEluZmluaXR5KVxuICAgICAgICAgICAgICAgICAgICAubWFwKChsZWFmKSA9PiBsZWFmLnByb3BlcnRpZXMubWFya2VyKSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogeyBsYXQsIGxuZyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFya2VyID0gcHJvcGVydGllcy5tYXJrZXI7XG4gICAgICAgIHJldHVybiBuZXcgQ2x1c3Rlcih7XG4gICAgICAgICAgICBtYXJrZXJzOiBbbWFya2VyXSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBNYXJrZXJVdGlscy5nZXRQb3NpdGlvbihtYXJrZXIpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMjEgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogQSB2ZXJ5IGZhc3QgSmF2YVNjcmlwdCBhbGdvcml0aG0gZm9yIGdlb3NwYXRpYWwgcG9pbnQgY2x1c3RlcmluZyB1c2luZyBLRCB0cmVlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL3N1cGVyY2x1c3RlciBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBvcHRpb25zLlxuICovXG5jbGFzcyBTdXBlckNsdXN0ZXJWaWV3cG9ydEFsZ29yaXRobSBleHRlbmRzIEFic3RyYWN0Vmlld3BvcnRBbGdvcml0aG0ge1xuICAgIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgICAgIHZhciB7IG1heFpvb20sIHJhZGl1cyA9IDYwLCB2aWV3cG9ydFBhZGRpbmcgPSA2MCB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcIm1heFpvb21cIiwgXCJyYWRpdXNcIiwgXCJ2aWV3cG9ydFBhZGRpbmdcIl0pO1xuICAgICAgICBzdXBlcih7IG1heFpvb20sIHZpZXdwb3J0UGFkZGluZyB9KTtcbiAgICAgICAgdGhpcy5zdXBlckNsdXN0ZXIgPSBuZXcgU3VwZXJjbHVzdGVyKE9iamVjdC5hc3NpZ24oeyBtYXhab29tOiB0aGlzLm1heFpvb20sIHJhZGl1cyB9LCBvcHRpb25zKSk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IHpvb206IC0xLCB2aWV3OiBbMCwgMCwgMCwgMF0gfTtcbiAgICB9XG4gICAgY2FsY3VsYXRlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgem9vbTogTWF0aC5yb3VuZChpbnB1dC5tYXAuZ2V0Wm9vbSgpKSxcbiAgICAgICAgICAgIHZpZXc6IGdldFBhZGRlZFZpZXdwb3J0KGlucHV0Lm1hcC5nZXRCb3VuZHMoKSwgaW5wdXQubWFwQ2FudmFzUHJvamVjdGlvbiwgdGhpcy52aWV3cG9ydFBhZGRpbmcpLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2hhbmdlZCA9ICFlcXVhbCh0aGlzLnN0YXRlLCBzdGF0ZSk7XG4gICAgICAgIGlmICghZXF1YWwoaW5wdXQubWFya2VycywgdGhpcy5tYXJrZXJzKSkge1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBUT0RPIHVzZSBwcm94eSB0byBhdm9pZCBjb3B5P1xuICAgICAgICAgICAgdGhpcy5tYXJrZXJzID0gWy4uLmlucHV0Lm1hcmtlcnNdO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5tYXJrZXJzLm1hcCgobWFya2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBNYXJrZXJVdGlscy5nZXRQb3NpdGlvbihtYXJrZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gW3Bvc2l0aW9uLmxuZygpLCBwb3NpdGlvbi5sYXQoKV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogeyBtYXJrZXIgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnN1cGVyQ2x1c3Rlci5sb2FkKHBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2x1c3RlcnMgPSB0aGlzLmNsdXN0ZXIoaW5wdXQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNsdXN0ZXJzOiB0aGlzLmNsdXN0ZXJzLCBjaGFuZ2VkIH07XG4gICAgfVxuICAgIGNsdXN0ZXIoeyBtYXAsIG1hcENhbnZhc1Byb2plY3Rpb24gfSkge1xuICAgICAgICAvKiByZWNhbGN1bGF0ZSBuZXcgc3RhdGUgYmVjYXVzZSB3ZSBjYW4ndCB1c2UgdGhlIGNhY2hlZCB2ZXJzaW9uLiAqL1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHpvb206IE1hdGgucm91bmQobWFwLmdldFpvb20oKSksXG4gICAgICAgICAgICB2aWV3OiBnZXRQYWRkZWRWaWV3cG9ydChtYXAuZ2V0Qm91bmRzKCksIG1hcENhbnZhc1Byb2plY3Rpb24sIHRoaXMudmlld3BvcnRQYWRkaW5nKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VwZXJDbHVzdGVyXG4gICAgICAgICAgICAuZ2V0Q2x1c3RlcnMoc3RhdGUudmlldywgc3RhdGUuem9vbSlcbiAgICAgICAgICAgIC5tYXAoKGZlYXR1cmUpID0+IHRoaXMudHJhbnNmb3JtQ2x1c3RlcihmZWF0dXJlKSk7XG4gICAgfVxuICAgIHRyYW5zZm9ybUNsdXN0ZXIoeyBnZW9tZXRyeTogeyBjb29yZGluYXRlczogW2xuZywgbGF0XSwgfSwgcHJvcGVydGllcywgfSkge1xuICAgICAgICBpZiAocHJvcGVydGllcy5jbHVzdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENsdXN0ZXIoe1xuICAgICAgICAgICAgICAgIG1hcmtlcnM6IHRoaXMuc3VwZXJDbHVzdGVyXG4gICAgICAgICAgICAgICAgICAgIC5nZXRMZWF2ZXMocHJvcGVydGllcy5jbHVzdGVyX2lkLCBJbmZpbml0eSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgobGVhZikgPT4gbGVhZi5wcm9wZXJ0aWVzLm1hcmtlciksXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IHsgbGF0LCBsbmcgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hcmtlciA9IHByb3BlcnRpZXMubWFya2VyO1xuICAgICAgICByZXR1cm4gbmV3IENsdXN0ZXIoe1xuICAgICAgICAgICAgbWFya2VyczogW21hcmtlcl0sXG4gICAgICAgICAgICBwb3NpdGlvbjogTWFya2VyVXRpbHMuZ2V0UG9zaXRpb24obWFya2VyKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFByb3ZpZGVzIHN0YXRpc3RpY3Mgb24gYWxsIGNsdXN0ZXJzIGluIHRoZSBjdXJyZW50IHJlbmRlciBjeWNsZSBmb3IgdXNlIGluIHtAbGluayBSZW5kZXJlci5yZW5kZXJ9LlxuICovXG5jbGFzcyBDbHVzdGVyU3RhdHMge1xuICAgIGNvbnN0cnVjdG9yKG1hcmtlcnMsIGNsdXN0ZXJzKSB7XG4gICAgICAgIHRoaXMubWFya2VycyA9IHsgc3VtOiBtYXJrZXJzLmxlbmd0aCB9O1xuICAgICAgICBjb25zdCBjbHVzdGVyTWFya2VyQ291bnRzID0gY2x1c3RlcnMubWFwKChhKSA9PiBhLmNvdW50KTtcbiAgICAgICAgY29uc3QgY2x1c3Rlck1hcmtlclN1bSA9IGNsdXN0ZXJNYXJrZXJDb3VudHMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgICAgIHRoaXMuY2x1c3RlcnMgPSB7XG4gICAgICAgICAgICBjb3VudDogY2x1c3RlcnMubGVuZ3RoLFxuICAgICAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgICAgICAgIG1lYW46IGNsdXN0ZXJNYXJrZXJTdW0gLyBjbHVzdGVycy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgc3VtOiBjbHVzdGVyTWFya2VyU3VtLFxuICAgICAgICAgICAgICAgIG1pbjogTWF0aC5taW4oLi4uY2x1c3Rlck1hcmtlckNvdW50cyksXG4gICAgICAgICAgICAgICAgbWF4OiBNYXRoLm1heCguLi5jbHVzdGVyTWFya2VyQ291bnRzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgRGVmYXVsdFJlbmRlcmVyIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCByZW5kZXIgZnVuY3Rpb24gZm9yIHRoZSBsaWJyYXJ5IHVzZWQgYnkge0BsaW5rIE1hcmtlckNsdXN0ZXJlcn0uXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkgc2V0IHRvIHVzZSB0aGUgZm9sbG93aW5nOlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGNoYW5nZSBjb2xvciBpZiB0aGlzIGNsdXN0ZXIgaGFzIG1vcmUgbWFya2VycyB0aGFuIHRoZSBtZWFuIGNsdXN0ZXJcbiAgICAgKiBjb25zdCBjb2xvciA9XG4gICAgICogICBjb3VudCA+IE1hdGgubWF4KDEwLCBzdGF0cy5jbHVzdGVycy5tYXJrZXJzLm1lYW4pXG4gICAgICogICAgID8gXCIjZmYwMDAwXCJcbiAgICAgKiAgICAgOiBcIiMwMDAwZmZcIjtcbiAgICAgKlxuICAgICAqIC8vIGNyZWF0ZSBzdmcgdXJsIHdpdGggZmlsbCBjb2xvclxuICAgICAqIGNvbnN0IHN2ZyA9IHdpbmRvdy5idG9hKGBcbiAgICAgKiA8c3ZnIGZpbGw9XCIke2NvbG9yfVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0MCAyNDBcIj5cbiAgICAgKiAgIDxjaXJjbGUgY3g9XCIxMjBcIiBjeT1cIjEyMFwiIG9wYWNpdHk9XCIuNlwiIHI9XCI3MFwiIC8+XG4gICAgICogICA8Y2lyY2xlIGN4PVwiMTIwXCIgY3k9XCIxMjBcIiBvcGFjaXR5PVwiLjNcIiByPVwiOTBcIiAvPlxuICAgICAqICAgPGNpcmNsZSBjeD1cIjEyMFwiIGN5PVwiMTIwXCIgb3BhY2l0eT1cIi4yXCIgcj1cIjExMFwiIC8+XG4gICAgICogICA8Y2lyY2xlIGN4PVwiMTIwXCIgY3k9XCIxMjBcIiBvcGFjaXR5PVwiLjFcIiByPVwiMTMwXCIgLz5cbiAgICAgKiA8L3N2Zz5gKTtcbiAgICAgKlxuICAgICAqIC8vIGNyZWF0ZSBtYXJrZXIgdXNpbmcgc3ZnIGljb25cbiAgICAgKiByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLk1hcmtlcih7XG4gICAgICogICBwb3NpdGlvbixcbiAgICAgKiAgIGljb246IHtcbiAgICAgKiAgICAgdXJsOiBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke3N2Z31gLFxuICAgICAqICAgICBzY2FsZWRTaXplOiBuZXcgZ29vZ2xlLm1hcHMuU2l6ZSg0NSwgNDUpLFxuICAgICAqICAgfSxcbiAgICAgKiAgIGxhYmVsOiB7XG4gICAgICogICAgIHRleHQ6IFN0cmluZyhjb3VudCksXG4gICAgICogICAgIGNvbG9yOiBcInJnYmEoMjU1LDI1NSwyNTUsMC45KVwiLFxuICAgICAqICAgICBmb250U2l6ZTogXCIxMnB4XCIsXG4gICAgICogICB9LFxuICAgICAqICAgLy8gYWRqdXN0IHpJbmRleCB0byBiZSBhYm92ZSBvdGhlciBtYXJrZXJzXG4gICAgICogICB6SW5kZXg6IDEwMDAgKyBjb3VudCxcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByZW5kZXIoeyBjb3VudCwgcG9zaXRpb24gfSwgc3RhdHMsIG1hcCkge1xuICAgICAgICAvLyBjaGFuZ2UgY29sb3IgaWYgdGhpcyBjbHVzdGVyIGhhcyBtb3JlIG1hcmtlcnMgdGhhbiB0aGUgbWVhbiBjbHVzdGVyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gY291bnQgPiBNYXRoLm1heCgxMCwgc3RhdHMuY2x1c3RlcnMubWFya2Vycy5tZWFuKSA/IFwiI2ZmMDAwMFwiIDogXCIjMDAwMGZmXCI7XG4gICAgICAgIC8vIGNyZWF0ZSBzdmcgbGl0ZXJhbCB3aXRoIGZpbGwgY29sb3JcbiAgICAgICAgY29uc3Qgc3ZnID0gYDxzdmcgZmlsbD1cIiR7Y29sb3J9XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQwIDI0MFwiIHdpZHRoPVwiNTBcIiBoZWlnaHQ9XCI1MFwiPlxuPGNpcmNsZSBjeD1cIjEyMFwiIGN5PVwiMTIwXCIgb3BhY2l0eT1cIi42XCIgcj1cIjcwXCIgLz5cbjxjaXJjbGUgY3g9XCIxMjBcIiBjeT1cIjEyMFwiIG9wYWNpdHk9XCIuM1wiIHI9XCI5MFwiIC8+XG48Y2lyY2xlIGN4PVwiMTIwXCIgY3k9XCIxMjBcIiBvcGFjaXR5PVwiLjJcIiByPVwiMTEwXCIgLz5cbjx0ZXh0IHg9XCI1MCVcIiB5PVwiNTAlXCIgc3R5bGU9XCJmaWxsOiNmZmZcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiIGZvbnQtc2l6ZT1cIjUwXCIgZG9taW5hbnQtYmFzZWxpbmU9XCJtaWRkbGVcIiBmb250LWZhbWlseT1cInJvYm90byxhcmlhbCxzYW5zLXNlcmlmXCI+JHtjb3VudH08L3RleHQ+XG48L3N2Zz5gO1xuICAgICAgICBjb25zdCB0aXRsZSA9IGBDbHVzdGVyIG9mICR7Y291bnR9IG1hcmtlcnNgLCBcbiAgICAgICAgLy8gYWRqdXN0IHpJbmRleCB0byBiZSBhYm92ZSBvdGhlciBtYXJrZXJzXG4gICAgICAgIHpJbmRleCA9IE51bWJlcihnb29nbGUubWFwcy5NYXJrZXIuTUFYX1pJTkRFWCkgKyBjb3VudDtcbiAgICAgICAgaWYgKE1hcmtlclV0aWxzLmlzQWR2YW5jZWRNYXJrZXJBdmFpbGFibGUobWFwKSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGNsdXN0ZXIgU1ZHIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHN2Z0VsID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhzdmcsIFwiaW1hZ2Uvc3ZnK3htbFwiKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICBzdmdFbC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCAyNSlcIik7XG4gICAgICAgICAgICBjb25zdCBjbHVzdGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgekluZGV4LFxuICAgICAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN2Z0VsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMubWFya2VyLkFkdmFuY2VkTWFya2VyRWxlbWVudChjbHVzdGVyT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2x1c3Rlck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgaWNvbjoge1xuICAgICAgICAgICAgICAgIHVybDogYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKHN2Zyl9YCxcbiAgICAgICAgICAgICAgICBhbmNob3I6IG5ldyBnb29nbGUubWFwcy5Qb2ludCgyNSwgMjUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBnb29nbGUubWFwcy5NYXJrZXIoY2x1c3Rlck9wdGlvbnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogRXh0ZW5kcyBhbiBvYmplY3QncyBwcm90b3R5cGUgYnkgYW5vdGhlcidzLlxuICpcbiAqIEBwYXJhbSB0eXBlMSBUaGUgVHlwZSB0byBiZSBleHRlbmRlZC5cbiAqIEBwYXJhbSB0eXBlMiBUaGUgVHlwZSB0byBleHRlbmQgd2l0aC5cbiAqIEBpZ25vcmVcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGV4dGVuZCh0eXBlMSwgdHlwZTIpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBmb3IgKGxldCBwcm9wZXJ0eSBpbiB0eXBlMi5wcm90b3R5cGUpIHtcbiAgICAgICAgdHlwZTEucHJvdG90eXBlW3Byb3BlcnR5XSA9IHR5cGUyLnByb3RvdHlwZVtwcm9wZXJ0eV07XG4gICAgfVxufVxuLyoqXG4gKiBAaWdub3JlXG4gKi9cbmNsYXNzIE92ZXJsYXlWaWV3U2FmZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIE1hcmtlckNsdXN0ZXJlciBpbXBsZW1lbnRzIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3IGludGVyZmFjZS4gV2UgdXNlIHRoZVxuICAgICAgICAvLyBleHRlbmQgZnVuY3Rpb24gdG8gZXh0ZW5kIE1hcmtlckNsdXN0ZXJlciB3aXRoIGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3XG4gICAgICAgIC8vIGJlY2F1c2UgaXQgbWlnaHQgbm90IGFsd2F5cyBiZSBhdmFpbGFibGUgd2hlbiB0aGUgY29kZSBpcyBkZWZpbmVkIHNvIHdlXG4gICAgICAgIC8vIGxvb2sgZm9yIGl0IGF0IHRoZSBsYXN0IHBvc3NpYmxlIG1vbWVudC4gSWYgaXQgZG9lc24ndCBleGlzdCBub3cgdGhlblxuICAgICAgICAvLyB0aGVyZSBpcyBubyBwb2ludCBnb2luZyBhaGVhZCA6KVxuICAgICAgICBleHRlbmQoT3ZlcmxheVZpZXdTYWZlLCBnb29nbGUubWFwcy5PdmVybGF5Vmlldyk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgTWFya2VyQ2x1c3RlcmVyRXZlbnRzO1xuKGZ1bmN0aW9uIChNYXJrZXJDbHVzdGVyZXJFdmVudHMpIHtcbiAgICBNYXJrZXJDbHVzdGVyZXJFdmVudHNbXCJDTFVTVEVSSU5HX0JFR0lOXCJdID0gXCJjbHVzdGVyaW5nYmVnaW5cIjtcbiAgICBNYXJrZXJDbHVzdGVyZXJFdmVudHNbXCJDTFVTVEVSSU5HX0VORFwiXSA9IFwiY2x1c3RlcmluZ2VuZFwiO1xuICAgIE1hcmtlckNsdXN0ZXJlckV2ZW50c1tcIkNMVVNURVJfQ0xJQ0tcIl0gPSBcImNsaWNrXCI7XG59KShNYXJrZXJDbHVzdGVyZXJFdmVudHMgfHwgKE1hcmtlckNsdXN0ZXJlckV2ZW50cyA9IHt9KSk7XG5jb25zdCBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyID0gKF8sIGNsdXN0ZXIsIG1hcCkgPT4ge1xuICAgIG1hcC5maXRCb3VuZHMoY2x1c3Rlci5ib3VuZHMpO1xufTtcbi8qKlxuICogTWFya2VyQ2x1c3RlcmVyIGNyZWF0ZXMgYW5kIG1hbmFnZXMgcGVyLXpvb20tbGV2ZWwgY2x1c3RlcnMgZm9yIGxhcmdlIGFtb3VudHNcbiAqIG9mIG1hcmtlcnMuIFNlZSB7QGxpbmsgTWFya2VyQ2x1c3RlcmVyT3B0aW9uc30gZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKi9cbmNsYXNzIE1hcmtlckNsdXN0ZXJlciBleHRlbmRzIE92ZXJsYXlWaWV3U2FmZSB7XG4gICAgY29uc3RydWN0b3IoeyBtYXAsIG1hcmtlcnMgPSBbXSwgYWxnb3JpdGhtT3B0aW9ucyA9IHt9LCBhbGdvcml0aG0gPSBuZXcgU3VwZXJDbHVzdGVyQWxnb3JpdGhtKGFsZ29yaXRobU9wdGlvbnMpLCByZW5kZXJlciA9IG5ldyBEZWZhdWx0UmVuZGVyZXIoKSwgb25DbHVzdGVyQ2xpY2sgPSBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyLCB9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWFya2VycyA9IFsuLi5tYXJrZXJzXTtcbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IFtdO1xuICAgICAgICB0aGlzLmFsZ29yaXRobSA9IGFsZ29yaXRobTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLm9uQ2x1c3RlckNsaWNrID0gb25DbHVzdGVyQ2xpY2s7XG4gICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTWFya2VyKG1hcmtlciwgbm9EcmF3KSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtlcnMuaW5jbHVkZXMobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya2Vycy5wdXNoKG1hcmtlcik7XG4gICAgICAgIGlmICghbm9EcmF3KSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZE1hcmtlcnMobWFya2Vycywgbm9EcmF3KSB7XG4gICAgICAgIG1hcmtlcnMuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE1hcmtlcihtYXJrZXIsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFub0RyYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlTWFya2VyKG1hcmtlciwgbm9EcmF3KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYXJrZXJzLmluZGV4T2YobWFya2VyKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgLy8gTWFya2VyIGlzIG5vdCBpbiBvdXIgbGlzdCBvZiBtYXJrZXJzLCBzbyBkbyBub3RoaW5nOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIE1hcmtlclV0aWxzLnNldE1hcChtYXJrZXIsIG51bGwpO1xuICAgICAgICB0aGlzLm1hcmtlcnMuc3BsaWNlKGluZGV4LCAxKTsgLy8gUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSB0aGUgbGlzdCBvZiBtYW5hZ2VkIG1hcmtlcnNcbiAgICAgICAgaWYgKCFub0RyYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlbW92ZU1hcmtlcnMobWFya2Vycywgbm9EcmF3KSB7XG4gICAgICAgIGxldCByZW1vdmVkID0gZmFsc2U7XG4gICAgICAgIG1hcmtlcnMuZm9yRWFjaCgobWFya2VyKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVkID0gdGhpcy5yZW1vdmVNYXJrZXIobWFya2VyLCB0cnVlKSB8fCByZW1vdmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlbW92ZWQgJiYgIW5vRHJhdykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG4gICAgY2xlYXJNYXJrZXJzKG5vRHJhdykge1xuICAgICAgICB0aGlzLm1hcmtlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKCFub0RyYXcpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIGFuZCBkcmF3cyBhbGwgdGhlIG1hcmtlciBjbHVzdGVycy5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHRoaXMuZ2V0TWFwKCk7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBnb29nbGUubWFwcy5NYXAgJiYgbWFwLmdldFByb2plY3Rpb24oKSkge1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCBNYXJrZXJDbHVzdGVyZXJFdmVudHMuQ0xVU1RFUklOR19CRUdJTiwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCB7IGNsdXN0ZXJzLCBjaGFuZ2VkIH0gPSB0aGlzLmFsZ29yaXRobS5jYWxjdWxhdGUoe1xuICAgICAgICAgICAgICAgIG1hcmtlcnM6IHRoaXMubWFya2VycyxcbiAgICAgICAgICAgICAgICBtYXAsXG4gICAgICAgICAgICAgICAgbWFwQ2FudmFzUHJvamVjdGlvbjogdGhpcy5nZXRQcm9qZWN0aW9uKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFsbG93IGFsZ29yaXRobXMgdG8gcmV0dXJuIGZsYWcgb24gd2hldGhlciB0aGUgY2x1c3RlcnMvbWFya2VycyBoYXZlIGNoYW5nZWQuXG4gICAgICAgICAgICBpZiAoY2hhbmdlZCB8fCBjaGFuZ2VkID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGUgdGhlIG1hcmtlcnMgb2YgdGhlIGNsdXN0ZXJzIGNvbXBvc2VkIG9mIGEgc2luZ2xlIG1hcmtlci5cbiAgICAgICAgICAgICAgICAvLyBUaG9zZSBjbHVzdGVycyBkaXJlY3RseSB1c2UgdGhlIG1hcmtlci5cbiAgICAgICAgICAgICAgICAvLyBDbHVzdGVycyB3aXRoIG1vcmUgdGhhbiBvbmUgbWFya2VycyB1c2UgYSBncm91cCBtYXJrZXIgZ2VuZXJhdGVkIGJ5IGEgcmVuZGVyZXIuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2luZ2xlTWFya2VyID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2x1c3RlciBvZiBjbHVzdGVycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2x1c3Rlci5tYXJrZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaW5nbGVNYXJrZXIuYWRkKGNsdXN0ZXIubWFya2Vyc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBNYXJrZXJzID0gW107XG4gICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aGUgY2x1c3RlcnMgdGhhdCBhcmUgY3VycmVudGx5IHJlbmRlcmVkLlxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2x1c3RlciBvZiB0aGlzLmNsdXN0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHVzdGVyLm1hcmtlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2x1c3Rlci5tYXJrZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpbmdsZU1hcmtlci5oYXMoY2x1c3Rlci5tYXJrZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1hcmtlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHdhcyBwcmV2aW91c2x5IHJlbmRlcmVkIGJlY2F1c2UgaXQgaXMgZnJvbSBhIGNsdXN0ZXIgd2l0aCAxIG1hcmtlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHNob3VsZCBubyBtb3JlIGJlIHJlbmRlcmVkIGFzIGl0IGlzIG5vdCBpbiBzaW5nbGVNYXJrZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWFya2VyVXRpbHMuc2V0TWFwKGNsdXN0ZXIubWFya2VyLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGF5IHRoZSByZW1vdmFsIG9mIG9sZCBncm91cCBtYXJrZXJzIHRvIGF2b2lkIGZsaWNrZXJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cE1hcmtlcnMucHVzaChjbHVzdGVyLm1hcmtlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jbHVzdGVycyA9IGNsdXN0ZXJzO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2x1c3RlcnMoKTtcbiAgICAgICAgICAgICAgICAvLyBEZWxheWVkIHJlbW92YWwgb2YgdGhlIG1hcmtlcnMgb2YgdGhlIGZvcm1lciBncm91cHMuXG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGdyb3VwTWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IE1hcmtlclV0aWxzLnNldE1hcChtYXJrZXIsIG51bGwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC50cmlnZ2VyKHRoaXMsIE1hcmtlckNsdXN0ZXJlckV2ZW50cy5DTFVTVEVSSU5HX0VORCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25BZGQoKSB7XG4gICAgICAgIHRoaXMuaWRsZUxpc3RlbmVyID0gdGhpcy5nZXRNYXAoKS5hZGRMaXN0ZW5lcihcImlkbGVcIiwgdGhpcy5yZW5kZXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIG9uUmVtb3ZlKCkge1xuICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcih0aGlzLmlkbGVMaXN0ZW5lcik7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubWFya2Vycy5mb3JFYWNoKChtYXJrZXIpID0+IE1hcmtlclV0aWxzLnNldE1hcChtYXJrZXIsIG51bGwpKTtcbiAgICAgICAgdGhpcy5jbHVzdGVycy5mb3JFYWNoKChjbHVzdGVyKSA9PiBjbHVzdGVyLmRlbGV0ZSgpKTtcbiAgICAgICAgdGhpcy5jbHVzdGVycyA9IFtdO1xuICAgIH1cbiAgICByZW5kZXJDbHVzdGVycygpIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgc3RhdHMgdG8gcGFzcyB0byByZW5kZXJlcnMuXG4gICAgICAgIGNvbnN0IHN0YXRzID0gbmV3IENsdXN0ZXJTdGF0cyh0aGlzLm1hcmtlcnMsIHRoaXMuY2x1c3RlcnMpO1xuICAgICAgICBjb25zdCBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgICAgICB0aGlzLmNsdXN0ZXJzLmZvckVhY2goKGNsdXN0ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChjbHVzdGVyLm1hcmtlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgY2x1c3Rlci5tYXJrZXIgPSBjbHVzdGVyLm1hcmtlcnNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgbWFya2VyIHRvIHJlcHJlc2VudCB0aGUgZ3JvdXAuXG4gICAgICAgICAgICAgICAgY2x1c3Rlci5tYXJrZXIgPSB0aGlzLnJlbmRlcmVyLnJlbmRlcihjbHVzdGVyLCBzdGF0cywgbWFwKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGluZGl2aWR1YWwgbWFya2VycyBhcmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXAuXG4gICAgICAgICAgICAgICAgY2x1c3Rlci5tYXJrZXJzLmZvckVhY2goKG1hcmtlcikgPT4gTWFya2VyVXRpbHMuc2V0TWFwKG1hcmtlciwgbnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uQ2x1c3RlckNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXIubWFya2VyLmFkZExpc3RlbmVyKFwiY2xpY2tcIiwgXG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcih0aGlzLCBNYXJrZXJDbHVzdGVyZXJFdmVudHMuQ0xVU1RFUl9DTElDSywgY2x1c3Rlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2x1c3RlckNsaWNrKGV2ZW50LCBjbHVzdGVyLCBtYXApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNYXJrZXJVdGlscy5zZXRNYXAoY2x1c3Rlci5tYXJrZXIsIG1hcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxudmFyIGluZGV4X2VzbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgQWJzdHJhY3RBbGdvcml0aG06IEFic3RyYWN0QWxnb3JpdGhtLFxuICAgIEFic3RyYWN0Vmlld3BvcnRBbGdvcml0aG06IEFic3RyYWN0Vmlld3BvcnRBbGdvcml0aG0sXG4gICAgQ2x1c3RlcjogQ2x1c3RlcixcbiAgICBDbHVzdGVyU3RhdHM6IENsdXN0ZXJTdGF0cyxcbiAgICBEZWZhdWx0UmVuZGVyZXI6IERlZmF1bHRSZW5kZXJlcixcbiAgICBHcmlkQWxnb3JpdGhtOiBHcmlkQWxnb3JpdGhtLFxuICAgIE1hcmtlckNsdXN0ZXJlcjogTWFya2VyQ2x1c3RlcmVyLFxuICAgIGdldCBNYXJrZXJDbHVzdGVyZXJFdmVudHMgKCkgeyByZXR1cm4gTWFya2VyQ2x1c3RlcmVyRXZlbnRzOyB9LFxuICAgIE1hcmtlclV0aWxzOiBNYXJrZXJVdGlscyxcbiAgICBOb29wQWxnb3JpdGhtOiBOb29wQWxnb3JpdGhtLFxuICAgIFN1cGVyQ2x1c3RlckFsZ29yaXRobTogU3VwZXJDbHVzdGVyQWxnb3JpdGhtLFxuICAgIFN1cGVyQ2x1c3RlclZpZXdwb3J0QWxnb3JpdGhtOiBTdXBlckNsdXN0ZXJWaWV3cG9ydEFsZ29yaXRobSxcbiAgICBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyOiBkZWZhdWx0T25DbHVzdGVyQ2xpY2tIYW5kbGVyLFxuICAgIGRpc3RhbmNlQmV0d2VlblBvaW50czogZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLFxuICAgIGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQ6IGV4dGVuZEJvdW5kc1RvUGFkZGVkVmlld3BvcnQsXG4gICAgZXh0ZW5kUGl4ZWxCb3VuZHM6IGV4dGVuZFBpeGVsQm91bmRzLFxuICAgIGZpbHRlck1hcmtlcnNUb1BhZGRlZFZpZXdwb3J0OiBmaWx0ZXJNYXJrZXJzVG9QYWRkZWRWaWV3cG9ydCxcbiAgICBnZXRQYWRkZWRWaWV3cG9ydDogZ2V0UGFkZGVkVmlld3BvcnQsXG4gICAgbm9vcDogbm9vcCQxLFxuICAgIHBpeGVsQm91bmRzVG9MYXRMbmdCb3VuZHM6IHBpeGVsQm91bmRzVG9MYXRMbmdCb3VuZHNcbn0pO1xuXG5mdW5jdGlvbiB1c2VHb29nbGVNYXJrZXJDbHVzdGVyZXIob3B0aW9ucykge1xuICAgIHZhciBtYXAgPSB1c2VHb29nbGVNYXAoKTtcbiAgICB2YXIgX2EgPSB1c2VTdGF0ZShudWxsKSwgbWFya2VyQ2x1c3RlcmVyID0gX2FbMF0sIHNldE1hcmtlckNsdXN0ZXJlciA9IF9hWzFdO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtYXAgJiYgbWFya2VyQ2x1c3RlcmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyQ2x1c3RlciA9IG5ldyBNYXJrZXJDbHVzdGVyZXIoX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG1hcDogbWFwIH0pKTtcbiAgICAgICAgICAgIHNldE1hcmtlckNsdXN0ZXJlcihtYXJrZXJDbHVzdGVyKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXBdKTtcbiAgICByZXR1cm4gbWFya2VyQ2x1c3RlcmVyO1xufVxuLyoqIFdyYXBwZXIgYXJvdW5kIFtAZ29vZ2xlbWFwcy9tYXJrZXJjbHVzdGVyZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVtYXBzL2pzLW1hcmtlcmNsdXN0ZXJlcilcbiAqXG4gKiBBY2NlcHRzIHtAbGluayAgTWFya2VyQ2x1c3RlcmVyT3B0aW9uc1N1YnNldH0gd2hpY2ggaXMgYSBzdWJzZXQgb2YgIHtAbGluayBNYXJrZXJDbHVzdGVyZXJPcHRpb25zfVxuICovXG5mdW5jdGlvbiBHb29nbGVNYXJrZXJDbHVzdGVyZXIoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgdmFyIG1hcmtlckNsdXN0ZXJlciA9IHVzZUdvb2dsZU1hcmtlckNsdXN0ZXJlcihvcHRpb25zKTtcbiAgICByZXR1cm4gbWFya2VyQ2x1c3RlcmVyICE9PSBudWxsID8gY2hpbGRyZW4obWFya2VyQ2x1c3RlcmVyKSA6IG51bGw7XG59XG52YXIgR29vZ2xlTWFya2VyQ2x1c3RlcmVyJDEgPSBtZW1vKEdvb2dsZU1hcmtlckNsdXN0ZXJlcik7XG5cbnZhciBldmVudE1hcCRjID0ge1xuICAgIG9uQ2xvc2VDbGljazogJ2Nsb3NlY2xpY2snLFxuICAgIG9uQ29udGVudENoYW5nZWQ6ICdjb250ZW50X2NoYW5nZWQnLFxuICAgIG9uRG9tUmVhZHk6ICdkb21yZWFkeScsXG4gICAgb25Qb3NpdGlvbkNoYW5nZWQ6ICdwb3NpdGlvbl9jaGFuZ2VkJyxcbiAgICBvblppbmRleENoYW5nZWQ6ICd6aW5kZXhfY2hhbmdlZCcsXG59O1xudmFyIHVwZGF0ZXJNYXAkYyA9IHtcbiAgICBvcHRpb25zOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBvc2l0aW9uKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHpJbmRleDogZnVuY3Rpb24gKGluc3RhbmNlLCB6SW5kZXgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBJbmZvV2luZG93RnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBhbmNob3IgPSBfYS5hbmNob3IsIG9wdGlvbnMgPSBfYS5vcHRpb25zLCBwb3NpdGlvbiA9IF9hLnBvc2l0aW9uLCB6SW5kZXggPSBfYS56SW5kZXgsIG9uQ2xvc2VDbGljayA9IF9hLm9uQ2xvc2VDbGljaywgb25Eb21SZWFkeSA9IF9hLm9uRG9tUmVhZHksIG9uQ29udGVudENoYW5nZWQgPSBfYS5vbkNvbnRlbnRDaGFuZ2VkLCBvblBvc2l0aW9uQ2hhbmdlZCA9IF9hLm9uUG9zaXRpb25DaGFuZ2VkLCBvblppbmRleENoYW5nZWQgPSBfYS5vblppbmRleENoYW5nZWQsIG9uTG9hZCA9IF9hLm9uTG9hZCwgb25Vbm1vdW50ID0gX2Eub25Vbm1vdW50O1xuICAgIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICAgIHZhciBfYiA9IHVzZVN0YXRlKG51bGwpLCBpbnN0YW5jZSA9IF9iWzBdLCBzZXRJbnN0YW5jZSA9IF9iWzFdO1xuICAgIHZhciBfYyA9IHVzZVN0YXRlKG51bGwpLCBjbG9zZWNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0Q2xvc2VDbGlja0xpc3RlbmVyID0gX2NbMV07XG4gICAgdmFyIF9kID0gdXNlU3RhdGUobnVsbCksIGRvbXJlYWR5Y2xpY2tMaXN0ZW5lciA9IF9kWzBdLCBzZXREb21SZWFkeUNsaWNrTGlzdGVuZXIgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSB1c2VTdGF0ZShudWxsKSwgY29udGVudGNoYW5nZWRjbGlja0xpc3RlbmVyID0gX2VbMF0sIHNldENvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lciA9IF9lWzFdO1xuICAgIHZhciBfZiA9IHVzZVN0YXRlKG51bGwpLCBwb3NpdGlvbmNoYW5nZWRjbGlja0xpc3RlbmVyID0gX2ZbMF0sIHNldFBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIgPSBfZlsxXTtcbiAgICB2YXIgX2cgPSB1c2VTdGF0ZShudWxsKSwgemluZGV4Y2hhbmdlZGNsaWNrTGlzdGVuZXIgPSBfZ1swXSwgc2V0WmluZGV4Q2hhbmdlZENsaWNrTGlzdGVuZXIgPSBfZ1sxXTtcbiAgICB2YXIgY29udGFpbmVyRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY2xvc2UoKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5vcGVuKG1hcCwgYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmdldFBvc2l0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5vcGVuKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbWFwLCBpbnN0YW5jZSwgYW5jaG9yXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIG9wdGlvbnNdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocG9zaXRpb24gJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sIFtwb3NpdGlvbl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgekluZGV4ID09PSAnbnVtYmVyJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgICAgIH1cbiAgICB9LCBbekluZGV4XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2xvc2VDbGljaykge1xuICAgICAgICAgICAgaWYgKGNsb3NlY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsb3NlY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDbG9zZUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbG9zZWNsaWNrJywgb25DbG9zZUNsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbG9zZUNsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRG9tUmVhZHkpIHtcbiAgICAgICAgICAgIGlmIChkb21yZWFkeWNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkb21yZWFkeWNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RG9tUmVhZHlDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZG9tcmVhZHknLCBvbkRvbVJlYWR5KSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Eb21SZWFkeV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkNvbnRlbnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoY29udGVudGNoYW5nZWRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGVudGNoYW5nZWRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENvbnRlbnRDaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NvbnRlbnRfY2hhbmdlZCcsIG9uQ29udGVudENoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNvbnRlbnRDaGFuZ2VkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uUG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25jaGFuZ2VkY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHBvc2l0aW9uY2hhbmdlZGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UG9zaXRpb25DaGFuZ2VkQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3Bvc2l0aW9uX2NoYW5nZWQnLCBvblBvc2l0aW9uQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uUG9zaXRpb25DaGFuZ2VkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uWmluZGV4Q2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKHppbmRleGNoYW5nZWRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoemluZGV4Y2hhbmdlZGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0WmluZGV4Q2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICd6aW5kZXhfY2hhbmdlZCcsIG9uWmluZGV4Q2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uWmluZGV4Q2hhbmdlZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmZvV2luZG93ID0gbmV3IGdvb2dsZS5tYXBzLkluZm9XaW5kb3coX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSkpO1xuICAgICAgICBzZXRJbnN0YW5jZShpbmZvV2luZG93KTtcbiAgICAgICAgY29udGFpbmVyRWxlbWVudFJlZi5jdXJyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGlmIChvbkNsb3NlQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsb3NlQ2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbmZvV2luZG93LCAnY2xvc2VjbGljaycsIG9uQ2xvc2VDbGljaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRvbVJlYWR5KSB7XG4gICAgICAgICAgICBzZXREb21SZWFkeUNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb1dpbmRvdywgJ2RvbXJlYWR5Jywgb25Eb21SZWFkeSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNvbnRlbnRDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRDb250ZW50Q2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb1dpbmRvdywgJ2NvbnRlbnRfY2hhbmdlZCcsIG9uQ29udGVudENoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Qb3NpdGlvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFBvc2l0aW9uQ2hhbmdlZENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5mb1dpbmRvdywgJ3Bvc2l0aW9uX2NoYW5nZWQnLCBvblBvc2l0aW9uQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblppbmRleENoYW5nZWQpIHtcbiAgICAgICAgICAgIHNldFppbmRleENoYW5nZWRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluZm9XaW5kb3csICd6aW5kZXhfY2hhbmdlZCcsIG9uWmluZGV4Q2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgICAgIGluZm9XaW5kb3cuc2V0Q29udGVudChjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQpO1xuICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6SW5kZXgpIHtcbiAgICAgICAgICAgIGluZm9XaW5kb3cuc2V0WkluZGV4KHpJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgaW5mb1dpbmRvdy5vcGVuKG1hcCwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmZvV2luZG93LmdldFBvc2l0aW9uKCkpIHtcbiAgICAgICAgICAgIGluZm9XaW5kb3cub3BlbihtYXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW52YXJpYW50JDEoZmFsc2UsIFwiWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gYW5jaG9yICh0eXBpY2FsbHkgcmVuZGVyIGl0IGluc2lkZSBhIDxNYXJrZXI+KSBvciBhIHBvc2l0aW9uIHByb3BzIGZvciA8SW5mb1dpbmRvdz4uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgIG9uTG9hZChpbmZvV2luZG93KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGNsb3NlY2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsb3NlY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudGNoYW5nZWRjbGlja0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY29udGVudGNoYW5nZWRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkb21yZWFkeWNsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkb21yZWFkeWNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uY2hhbmdlZGNsaWNrTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihwb3NpdGlvbmNoYW5nZWRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh6aW5kZXhjaGFuZ2VkY2xpY2tMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHppbmRleGNoYW5nZWRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQoaW5mb1dpbmRvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmZvV2luZG93LmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQgPyAoY3JlYXRlUG9ydGFsKENoaWxkcmVuLm9ubHkoY2hpbGRyZW4pLCBjb250YWluZXJFbGVtZW50UmVmLmN1cnJlbnQpKSA6IChudWxsKTtcbn1cbnZhciBJbmZvV2luZG93RiA9IG1lbW8oSW5mb1dpbmRvd0Z1bmN0aW9uYWwpO1xudmFyIEluZm9XaW5kb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEluZm9XaW5kb3csIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5mb1dpbmRvdygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyRWxlbWVudCA9IG51bGw7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgaW5mb1dpbmRvdzogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub3BlbiA9IGZ1bmN0aW9uIChpbmZvV2luZG93LCBhbmNob3IpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgICAgICBpbmZvV2luZG93Lm9wZW4oX3RoaXMuY29udGV4dCwgYW5jaG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluZm9XaW5kb3cuZ2V0UG9zaXRpb24oKSkge1xuICAgICAgICAgICAgICAgIGluZm9XaW5kb3cub3BlbihfdGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGludmFyaWFudCQxKGZhbHNlLCBcIllvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGFuY2hvciAodHlwaWNhbGx5IHJlbmRlciBpdCBpbnNpZGUgYSA8TWFya2VyPikgb3IgYSBwb3NpdGlvbiBwcm9wcyBmb3IgPEluZm9XaW5kb3c+LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0SW5mb1dpbmRvd0NhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmluZm9XaW5kb3cgIT09IG51bGwgJiYgX3RoaXMuY29udGFpbmVyRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmluZm9XaW5kb3cuc2V0Q29udGVudChfdGhpcy5jb250YWluZXJFbGVtZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vcGVuKF90aGlzLnN0YXRlLmluZm9XaW5kb3csIF90aGlzLnByb3BzLmFuY2hvcik7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUuaW5mb1dpbmRvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluZm9XaW5kb3cucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5mb1dpbmRvdyA9IG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KF9fYXNzaWduKHt9LCAodGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9KSkpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGMsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkYyxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5mb1dpbmRvdyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbmZvV2luZG93OiBpbmZvV2luZG93LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRJbmZvV2luZG93Q2FsbGJhY2spO1xuICAgIH07XG4gICAgSW5mb1dpbmRvdy5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbmZvV2luZG93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGMsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGMsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmluZm9XaW5kb3csXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb1dpbmRvdy5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmluZm9XaW5kb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuaW5mb1dpbmRvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmluZm9XaW5kb3cuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSW5mb1dpbmRvdy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJFbGVtZW50ID8gKGNyZWF0ZVBvcnRhbChDaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pLCB0aGlzLmNvbnRhaW5lckVsZW1lbnQpKSA6IChudWxsKTtcbiAgICB9O1xuICAgIEluZm9XaW5kb3cuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBJbmZvV2luZG93O1xufShQdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCRiID0ge1xuICAgIG9uQ2xpY2s6ICdjbGljaycsXG4gICAgb25EYmxDbGljazogJ2RibGNsaWNrJyxcbiAgICBvbkRyYWc6ICdkcmFnJyxcbiAgICBvbkRyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgICBvbkRyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gICAgb25Nb3VzZURvd246ICdtb3VzZWRvd24nLFxuICAgIG9uTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICBvbk1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICAgIG9uTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgICBvbk1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgICBvblJpZ2h0Q2xpY2s6ICdyaWdodGNsaWNrJyxcbn07XG52YXIgdXBkYXRlck1hcCRiID0ge1xuICAgIGRyYWdnYWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBkcmFnZ2FibGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgfSxcbiAgICBlZGl0YWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBlZGl0YWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbWFwKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBwYXRoOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhdGgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGF0aChwYXRoKTtcbiAgICB9LFxuICAgIHZpc2libGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdmlzaWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgIH0sXG59O1xudmFyIGRlZmF1bHRPcHRpb25zJDEgPSB7fTtcbmZ1bmN0aW9uIFBvbHlsaW5lRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucywgZHJhZ2dhYmxlID0gX2EuZHJhZ2dhYmxlLCBlZGl0YWJsZSA9IF9hLmVkaXRhYmxlLCB2aXNpYmxlID0gX2EudmlzaWJsZSwgcGF0aCA9IF9hLnBhdGgsIG9uRGJsQ2xpY2sgPSBfYS5vbkRibENsaWNrLCBvbkRyYWdFbmQgPSBfYS5vbkRyYWdFbmQsIG9uRHJhZ1N0YXJ0ID0gX2Eub25EcmFnU3RhcnQsIG9uTW91c2VEb3duID0gX2Eub25Nb3VzZURvd24sIG9uTW91c2VNb3ZlID0gX2Eub25Nb3VzZU1vdmUsIG9uTW91c2VPdXQgPSBfYS5vbk1vdXNlT3V0LCBvbk1vdXNlT3ZlciA9IF9hLm9uTW91c2VPdmVyLCBvbk1vdXNlVXAgPSBfYS5vbk1vdXNlVXAsIG9uUmlnaHRDbGljayA9IF9hLm9uUmlnaHRDbGljaywgb25DbGljayA9IF9hLm9uQ2xpY2ssIG9uRHJhZyA9IF9hLm9uRHJhZywgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gdXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gdXNlU3RhdGUobnVsbCksIGRibGNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0RGJsY2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHVzZVN0YXRlKG51bGwpLCBkcmFnZW5kTGlzdGVuZXIgPSBfZFswXSwgc2V0RHJhZ2VuZExpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gdXNlU3RhdGUobnVsbCksIGRyYWdzdGFydExpc3RlbmVyID0gX2VbMF0sIHNldERyYWdzdGFydExpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gdXNlU3RhdGUobnVsbCksIG1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMV07XG4gICAgdmFyIF9nID0gdXNlU3RhdGUobnVsbCksIG1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMF0sIHNldE1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMV07XG4gICAgdmFyIF9oID0gdXNlU3RhdGUobnVsbCksIG1vdXNlb3V0TGlzdGVuZXIgPSBfaFswXSwgc2V0TW91c2VvdXRMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzBdLCBzZXRNb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzFdO1xuICAgIHZhciBfayA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZXVwTGlzdGVuZXIgPSBfa1swXSwgc2V0TW91c2V1cExpc3RlbmVyID0gX2tbMV07XG4gICAgdmFyIF9sID0gdXNlU3RhdGUobnVsbCksIHJpZ2h0Y2xpY2tMaXN0ZW5lciA9IF9sWzBdLCBzZXRSaWdodGNsaWNrTGlzdGVuZXIgPSBfbFsxXTtcbiAgICB2YXIgX20gPSB1c2VTdGF0ZShudWxsKSwgY2xpY2tMaXN0ZW5lciA9IF9tWzBdLCBzZXRDbGlja0xpc3RlbmVyID0gX21bMV07XG4gICAgdmFyIF9vID0gdXNlU3RhdGUobnVsbCksIGRyYWdMaXN0ZW5lciA9IF9vWzBdLCBzZXREcmFnTGlzdGVuZXIgPSBfb1sxXTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGRyYWdnYWJsZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWRpdGFibGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGVkaXRhYmxlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgdmlzaWJsZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIHBhdGhdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EYmxDbGljaykge1xuICAgICAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRibENsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZ0VuZCkge1xuICAgICAgICAgICAgaWYgKGRyYWdlbmRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdlbmRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnZW5kJywgb25EcmFnRW5kKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnRW5kXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoZHJhZ3N0YXJ0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnc3RhcnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnU3RhcnRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2Vkb3duJywgb25Nb3VzZURvd24pKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlRG93bl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlTW92ZSkge1xuICAgICAgICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2Vtb3ZlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VNb3ZlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdXQpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW91dExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdXQnLCBvbk1vdXNlT3V0KSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU91dF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdmVyTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW92ZXInLCBvbk1vdXNlT3ZlcikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VPdmVyXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VVcCkge1xuICAgICAgICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNldXBMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZXVwJywgb25Nb3VzZVVwKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZVVwXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uUmlnaHRDbGljaykge1xuICAgICAgICAgICAgaWYgKHJpZ2h0Y2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSaWdodGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SaWdodENsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25DbGlja10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWcpIHtcbiAgICAgICAgICAgIGlmIChkcmFnTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZycsIG9uRHJhZykpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb2x5bGluZSA9IG5ldyBnb29nbGUubWFwcy5Qb2x5bGluZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwgZGVmYXVsdE9wdGlvbnMkMSkpLCB7IG1hcDogbWFwIH0pKTtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBvbHlsaW5lLnNldFBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcG9seWxpbmUuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVkaXRhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcG9seWxpbmUuc2V0RWRpdGFibGUoZWRpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcG9seWxpbmUuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnRW5kKSB7XG4gICAgICAgICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdkcmFnZW5kJywgb25EcmFnRW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VEb3duKSB7XG4gICAgICAgICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5bGluZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VPdXQpIHtcbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZU92ZXIpIHtcbiAgICAgICAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWxpbmUsICdtb3VzZXVwJywgb25Nb3VzZVVwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUmlnaHRDbGljaykge1xuICAgICAgICAgICAgc2V0UmlnaHRjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAncmlnaHRjbGljaycsIG9uUmlnaHRDbGljaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICBzZXRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZykge1xuICAgICAgICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlsaW5lLCAnZHJhZycsIG9uRHJhZykpO1xuICAgICAgICB9XG4gICAgICAgIHNldEluc3RhbmNlKHBvbHlsaW5lKTtcbiAgICAgICAgaWYgKG9uTG9hZCkge1xuICAgICAgICAgICAgb25Mb2FkKHBvbHlsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0Y2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIG9uVW5tb3VudChwb2x5bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2x5bGluZS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBudWxsO1xufVxudmFyIFBvbHlsaW5lRiA9IG1lbW8oUG9seWxpbmVGdW5jdGlvbmFsKTtcbnZhciBQb2x5bGluZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9seWxpbmUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUG9seWxpbmUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcG9seWxpbmU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFBvbHlsaW5lQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUucG9seWxpbmUgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLnBvbHlsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb2x5bGluZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwb2x5bGluZSA9IG5ldyBnb29nbGUubWFwcy5Qb2x5bGluZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGIsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkYixcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogcG9seWxpbmUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldFBvbHlsaW5lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwb2x5bGluZTogcG9seWxpbmUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldFBvbHlsaW5lQ2FsbGJhY2spO1xuICAgIH07XG4gICAgUG9seWxpbmUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucG9seWxpbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYixcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkYixcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUucG9seWxpbmUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9seWxpbmUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb2x5bGluZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5wb2x5bGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnBvbHlsaW5lLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9seWxpbmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBQb2x5bGluZS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIFBvbHlsaW5lO1xufShQdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCRhID0ge1xuICAgIG9uQ2xpY2s6ICdjbGljaycsXG4gICAgb25EYmxDbGljazogJ2RibGNsaWNrJyxcbiAgICBvbkRyYWc6ICdkcmFnJyxcbiAgICBvbkRyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgICBvbkRyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gICAgb25Nb3VzZURvd246ICdtb3VzZWRvd24nLFxuICAgIG9uTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICBvbk1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICAgIG9uTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgICBvbk1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgICBvblJpZ2h0Q2xpY2s6ICdyaWdodGNsaWNrJyxcbn07XG52YXIgdXBkYXRlck1hcCRhID0ge1xuICAgIGRyYWdnYWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBkcmFnZ2FibGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgfSxcbiAgICBlZGl0YWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBlZGl0YWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbWFwKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICBwYXRoOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhdGgpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGF0aChwYXRoKTtcbiAgICB9LFxuICAgIHBhdGhzOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHBhdGhzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFBhdGhzKHBhdGhzKTtcbiAgICB9LFxuICAgIHZpc2libGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdmlzaWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gUG9seWdvbkZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGRyYWdnYWJsZSA9IF9hLmRyYWdnYWJsZSwgZWRpdGFibGUgPSBfYS5lZGl0YWJsZSwgdmlzaWJsZSA9IF9hLnZpc2libGUsIHBhdGggPSBfYS5wYXRoLCBwYXRocyA9IF9hLnBhdGhzLCBvbkRibENsaWNrID0gX2Eub25EYmxDbGljaywgb25EcmFnRW5kID0gX2Eub25EcmFnRW5kLCBvbkRyYWdTdGFydCA9IF9hLm9uRHJhZ1N0YXJ0LCBvbk1vdXNlRG93biA9IF9hLm9uTW91c2VEb3duLCBvbk1vdXNlTW92ZSA9IF9hLm9uTW91c2VNb3ZlLCBvbk1vdXNlT3V0ID0gX2Eub25Nb3VzZU91dCwgb25Nb3VzZU92ZXIgPSBfYS5vbk1vdXNlT3Zlciwgb25Nb3VzZVVwID0gX2Eub25Nb3VzZVVwLCBvblJpZ2h0Q2xpY2sgPSBfYS5vblJpZ2h0Q2xpY2ssIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uTG9hZCA9IF9hLm9uTG9hZCwgb25Vbm1vdW50ID0gX2Eub25Vbm1vdW50LCBvbkVkaXQgPSBfYS5vbkVkaXQ7XG4gICAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gdXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gdXNlU3RhdGUobnVsbCksIGRibGNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0RGJsY2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHVzZVN0YXRlKG51bGwpLCBkcmFnZW5kTGlzdGVuZXIgPSBfZFswXSwgc2V0RHJhZ2VuZExpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gdXNlU3RhdGUobnVsbCksIGRyYWdzdGFydExpc3RlbmVyID0gX2VbMF0sIHNldERyYWdzdGFydExpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gdXNlU3RhdGUobnVsbCksIG1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMV07XG4gICAgdmFyIF9nID0gdXNlU3RhdGUobnVsbCksIG1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMF0sIHNldE1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMV07XG4gICAgdmFyIF9oID0gdXNlU3RhdGUobnVsbCksIG1vdXNlb3V0TGlzdGVuZXIgPSBfaFswXSwgc2V0TW91c2VvdXRMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzBdLCBzZXRNb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzFdO1xuICAgIHZhciBfayA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZXVwTGlzdGVuZXIgPSBfa1swXSwgc2V0TW91c2V1cExpc3RlbmVyID0gX2tbMV07XG4gICAgdmFyIF9sID0gdXNlU3RhdGUobnVsbCksIHJpZ2h0Y2xpY2tMaXN0ZW5lciA9IF9sWzBdLCBzZXRSaWdodGNsaWNrTGlzdGVuZXIgPSBfbFsxXTtcbiAgICB2YXIgX20gPSB1c2VTdGF0ZShudWxsKSwgY2xpY2tMaXN0ZW5lciA9IF9tWzBdLCBzZXRDbGlja0xpc3RlbmVyID0gX21bMV07XG4gICAgdmFyIF9vID0gdXNlU3RhdGUobnVsbCksIGRyYWdMaXN0ZW5lciA9IF9vWzBdLCBzZXREcmFnTGlzdGVuZXIgPSBfb1sxXTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGRyYWdnYWJsZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWRpdGFibGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGVkaXRhYmxlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgdmlzaWJsZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIHBhdGhdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHBhdGhzICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UGF0aHMocGF0aHMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBwYXRoc10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRibENsaWNrKSB7XG4gICAgICAgICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uRGJsQ2xpY2tdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLmdldFBhdGgoKSwgJ2luc2VydF9hdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvbkVkaXQgPT09IG51bGwgfHwgb25FZGl0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkVkaXQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZS5nZXRQYXRoKCksICdzZXRfYXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb25FZGl0ID09PSBudWxsIHx8IG9uRWRpdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FZGl0KGluc3RhbmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvbkVkaXRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnRW5kKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdFbmRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdTdGFydF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlRG93bikge1xuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VEb3duXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU92ZXJdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlVXBdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZykge1xuICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnJywgb25EcmFnKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWdvbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKSwgeyBtYXA6IG1hcCB9KSk7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBwb2x5Z29uLnNldFBhdGgocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhzKSB7XG4gICAgICAgICAgICBwb2x5Z29uLnNldFBhdGhzKHBhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwb2x5Z29uLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBvbHlnb24uc2V0RWRpdGFibGUoZWRpdGFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcG9seWdvbi5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5Z29uLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZ0VuZCkge1xuICAgICAgICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdkcmFnZW5kJywgb25EcmFnRW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgICBzZXREcmFnc3RhcnRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5Z29uLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlTW92ZSkge1xuICAgICAgICAgICAgc2V0TW91c2Vtb3ZlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VPdXQpIHtcbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VVcCkge1xuICAgICAgICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdtb3VzZXVwJywgb25Nb3VzZVVwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uUmlnaHRDbGljaykge1xuICAgICAgICAgICAgc2V0UmlnaHRjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHBvbHlnb24sICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocG9seWdvbiwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWcpIHtcbiAgICAgICAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihwb2x5Z29uLCAnZHJhZycsIG9uRHJhZykpO1xuICAgICAgICB9XG4gICAgICAgIHNldEluc3RhbmNlKHBvbHlnb24pO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQocG9seWdvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZWRvd25MaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlZG93bkxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW1vdmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlbW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW91dExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2VvdXRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQocG9seWdvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2x5Z29uLnNldE1hcChudWxsKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgUG9seWdvbkYgPSBtZW1vKFBvbHlnb25GdW5jdGlvbmFsKTtcbnZhciBQb2x5Z29uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQb2x5Z29uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvbHlnb24oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcG9seWdvbjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0UG9seWdvbkNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnBvbHlnb24gIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLnBvbHlnb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBvbHlnb24ucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBnb29nbGUubWFwcy5Qb2x5Z29uKF9fYXNzaWduKF9fYXNzaWduKHt9LCAodGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9KSksIHsgbWFwOiB0aGlzLmNvbnRleHQgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkYSxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCRhLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBwb2x5Z29uLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRQb2x5Z29uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwb2x5Z29uOiBwb2x5Z29uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRQb2x5Z29uQ2FsbGJhY2spO1xuICAgIH07XG4gICAgUG9seWdvbi5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb2x5Z29uICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJGEsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJGEsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnBvbHlnb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9seWdvbi5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnBvbHlnb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUucG9seWdvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnBvbHlnb24gJiYgdGhpcy5zdGF0ZS5wb2x5Z29uLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUG9seWdvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFBvbHlnb24uY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBQb2x5Z29uO1xufShQdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCQ5ID0ge1xuICAgIG9uQm91bmRzQ2hhbmdlZDogJ2JvdW5kc19jaGFuZ2VkJyxcbiAgICBvbkNsaWNrOiAnY2xpY2snLFxuICAgIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gICAgb25EcmFnOiAnZHJhZycsXG4gICAgb25EcmFnRW5kOiAnZHJhZ2VuZCcsXG4gICAgb25EcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICAgIG9uTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgICBvbk1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gICAgb25Nb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgICBvbk1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gICAgb25Nb3VzZVVwOiAnbW91c2V1cCcsXG4gICAgb25SaWdodENsaWNrOiAncmlnaHRjbGljaycsXG59O1xudmFyIHVwZGF0ZXJNYXAkOSA9IHtcbiAgICBib3VuZHM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgYm91bmRzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEJvdW5kcyhib3VuZHMpO1xuICAgIH0sXG4gICAgZHJhZ2dhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGRyYWdnYWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICB9LFxuICAgIGVkaXRhYmxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGVkaXRhYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICB9LFxuICAgIG1hcDogZnVuY3Rpb24gKGluc3RhbmNlLCBtYXApIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgfSxcbiAgICBvcHRpb25zOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHZpc2libGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdmlzaWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gUmVjdGFuZ2xlRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBvcHRpb25zID0gX2Eub3B0aW9ucywgYm91bmRzID0gX2EuYm91bmRzLCBkcmFnZ2FibGUgPSBfYS5kcmFnZ2FibGUsIGVkaXRhYmxlID0gX2EuZWRpdGFibGUsIHZpc2libGUgPSBfYS52aXNpYmxlLCBvbkRibENsaWNrID0gX2Eub25EYmxDbGljaywgb25EcmFnRW5kID0gX2Eub25EcmFnRW5kLCBvbkRyYWdTdGFydCA9IF9hLm9uRHJhZ1N0YXJ0LCBvbk1vdXNlRG93biA9IF9hLm9uTW91c2VEb3duLCBvbk1vdXNlTW92ZSA9IF9hLm9uTW91c2VNb3ZlLCBvbk1vdXNlT3V0ID0gX2Eub25Nb3VzZU91dCwgb25Nb3VzZU92ZXIgPSBfYS5vbk1vdXNlT3Zlciwgb25Nb3VzZVVwID0gX2Eub25Nb3VzZVVwLCBvblJpZ2h0Q2xpY2sgPSBfYS5vblJpZ2h0Q2xpY2ssIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uQm91bmRzQ2hhbmdlZCA9IF9hLm9uQm91bmRzQ2hhbmdlZCwgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gdXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gdXNlU3RhdGUobnVsbCksIGRibGNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0RGJsY2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHVzZVN0YXRlKG51bGwpLCBkcmFnZW5kTGlzdGVuZXIgPSBfZFswXSwgc2V0RHJhZ2VuZExpc3RlbmVyID0gX2RbMV07XG4gICAgdmFyIF9lID0gdXNlU3RhdGUobnVsbCksIGRyYWdzdGFydExpc3RlbmVyID0gX2VbMF0sIHNldERyYWdzdGFydExpc3RlbmVyID0gX2VbMV07XG4gICAgdmFyIF9mID0gdXNlU3RhdGUobnVsbCksIG1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlZG93bkxpc3RlbmVyID0gX2ZbMV07XG4gICAgdmFyIF9nID0gdXNlU3RhdGUobnVsbCksIG1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMF0sIHNldE1vdXNlbW92ZUxpc3RlbmVyID0gX2dbMV07XG4gICAgdmFyIF9oID0gdXNlU3RhdGUobnVsbCksIG1vdXNlb3V0TGlzdGVuZXIgPSBfaFswXSwgc2V0TW91c2VvdXRMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzBdLCBzZXRNb3VzZW92ZXJMaXN0ZW5lciA9IF9qWzFdO1xuICAgIHZhciBfayA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZXVwTGlzdGVuZXIgPSBfa1swXSwgc2V0TW91c2V1cExpc3RlbmVyID0gX2tbMV07XG4gICAgdmFyIF9sID0gdXNlU3RhdGUobnVsbCksIHJpZ2h0Q2xpY2tMaXN0ZW5lciA9IF9sWzBdLCBzZXRSaWdodENsaWNrTGlzdGVuZXIgPSBfbFsxXTtcbiAgICB2YXIgX20gPSB1c2VTdGF0ZShudWxsKSwgY2xpY2tMaXN0ZW5lciA9IF9tWzBdLCBzZXRDbGlja0xpc3RlbmVyID0gX21bMV07XG4gICAgdmFyIF9vID0gdXNlU3RhdGUobnVsbCksIGRyYWdMaXN0ZW5lciA9IF9vWzBdLCBzZXREcmFnTGlzdGVuZXIgPSBfb1sxXTtcbiAgICB2YXIgX3AgPSB1c2VTdGF0ZShudWxsKSwgYm91bmRzQ2hhbmdlZExpc3RlbmVyID0gX3BbMF0sIHNldEJvdW5kc0NoYW5nZWRMaXN0ZW5lciA9IF9wWzFdO1xuICAgIC8vIE9yZGVyIGRvZXMgbWF0dGVyXG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICAgICAgfVxuICAgIH0sIFttYXBdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvcHRpb25zXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkcmFnZ2FibGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgZHJhZ2dhYmxlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlZGl0YWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgZWRpdGFibGVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRWaXNpYmxlKHZpc2libGUpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCB2aXNpYmxlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib3VuZHMgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgYm91bmRzXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREYmxjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EYmxDbGlja10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdFbmQpIHtcbiAgICAgICAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RHJhZ2VuZExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ0VuZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uRHJhZ1N0YXJ0XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VEb3duKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZWRvd25MaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZWRvd25MaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZURvd25dKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU1vdmUpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW1vdmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlbW92ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlbW92ZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlTW92ZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3V0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VPdXRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU92ZXIpIHtcbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3Zlckxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3Zlcl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlVXApIHtcbiAgICAgICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2V1cExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VVcF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIGlmIChyaWdodENsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihyaWdodENsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0UmlnaHRDbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncmlnaHRjbGljaycsIG9uUmlnaHRDbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uUmlnaHRDbGlja10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkNsaWNrKSB7XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2NsaWNrJywgb25DbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2tdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWddKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Cb3VuZHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAoYm91bmRzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoYm91bmRzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEJvdW5kc0NoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2JvdW5kc19jaGFuZ2VkJywgb25Cb3VuZHNDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Cb3VuZHNDaGFuZ2VkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlY3RhbmdsZSA9IG5ldyBnb29nbGUubWFwcy5SZWN0YW5nbGUoX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IHt9KSksIHsgbWFwOiBtYXAgfSkpO1xuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZWN0YW5nbGUuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVkaXRhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVjdGFuZ2xlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlY3RhbmdsZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJvdW5kcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJlY3RhbmdsZS5zZXRCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnRW5kKSB7XG4gICAgICAgICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIHNldFJpZ2h0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihyZWN0YW5nbGUsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZykge1xuICAgICAgICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKHJlY3RhbmdsZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Cb3VuZHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRCb3VuZHNDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIocmVjdGFuZ2xlLCAnYm91bmRzX2NoYW5nZWQnLCBvbkJvdW5kc0NoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnN0YW5jZShyZWN0YW5nbGUpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQocmVjdGFuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0Q2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Q2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm91bmRzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoYm91bmRzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQocmVjdGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3RhbmdsZS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBudWxsO1xufVxudmFyIFJlY3RhbmdsZUYgPSBtZW1vKFJlY3RhbmdsZUZ1bmN0aW9uYWwpO1xudmFyIFJlY3RhbmdsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVjdGFuZ2xlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlY3RhbmdsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByZWN0YW5nbGU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFJlY3RhbmdsZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnJlY3RhbmdsZSAhPT0gbnVsbCAmJiBfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUucmVjdGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVjdGFuZ2xlID0gbmV3IGdvb2dsZS5tYXBzLlJlY3RhbmdsZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDksXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkOSxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogcmVjdGFuZ2xlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRSZWN0YW5nbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlY3RhbmdsZTogcmVjdGFuZ2xlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRSZWN0YW5nbGVDYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucmVjdGFuZ2xlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDksXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDksXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnJlY3RhbmdsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5yZWN0YW5nbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUucmVjdGFuZ2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjdGFuZ2xlLnNldE1hcChudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgUmVjdGFuZ2xlLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcbiAgICByZXR1cm4gUmVjdGFuZ2xlO1xufShQdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCQ4ID0ge1xuICAgIG9uQ2VudGVyQ2hhbmdlZDogJ2NlbnRlcl9jaGFuZ2VkJyxcbiAgICBvblJhZGl1c0NoYW5nZWQ6ICdyYWRpdXNfY2hhbmdlZCcsXG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRibENsaWNrOiAnZGJsY2xpY2snLFxuICAgIG9uRHJhZzogJ2RyYWcnLFxuICAgIG9uRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICAgIG9uRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgICBvbk1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gICAgb25Nb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxufTtcbnZhciB1cGRhdGVyTWFwJDggPSB7XG4gICAgY2VudGVyOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNlbnRlcikge1xuICAgICAgICBpbnN0YW5jZS5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICB9LFxuICAgIGRyYWdnYWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBkcmFnZ2FibGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgfSxcbiAgICBlZGl0YWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCBlZGl0YWJsZSkge1xuICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgfSxcbiAgICBtYXA6IGZ1bmN0aW9uIChpbnN0YW5jZSwgbWFwKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgIH0sXG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICByYWRpdXM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcmFkaXVzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFJhZGl1cyhyYWRpdXMpO1xuICAgIH0sXG4gICAgdmlzaWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbn07XG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7fTtcbmZ1bmN0aW9uIENpcmNsZUZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIGNlbnRlciA9IF9hLmNlbnRlciwgcmFkaXVzID0gX2EucmFkaXVzLCBkcmFnZ2FibGUgPSBfYS5kcmFnZ2FibGUsIGVkaXRhYmxlID0gX2EuZWRpdGFibGUsIHZpc2libGUgPSBfYS52aXNpYmxlLCBvbkRibENsaWNrID0gX2Eub25EYmxDbGljaywgb25EcmFnRW5kID0gX2Eub25EcmFnRW5kLCBvbkRyYWdTdGFydCA9IF9hLm9uRHJhZ1N0YXJ0LCBvbk1vdXNlRG93biA9IF9hLm9uTW91c2VEb3duLCBvbk1vdXNlTW92ZSA9IF9hLm9uTW91c2VNb3ZlLCBvbk1vdXNlT3V0ID0gX2Eub25Nb3VzZU91dCwgb25Nb3VzZU92ZXIgPSBfYS5vbk1vdXNlT3Zlciwgb25Nb3VzZVVwID0gX2Eub25Nb3VzZVVwLCBvblJpZ2h0Q2xpY2sgPSBfYS5vblJpZ2h0Q2xpY2ssIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBvbkRyYWcgPSBfYS5vbkRyYWcsIG9uQ2VudGVyQ2hhbmdlZCA9IF9hLm9uQ2VudGVyQ2hhbmdlZCwgb25SYWRpdXNDaGFuZ2VkID0gX2Eub25SYWRpdXNDaGFuZ2VkLCBvbkxvYWQgPSBfYS5vbkxvYWQsIG9uVW5tb3VudCA9IF9hLm9uVW5tb3VudDtcbiAgICB2YXIgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICB2YXIgX2IgPSB1c2VTdGF0ZShudWxsKSwgaW5zdGFuY2UgPSBfYlswXSwgc2V0SW5zdGFuY2UgPSBfYlsxXTtcbiAgICB2YXIgX2MgPSB1c2VTdGF0ZShudWxsKSwgZGJsY2xpY2tMaXN0ZW5lciA9IF9jWzBdLCBzZXREYmxjbGlja0xpc3RlbmVyID0gX2NbMV07XG4gICAgdmFyIF9kID0gdXNlU3RhdGUobnVsbCksIGRyYWdlbmRMaXN0ZW5lciA9IF9kWzBdLCBzZXREcmFnZW5kTGlzdGVuZXIgPSBfZFsxXTtcbiAgICB2YXIgX2UgPSB1c2VTdGF0ZShudWxsKSwgZHJhZ3N0YXJ0TGlzdGVuZXIgPSBfZVswXSwgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIgPSBfZVsxXTtcbiAgICB2YXIgX2YgPSB1c2VTdGF0ZShudWxsKSwgbW91c2Vkb3duTGlzdGVuZXIgPSBfZlswXSwgc2V0TW91c2Vkb3duTGlzdGVuZXIgPSBfZlsxXTtcbiAgICB2YXIgX2cgPSB1c2VTdGF0ZShudWxsKSwgbW91c2Vtb3ZlTGlzdGVuZXIgPSBfZ1swXSwgc2V0TW91c2Vtb3ZlTGlzdGVuZXIgPSBfZ1sxXTtcbiAgICB2YXIgX2ggPSB1c2VTdGF0ZShudWxsKSwgbW91c2VvdXRMaXN0ZW5lciA9IF9oWzBdLCBzZXRNb3VzZW91dExpc3RlbmVyID0gX2hbMV07XG4gICAgdmFyIF9qID0gdXNlU3RhdGUobnVsbCksIG1vdXNlb3Zlckxpc3RlbmVyID0gX2pbMF0sIHNldE1vdXNlb3Zlckxpc3RlbmVyID0gX2pbMV07XG4gICAgdmFyIF9rID0gdXNlU3RhdGUobnVsbCksIG1vdXNldXBMaXN0ZW5lciA9IF9rWzBdLCBzZXRNb3VzZXVwTGlzdGVuZXIgPSBfa1sxXTtcbiAgICB2YXIgX2wgPSB1c2VTdGF0ZShudWxsKSwgcmlnaHRjbGlja0xpc3RlbmVyID0gX2xbMF0sIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lciA9IF9sWzFdO1xuICAgIHZhciBfbSA9IHVzZVN0YXRlKG51bGwpLCBjbGlja0xpc3RlbmVyID0gX21bMF0sIHNldENsaWNrTGlzdGVuZXIgPSBfbVsxXTtcbiAgICB2YXIgX28gPSB1c2VTdGF0ZShudWxsKSwgZHJhZ0xpc3RlbmVyID0gX29bMF0sIHNldERyYWdMaXN0ZW5lciA9IF9vWzFdO1xuICAgIHZhciBfcCA9IHVzZVN0YXRlKG51bGwpLCBjZW50ZXJDaGFuZ2VkTGlzdGVuZXIgPSBfcFswXSwgc2V0Q2VudGVyQ2hhbmdlZExpc3RlbmVyID0gX3BbMV07XG4gICAgdmFyIF9xID0gdXNlU3RhdGUobnVsbCksIHJhZGl1c0NoYW5nZWRMaXN0ZW5lciA9IF9xWzBdLCBzZXRSYWRpdXNDaGFuZ2VkTGlzdGVuZXIgPSBfcVsxXTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgb3B0aW9uc10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZHJhZ2dhYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0RHJhZ2dhYmxlKGRyYWdnYWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGRyYWdnYWJsZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWRpdGFibGUgIT09ICd1bmRlZmluZWQnICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRFZGl0YWJsZShlZGl0YWJsZSk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGVkaXRhYmxlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2aXNpYmxlICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbnN0YW5jZSwgdmlzaWJsZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAnbnVtYmVyJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0UmFkaXVzKHJhZGl1cyk7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIHJhZGl1c10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2VudGVyICE9PSAndW5kZWZpbmVkJyAmJiBpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0Q2VudGVyKGNlbnRlcik7XG4gICAgICAgIH1cbiAgICB9LCBbaW5zdGFuY2UsIGNlbnRlcl0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbkRibENsaWNrKSB7XG4gICAgICAgICAgICBpZiAoZGJsY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICB9XG4gICAgfSwgW29uRGJsQ2xpY2tdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnRW5kKSB7XG4gICAgICAgICAgICBpZiAoZHJhZ2VuZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ2VuZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdlbmRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ2RyYWdlbmQnLCBvbkRyYWdFbmQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdFbmRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChkcmFnc3RhcnRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdzdGFydExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldERyYWdzdGFydExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkRyYWdTdGFydF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlRG93bikge1xuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VEb3duXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU92ZXJdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlVXBdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRHJhZykge1xuICAgICAgICAgICAgaWYgKGRyYWdMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRyYWdMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdkcmFnJywgb25EcmFnKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EcmFnXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQ2VudGVyQ2hhbmdlZCkge1xuICAgICAgICAgICAgaWYgKGNlbnRlckNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNlbnRlckNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDZW50ZXJDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjZW50ZXJfY2hhbmdlZCcsIG9uQ2VudGVyQ2hhbmdlZCkpO1xuICAgICAgICB9XG4gICAgfSwgW29uQ2xpY2tdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SYWRpdXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBpZiAocmFkaXVzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmFkaXVzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJhZGl1c0NoYW5nZWRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JhZGl1c19jaGFuZ2VkJywgb25SYWRpdXNDaGFuZ2VkKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SYWRpdXNDaGFuZ2VkXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNpcmNsZSA9IG5ldyBnb29nbGUubWFwcy5DaXJjbGUoX19hc3NpZ24oX19hc3NpZ24oe30sIChvcHRpb25zIHx8IGRlZmF1bHRPcHRpb25zKSksIHsgbWFwOiBtYXAgfSkpO1xuICAgICAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRSYWRpdXMocmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNlbnRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRDZW50ZXIoY2VudGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNpcmNsZS5zZXRSYWRpdXMocmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZpc2libGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjaXJjbGUuc2V0VmlzaWJsZSh2aXNpYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVkaXRhYmxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY2lyY2xlLnNldEVkaXRhYmxlKGVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRyYWdnYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNpcmNsZS5zZXREcmFnZ2FibGUoZHJhZ2dhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgICAgICAgc2V0RGJsY2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdkYmxjbGljaycsIG9uRGJsQ2xpY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25EcmFnRW5kKSB7XG4gICAgICAgICAgICBzZXREcmFnZW5kTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnZHJhZ2VuZCcsIG9uRHJhZ0VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgc2V0RHJhZ3N0YXJ0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnZHJhZ3N0YXJ0Jywgb25EcmFnU3RhcnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZURvd24pIHtcbiAgICAgICAgICAgIHNldE1vdXNlZG93bkxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICBzZXRNb3VzZW91dExpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ21vdXNlb3V0Jywgb25Nb3VzZU91dCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbk1vdXNlT3Zlcikge1xuICAgICAgICAgICAgc2V0TW91c2VvdmVyTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnbW91c2V1cCcsIG9uTW91c2VVcCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihjaXJjbGUsICdyaWdodGNsaWNrJywgb25SaWdodENsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uRHJhZykge1xuICAgICAgICAgICAgc2V0RHJhZ0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGNpcmNsZSwgJ2RyYWcnLCBvbkRyYWcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25DZW50ZXJDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRDZW50ZXJDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAnY2VudGVyX2NoYW5nZWQnLCBvbkNlbnRlckNoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25SYWRpdXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICBzZXRSYWRpdXNDaGFuZ2VkTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoY2lyY2xlLCAncmFkaXVzX2NoYW5nZWQnLCBvblJhZGl1c0NoYW5nZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRJbnN0YW5jZShjaXJjbGUpO1xuICAgICAgICBpZiAob25Mb2FkKSB7XG4gICAgICAgICAgICBvbkxvYWQoY2lyY2xlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRibGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkYmxjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkcmFnZW5kTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihkcmFnZW5kTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYWdzdGFydExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZHJhZ3N0YXJ0TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlbW92ZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZW92ZXJMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3VzZXVwTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0Y2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2xpY2tMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNlbnRlckNoYW5nZWRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNlbnRlckNoYW5nZWRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmFkaXVzQ2hhbmdlZExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmFkaXVzQ2hhbmdlZExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICBvblVubW91bnQoY2lyY2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNpcmNsZS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBudWxsO1xufVxudmFyIENpcmNsZUYgPSBtZW1vKENpcmNsZUZ1bmN0aW9uYWwpO1xudmFyIENpcmNsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2lyY2xlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBjaXJjbGU6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldENpcmNsZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmNpcmNsZSAhPT0gbnVsbCAmJiBfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUuY2lyY2xlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDaXJjbGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2lyY2xlID0gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKHRoaXMucHJvcHMub3B0aW9ucyB8fCB7fSkpLCB7IG1hcDogdGhpcy5jb250ZXh0IH0pKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDgsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkOCxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogY2lyY2xlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRDaXJjbGUoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNpcmNsZTogY2lyY2xlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRDaXJjbGVDYWxsYmFjayk7XG4gICAgfTtcbiAgICBDaXJjbGUucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuY2lyY2xlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDgsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDgsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmNpcmNsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaXJjbGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmNpcmNsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5jaXJjbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5zdGF0ZS5jaXJjbGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENpcmNsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIENpcmNsZS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIENpcmNsZTtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgZXZlbnRNYXAkNyA9IHtcbiAgICBvbkNsaWNrOiAnY2xpY2snLFxuICAgIG9uRGJsQ2xpY2s6ICdkYmxjbGljaycsXG4gICAgb25Nb3VzZURvd246ICdtb3VzZWRvd24nLFxuICAgIG9uTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gICAgb25Nb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICAgIG9uTW91c2VVcDogJ21vdXNldXAnLFxuICAgIG9uUmlnaHRDbGljazogJ3JpZ2h0Y2xpY2snLFxuICAgIG9uQWRkRmVhdHVyZTogJ2FkZGZlYXR1cmUnLFxuICAgIG9uUmVtb3ZlRmVhdHVyZTogJ3JlbW92ZWZlYXR1cmUnLFxuICAgIG9uUmVtb3ZlUHJvcGVydHk6ICdyZW1vdmVwcm9wZXJ0eScsXG4gICAgb25TZXRHZW9tZXRyeTogJ3NldGdlb21ldHJ5JyxcbiAgICBvblNldFByb3BlcnR5OiAnc2V0cHJvcGVydHknLFxufTtcbnZhciB1cGRhdGVyTWFwJDcgPSB7XG4gICAgYWRkOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGZlYXR1cmUpIHtcbiAgICAgICAgaW5zdGFuY2UuYWRkKGZlYXR1cmUpO1xuICAgIH0sXG4gICAgYWRkZ2VvanNvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBnZW9qc29uLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLmFkZEdlb0pzb24oZ2VvanNvbiwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBjb250YWluczogZnVuY3Rpb24gKGluc3RhbmNlLCBmZWF0dXJlKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbnRhaW5zKGZlYXR1cmUpO1xuICAgIH0sXG4gICAgZm9yZWFjaDogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgICBpbnN0YW5jZS5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9LFxuICAgIGxvYWRnZW9qc29uOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHVybCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaW5zdGFuY2UubG9hZEdlb0pzb24odXJsLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfSxcbiAgICBvdmVycmlkZXN0eWxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGZlYXR1cmUsIHN0eWxlKSB7XG4gICAgICAgIGluc3RhbmNlLm92ZXJyaWRlU3R5bGUoZmVhdHVyZSwgc3R5bGUpO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGZlYXR1cmUpIHtcbiAgICAgICAgaW5zdGFuY2UucmVtb3ZlKGZlYXR1cmUpO1xuICAgIH0sXG4gICAgcmV2ZXJ0c3R5bGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgZmVhdHVyZSkge1xuICAgICAgICBpbnN0YW5jZS5yZXZlcnRTdHlsZShmZWF0dXJlKTtcbiAgICB9LFxuICAgIGNvbnRyb2xwb3NpdGlvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBjb250cm9sUG9zaXRpb24pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q29udHJvbFBvc2l0aW9uKGNvbnRyb2xQb3NpdGlvbik7XG4gICAgfSxcbiAgICBjb250cm9sczogZnVuY3Rpb24gKGluc3RhbmNlLCBjb250cm9scykge1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250cm9scyhjb250cm9scyk7XG4gICAgfSxcbiAgICBkcmF3aW5nbW9kZTogZnVuY3Rpb24gKGluc3RhbmNlLCBtb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldERyYXdpbmdNb2RlKG1vZGUpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG1hcCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9LFxuICAgIHN0eWxlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHN0eWxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFN0eWxlKHN0eWxlKTtcbiAgICB9LFxuICAgIHRvZ2VvanNvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICAgICBpbnN0YW5jZS50b0dlb0pzb24oY2FsbGJhY2spO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gRGF0YUZ1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrLCBvbkRibENsaWNrID0gX2Eub25EYmxDbGljaywgb25Nb3VzZURvd24gPSBfYS5vbk1vdXNlRG93biwgb25Nb3VzZU1vdmUgPSBfYS5vbk1vdXNlTW92ZSwgb25Nb3VzZU91dCA9IF9hLm9uTW91c2VPdXQsIG9uTW91c2VPdmVyID0gX2Eub25Nb3VzZU92ZXIsIG9uTW91c2VVcCA9IF9hLm9uTW91c2VVcCwgb25SaWdodENsaWNrID0gX2Eub25SaWdodENsaWNrLCBvbkFkZEZlYXR1cmUgPSBfYS5vbkFkZEZlYXR1cmUsIG9uUmVtb3ZlRmVhdHVyZSA9IF9hLm9uUmVtb3ZlRmVhdHVyZSwgb25SZW1vdmVQcm9wZXJ0eSA9IF9hLm9uUmVtb3ZlUHJvcGVydHksIG9uU2V0R2VvbWV0cnkgPSBfYS5vblNldEdlb21ldHJ5LCBvblNldFByb3BlcnR5ID0gX2Eub25TZXRQcm9wZXJ0eSwgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQ7XG4gICAgdmFyIG1hcCA9IHVzZUNvbnRleHQoTWFwQ29udGV4dCk7XG4gICAgdmFyIF9iID0gdXNlU3RhdGUobnVsbCksIGluc3RhbmNlID0gX2JbMF0sIHNldEluc3RhbmNlID0gX2JbMV07XG4gICAgdmFyIF9jID0gdXNlU3RhdGUobnVsbCksIGRibGNsaWNrTGlzdGVuZXIgPSBfY1swXSwgc2V0RGJsY2xpY2tMaXN0ZW5lciA9IF9jWzFdO1xuICAgIHZhciBfZCA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZWRvd25MaXN0ZW5lciA9IF9kWzBdLCBzZXRNb3VzZWRvd25MaXN0ZW5lciA9IF9kWzFdO1xuICAgIHZhciBfZSA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZW1vdmVMaXN0ZW5lciA9IF9lWzBdLCBzZXRNb3VzZW1vdmVMaXN0ZW5lciA9IF9lWzFdO1xuICAgIHZhciBfZiA9IHVzZVN0YXRlKG51bGwpLCBtb3VzZW91dExpc3RlbmVyID0gX2ZbMF0sIHNldE1vdXNlb3V0TGlzdGVuZXIgPSBfZlsxXTtcbiAgICB2YXIgX2cgPSB1c2VTdGF0ZShudWxsKSwgbW91c2VvdmVyTGlzdGVuZXIgPSBfZ1swXSwgc2V0TW91c2VvdmVyTGlzdGVuZXIgPSBfZ1sxXTtcbiAgICB2YXIgX2ggPSB1c2VTdGF0ZShudWxsKSwgbW91c2V1cExpc3RlbmVyID0gX2hbMF0sIHNldE1vdXNldXBMaXN0ZW5lciA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHVzZVN0YXRlKG51bGwpLCByaWdodGNsaWNrTGlzdGVuZXIgPSBfalswXSwgc2V0UmlnaHRjbGlja0xpc3RlbmVyID0gX2pbMV07XG4gICAgdmFyIF9rID0gdXNlU3RhdGUobnVsbCksIGNsaWNrTGlzdGVuZXIgPSBfa1swXSwgc2V0Q2xpY2tMaXN0ZW5lciA9IF9rWzFdO1xuICAgIHZhciBfbCA9IHVzZVN0YXRlKG51bGwpLCBhZGRGZWF0dXJlTGlzdGVuZXIgPSBfbFswXSwgc2V0QWRkRmVhdHVyZUxpc3RlbmVyID0gX2xbMV07XG4gICAgdmFyIF9tID0gdXNlU3RhdGUobnVsbCksIHJlbW92ZUZlYXR1cmVMaXN0ZW5lciA9IF9tWzBdLCBzZXRSZW1vdmVGZWF0dXJlTGlzdGVuZXIgPSBfbVsxXTtcbiAgICB2YXIgX28gPSB1c2VTdGF0ZShudWxsKSwgcmVtb3ZlUHJvcGVydHlMaXN0ZW5lciA9IF9vWzBdLCBzZXRSZW1vdmVQcm9wZXJ0eUxpc3RlbmVyID0gX29bMV07XG4gICAgdmFyIF9wID0gdXNlU3RhdGUobnVsbCksIHNldEdlb21ldHJ5TGlzdGVuZXIgPSBfcFswXSwgc2V0U2V0R2VvbWV0cnlMaXN0ZW5lciA9IF9wWzFdO1xuICAgIHZhciBfcSA9IHVzZVN0YXRlKG51bGwpLCBzZXRQcm9wZXJ0eUxpc3RlbmVyID0gX3FbMF0sIHNldFNldFByb3BlcnR5TGlzdGVuZXIgPSBfcVsxXTtcbiAgICAvLyBPcmRlciBkb2VzIG1hdHRlclxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIoZGJsY2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREYmxjbGlja0xpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAnZGJsY2xpY2snLCBvbkRibENsaWNrKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25EYmxDbGlja10pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvbk1vdXNlRG93bikge1xuICAgICAgICAgICAgaWYgKG1vdXNlZG93bkxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZWRvd24nLCBvbk1vdXNlRG93bikpO1xuICAgICAgICB9XG4gICAgfSwgW29uTW91c2VEb3duXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VNb3ZlKSB7XG4gICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU1vdmVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZU91dCkge1xuICAgICAgICAgICAgaWYgKG1vdXNlb3V0TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNlb3V0TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdtb3VzZW91dCcsIG9uTW91c2VPdXQpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlT3V0XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uTW91c2VPdmVyKSB7XG4gICAgICAgICAgICBpZiAobW91c2VvdmVyTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW92ZXJMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNlb3ZlcicsIG9uTW91c2VPdmVyKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25Nb3VzZU92ZXJdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25Nb3VzZVVwKSB7XG4gICAgICAgICAgICBpZiAobW91c2V1cExpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2V1cExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1vdXNldXBMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbk1vdXNlVXBdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25SaWdodENsaWNrKSB7XG4gICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmlnaHRjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFJpZ2h0Y2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblJpZ2h0Q2xpY2tdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25DbGljaykge1xuICAgICAgICAgICAgaWYgKGNsaWNrTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihjbGlja0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdjbGljaycsIG9uQ2xpY2spKTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkNsaWNrXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uQWRkRmVhdHVyZSkge1xuICAgICAgICAgICAgaWYgKGFkZEZlYXR1cmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGFkZEZlYXR1cmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRBZGRGZWF0dXJlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdhZGRmZWF0dXJlJywgb25BZGRGZWF0dXJlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25BZGRGZWF0dXJlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uUmVtb3ZlRmVhdHVyZSkge1xuICAgICAgICAgICAgaWYgKHJlbW92ZUZlYXR1cmVMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJlbW92ZUZlYXR1cmVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZW1vdmVGZWF0dXJlTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdyZW1vdmVmZWF0dXJlJywgb25SZW1vdmVGZWF0dXJlKSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SZW1vdmVGZWF0dXJlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlICYmIG9uUmVtb3ZlUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmIChyZW1vdmVQcm9wZXJ0eUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmVtb3ZlUHJvcGVydHlMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRSZW1vdmVQcm9wZXJ0eUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGluc3RhbmNlLCAncmVtb3ZlcHJvcGVydHknLCBvblJlbW92ZVByb3BlcnR5KSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25SZW1vdmVQcm9wZXJ0eV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiBvblNldEdlb21ldHJ5KSB7XG4gICAgICAgICAgICBpZiAoc2V0R2VvbWV0cnlMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHNldEdlb21ldHJ5TGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0U2V0R2VvbWV0cnlMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihpbnN0YW5jZSwgJ3NldGdlb21ldHJ5Jywgb25TZXRHZW9tZXRyeSkpO1xuICAgICAgICB9XG4gICAgfSwgW29uU2V0R2VvbWV0cnldKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgb25TZXRQcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKHNldFByb3BlcnR5TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihzZXRQcm9wZXJ0eUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFNldFByb3BlcnR5TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoaW5zdGFuY2UsICdzZXRwcm9wZXJ0eScsIG9uU2V0UHJvcGVydHkpKTtcbiAgICAgICAgfVxuICAgIH0sIFtvblNldFByb3BlcnR5XSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1hcCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBuZXcgZ29vZ2xlLm1hcHMuRGF0YShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKSwgeyBtYXA6IG1hcCB9KSk7XG4gICAgICAgICAgICBpZiAob25EYmxDbGljaykge1xuICAgICAgICAgICAgICAgIHNldERibGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ2RibGNsaWNrJywgb25EYmxDbGljaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uTW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgc2V0TW91c2Vkb3duTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ21vdXNlZG93bicsIG9uTW91c2VEb3duKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Nb3VzZU1vdmUpIHtcbiAgICAgICAgICAgICAgICBzZXRNb3VzZW1vdmVMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnbW91c2Vtb3ZlJywgb25Nb3VzZU1vdmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlT3V0KSB7XG4gICAgICAgICAgICAgICAgc2V0TW91c2VvdXRMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnbW91c2VvdXQnLCBvbk1vdXNlT3V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Nb3VzZU92ZXIpIHtcbiAgICAgICAgICAgICAgICBzZXRNb3VzZW92ZXJMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnbW91c2VvdmVyJywgb25Nb3VzZU92ZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlVXApIHtcbiAgICAgICAgICAgICAgICBzZXRNb3VzZXVwTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ21vdXNldXAnLCBvbk1vdXNlVXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblJpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgICAgICBzZXRSaWdodGNsaWNrTGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ3JpZ2h0Y2xpY2snLCBvblJpZ2h0Q2xpY2spKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgc2V0Q2xpY2tMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnY2xpY2snLCBvbkNsaWNrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25BZGRGZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc2V0QWRkRmVhdHVyZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRhdGEsICdhZGRmZWF0dXJlJywgb25BZGRGZWF0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25SZW1vdmVGZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVtb3ZlRmVhdHVyZUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRhdGEsICdyZW1vdmVmZWF0dXJlJywgb25SZW1vdmVGZWF0dXJlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25SZW1vdmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHNldFJlbW92ZVByb3BlcnR5TGlzdGVuZXIoZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIoZGF0YSwgJ3JlbW92ZXByb3BlcnR5Jywgb25SZW1vdmVQcm9wZXJ0eSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uU2V0R2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICBzZXRTZXRHZW9tZXRyeUxpc3RlbmVyKGdvb2dsZS5tYXBzLmV2ZW50LmFkZExpc3RlbmVyKGRhdGEsICdzZXRnZW9tZXRyeScsIG9uU2V0R2VvbWV0cnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblNldFByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgc2V0U2V0UHJvcGVydHlMaXN0ZW5lcihnb29nbGUubWFwcy5ldmVudC5hZGRMaXN0ZW5lcihkYXRhLCAnc2V0cHJvcGVydHknLCBvblNldFByb3BlcnR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJbnN0YW5jZShkYXRhKTtcbiAgICAgICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBvbkxvYWQoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlmIChkYmxjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGRibGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW91c2Vkb3duTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW91c2Vtb3ZlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIobW91c2Vtb3ZlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW91c2VvdXRMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZW91dExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNlb3Zlckxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKG1vdXNlb3Zlckxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1vdXNldXBMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihtb3VzZXVwTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmlnaHRjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHJpZ2h0Y2xpY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbGlja0xpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGNsaWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkRmVhdHVyZUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKGFkZEZlYXR1cmVMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVGZWF0dXJlTGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmVtb3ZlRmVhdHVyZUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZVByb3BlcnR5TGlzdGVuZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQucmVtb3ZlTGlzdGVuZXIocmVtb3ZlUHJvcGVydHlMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXRHZW9tZXRyeUxpc3RlbmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZS5tYXBzLmV2ZW50LnJlbW92ZUxpc3RlbmVyKHNldEdlb21ldHJ5TGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0UHJvcGVydHlMaXN0ZW5lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBnb29nbGUubWFwcy5ldmVudC5yZW1vdmVMaXN0ZW5lcihzZXRQcm9wZXJ0eUxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBvblVubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZXRNYXAobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBudWxsO1xufVxudmFyIERhdGFGID0gbWVtbyhEYXRhRnVuY3Rpb25hbCk7XG52YXIgRGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGF0YSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXRhKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldERhdGFDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5kYXRhICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXRhLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGRhdGFfMSA9IG5ldyBnb29nbGUubWFwcy5EYXRhKF9fYXNzaWduKF9fYXNzaWduKHt9LCAodGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9KSksIHsgbWFwOiB0aGlzLmNvbnRleHQgfSkpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ3LFxuICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ3LFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBkYXRhXzEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFfMSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgdGhpcy5zZXREYXRhQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNyxcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkNyxcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmRhdGEuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRhLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRGF0YS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIERhdGE7XG59KFB1cmVDb21wb25lbnQpKTtcblxudmFyIGV2ZW50TWFwJDYgPSB7XG4gICAgb25DbGljazogJ2NsaWNrJyxcbiAgICBvbkRlZmF1bHRWaWV3cG9ydENoYW5nZWQ6ICdkZWZhdWx0dmlld3BvcnRfY2hhbmdlZCcsXG4gICAgb25TdGF0dXNDaGFuZ2VkOiAnc3RhdHVzX2NoYW5nZWQnLFxufTtcbnZhciB1cGRhdGVyTWFwJDYgPSB7XG4gICAgb3B0aW9uczogZnVuY3Rpb24gKGluc3RhbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfSxcbiAgICB1cmw6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdXJsKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFVybCh1cmwpO1xuICAgIH0sXG4gICAgekluZGV4OiBmdW5jdGlvbiAoaW5zdGFuY2UsIHpJbmRleCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRaSW5kZXgoekluZGV4KTtcbiAgICB9LFxufTtcbnZhciBLbWxMYXllciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoS21sTGF5ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gS21sTGF5ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAga21sTGF5ZXI6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEttbExheWVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUua21sTGF5ZXIgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLmttbExheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBLbWxMYXllci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBrbWxMYXllciA9IG5ldyBnb29nbGUubWFwcy5LbWxMYXllcihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcy5vcHRpb25zKSwgeyBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ2LFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDYsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGttbExheWVyLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRMbWxMYXllcigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga21sTGF5ZXI6IGttbExheWVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRLbWxMYXllckNhbGxiYWNrKTtcbiAgICB9O1xuICAgIEttbExheWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmttbExheWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDYsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDYsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmttbExheWVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEttbExheWVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUua21sTGF5ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUua21sTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5rbWxMYXllci5zZXRNYXAobnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEttbExheWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgS21sTGF5ZXIuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBLbWxMYXllcjtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRPdmVycmlkZShjb250YWluZXJFbGVtZW50LCBnZXRQaXhlbFBvc2l0aW9uT2Zmc2V0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBnZXRQaXhlbFBvc2l0aW9uT2Zmc2V0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldChjb250YWluZXJFbGVtZW50Lm9mZnNldFdpZHRoLCBjb250YWluZXJFbGVtZW50Lm9mZnNldEhlaWdodClcbiAgICAgICAgOiB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgfTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBjcmVhdGVMYXRMbmcoaW5zdCwgVHlwZSkgeyByZXR1cm4gbmV3IFR5cGUoaW5zdC5sYXQsIGluc3QubG5nKTsgfVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIGNyZWF0ZUxhdExuZ0JvdW5kcyhpbnN0LCBUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoaW5zdC5uZS5sYXQsIGluc3QubmUubG5nKSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhpbnN0LnN3LmxhdCwgaW5zdC5zdy5sbmcpKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBlbnN1cmVPZlR5cGUoaW5zdCwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxudHlwZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZmFjdG9yeVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbikge1xuICAgIHJldHVybiBpbnN0IGluc3RhbmNlb2YgdHlwZSA/IGluc3QgOiBmYWN0b3J5KGluc3QsIHR5cGUpO1xufVxuZnVuY3Rpb24gZW5zdXJlT2ZUeXBlQm91bmRzKGluc3QsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnR5cGUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZhY3Rvcnlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pIHtcbiAgICByZXR1cm4gaW5zdCBpbnN0YW5jZW9mIHR5cGUgPyBpbnN0IDogZmFjdG9yeShpbnN0LCB0eXBlKTtcbn1cbmZ1bmN0aW9uIGdldExheW91dFN0eWxlc0J5Qm91bmRzKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgYm91bmRzKSB7XG4gICAgdmFyIG5lID0gbWFwQ2FudmFzUHJvamVjdGlvbiAmJiBtYXBDYW52YXNQcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKGJvdW5kcy5nZXROb3J0aEVhc3QoKSk7XG4gICAgdmFyIHN3ID0gbWFwQ2FudmFzUHJvamVjdGlvbiAmJiBtYXBDYW52YXNQcm9qZWN0aW9uLmZyb21MYXRMbmdUb0RpdlBpeGVsKGJvdW5kcy5nZXRTb3V0aFdlc3QoKSk7XG4gICAgaWYgKG5lICYmIHN3KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBcIlwiLmNvbmNhdChzdy54ICsgb2Zmc2V0LngsIFwicHhcIiksXG4gICAgICAgICAgICB0b3A6IFwiXCIuY29uY2F0KG5lLnkgKyBvZmZzZXQueSwgXCJweFwiKSxcbiAgICAgICAgICAgIHdpZHRoOiBcIlwiLmNvbmNhdChuZS54IC0gc3cueCAtIG9mZnNldC54LCBcInB4XCIpLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIlwiLmNvbmNhdChzdy55IC0gbmUueSAtIG9mZnNldC55LCBcInB4XCIpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAnLTk5OTlweCcsXG4gICAgICAgIHRvcDogJy05OTk5cHgnLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRMYXlvdXRTdHlsZXNCeVBvc2l0aW9uKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgcG9zaXRpb24pIHtcbiAgICB2YXIgcG9pbnQgPSBtYXBDYW52YXNQcm9qZWN0aW9uICYmIG1hcENhbnZhc1Byb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwocG9zaXRpb24pO1xuICAgIGlmIChwb2ludCkge1xuICAgICAgICB2YXIgeCA9IHBvaW50LngsIHkgPSBwb2ludC55O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdDogXCJcIi5jb25jYXQoeCArIG9mZnNldC54LCBcInB4XCIpLFxuICAgICAgICAgICAgdG9wOiBcIlwiLmNvbmNhdCh5ICsgb2Zmc2V0LnksIFwicHhcIiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6ICctOTk5OXB4JyxcbiAgICAgICAgdG9wOiAnLTk5OTlweCcsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldExheW91dFN0eWxlcyhtYXBDYW52YXNQcm9qZWN0aW9uLCBvZmZzZXQsIGJvdW5kcywgcG9zaXRpb24pIHtcbiAgICByZXR1cm4gYm91bmRzICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBnZXRMYXlvdXRTdHlsZXNCeUJvdW5kcyhtYXBDYW52YXNQcm9qZWN0aW9uLCBvZmZzZXQsIGVuc3VyZU9mVHlwZUJvdW5kcyhib3VuZHMsIGdvb2dsZS5tYXBzLkxhdExuZ0JvdW5kcywgY3JlYXRlTGF0TG5nQm91bmRzKSlcbiAgICAgICAgOiBnZXRMYXlvdXRTdHlsZXNCeVBvc2l0aW9uKG1hcENhbnZhc1Byb2plY3Rpb24sIG9mZnNldCwgZW5zdXJlT2ZUeXBlKHBvc2l0aW9uLCBnb29nbGUubWFwcy5MYXRMbmcsIGNyZWF0ZUxhdExuZykpO1xufVxuZnVuY3Rpb24gYXJlUG9zaXRpb25zRXF1YWwoY3VycmVudFBvc2l0aW9uLCBwcmV2aW91c1Bvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGN1cnJlbnRQb3NpdGlvbi5sZWZ0ID09PSBwcmV2aW91c1Bvc2l0aW9uLmxlZnRcbiAgICAgICAgJiYgY3VycmVudFBvc2l0aW9uLnRvcCA9PT0gcHJldmlvdXNQb3NpdGlvbi50b3BcbiAgICAgICAgJiYgY3VycmVudFBvc2l0aW9uLndpZHRoID09PSBwcmV2aW91c1Bvc2l0aW9uLmhlaWdodFxuICAgICAgICAmJiBjdXJyZW50UG9zaXRpb24uaGVpZ2h0ID09PSBwcmV2aW91c1Bvc2l0aW9uLmhlaWdodDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT3ZlcmxheShjb250YWluZXIsIHBhbmUsIHBvc2l0aW9uLCBib3VuZHMsIGdldFBpeGVsUG9zaXRpb25PZmZzZXQpIHtcbiAgICB2YXIgT3ZlcmxheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKE92ZXJsYXksIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIE92ZXJsYXkoY29udGFpbmVyLCBwYW5lLCBwb3NpdGlvbiwgYm91bmRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAgICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgX3RoaXMucGFuZSA9IHBhbmU7XG4gICAgICAgICAgICBfdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgX3RoaXMuYm91bmRzID0gYm91bmRzO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIE92ZXJsYXkucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIHBhbmUgPSAoX2EgPSB0aGlzLmdldFBhbmVzKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVt0aGlzLnBhbmVdO1xuICAgICAgICAgICAgcGFuZSA9PT0gbnVsbCB8fCBwYW5lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYW5lLmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgT3ZlcmxheS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5nZXRQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gX19hc3NpZ24oe30sICh0aGlzLmNvbnRhaW5lclxuICAgICAgICAgICAgICAgID8gZ2V0T2Zmc2V0T3ZlcnJpZGUodGhpcy5jb250YWluZXIsIGdldFBpeGVsUG9zaXRpb25PZmZzZXQpXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdmFyIGxheW91dFN0eWxlcyA9IGdldExheW91dFN0eWxlcyhwcm9qZWN0aW9uLCBvZmZzZXQsIHRoaXMuYm91bmRzLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhsYXlvdXRTdHlsZXMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBfYiA9IF9hW19pXSwga2V5ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIE92ZXJsYXkucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIE92ZXJsYXk7XG4gICAgfShnb29nbGUubWFwcy5PdmVybGF5VmlldykpO1xuICAgIHJldHVybiBuZXcgT3ZlcmxheShjb250YWluZXIsIHBhbmUsIHBvc2l0aW9uLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0VG9MYXRMbmdTdHJpbmcobGF0TG5nTGlrZSkge1xuICAgIGlmICghbGF0TG5nTGlrZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBsYXRMbmcgPSBsYXRMbmdMaWtlIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nXG4gICAgICAgID8gbGF0TG5nTGlrZVxuICAgICAgICA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmcobGF0TG5nTGlrZS5sYXQsIGxhdExuZ0xpa2UubG5nKTtcbiAgICByZXR1cm4gbGF0TG5nICsgJyc7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYXRMbmdCb3VuZHNTdHJpbmcobGF0TG5nQm91bmRzTGlrZSkge1xuICAgIGlmICghbGF0TG5nQm91bmRzTGlrZSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBsYXRMbmdCb3VuZHMgPSBsYXRMbmdCb3VuZHNMaWtlIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzXG4gICAgICAgID8gbGF0TG5nQm91bmRzTGlrZVxuICAgICAgICA6IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMobmV3IGdvb2dsZS5tYXBzLkxhdExuZyhsYXRMbmdCb3VuZHNMaWtlLnNvdXRoLCBsYXRMbmdCb3VuZHNMaWtlLmVhc3QpLCBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKGxhdExuZ0JvdW5kc0xpa2Uubm9ydGgsIGxhdExuZ0JvdW5kc0xpa2Uud2VzdCkpO1xuICAgIHJldHVybiBsYXRMbmdCb3VuZHMgKyAnJztcbn1cbnZhciBGTE9BVF9QQU5FID0gXCJmbG9hdFBhbmVcIjtcbnZhciBNQVBfUEFORSA9IFwibWFwUGFuZVwiO1xudmFyIE1BUktFUl9MQVlFUiA9IFwibWFya2VyTGF5ZXJcIjtcbnZhciBPVkVSTEFZX0xBWUVSID0gXCJvdmVybGF5TGF5ZXJcIjtcbnZhciBPVkVSTEFZX01PVVNFX1RBUkdFVCA9IFwib3ZlcmxheU1vdXNlVGFyZ2V0XCI7XG5mdW5jdGlvbiBPdmVybGF5Vmlld0Z1bmN0aW9uYWwoX2EpIHtcbiAgICB2YXIgcG9zaXRpb24gPSBfYS5wb3NpdGlvbiwgYm91bmRzID0gX2EuYm91bmRzLCBtYXBQYW5lTmFtZSA9IF9hLm1hcFBhbmVOYW1lLCB6SW5kZXggPSBfYS56SW5kZXgsIG9uTG9hZCA9IF9hLm9uTG9hZCwgb25Vbm1vdW50ID0gX2Eub25Vbm1vdW50LCBnZXRQaXhlbFBvc2l0aW9uT2Zmc2V0ID0gX2EuZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcbiAgICB2YXIgbWFwID0gdXNlQ29udGV4dChNYXBDb250ZXh0KTtcbiAgICB2YXIgY29udGFpbmVyID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9LCBbXSk7XG4gICAgdmFyIG92ZXJsYXkgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU92ZXJsYXkoY29udGFpbmVyLCBtYXBQYW5lTmFtZSwgcG9zaXRpb24sIGJvdW5kcywgZ2V0UGl4ZWxQb3NpdGlvbk9mZnNldCk7XG4gICAgfSwgW2NvbnRhaW5lciwgbWFwUGFuZU5hbWUsIHBvc2l0aW9uLCBib3VuZHNdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBvbkxvYWQgPT09IG51bGwgfHwgb25Mb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkxvYWQob3ZlcmxheSk7XG4gICAgICAgIG92ZXJsYXkgPT09IG51bGwgfHwgb3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcmxheS5zZXRNYXAobWFwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9uVW5tb3VudCA9PT0gbnVsbCB8fCBvblVubW91bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVW5tb3VudChvdmVybGF5KTtcbiAgICAgICAgICAgIG92ZXJsYXkgPT09IG51bGwgfHwgb3ZlcmxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3ZlcmxheS5zZXRNYXAobnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW21hcCwgb3ZlcmxheV0pO1xuICAgIC8vIHRvIG1vdmUgdGhlIGNvbnRhaW5lciB0byB0aGUgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZFxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS56SW5kZXggPSBcIlwiLmNvbmNhdCh6SW5kZXgpO1xuICAgIH0sIFt6SW5kZXgsIGNvbnRhaW5lcl0pO1xuICAgIHJldHVybiBSZWFjdERPTS5jcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGNvbnRhaW5lcik7XG59XG52YXIgT3ZlcmxheVZpZXdGID0gbWVtbyhPdmVybGF5Vmlld0Z1bmN0aW9uYWwpO1xudmFyIE92ZXJsYXlWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdmVybGF5VmlldywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPdmVybGF5Vmlldyhwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBwYW5lRWw6IG51bGwsXG4gICAgICAgICAgICBjb250YWluZXJTdHlsZToge1xuICAgICAgICAgICAgICAgIC8vIHNldCBpbml0aWFsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy51cGRhdGVQYW5lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hcFBhbmVOYW1lID0gX3RoaXMucHJvcHMubWFwUGFuZU5hbWU7XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC8zLmV4cC9yZWZlcmVuY2UjTWFwUGFuZXNcbiAgICAgICAgICAgIHZhciBtYXBQYW5lcyA9IF90aGlzLm92ZXJsYXlWaWV3LmdldFBhbmVzKCk7XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSghIW1hcFBhbmVOYW1lLCBcIk92ZXJsYXlWaWV3IHJlcXVpcmVzIHByb3BzLm1hcFBhbmVOYW1lIGJ1dCBnb3QgJXNcIiwgbWFwUGFuZU5hbWUpO1xuICAgICAgICAgICAgaWYgKG1hcFBhbmVzKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBwYW5lRWw6IG1hcFBhbmVzW21hcFBhbmVOYW1lXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgcGFuZUVsOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkFkZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVQYW5lKCk7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25Mb2FkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgX3RoaXMub3ZlcmxheVZpZXcpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblBvc2l0aW9uRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtYXBDYW52YXNQcm9qZWN0aW9uID0gX3RoaXMub3ZlcmxheVZpZXcuZ2V0UHJvamVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IF9fYXNzaWduKHsgeDogMCwgeTogMCB9LCAoX3RoaXMuY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgICAgICAgICAgICAgICA/IGdldE9mZnNldE92ZXJyaWRlKF90aGlzLmNvbnRhaW5lclJlZi5jdXJyZW50LCBfdGhpcy5wcm9wcy5nZXRQaXhlbFBvc2l0aW9uT2Zmc2V0KVxuICAgICAgICAgICAgICAgIDoge30pKTtcbiAgICAgICAgICAgIHZhciBsYXlvdXRTdHlsZXMgPSBnZXRMYXlvdXRTdHlsZXMobWFwQ2FudmFzUHJvamVjdGlvbiwgb2Zmc2V0LCBfdGhpcy5wcm9wcy5ib3VuZHMsIF90aGlzLnByb3BzLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnN0YXRlLmNvbnRhaW5lclN0eWxlLCBsZWZ0ID0gX2EubGVmdCwgdG9wID0gX2EudG9wLCB3aWR0aCA9IF9hLndpZHRoLCBoZWlnaHQgPSBfYS5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAoIWFyZVBvc2l0aW9uc0VxdWFsKGxheW91dFN0eWxlcywgeyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcCwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogbGF5b3V0U3R5bGVzLnRvcCB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogbGF5b3V0U3R5bGVzLmxlZnQgfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBsYXlvdXRTdHlsZXMud2lkdGggfHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbGF5b3V0U3R5bGVzLmhlaWdodCB8fCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmRyYXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vblBvc2l0aW9uRWxlbWVudCgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgIHBhbmVFbDogbnVsbCxcbiAgICAgICAgICAgIH0pOyB9KTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vblVubW91bnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBfdGhpcy5vdmVybGF5Vmlldyk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNvbnRhaW5lclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICAvLyBZb3UgbXVzdCBpbXBsZW1lbnQgdGhyZWUgbWV0aG9kczogb25BZGQoKSwgZHJhdygpLCBhbmQgb25SZW1vdmUoKS5cbiAgICAgICAgdmFyIG92ZXJsYXlWaWV3ID0gbmV3IGdvb2dsZS5tYXBzLk92ZXJsYXlWaWV3KCk7XG4gICAgICAgIG92ZXJsYXlWaWV3Lm9uQWRkID0gX3RoaXMub25BZGQ7XG4gICAgICAgIG92ZXJsYXlWaWV3LmRyYXcgPSBfdGhpcy5kcmF3O1xuICAgICAgICBvdmVybGF5Vmlldy5vblJlbW92ZSA9IF90aGlzLm9uUmVtb3ZlO1xuICAgICAgICBfdGhpcy5vdmVybGF5VmlldyA9IG92ZXJsYXlWaWV3O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5Vmlldy5zZXRNYXAodGhpcy5jb250ZXh0KTtcbiAgICB9O1xuICAgIE92ZXJsYXlWaWV3LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBwcmV2UG9zaXRpb25TdHJpbmcgPSBjb252ZXJ0VG9MYXRMbmdTdHJpbmcocHJldlByb3BzLnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uU3RyaW5nID0gY29udmVydFRvTGF0TG5nU3RyaW5nKHRoaXMucHJvcHMucG9zaXRpb24pO1xuICAgICAgICB2YXIgcHJldkJvdW5kc1N0cmluZyA9IGNvbnZlcnRUb0xhdExuZ0JvdW5kc1N0cmluZyhwcmV2UHJvcHMuYm91bmRzKTtcbiAgICAgICAgdmFyIGJvdW5kc1N0cmluZyA9IGNvbnZlcnRUb0xhdExuZ0JvdW5kc1N0cmluZyh0aGlzLnByb3BzLmJvdW5kcyk7XG4gICAgICAgIGlmIChwcmV2UG9zaXRpb25TdHJpbmcgIT09IHBvc2l0aW9uU3RyaW5nIHx8XG4gICAgICAgICAgICBwcmV2Qm91bmRzU3RyaW5nICE9PSBib3VuZHNTdHJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVZpZXcuZHJhdygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UHJvcHMubWFwUGFuZU5hbWUgIT09IHRoaXMucHJvcHMubWFwUGFuZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUGFuZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheVZpZXcuc2V0TWFwKG51bGwpO1xuICAgIH07XG4gICAgT3ZlcmxheVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhbmVFbCA9IHRoaXMuc3RhdGUucGFuZUVsO1xuICAgICAgICBpZiAocGFuZUVsKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVhY3RET00uY3JlYXRlUG9ydGFsKGpzeChcImRpdlwiLCB7IHJlZjogdGhpcy5jb250YWluZXJSZWYsIHN0eWxlOiB0aGlzLnN0YXRlLmNvbnRhaW5lclN0eWxlLCBjaGlsZHJlbjogQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSB9KSwgcGFuZUVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPdmVybGF5Vmlldy5GTE9BVF9QQU5FID0gXCJmbG9hdFBhbmVcIjtcbiAgICBPdmVybGF5Vmlldy5NQVBfUEFORSA9IFwibWFwUGFuZVwiO1xuICAgIE92ZXJsYXlWaWV3Lk1BUktFUl9MQVlFUiA9IFwibWFya2VyTGF5ZXJcIjtcbiAgICBPdmVybGF5Vmlldy5PVkVSTEFZX0xBWUVSID0gXCJvdmVybGF5TGF5ZXJcIjtcbiAgICBPdmVybGF5Vmlldy5PVkVSTEFZX01PVVNFX1RBUkdFVCA9IFwib3ZlcmxheU1vdXNlVGFyZ2V0XCI7XG4gICAgT3ZlcmxheVZpZXcuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBPdmVybGF5Vmlldztcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBub29wKCkgeyByZXR1cm47IH1cblxudmFyIGV2ZW50TWFwJDUgPSB7XG4gICAgb25EYmxDbGljazogJ2RibGNsaWNrJyxcbiAgICBvbkNsaWNrOiAnY2xpY2snLFxufTtcbnZhciB1cGRhdGVyTWFwJDUgPSB7XG4gICAgb3BhY2l0eTogZnVuY3Rpb24gKGluc3RhbmNlLCBvcGFjaXR5KSB7XG4gICAgICAgIGluc3RhbmNlLnNldE9wYWNpdHkob3BhY2l0eSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBHcm91bmRPdmVybGF5RnVuY3Rpb25hbChfYSkge1xuICAgIHZhciB1cmwgPSBfYS51cmwsIGJvdW5kcyA9IF9hLmJvdW5kcywgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIHZpc2libGUgPSBfYS52aXNpYmxlO1xuICAgIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICAgIHZhciBpbWFnZUJvdW5kcyA9IG5ldyBnb29nbGUubWFwcy5MYXRMbmdCb3VuZHMobmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMuc291dGgsIGJvdW5kcy53ZXN0KSwgbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhib3VuZHMubm9ydGgsIGJvdW5kcy5lYXN0KSk7XG4gICAgdmFyIGdyb3VuZE92ZXJsYXkgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG92ZXJsYXkgPSBuZXcgZ29vZ2xlLm1hcHMuR3JvdW5kT3ZlcmxheSh1cmwsIGltYWdlQm91bmRzLCBfX2Fzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gb3ZlcmxheTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGdyb3VuZE92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGdyb3VuZE92ZXJsYXkuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWFwXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnICYmIGdyb3VuZE92ZXJsYXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGdyb3VuZE92ZXJsYXkuc2V0KFwidXJsXCIsIHVybCk7XG4gICAgICAgICAgICBncm91bmRPdmVybGF5LnNldE1hcChtYXApO1xuICAgICAgICB9XG4gICAgfSwgW2dyb3VuZE92ZXJsYXksIHVybF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmlzaWJsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ3JvdW5kT3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZ3JvdW5kT3ZlcmxheS5zZXRPcGFjaXR5KHZpc2libGUgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICB9LCBbZ3JvdW5kT3ZlcmxheSwgdmlzaWJsZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdCb3VuZHMgPSBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nQm91bmRzKG5ldyBnb29nbGUubWFwcy5MYXRMbmcoYm91bmRzLnNvdXRoLCBib3VuZHMud2VzdCksIG5ldyBnb29nbGUubWFwcy5MYXRMbmcoYm91bmRzLm5vcnRoLCBib3VuZHMuZWFzdCkpO1xuICAgICAgICBpZiAodHlwZW9mIGJvdW5kcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ3JvdW5kT3ZlcmxheSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZ3JvdW5kT3ZlcmxheS5zZXQoXCJib3VuZHNcIiwgbmV3Qm91bmRzKTtcbiAgICAgICAgICAgIGdyb3VuZE92ZXJsYXkuc2V0TWFwKG1hcCk7XG4gICAgICAgIH1cbiAgICB9LCBbZ3JvdW5kT3ZlcmxheSwgYm91bmRzXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgR3JvdW5kT3ZlcmxheUYgPSBtZW1vKEdyb3VuZE92ZXJsYXlGdW5jdGlvbmFsKTtcbnZhciBHcm91bmRPdmVybGF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhHcm91bmRPdmVybGF5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEdyb3VuZE92ZXJsYXkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZ3JvdW5kT3ZlcmxheTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0R3JvdW5kT3ZlcmxheUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdyb3VuZE92ZXJsYXkucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQkMSghIXRoaXMucHJvcHMudXJsIHx8ICEhdGhpcy5wcm9wcy5ib3VuZHMsIFwiRm9yIEdyb3VuZE92ZXJsYXksIHVybCBhbmQgYm91bmRzIGFyZSBwYXNzZWQgaW4gdG8gY29uc3RydWN0b3IgYW5kIGFyZSBpbW11dGFibGUgYWZ0ZXIgaW5zdGFudGlhdGVkLiBUaGlzIGlzIHRoZSBiZWhhdmlvciBvZiBHb29nbGUgTWFwcyBKYXZhU2NyaXB0IEFQSSB2MyAoIFNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjR3JvdW5kT3ZlcmxheSkgSGVuY2UsIHVzZSB0aGUgY29ycmVzcG9uZGluZyB0d28gcHJvcHMgcHJvdmlkZWQgYnkgYHJlYWN0LWdvb2dsZS1tYXBzLWFwaWAsIHVybCBhbmQgYm91bmRzLiBJbiBzb21lIGNhc2VzLCB5b3UnbGwgbmVlZCB0aGUgR3JvdW5kT3ZlcmxheSBjb21wb25lbnQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlcyBvZiB1cmwgYW5kIGJvdW5kcy4gWW91IGNhbiBsZXZlcmFnZSB0aGUgUmVhY3QncyBrZXkgcHJvcGVydHkgdG8gcmVtb3VudCB0aGUgY29tcG9uZW50LiBUeXBpY2FsbHksIGp1c3QgYGtleT17dXJsfWAgd291bGQgc2VydmUgeW91ciBuZWVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3RvbWNoZW50dy9yZWFjdC1nb29nbGUtbWFwcy9pc3N1ZXMvNjU1XCIpO1xuICAgICAgICB2YXIgZ3JvdW5kT3ZlcmxheSA9IG5ldyBnb29nbGUubWFwcy5Hcm91bmRPdmVybGF5KHRoaXMucHJvcHMudXJsLCB0aGlzLnByb3BzLmJvdW5kcywgX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMucHJvcHMub3B0aW9ucyksIHsgbWFwOiB0aGlzLmNvbnRleHQgfSkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkNSxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQ1LFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBncm91bmRPdmVybGF5LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXRHcm91bmRPdmVybGF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBncm91bmRPdmVybGF5OiBncm91bmRPdmVybGF5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRHcm91bmRPdmVybGF5Q2FsbGJhY2spO1xuICAgIH07XG4gICAgR3JvdW5kT3ZlcmxheS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5ncm91bmRPdmVybGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDUsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDUsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgR3JvdW5kT3ZlcmxheS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZ3JvdW5kT3ZlcmxheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmdyb3VuZE92ZXJsYXkuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHcm91bmRPdmVybGF5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgR3JvdW5kT3ZlcmxheS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIG9uTG9hZDogbm9vcCxcbiAgICB9O1xuICAgIEdyb3VuZE92ZXJsYXkuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBHcm91bmRPdmVybGF5O1xufShQdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCQ0ID0ge307XG52YXIgdXBkYXRlck1hcCQ0ID0ge1xuICAgIGRhdGE6IGZ1bmN0aW9uIChpbnN0YW5jZSwgZGF0YSkge1xuICAgICAgICBpbnN0YW5jZS5zZXREYXRhKGRhdGEpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG1hcCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9LFxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gSGVhdG1hcExheWVyRnVuY3Rpb25hbChfYSkge1xuICAgIHZhciBkYXRhID0gX2EuZGF0YSwgb25Mb2FkID0gX2Eub25Mb2FkLCBvblVubW91bnQgPSBfYS5vblVubW91bnQsIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgIHZhciBtYXAgPSB1c2VDb250ZXh0KE1hcENvbnRleHQpO1xuICAgIHZhciBfYiA9IHVzZVN0YXRlKG51bGwpLCBpbnN0YW5jZSA9IF9iWzBdLCBzZXRJbnN0YW5jZSA9IF9iWzFdO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZ29vZ2xlLm1hcHMudmlzdWFsaXphdGlvbikge1xuICAgICAgICAgICAgaW52YXJpYW50JDEoISFnb29nbGUubWFwcy52aXN1YWxpemF0aW9uLCAnRGlkIHlvdSBpbmNsdWRlIHByb3AgbGlicmFyaWVzPXtbXCJ2aXN1YWxpemF0aW9uXCJdfSBpbiB1c2VKc0FwaVNjcmlwdD8gJXMnLCBnb29nbGUubWFwcy52aXN1YWxpemF0aW9uKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQkMSghIWRhdGEsICdkYXRhIHByb3BlcnR5IGlzIHJlcXVpcmVkIGluIEhlYXRtYXBMYXllciAlcycsIGRhdGEpO1xuICAgIH0sIFtkYXRhXSk7XG4gICAgLy8gT3JkZXIgZG9lcyBtYXR0ZXJcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldE1hcChtYXApO1xuICAgICAgICB9XG4gICAgfSwgW21hcF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW2luc3RhbmNlLCBvcHRpb25zXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhlYXRtYXBMYXllciA9IG5ldyBnb29nbGUubWFwcy52aXN1YWxpemF0aW9uLkhlYXRtYXBMYXllcihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgKG9wdGlvbnMgfHwge30pKSwgeyBkYXRhOiBkYXRhLCBtYXA6IG1hcCB9KSk7XG4gICAgICAgIHNldEluc3RhbmNlKGhlYXRtYXBMYXllcik7XG4gICAgICAgIGlmIChvbkxvYWQpIHtcbiAgICAgICAgICAgIG9uTG9hZChoZWF0bWFwTGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uVW5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlLnNldE1hcChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG52YXIgSGVhdG1hcExheWVyRiA9IG1lbW8oSGVhdG1hcExheWVyRnVuY3Rpb25hbCk7XG52YXIgSGVhdG1hcExheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWF0bWFwTGF5ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGVhdG1hcExheWVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGhlYXRtYXBMYXllcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0SGVhdG1hcExheWVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuaGVhdG1hcExheWVyICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEhlYXRtYXBMYXllci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudCQxKCEhZ29vZ2xlLm1hcHMudmlzdWFsaXphdGlvbiwgJ0RpZCB5b3UgaW5jbHVkZSBwcm9wIGxpYnJhcmllcz17W1widmlzdWFsaXphdGlvblwiXX0gdG8gPExvYWRTY3JpcHQgLz4/ICVzJywgZ29vZ2xlLm1hcHMudmlzdWFsaXphdGlvbik7XG4gICAgICAgIGludmFyaWFudCQxKCEhdGhpcy5wcm9wcy5kYXRhLCAnZGF0YSBwcm9wZXJ0eSBpcyByZXF1aXJlZCBpbiBIZWF0bWFwTGF5ZXIgJXMnLCB0aGlzLnByb3BzLmRhdGEpO1xuICAgICAgICB2YXIgaGVhdG1hcExheWVyID0gbmV3IGdvb2dsZS5tYXBzLnZpc3VhbGl6YXRpb24uSGVhdG1hcExheWVyKF9fYXNzaWduKF9fYXNzaWduKHt9LCAodGhpcy5wcm9wcy5vcHRpb25zIHx8IHt9KSksIHsgZGF0YTogdGhpcy5wcm9wcy5kYXRhLCBtYXA6IHRoaXMuY29udGV4dCB9KSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCQ0LFxuICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDQsXG4gICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGhlYXRtYXBMYXllcixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gc2V0SGVhdG1hcExheWVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoZWF0bWFwTGF5ZXI6IGhlYXRtYXBMYXllcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMuc2V0SGVhdG1hcExheWVyQ2FsbGJhY2spO1xuICAgIH07XG4gICAgSGVhdG1hcExheWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDQsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkNCxcbiAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuaGVhdG1hcExheWVyLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEhlYXRtYXBMYXllci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmhlYXRtYXBMYXllciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5oZWF0bWFwTGF5ZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIZWF0bWFwTGF5ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBIZWF0bWFwTGF5ZXIuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBIZWF0bWFwTGF5ZXI7XG59KFB1cmVDb21wb25lbnQpKTtcblxudmFyIGV2ZW50TWFwJDMgPSB7XG4gICAgb25DbG9zZUNsaWNrOiAnY2xvc2VjbGljaycsXG4gICAgb25QYW5vQ2hhbmdlZDogJ3Bhbm9fY2hhbmdlZCcsXG4gICAgb25Qb3NpdGlvbkNoYW5nZWQ6ICdwb3NpdGlvbl9jaGFuZ2VkJyxcbiAgICBvblBvdkNoYW5nZWQ6ICdwb3ZfY2hhbmdlZCcsXG4gICAgb25SZXNpemU6ICdyZXNpemUnLFxuICAgIG9uU3RhdHVzQ2hhbmdlZDogJ3N0YXR1c19jaGFuZ2VkJyxcbiAgICBvblZpc2libGVDaGFuZ2VkOiAndmlzaWJsZV9jaGFuZ2VkJyxcbiAgICBvblpvb21DaGFuZ2VkOiAnem9vbV9jaGFuZ2VkJyxcbn07XG52YXIgdXBkYXRlck1hcCQzID0ge1xuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnJlZ2lzdGVyUGFub1Byb3ZpZGVyKHByb3ZpZGVyLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGxpbmtzOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGxpbmtzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldExpbmtzKGxpbmtzKTtcbiAgICB9LFxuICAgIG1vdGlvblRyYWNraW5nOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG1vdGlvblRyYWNraW5nKSB7XG4gICAgICAgIGluc3RhbmNlLnNldE1vdGlvblRyYWNraW5nKG1vdGlvblRyYWNraW5nKTtcbiAgICB9LFxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgcGFubzogZnVuY3Rpb24gKGluc3RhbmNlLCBwYW5vKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFBhbm8ocGFubyk7XG4gICAgfSxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24gKGluc3RhbmNlLCBwb3NpdGlvbikge1xuICAgICAgICBpbnN0YW5jZS5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgfSxcbiAgICBwb3Y6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcG92KSB7XG4gICAgICAgIGluc3RhbmNlLnNldFBvdihwb3YpO1xuICAgIH0sXG4gICAgdmlzaWJsZTogZnVuY3Rpb24gKGluc3RhbmNlLCB2aXNpYmxlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFZpc2libGUodmlzaWJsZSk7XG4gICAgfSxcbiAgICB6b29tOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHpvb20pIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Wm9vbSh6b29tKTtcbiAgICB9LFxufTtcbnZhciBTdHJlZXRWaWV3UGFub3JhbWEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0cmVldFZpZXdQYW5vcmFtYSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJlZXRWaWV3UGFub3JhbWEoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gW107XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc3RyZWV0Vmlld1Bhbm9yYW1hOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRTdHJlZXRWaWV3UGFub3JhbWFDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5zdHJlZXRWaWV3UGFub3JhbWEgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3RyZWV0Vmlld1Bhbm9yYW1hLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIHN0cmVldFZpZXdQYW5vcmFtYSA9IChfYiA9IChfYSA9IHRoaXMuY29udGV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0cmVldFZpZXcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbDtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkRXZlbnRzID0gYXBwbHlVcGRhdGVyc1RvUHJvcHNBbmRSZWdpc3RlckV2ZW50cyh7XG4gICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDMsXG4gICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkMyxcbiAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICBpbnN0YW5jZTogc3RyZWV0Vmlld1Bhbm9yYW1hLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0cmVldFZpZXdQYW5vcmFtYTogc3RyZWV0Vmlld1Bhbm9yYW1hLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXRTdHJlZXRWaWV3UGFub3JhbWFDYWxsYmFjayk7XG4gICAgfTtcbiAgICBTdHJlZXRWaWV3UGFub3JhbWEucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyZWV0Vmlld1Bhbm9yYW1hICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDMsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDMsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnN0cmVldFZpZXdQYW5vcmFtYSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlZXRWaWV3UGFub3JhbWEucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdHJlZXRWaWV3UGFub3JhbWEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuc3RyZWV0Vmlld1Bhbm9yYW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RyZWV0Vmlld1Bhbm9yYW1hLnNldFZpc2libGUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHJlZXRWaWV3UGFub3JhbWEucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdHJlZXRWaWV3UGFub3JhbWEuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBTdHJlZXRWaWV3UGFub3JhbWE7XG59KFB1cmVDb21wb25lbnQpKTtcblxudmFyIFN0cmVldFZpZXdTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHJlZXRWaWV3U2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdHJlZXRWaWV3U2VydmljZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgc3RyZWV0Vmlld1NlcnZpY2U6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldFN0cmVldFZpZXdTZXJ2aWNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuc3RyZWV0Vmlld1NlcnZpY2UgIT09IG51bGwgJiYgX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Mb2FkKF90aGlzLnN0YXRlLnN0cmVldFZpZXdTZXJ2aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdHJlZXRWaWV3U2VydmljZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHJlZXRWaWV3U2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5TdHJlZXRWaWV3U2VydmljZSgpO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldFN0cmVldFZpZXdTZXJ2aWNlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdHJlZXRWaWV3U2VydmljZTogc3RyZWV0Vmlld1NlcnZpY2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldFN0cmVldFZpZXdTZXJ2aWNlQ2FsbGJhY2spO1xuICAgIH07XG4gICAgU3RyZWV0Vmlld1NlcnZpY2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdHJlZXRWaWV3U2VydmljZSAhPT0gbnVsbCAmJiB0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5zdHJlZXRWaWV3U2VydmljZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0cmVldFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgU3RyZWV0Vmlld1NlcnZpY2UuY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBTdHJlZXRWaWV3U2VydmljZTtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgRGlyZWN0aW9uc1NlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpcmVjdGlvbnNTZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpcmVjdGlvbnNTZXJ2aWNlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkaXJlY3Rpb25zU2VydmljZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0RGlyZWN0aW9uc1NlcnZpY2VDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5kaXJlY3Rpb25zU2VydmljZSAhPT0gbnVsbCAmJiBfdGhpcy5wcm9wcy5vbkxvYWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxvYWQoX3RoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERpcmVjdGlvbnNTZXJ2aWNlLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50JDEoISF0aGlzLnByb3BzLm9wdGlvbnMsICdEaXJlY3Rpb25zU2VydmljZSBleHBlY3RlZCBvcHRpb25zIG9iamVjdCBhcyBwYXJhbWV0ZXIsIGJ1dCBnb3QgJXMnLCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uc1NlcnZpY2UgPSBuZXcgZ29vZ2xlLm1hcHMuRGlyZWN0aW9uc1NlcnZpY2UoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXREaXJlY3Rpb25zU2VydmljZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uc1NlcnZpY2U6IGRpcmVjdGlvbnNTZXJ2aWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXREaXJlY3Rpb25zU2VydmljZUNhbGxiYWNrKTtcbiAgICB9O1xuICAgIERpcmVjdGlvbnNTZXJ2aWNlLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRpcmVjdGlvbnNTZXJ2aWNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRpcmVjdGlvbnNTZXJ2aWNlLnJvdXRlKHRoaXMucHJvcHMub3B0aW9ucywgdGhpcy5wcm9wcy5jYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpcmVjdGlvbnNTZXJ2aWNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uVW5tb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZGlyZWN0aW9uc1NlcnZpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXJlY3Rpb25zU2VydmljZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBEaXJlY3Rpb25zU2VydmljZTtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgZXZlbnRNYXAkMiA9IHtcbiAgICBvbkRpcmVjdGlvbnNDaGFuZ2VkOiAnZGlyZWN0aW9uc19jaGFuZ2VkJyxcbn07XG52YXIgdXBkYXRlck1hcCQyID0ge1xuICAgIGRpcmVjdGlvbnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgZGlyZWN0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXREaXJlY3Rpb25zKGRpcmVjdGlvbnMpO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiAoaW5zdGFuY2UsIG1hcCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRNYXAobWFwKTtcbiAgICB9LFxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgcGFuZWw6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGFuZWwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGFuZWwocGFuZWwpO1xuICAgIH0sXG4gICAgcm91dGVJbmRleDogZnVuY3Rpb24gKGluc3RhbmNlLCByb3V0ZUluZGV4KSB7XG4gICAgICAgIGluc3RhbmNlLnNldFJvdXRlSW5kZXgocm91dGVJbmRleCk7XG4gICAgfSxcbn07XG52YXIgRGlyZWN0aW9uc1JlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXJlY3Rpb25zUmVuZGVyZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlyZWN0aW9uc1JlbmRlcmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IFtdO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRpcmVjdGlvbnNSZW5kZXJlcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0RGlyZWN0aW9uc1JlbmRlcmVyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyLnNldE1hcChfdGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEaXJlY3Rpb25zUmVuZGVyZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uc1JlbmRlcmVyID0gbmV3IGdvb2dsZS5tYXBzLkRpcmVjdGlvbnNSZW5kZXJlcih0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkMixcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQyLFxuICAgICAgICAgICAgcHJldlByb3BzOiB7fSxcbiAgICAgICAgICAgIG5leHRQcm9wczogdGhpcy5wcm9wcyxcbiAgICAgICAgICAgIGluc3RhbmNlOiBkaXJlY3Rpb25zUmVuZGVyZXIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldERpcmVjdGlvbnNSZW5kZXJlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uc1JlbmRlcmVyOiBkaXJlY3Rpb25zUmVuZGVyZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzLnNldERpcmVjdGlvbnNSZW5kZXJlckNhbGxiYWNrKTtcbiAgICB9O1xuICAgIERpcmVjdGlvbnNSZW5kZXJlci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFdmVudHModGhpcy5yZWdpc3RlcmVkRXZlbnRzKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAkMixcbiAgICAgICAgICAgICAgICBldmVudE1hcDogZXZlbnRNYXAkMixcbiAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHByZXZQcm9wcyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERpcmVjdGlvbnNSZW5kZXJlci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmRpcmVjdGlvbnNSZW5kZXJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Vbm1vdW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVubW91bnQodGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlyZWN0aW9uc1JlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5kaXJlY3Rpb25zUmVuZGVyZXIuc2V0TWFwKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXJlY3Rpb25zUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpzeChGcmFnbWVudCwge30pO1xuICAgIH07XG4gICAgRGlyZWN0aW9uc1JlbmRlcmVyLmNvbnRleHRUeXBlID0gTWFwQ29udGV4dDtcbiAgICByZXR1cm4gRGlyZWN0aW9uc1JlbmRlcmVyO1xufShQdXJlQ29tcG9uZW50KSk7XG5cbnZhciBEaXN0YW5jZU1hdHJpeFNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERpc3RhbmNlTWF0cml4U2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEaXN0YW5jZU1hdHJpeFNlcnZpY2UoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRpc3RhbmNlTWF0cml4U2VydmljZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0RGlzdGFuY2VNYXRyaXhTZXJ2aWNlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5kaXN0YW5jZU1hdHJpeFNlcnZpY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERpc3RhbmNlTWF0cml4U2VydmljZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudCQxKCEhdGhpcy5wcm9wcy5vcHRpb25zLCAnRGlzdGFuY2VNYXRyaXhTZXJ2aWNlIGV4cGVjdGVkIG9wdGlvbnMgb2JqZWN0IGFzIHBhcmFtZXRlciwgYnV0IGdvICVzJywgdGhpcy5wcm9wcy5vcHRpb25zKTtcbiAgICAgICAgdmFyIGRpc3RhbmNlTWF0cml4U2VydmljZSA9IG5ldyBnb29nbGUubWFwcy5EaXN0YW5jZU1hdHJpeFNlcnZpY2UoKTtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiBzZXREaXN0YW5jZU1hdHJpeFNlcnZpY2UoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlTWF0cml4U2VydmljZTogZGlzdGFuY2VNYXRyaXhTZXJ2aWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcy5zZXREaXN0YW5jZU1hdHJpeFNlcnZpY2VDYWxsYmFjayk7XG4gICAgfTtcbiAgICBEaXN0YW5jZU1hdHJpeFNlcnZpY2UucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmRpc3RhbmNlTWF0cml4U2VydmljZS5nZXREaXN0YW5jZU1hdHJpeCh0aGlzLnByb3BzLm9wdGlvbnMsIHRoaXMucHJvcHMuY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEaXN0YW5jZU1hdHJpeFNlcnZpY2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5kaXN0YW5jZU1hdHJpeFNlcnZpY2UgIT09IG51bGwgJiYgdGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Vbm1vdW50KHRoaXMuc3RhdGUuZGlzdGFuY2VNYXRyaXhTZXJ2aWNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGlzdGFuY2VNYXRyaXhTZXJ2aWNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIERpc3RhbmNlTWF0cml4U2VydmljZTtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG52YXIgZXZlbnRNYXAkMSA9IHtcbiAgICBvblBsYWNlc0NoYW5nZWQ6ICdwbGFjZXNfY2hhbmdlZCcsXG59O1xudmFyIHVwZGF0ZXJNYXAkMSA9IHtcbiAgICBib3VuZHM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgYm91bmRzKSB7XG4gICAgICAgIGluc3RhbmNlLnNldEJvdW5kcyhib3VuZHMpO1xuICAgIH0sXG59O1xudmFyIFN0YW5kYWxvbmVTZWFyY2hCb3ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0YW5kYWxvbmVTZWFyY2hCb3gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhbmRhbG9uZVNlYXJjaEJveCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyRWxlbWVudCA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNlYXJjaEJveDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0U2VhcmNoQm94Q2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuc2VhcmNoQm94ICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5zZWFyY2hCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN0YW5kYWxvbmVTZWFyY2hCb3gucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQkMSghIWdvb2dsZS5tYXBzLnBsYWNlcywgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgbGlicmFyaWVzPXtbXCJwbGFjZXNcIl19IHByb3AgdG8gPExvYWRTY3JpcHQgLz4gY29tcG9uZW50ICVzJywgZ29vZ2xlLm1hcHMucGxhY2VzKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyRWxlbWVudCAhPT0gbnVsbCAmJiB0aGlzLmNvbnRhaW5lckVsZW1lbnQuY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5jb250YWluZXJFbGVtZW50LmN1cnJlbnQucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWFyY2hCb3hfMSA9IG5ldyBnb29nbGUubWFwcy5wbGFjZXMuU2VhcmNoQm94KGlucHV0LCB0aGlzLnByb3BzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDEsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCQxLFxuICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBuZXh0UHJvcHM6IHRoaXMucHJvcHMsXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBzZWFyY2hCb3hfMSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKGZ1bmN0aW9uIHNldFNlYXJjaEJveCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaEJveDogc2VhcmNoQm94XzEsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSwgdGhpcy5zZXRTZWFyY2hCb3hDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YW5kYWxvbmVTZWFyY2hCb3gucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VhcmNoQm94ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBhcHBseVVwZGF0ZXJzVG9Qcm9wc0FuZFJlZ2lzdGVyRXZlbnRzKHtcbiAgICAgICAgICAgICAgICB1cGRhdGVyTWFwOiB1cGRhdGVyTWFwJDEsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwJDEsXG4gICAgICAgICAgICAgICAgcHJldlByb3BzOiBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiB0aGlzLnN0YXRlLnNlYXJjaEJveCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdGFuZGFsb25lU2VhcmNoQm94LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VhcmNoQm94ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vblVubW91bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uVW5tb3VudCh0aGlzLnN0YXRlLnNlYXJjaEJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YW5kYWxvbmVTZWFyY2hCb3gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpzeChcImRpdlwiLCB7IHJlZjogdGhpcy5jb250YWluZXJFbGVtZW50LCBjaGlsZHJlbjogQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSB9KTtcbiAgICB9O1xuICAgIFN0YW5kYWxvbmVTZWFyY2hCb3guY29udGV4dFR5cGUgPSBNYXBDb250ZXh0O1xuICAgIHJldHVybiBTdGFuZGFsb25lU2VhcmNoQm94O1xufShQdXJlQ29tcG9uZW50KSk7XG5cbnZhciBldmVudE1hcCA9IHtcbiAgICBvblBsYWNlQ2hhbmdlZDogJ3BsYWNlX2NoYW5nZWQnLFxufTtcbnZhciB1cGRhdGVyTWFwID0ge1xuICAgIGJvdW5kczogZnVuY3Rpb24gKGluc3RhbmNlLCBib3VuZHMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Qm91bmRzKGJvdW5kcyk7XG4gICAgfSxcbiAgICByZXN0cmljdGlvbnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcmVzdHJpY3Rpb25zKSB7XG4gICAgICAgIGluc3RhbmNlLnNldENvbXBvbmVudFJlc3RyaWN0aW9ucyhyZXN0cmljdGlvbnMpO1xuICAgIH0sXG4gICAgZmllbGRzOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGZpZWxkcykge1xuICAgICAgICBpbnN0YW5jZS5zZXRGaWVsZHMoZmllbGRzKTtcbiAgICB9LFxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgb3B0aW9ucykge1xuICAgICAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgdHlwZXM6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZXMpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0VHlwZXModHlwZXMpO1xuICAgIH0sXG59O1xudmFyIEF1dG9jb21wbGV0ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXV0b2NvbXBsZXRlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEF1dG9jb21wbGV0ZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJlZ2lzdGVyZWRFdmVudHMgPSBbXTtcbiAgICAgICAgX3RoaXMuY29udGFpbmVyRWxlbWVudCA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZTogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0QXV0b2NvbXBsZXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuYXV0b2NvbXBsZXRlICE9PSBudWxsICYmIF90aGlzLnByb3BzLm9uTG9hZCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTG9hZChfdGhpcy5zdGF0ZS5hdXRvY29tcGxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaW52YXJpYW50JDEoISFnb29nbGUubWFwcy5wbGFjZXMsICdZb3UgbmVlZCB0byBwcm92aWRlIGxpYnJhcmllcz17W1wicGxhY2VzXCJdfSBwcm9wIHRvIDxMb2FkU2NyaXB0IC8+IGNvbXBvbmVudCAlcycsIGdvb2dsZS5tYXBzLnBsYWNlcyk7XG4gICAgICAgIC8vIFRPRE86IHdoeSBjdXJyZW50IGNvdWxkIGJlIGVxdWFsIG51bGw/XG4gICAgICAgIHZhciBpbnB1dCA9IChfYSA9IHRoaXMuY29udGFpbmVyRWxlbWVudC5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvcignaW5wdXQnKTtcbiAgICAgICAgaWYgKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgYXV0b2NvbXBsZXRlXzEgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZShpbnB1dCwgdGhpcy5wcm9wcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgICAgIHVwZGF0ZXJNYXA6IHVwZGF0ZXJNYXAsXG4gICAgICAgICAgICAgICAgZXZlbnRNYXA6IGV2ZW50TWFwLFxuICAgICAgICAgICAgICAgIHByZXZQcm9wczoge30sXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgICAgIGluc3RhbmNlOiBhdXRvY29tcGxldGVfMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlOiBhdXRvY29tcGxldGVfMSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgdGhpcy5zZXRBdXRvY29tcGxldGVDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB1bnJlZ2lzdGVyRXZlbnRzKHRoaXMucmVnaXN0ZXJlZEV2ZW50cyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZEV2ZW50cyA9IGFwcGx5VXBkYXRlcnNUb1Byb3BzQW5kUmVnaXN0ZXJFdmVudHMoe1xuICAgICAgICAgICAgdXBkYXRlck1hcDogdXBkYXRlck1hcCxcbiAgICAgICAgICAgIGV2ZW50TWFwOiBldmVudE1hcCxcbiAgICAgICAgICAgIHByZXZQcm9wczogcHJldlByb3BzLFxuICAgICAgICAgICAgbmV4dFByb3BzOiB0aGlzLnByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2U6IHRoaXMuc3RhdGUuYXV0b2NvbXBsZXRlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmF1dG9jb21wbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdW5yZWdpc3RlckV2ZW50cyh0aGlzLnJlZ2lzdGVyZWRFdmVudHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGpzeChcImRpdlwiLCB7IHJlZjogdGhpcy5jb250YWluZXJFbGVtZW50LCBjbGFzc05hbWU6IHRoaXMucHJvcHMuY2xhc3NOYW1lLCBjaGlsZHJlbjogQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKSB9KTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIGNsYXNzTmFtZTogJydcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZS5jb250ZXh0VHlwZSA9IE1hcENvbnRleHQ7XG4gICAgcmV0dXJuIEF1dG9jb21wbGV0ZTtcbn0oUHVyZUNvbXBvbmVudCkpO1xuXG5leHBvcnQgeyBBdXRvY29tcGxldGUsIEJpY3ljbGluZ0xheWVyLCBCaWN5Y2xpbmdMYXllckYsIENpcmNsZSwgQ2lyY2xlRiwgRGF0YSwgRGF0YUYsIERpcmVjdGlvbnNSZW5kZXJlciwgRGlyZWN0aW9uc1NlcnZpY2UsIERpc3RhbmNlTWF0cml4U2VydmljZSwgRHJhd2luZ01hbmFnZXIsIERyYXdpbmdNYW5hZ2VyRiwgRkxPQVRfUEFORSwgR29vZ2xlTWFwLCBpbmRleF9lc20gYXMgR29vZ2xlTWFwc01hcmtlckNsdXN0ZXJlciwgR29vZ2xlTWFya2VyQ2x1c3RlcmVyJDEgYXMgR29vZ2xlTWFya2VyQ2x1c3RlcmVyLCBHcm91bmRPdmVybGF5LCBHcm91bmRPdmVybGF5RiwgSGVhdG1hcExheWVyLCBIZWF0bWFwTGF5ZXJGLCBJbmZvQm94Q29tcG9uZW50IGFzIEluZm9Cb3gsIEluZm9Cb3hGLCBJbmZvV2luZG93LCBJbmZvV2luZG93RiwgS21sTGF5ZXIsIExvYWRTY3JpcHQsIExvYWRTY3JpcHROZXh0JDEgYXMgTG9hZFNjcmlwdE5leHQsIE1BUF9QQU5FLCBNQVJLRVJfTEFZRVIsIE1hcENvbnRleHQsIE1hcmtlciwgQ2x1c3RlcmVyQ29tcG9uZW50IGFzIE1hcmtlckNsdXN0ZXJlciwgTWFya2VyQ2x1c3RlcmVyRiwgTWFya2VyRiwgT1ZFUkxBWV9MQVlFUiwgT1ZFUkxBWV9NT1VTRV9UQVJHRVQsIE92ZXJsYXlWaWV3LCBPdmVybGF5Vmlld0YsIFBvbHlnb24sIFBvbHlnb25GLCBQb2x5bGluZSwgUG9seWxpbmVGLCBSZWN0YW5nbGUsIFJlY3RhbmdsZUYsIFN0YW5kYWxvbmVTZWFyY2hCb3gsIFN0cmVldFZpZXdQYW5vcmFtYSwgU3RyZWV0Vmlld1NlcnZpY2UsIFRyYWZmaWNMYXllciwgVHJhZmZpY0xheWVyRiwgVHJhbnNpdExheWVyLCBUcmFuc2l0TGF5ZXJGLCB1c2VHb29nbGVNYXAsIHVzZUpzQXBpTG9hZGVyLCB1c2VMb2FkU2NyaXB0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@react-google-maps/api/dist/esm.js\n");

/***/ }),

/***/ "./node_modules/next-progress/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/next-progress/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar NProgress = __webpack_require__(/*! nprogress */ \"./node_modules/nprogress/nprogress.js\");\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar Router = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n\n/**\n * @param height Height of the progress bar.\n * @param color Color of the progress bar.\n * @param delay Delay of the animation - when page loads faster than the delay time progress bar won't be displayed.\n * @param disableSameRoute If true, progress bar won't be displayed when user travels the same route they're currently on.\n * @param options Options for - NProgress.configure(options).\n * @param customGlobalCss Custom NProgress styles - must be provided as a string that will go inside the <style jsx> tag. Color param won't work as you should set the color yourself inside custom css.\n */\nvar NextProgress = React.memo(function (_a) {\n    var _b = _a.height, height = _b === void 0 ? \"2px\" : _b, _c = _a.color, color = _c === void 0 ? \"#29D\" : _c, _d = _a.delay, delay = _d === void 0 ? 0 : _d, options = _a.options, customGlobalCss = _a.customGlobalCss, _e = _a.disableSameRoute, disableSameRoute = _e === void 0 ? false : _e;\n    var nextProgressStyles = (React.createElement(\"style\", null, customGlobalCss ||\n        // prettier-ignore\n        //? Source: https://unpkg.com/nprogress@0.2.0/nprogress.css\n        \"#nprogress{pointer-events:none}#nprogress .bar{background:\".concat(color, \";position:fixed;z-index:99999;top:0;left:0;width:100%;height:\").concat(typeof height === \"string\" ? height : \"\".concat(height, \"px\"), \"}#nprogress .peg,.nprogress-custom-parent #nprogress .bar,.nprogress-custom-parent #nprogress .spinner{position:absolute}#nprogress .peg{display:block;right:0;width:100px;height:100%;box-shadow:0 0 10px \").concat(color, \",0 0 5px \").concat(color, \";opacity:1;-webkit-transform:rotate(3deg) translate(0,-4px);-ms-transform:rotate(3deg) translate(0,-4px);transform:rotate(3deg) translate(0,-4px)}#nprogress .spinner{display:block;position:fixed;z-index:99999;top:15px;right:15px}#nprogress .spinner-icon{width:18px;height:18px;box-sizing:border-box;border:2px solid transparent;border-top-color:\").concat(color, \";border-left-color:\").concat(color, \";border-radius:50%;-webkit-animation:.4s linear infinite nprogress-spinner;animation:.4s linear infinite nprogress-spinner}.nprogress-custom-parent{overflow:hidden;position:relative}@-webkit-keyframes nprogress-spinner{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes nprogress-spinner{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}\")));\n    React.useEffect(function () {\n        options && NProgress.configure(options);\n        var timeout;\n        var start = function (e) {\n            clearTimeout(timeout);\n            if (disableSameRoute && Router.route === e)\n                return;\n            timeout = setTimeout(function () { return NProgress.start(); }, delay);\n        }, done = function () {\n            clearTimeout(timeout);\n            NProgress.done();\n        };\n        Router.events.on(\"routeChangeStart\", start);\n        Router.events.on(\"routeChangeComplete\", done);\n        Router.events.on(\"routeChangeError\", done);\n        return function () {\n            Router.events.off(\"routeChangeStart\", start);\n            Router.events.off(\"routeChangeComplete\", done);\n            Router.events.off(\"routeChangeError\", done);\n            clearTimeout(timeout);\n        };\n    }, []);\n    return nextProgressStyles;\n}, function () { return true; });\n\nexports[\"default\"] = NextProgress;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC1wcm9ncmVzcy9kaXN0L2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsZ0JBQWdCLG1CQUFPLENBQUMsd0RBQVc7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLDRDQUFPO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxrREFBYTs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CLGdCQUFnQiw2QkFBNkIsZUFBZSxjQUFjLE1BQU0sT0FBTyxXQUFXLGtGQUFrRixzR0FBc0csa0JBQWtCLGdCQUFnQixjQUFjLFFBQVEsWUFBWSxZQUFZLGtFQUFrRSxVQUFVLGlEQUFpRCw2Q0FBNkMseUNBQXlDLG9CQUFvQixjQUFjLGVBQWUsY0FBYyxTQUFTLFdBQVcseUJBQXlCLFdBQVcsWUFBWSxzQkFBc0IsNkJBQTZCLG9DQUFvQyxxQ0FBcUMsa0JBQWtCLHdEQUF3RCxnREFBZ0QseUJBQXlCLGdCQUFnQixrQkFBa0IscUNBQXFDLEdBQUcsNEJBQTRCLEtBQUssa0NBQWtDLDZCQUE2QixHQUFHLG9CQUFvQixLQUFLLDBCQUEwQjtBQUN2dEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkJBQTJCO0FBQzFFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLGdCQUFnQixjQUFjOztBQUUvQixrQkFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0LXByb2dyZXNzL2Rpc3QvaW5kZXguanM/NWQzZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBOUHJvZ3Jlc3MgPSByZXF1aXJlKCducHJvZ3Jlc3MnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgUm91dGVyID0gcmVxdWlyZSgnbmV4dC9yb3V0ZXInKTtcblxuLyoqXG4gKiBAcGFyYW0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuICogQHBhcmFtIGNvbG9yIENvbG9yIG9mIHRoZSBwcm9ncmVzcyBiYXIuXG4gKiBAcGFyYW0gZGVsYXkgRGVsYXkgb2YgdGhlIGFuaW1hdGlvbiAtIHdoZW4gcGFnZSBsb2FkcyBmYXN0ZXIgdGhhbiB0aGUgZGVsYXkgdGltZSBwcm9ncmVzcyBiYXIgd29uJ3QgYmUgZGlzcGxheWVkLlxuICogQHBhcmFtIGRpc2FibGVTYW1lUm91dGUgSWYgdHJ1ZSwgcHJvZ3Jlc3MgYmFyIHdvbid0IGJlIGRpc3BsYXllZCB3aGVuIHVzZXIgdHJhdmVscyB0aGUgc2FtZSByb3V0ZSB0aGV5J3JlIGN1cnJlbnRseSBvbi5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIC0gTlByb2dyZXNzLmNvbmZpZ3VyZShvcHRpb25zKS5cbiAqIEBwYXJhbSBjdXN0b21HbG9iYWxDc3MgQ3VzdG9tIE5Qcm9ncmVzcyBzdHlsZXMgLSBtdXN0IGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nIHRoYXQgd2lsbCBnbyBpbnNpZGUgdGhlIDxzdHlsZSBqc3g+IHRhZy4gQ29sb3IgcGFyYW0gd29uJ3Qgd29yayBhcyB5b3Ugc2hvdWxkIHNldCB0aGUgY29sb3IgeW91cnNlbGYgaW5zaWRlIGN1c3RvbSBjc3MuXG4gKi9cbnZhciBOZXh0UHJvZ3Jlc3MgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9hLmhlaWdodCwgaGVpZ2h0ID0gX2IgPT09IHZvaWQgMCA/IFwiMnB4XCIgOiBfYiwgX2MgPSBfYS5jb2xvciwgY29sb3IgPSBfYyA9PT0gdm9pZCAwID8gXCIjMjlEXCIgOiBfYywgX2QgPSBfYS5kZWxheSwgZGVsYXkgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kLCBvcHRpb25zID0gX2Eub3B0aW9ucywgY3VzdG9tR2xvYmFsQ3NzID0gX2EuY3VzdG9tR2xvYmFsQ3NzLCBfZSA9IF9hLmRpc2FibGVTYW1lUm91dGUsIGRpc2FibGVTYW1lUm91dGUgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZTtcbiAgICB2YXIgbmV4dFByb2dyZXNzU3R5bGVzID0gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCBudWxsLCBjdXN0b21HbG9iYWxDc3MgfHxcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIC8vPyBTb3VyY2U6IGh0dHBzOi8vdW5wa2cuY29tL25wcm9ncmVzc0AwLjIuMC9ucHJvZ3Jlc3MuY3NzXG4gICAgICAgIFwiI25wcm9ncmVzc3twb2ludGVyLWV2ZW50czpub25lfSNucHJvZ3Jlc3MgLmJhcntiYWNrZ3JvdW5kOlwiLmNvbmNhdChjb2xvciwgXCI7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDo5OTk5OTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6XCIpLmNvbmNhdCh0eXBlb2YgaGVpZ2h0ID09PSBcInN0cmluZ1wiID8gaGVpZ2h0IDogXCJcIi5jb25jYXQoaGVpZ2h0LCBcInB4XCIpLCBcIn0jbnByb2dyZXNzIC5wZWcsLm5wcm9ncmVzcy1jdXN0b20tcGFyZW50ICNucHJvZ3Jlc3MgLmJhciwubnByb2dyZXNzLWN1c3RvbS1wYXJlbnQgI25wcm9ncmVzcyAuc3Bpbm5lcntwb3NpdGlvbjphYnNvbHV0ZX0jbnByb2dyZXNzIC5wZWd7ZGlzcGxheTpibG9jaztyaWdodDowO3dpZHRoOjEwMHB4O2hlaWdodDoxMDAlO2JveC1zaGFkb3c6MCAwIDEwcHggXCIpLmNvbmNhdChjb2xvciwgXCIsMCAwIDVweCBcIikuY29uY2F0KGNvbG9yLCBcIjtvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDNkZWcpIHRyYW5zbGF0ZSgwLC00cHgpOy1tcy10cmFuc2Zvcm06cm90YXRlKDNkZWcpIHRyYW5zbGF0ZSgwLC00cHgpO3RyYW5zZm9ybTpyb3RhdGUoM2RlZykgdHJhbnNsYXRlKDAsLTRweCl9I25wcm9ncmVzcyAuc3Bpbm5lcntkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6OTk5OTk7dG9wOjE1cHg7cmlnaHQ6MTVweH0jbnByb2dyZXNzIC5zcGlubmVyLWljb257d2lkdGg6MThweDtoZWlnaHQ6MThweDtib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym9yZGVyOjJweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItdG9wLWNvbG9yOlwiKS5jb25jYXQoY29sb3IsIFwiO2JvcmRlci1sZWZ0LWNvbG9yOlwiKS5jb25jYXQoY29sb3IsIFwiO2JvcmRlci1yYWRpdXM6NTAlOy13ZWJraXQtYW5pbWF0aW9uOi40cyBsaW5lYXIgaW5maW5pdGUgbnByb2dyZXNzLXNwaW5uZXI7YW5pbWF0aW9uOi40cyBsaW5lYXIgaW5maW5pdGUgbnByb2dyZXNzLXNwaW5uZXJ9Lm5wcm9ncmVzcy1jdXN0b20tcGFyZW50e292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZX1ALXdlYmtpdC1rZXlmcmFtZXMgbnByb2dyZXNzLXNwaW5uZXJ7MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgbnByb2dyZXNzLXNwaW5uZXJ7MCV7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMDAle3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19XCIpKSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3B0aW9ucyAmJiBOUHJvZ3Jlc3MuY29uZmlndXJlKG9wdGlvbnMpO1xuICAgICAgICB2YXIgdGltZW91dDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlU2FtZVJvdXRlICYmIFJvdXRlci5yb3V0ZSA9PT0gZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBOUHJvZ3Jlc3Muc3RhcnQoKTsgfSwgZGVsYXkpO1xuICAgICAgICB9LCBkb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgTlByb2dyZXNzLmRvbmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgUm91dGVyLmV2ZW50cy5vbihcInJvdXRlQ2hhbmdlU3RhcnRcIiwgc3RhcnQpO1xuICAgICAgICBSb3V0ZXIuZXZlbnRzLm9uKFwicm91dGVDaGFuZ2VDb21wbGV0ZVwiLCBkb25lKTtcbiAgICAgICAgUm91dGVyLmV2ZW50cy5vbihcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZG9uZSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLm9mZihcInJvdXRlQ2hhbmdlU3RhcnRcIiwgc3RhcnQpO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5vZmYoXCJyb3V0ZUNoYW5nZUNvbXBsZXRlXCIsIGRvbmUpO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5vZmYoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGRvbmUpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gbmV4dFByb2dyZXNzU3R5bGVzO1xufSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE5leHRQcm9ncmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next-progress/dist/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"@import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Kdam+Thmor+Pro&family=Libre+Baskerville&family=Poppins&display=swap&family=Open+Sans:wght@300&display=swap');\\n/* @import \\\"./z-index.css\\\" */\\n/* ! tailwindcss v3.4.4 | MIT License | https://tailwindcss.com */\\n/*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n5. Use the user's configured `sans` font-feature-settings by default.\\n6. Use the user's configured `sans` font-variation-settings by default.\\n7. Disable tap highlights on iOS\\n*/\\nhtml,\\n:host {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n  font-feature-settings: normal; /* 5 */\\n  font-variation-settings: normal; /* 6 */\\n  -webkit-tap-highlight-color: transparent; /* 7 */\\n}\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n/*\\nRemove the default font size and weight for headings.\\n*/\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n/*\\n1. Use the user's configured `mono` font-family by default.\\n2. Use the user's configured `mono` font-feature-settings by default.\\n3. Use the user's configured `mono` font-variation-settings by default.\\n4. Correct the odd `em` font sizing in all browsers.\\n*/\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-feature-settings: normal; /* 2 */\\n  font-variation-settings: normal; /* 3 */\\n  font-size: 1em; /* 4 */\\n}\\n/*\\nAdd the correct font size in all browsers.\\n*/\\nsmall {\\n  font-size: 80%;\\n}\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\nsub {\\n  bottom: -0.25em;\\n}\\nsup {\\n  top: -0.5em;\\n}\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-feature-settings: inherit; /* 1 */\\n  font-variation-settings: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  letter-spacing: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\nbutton,\\ninput:where([type='button']),\\ninput:where([type='reset']),\\ninput:where([type='submit']) {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n:-moz-focusring {\\n  outline: auto;\\n}\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\nprogress {\\n  vertical-align: baseline;\\n}\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\nsummary {\\n  display: list-item;\\n}\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\nlegend {\\n  padding: 0;\\n}\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n/*\\nReset default styling for dialogs.\\n*/\\ndialog {\\n  padding: 0;\\n}\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\ntextarea {\\n  resize: vertical;\\n}\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n/*\\nSet the default cursor for buttons.\\n*/\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n/* Make elements with the HTML hidden attribute stay hidden by default */\\n[hidden] {\\n  display: none;\\n}\\n*, ::before, ::after{\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n  --tw-contain-size:  ;\\n  --tw-contain-layout:  ;\\n  --tw-contain-paint:  ;\\n  --tw-contain-style:  ;\\n}\\n::backdrop{\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-gradient-from-position:  ;\\n  --tw-gradient-via-position:  ;\\n  --tw-gradient-to-position:  ;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n  --tw-contain-size:  ;\\n  --tw-contain-layout:  ;\\n  --tw-contain-paint:  ;\\n  --tw-contain-style:  ;\\n}\\n.container{\\n  width: 100%;\\n}\\n@media (min-width: 640px){\\n  .container{\\n    max-width: 640px;\\n  }\\n}\\n@media (min-width: 768px){\\n  .container{\\n    max-width: 768px;\\n  }\\n}\\n@media (min-width: 1024px){\\n  .container{\\n    max-width: 1024px;\\n  }\\n}\\n@media (min-width: 1280px){\\n  .container{\\n    max-width: 1280px;\\n  }\\n}\\n@media (min-width: 1536px){\\n  .container{\\n    max-width: 1536px;\\n  }\\n}\\n.visible{\\n  visibility: visible;\\n}\\n.fixed{\\n  position: fixed;\\n}\\n.absolute{\\n  position: absolute;\\n}\\n.relative{\\n  position: relative;\\n}\\n.sticky{\\n  position: sticky;\\n}\\n.-top-\\\\[110px\\\\]{\\n  top: -110px;\\n}\\n.-top-\\\\[290px\\\\]{\\n  top: -290px;\\n}\\n.-top-\\\\[2px\\\\]{\\n  top: -2px;\\n}\\n.bottom-0{\\n  bottom: 0px;\\n}\\n.left-2{\\n  left: 0.5rem;\\n}\\n.right-2{\\n  right: 0.5rem;\\n}\\n.right-8{\\n  right: 2rem;\\n}\\n.top-0{\\n  top: 0px;\\n}\\n.top-\\\\[70\\\\.5px\\\\]{\\n  top: 70.5px;\\n}\\n.z-10{\\n  z-index: 10;\\n}\\n.z-\\\\[100000\\\\]{\\n  z-index: 100000;\\n}\\n.z-\\\\[100001\\\\]{\\n  z-index: 100001;\\n}\\n.z-\\\\[999999999999999999999999\\\\]{\\n  z-index: 999999999999999999999999;\\n}\\n.z-\\\\[9999999999999999999999\\\\]{\\n  z-index: 9999999999999999999999;\\n}\\n.z-\\\\[99999999999999999999\\\\]{\\n  z-index: 99999999999999999999;\\n}\\n.z-\\\\[9999999999\\\\]{\\n  z-index: 9999999999;\\n}\\n.z-\\\\[99999\\\\]{\\n  z-index: 99999;\\n}\\n.float-right{\\n  float: right;\\n}\\n.float-left{\\n  float: left;\\n}\\n.m-1{\\n  margin: 0.25rem;\\n}\\n.m-auto{\\n  margin: auto;\\n}\\n.mx-auto{\\n  margin-left: auto;\\n  margin-right: auto;\\n}\\n.mb-0{\\n  margin-bottom: 0px;\\n}\\n.mb-1{\\n  margin-bottom: 0.25rem;\\n}\\n.mb-12{\\n  margin-bottom: 3rem;\\n}\\n.mb-2{\\n  margin-bottom: 0.5rem;\\n}\\n.mb-3{\\n  margin-bottom: 0.75rem;\\n}\\n.mb-4{\\n  margin-bottom: 1rem;\\n}\\n.mb-5{\\n  margin-bottom: 1.25rem;\\n}\\n.mb-6{\\n  margin-bottom: 1.5rem;\\n}\\n.mb-8{\\n  margin-bottom: 2rem;\\n}\\n.mb-\\\\[40px\\\\]{\\n  margin-bottom: 40px;\\n}\\n.ml-2{\\n  margin-left: 0.5rem;\\n}\\n.ml-3{\\n  margin-left: 0.75rem;\\n}\\n.mr-1{\\n  margin-right: 0.25rem;\\n}\\n.mr-2{\\n  margin-right: 0.5rem;\\n}\\n.mr-4{\\n  margin-right: 1rem;\\n}\\n.mt-14{\\n  margin-top: 3.5rem;\\n}\\n.mt-20{\\n  margin-top: 5rem;\\n}\\n.mt-3{\\n  margin-top: 0.75rem;\\n}\\n.mt-4{\\n  margin-top: 1rem;\\n}\\n.mt-6{\\n  margin-top: 1.5rem;\\n}\\n.mt-8{\\n  margin-top: 2rem;\\n}\\n.mt-\\\\[24px\\\\]{\\n  margin-top: 24px;\\n}\\n.mt-\\\\[6rem\\\\]{\\n  margin-top: 6rem;\\n}\\n.mt-\\\\[93px\\\\]{\\n  margin-top: 93px;\\n}\\n.block{\\n  display: block;\\n}\\n.inline-block{\\n  display: inline-block;\\n}\\n.inline{\\n  display: inline;\\n}\\n.flex{\\n  display: flex;\\n}\\n.table{\\n  display: table;\\n}\\n.grid{\\n  display: grid;\\n}\\n.hidden{\\n  display: none;\\n}\\n.aspect-square{\\n  aspect-ratio: 1 / 1;\\n}\\n.h-1{\\n  height: 0.25rem;\\n}\\n.h-10{\\n  height: 2.5rem;\\n}\\n.h-2{\\n  height: 0.5rem;\\n}\\n.h-20{\\n  height: 5rem;\\n}\\n.h-24{\\n  height: 6rem;\\n}\\n.h-3{\\n  height: 0.75rem;\\n}\\n.h-32{\\n  height: 8rem;\\n}\\n.h-5{\\n  height: 1.25rem;\\n}\\n.h-8{\\n  height: 2rem;\\n}\\n.h-96{\\n  height: 24rem;\\n}\\n.h-\\\\[0\\\\.35rem\\\\]{\\n  height: 0.35rem;\\n}\\n.h-\\\\[1100px\\\\]{\\n  height: 1100px;\\n}\\n.h-\\\\[14rem\\\\]{\\n  height: 14rem;\\n}\\n.h-\\\\[2\\\\.75rem\\\\]{\\n  height: 2.75rem;\\n}\\n.h-\\\\[280px\\\\]{\\n  height: 280px;\\n}\\n.h-\\\\[30rem\\\\]{\\n  height: 30rem;\\n}\\n.h-\\\\[35px\\\\]{\\n  height: 35px;\\n}\\n.h-\\\\[400px\\\\]{\\n  height: 400px;\\n}\\n.h-\\\\[60px\\\\]{\\n  height: 60px;\\n}\\n.h-\\\\[80px\\\\]{\\n  height: 80px;\\n}\\n.h-\\\\[calc\\\\(100vh-93px\\\\)\\\\]{\\n  height: calc(100vh - 93px);\\n}\\n.h-auto{\\n  height: auto;\\n}\\n.h-fit{\\n  height: -moz-fit-content;\\n  height: fit-content;\\n}\\n.h-full{\\n  height: 100%;\\n}\\n.h-max{\\n  height: -moz-max-content;\\n  height: max-content;\\n}\\n.h-min{\\n  height: -moz-min-content;\\n  height: min-content;\\n}\\n.h-screen{\\n  height: 100vh;\\n}\\n.max-h-screen{\\n  max-height: 100vh;\\n}\\n.min-h-\\\\[10rem\\\\]{\\n  min-height: 10rem;\\n}\\n.min-h-screen{\\n  min-height: 100vh;\\n}\\n.w-1\\\\/2{\\n  width: 50%;\\n}\\n.w-10{\\n  width: 2.5rem;\\n}\\n.w-2{\\n  width: 0.5rem;\\n}\\n.w-28{\\n  width: 7rem;\\n}\\n.w-3{\\n  width: 0.75rem;\\n}\\n.w-5{\\n  width: 1.25rem;\\n}\\n.w-56{\\n  width: 14rem;\\n}\\n.w-8{\\n  width: 2rem;\\n}\\n.w-96{\\n  width: 24rem;\\n}\\n.w-\\\\[14rem\\\\]{\\n  width: 14rem;\\n}\\n.w-\\\\[158\\\\.4px\\\\]{\\n  width: 158.4px;\\n}\\n.w-\\\\[20rem\\\\]{\\n  width: 20rem;\\n}\\n.w-\\\\[288px\\\\]{\\n  width: 288px;\\n}\\n.w-\\\\[28rem\\\\]{\\n  width: 28rem;\\n}\\n.w-\\\\[3\\\\.5rem\\\\]{\\n  width: 3.5rem;\\n}\\n.w-\\\\[300px\\\\]{\\n  width: 300px;\\n}\\n.w-\\\\[40\\\\%\\\\]{\\n  width: 40%;\\n}\\n.w-\\\\[452px\\\\]{\\n  width: 452px;\\n}\\n.w-\\\\[484px\\\\]{\\n  width: 484px;\\n}\\n.w-\\\\[600px\\\\]{\\n  width: 600px;\\n}\\n.w-\\\\[70\\\\%\\\\]{\\n  width: 70%;\\n}\\n.w-\\\\[80\\\\%\\\\]{\\n  width: 80%;\\n}\\n.w-\\\\[90vw\\\\]{\\n  width: 90vw;\\n}\\n.w-auto{\\n  width: auto;\\n}\\n.w-full{\\n  width: 100%;\\n}\\n.w-screen{\\n  width: 100vw;\\n}\\n.min-w-0{\\n  min-width: 0px;\\n}\\n.min-w-\\\\[40\\\\%\\\\]{\\n  min-width: 40%;\\n}\\n.max-w-\\\\[100vw\\\\]{\\n  max-width: 100vw;\\n}\\n.max-w-\\\\[48rem\\\\]{\\n  max-width: 48rem;\\n}\\n.max-w-\\\\[66vw\\\\]{\\n  max-width: 66vw;\\n}\\n.max-w-full{\\n  max-width: 100%;\\n}\\n.max-w-screen-md{\\n  max-width: 768px;\\n}\\n.flex-auto{\\n  flex: 1 1 auto;\\n}\\n.flex-shrink-0{\\n  flex-shrink: 0;\\n}\\n.border-collapse{\\n  border-collapse: collapse;\\n}\\n.translate-x-\\\\[1px\\\\]{\\n  --tw-translate-x: 1px;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.translate-y-3{\\n  --tw-translate-y: 0.75rem;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.scale-105{\\n  --tw-scale-x: 1.05;\\n  --tw-scale-y: 1.05;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.scale-150{\\n  --tw-scale-x: 1.5;\\n  --tw-scale-y: 1.5;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.scale-90{\\n  --tw-scale-x: .9;\\n  --tw-scale-y: .9;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.scale-95{\\n  --tw-scale-x: .95;\\n  --tw-scale-y: .95;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.scale-\\\\[0\\\\.7\\\\]{\\n  --tw-scale-x: 0.7;\\n  --tw-scale-y: 0.7;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.scale-\\\\[0\\\\.85\\\\]{\\n  --tw-scale-x: 0.85;\\n  --tw-scale-y: 0.85;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.scale-\\\\[0\\\\.8\\\\]{\\n  --tw-scale-x: 0.8;\\n  --tw-scale-y: 0.8;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.transform{\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.cursor-pointer{\\n  cursor: pointer;\\n}\\n.resize{\\n  resize: both;\\n}\\n.flex-row{\\n  flex-direction: row;\\n}\\n.flex-col{\\n  flex-direction: column;\\n}\\n.flex-wrap{\\n  flex-wrap: wrap;\\n}\\n.place-items-center{\\n  place-items: center;\\n}\\n.content-center{\\n  align-content: center;\\n}\\n.items-start{\\n  align-items: flex-start;\\n}\\n.items-center{\\n  align-items: center;\\n}\\n.justify-start{\\n  justify-content: flex-start;\\n}\\n.justify-end{\\n  justify-content: flex-end;\\n}\\n.justify-center{\\n  justify-content: center;\\n}\\n.justify-between{\\n  justify-content: space-between;\\n}\\n.justify-around{\\n  justify-content: space-around;\\n}\\n.justify-evenly{\\n  justify-content: space-evenly;\\n}\\n.gap-3{\\n  gap: 0.75rem;\\n}\\n.gap-\\\\[20px\\\\]{\\n  gap: 20px;\\n}\\n.space-y-8 > :not([hidden]) ~ :not([hidden]){\\n  --tw-space-y-reverse: 0;\\n  margin-top: calc(2rem * calc(1 - var(--tw-space-y-reverse)));\\n  margin-bottom: calc(2rem * var(--tw-space-y-reverse));\\n}\\n.overflow-hidden{\\n  overflow: hidden;\\n}\\n.overflow-visible{\\n  overflow: visible;\\n}\\n.overflow-x-hidden{\\n  overflow-x: hidden;\\n}\\n.overflow-x-scroll{\\n  overflow-x: scroll;\\n}\\n.overflow-y-scroll{\\n  overflow-y: scroll;\\n}\\n.break-words{\\n  overflow-wrap: break-word;\\n}\\n.rounded{\\n  border-radius: 0.25rem;\\n}\\n.rounded-2xl{\\n  border-radius: 1rem;\\n}\\n.rounded-\\\\[3rem\\\\]{\\n  border-radius: 3rem;\\n}\\n.rounded-\\\\[4px\\\\]{\\n  border-radius: 4px;\\n}\\n.rounded-\\\\[5px\\\\]{\\n  border-radius: 5px;\\n}\\n.rounded-\\\\[8px\\\\]{\\n  border-radius: 8px;\\n}\\n.rounded-full{\\n  border-radius: 9999px;\\n}\\n.rounded-lg{\\n  border-radius: 0.5rem;\\n}\\n.rounded-xl{\\n  border-radius: 0.75rem;\\n}\\n.rounded-b-\\\\[5px\\\\]{\\n  border-bottom-right-radius: 5px;\\n  border-bottom-left-radius: 5px;\\n}\\n.rounded-t{\\n  border-top-left-radius: 0.25rem;\\n  border-top-right-radius: 0.25rem;\\n}\\n.rounded-tr-lg{\\n  border-top-right-radius: 0.5rem;\\n}\\n.border{\\n  border-width: 1px;\\n}\\n.border-0{\\n  border-width: 0px;\\n}\\n.border-2{\\n  border-width: 2px;\\n}\\n.border-b-0{\\n  border-bottom-width: 0px;\\n}\\n.border-b-\\\\[3px\\\\]{\\n  border-bottom-width: 3px;\\n}\\n.border-l-0{\\n  border-left-width: 0px;\\n}\\n.border-r-0{\\n  border-right-width: 0px;\\n}\\n.border-t-0{\\n  border-top-width: 0px;\\n}\\n.border-gray-300{\\n  --tw-border-opacity: 1;\\n  border-color: rgb(209 213 219 / var(--tw-border-opacity));\\n}\\n.border-slate-500{\\n  --tw-border-opacity: 1;\\n  border-color: rgb(100 116 139 / var(--tw-border-opacity));\\n}\\n.bg-\\\\[\\\\#00a3ac\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(0 163 172 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[\\\\#04c6d096\\\\]{\\n  background-color: #04c6d096;\\n}\\n.bg-\\\\[\\\\#06000f86\\\\]{\\n  background-color: #06000f86;\\n}\\n.bg-\\\\[\\\\#161c24\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(22 28 36 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[\\\\#181819\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(24 24 25 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[\\\\#1d025c\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(29 2 92 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[\\\\#2f303894\\\\]{\\n  background-color: #2f303894;\\n}\\n.bg-\\\\[\\\\#303030\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(48 48 48 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[\\\\#380fe2a1\\\\]{\\n  background-color: #380fe2a1;\\n}\\n.bg-\\\\[\\\\#5d007782\\\\]{\\n  background-color: #5d007782;\\n}\\n.bg-\\\\[\\\\#61718b6f\\\\]{\\n  background-color: #61718b6f;\\n}\\n.bg-\\\\[\\\\#a5a5a552\\\\]{\\n  background-color: #a5a5a552;\\n}\\n.bg-\\\\[\\\\#c3c3c3\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(195 195 195 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[\\\\#cecdcdfa\\\\]{\\n  background-color: #cecdcdfa;\\n}\\n.bg-\\\\[\\\\#f3e3e3\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(243 227 227 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[\\\\#ffffff50\\\\]{\\n  background-color: #ffffff50;\\n}\\n.bg-\\\\[black\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(0 0 0 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[hsl\\\\(0\\\\2c 0\\\\%\\\\2c 10\\\\%\\\\)\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: hsl(0 0% 10% / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[hsl\\\\(0\\\\2c 0\\\\%\\\\2c 15\\\\%\\\\)\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: hsl(0 0% 15% / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[hsl\\\\(0\\\\2c 0\\\\%\\\\2c 8\\\\%\\\\)\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: hsl(0 0% 8% / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[rgb\\\\(46\\\\2c 50\\\\2c 54\\\\)\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(46 50 54 / var(--tw-bg-opacity));\\n}\\n.bg-\\\\[rgba\\\\(31\\\\2c 31\\\\2c 31\\\\2c 0\\\\.46\\\\)\\\\]{\\n  background-color: rgba(31,31,31,0.46);\\n}\\n.bg-\\\\[rgba\\\\(71\\\\2c 85\\\\2c 115\\\\2c 0\\\\.6\\\\)\\\\]{\\n  background-color: rgba(71,85,115,0.6);\\n}\\n.bg-\\\\[whitesmoke\\\\]{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(245 245 245 / var(--tw-bg-opacity));\\n}\\n.bg-black{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(0 0 0 / var(--tw-bg-opacity));\\n}\\n.bg-gray-300{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(209 213 219 / var(--tw-bg-opacity));\\n}\\n.bg-gray-900{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(17 24 39 / var(--tw-bg-opacity));\\n}\\n.bg-slate-700{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(51 65 85 / var(--tw-bg-opacity));\\n}\\n.bg-transparent{\\n  background-color: transparent;\\n}\\n.bg-white{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\\n}\\n.object-contain{\\n  -o-object-fit: contain;\\n     object-fit: contain;\\n}\\n.p-16{\\n  padding: 4rem;\\n}\\n.p-2{\\n  padding: 0.5rem;\\n}\\n.p-2\\\\.5{\\n  padding: 0.625rem;\\n}\\n.p-4{\\n  padding: 1rem;\\n}\\n.p-5{\\n  padding: 1.25rem;\\n}\\n.p-6{\\n  padding: 1.5rem;\\n}\\n.px-10{\\n  padding-left: 2.5rem;\\n  padding-right: 2.5rem;\\n}\\n.px-24{\\n  padding-left: 6rem;\\n  padding-right: 6rem;\\n}\\n.px-3{\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\n.px-4{\\n  padding-left: 1rem;\\n  padding-right: 1rem;\\n}\\n.px-5{\\n  padding-left: 1.25rem;\\n  padding-right: 1.25rem;\\n}\\n.px-6{\\n  padding-left: 1.5rem;\\n  padding-right: 1.5rem;\\n}\\n.py-10{\\n  padding-top: 2.5rem;\\n  padding-bottom: 2.5rem;\\n}\\n.py-3{\\n  padding-top: 0.75rem;\\n  padding-bottom: 0.75rem;\\n}\\n.py-8{\\n  padding-top: 2rem;\\n  padding-bottom: 2rem;\\n}\\n.py-\\\\[93px\\\\]{\\n  padding-top: 93px;\\n  padding-bottom: 93px;\\n}\\n.pb-2{\\n  padding-bottom: 0.5rem;\\n}\\n.pb-3{\\n  padding-bottom: 0.75rem;\\n}\\n.pb-5{\\n  padding-bottom: 1.25rem;\\n}\\n.pb-8{\\n  padding-bottom: 2rem;\\n}\\n.pl-12{\\n  padding-left: 3rem;\\n}\\n.pl-2{\\n  padding-left: 0.5rem;\\n}\\n.pl-3{\\n  padding-left: 0.75rem;\\n}\\n.pl-32{\\n  padding-left: 8rem;\\n}\\n.pl-4{\\n  padding-left: 1rem;\\n}\\n.pl-5{\\n  padding-left: 1.25rem;\\n}\\n.pr-12{\\n  padding-right: 3rem;\\n}\\n.pr-2{\\n  padding-right: 0.5rem;\\n}\\n.pr-3{\\n  padding-right: 0.75rem;\\n}\\n.pr-4{\\n  padding-right: 1rem;\\n}\\n.pr-5{\\n  padding-right: 1.25rem;\\n}\\n.pt-0{\\n  padding-top: 0px;\\n}\\n.pt-2{\\n  padding-top: 0.5rem;\\n}\\n.pt-28{\\n  padding-top: 7rem;\\n}\\n.pt-3{\\n  padding-top: 0.75rem;\\n}\\n.pt-5{\\n  padding-top: 1.25rem;\\n}\\n.pt-6{\\n  padding-top: 1.5rem;\\n}\\n.pt-\\\\[0px\\\\]{\\n  padding-top: 0px;\\n}\\n.pt-\\\\[500px\\\\]{\\n  padding-top: 500px;\\n}\\n.pt-\\\\[93px\\\\]{\\n  padding-top: 93px;\\n}\\n.text-left{\\n  text-align: left;\\n}\\n.text-center{\\n  text-align: center;\\n}\\n.text-right{\\n  text-align: right;\\n}\\n.text-justify{\\n  text-align: justify;\\n}\\n.font-\\\\[Barlow\\\\2c sans-serif\\\\]{\\n  font-family: Barlow,sans-serif;\\n}\\n.font-dancing{\\n  font-family: Dancing Script;\\n}\\n.font-kdam{\\n  font-family: Kdam Thmor Pro;\\n}\\n.font-openSans{\\n  font-family: 'Open Sans', sans-serif;\\n}\\n.font-poppins{\\n  font-family: 'Poppins';\\n}\\n.text-2xl{\\n  font-size: 1.5rem;\\n  line-height: 2rem;\\n}\\n.text-3xl{\\n  font-size: 1.875rem;\\n  line-height: 2.25rem;\\n}\\n.text-4xl{\\n  font-size: 2.25rem;\\n  line-height: 2.5rem;\\n}\\n.text-5xl{\\n  font-size: 3rem;\\n  line-height: 1;\\n}\\n.text-\\\\[1rem\\\\]{\\n  font-size: 1rem;\\n}\\n.text-\\\\[3\\\\.5rem\\\\]{\\n  font-size: 3.5rem;\\n}\\n.text-base{\\n  font-size: 1rem;\\n  line-height: 1.5rem;\\n}\\n.text-lg{\\n  font-size: 1.125rem;\\n  line-height: 1.75rem;\\n}\\n.text-sm{\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\n.text-xl{\\n  font-size: 1.25rem;\\n  line-height: 1.75rem;\\n}\\n.text-xs{\\n  font-size: 0.75rem;\\n  line-height: 1rem;\\n}\\n.font-\\\\[400\\\\]{\\n  font-weight: 400;\\n}\\n.font-bold{\\n  font-weight: 700;\\n}\\n.font-extrabold{\\n  font-weight: 800;\\n}\\n.font-light{\\n  font-weight: 300;\\n}\\n.font-medium{\\n  font-weight: 500;\\n}\\n.uppercase{\\n  text-transform: uppercase;\\n}\\n.capitalize{\\n  text-transform: capitalize;\\n}\\n.leading-\\\\[1\\\\.75\\\\]{\\n  line-height: 1.75;\\n}\\n.tracking-tight{\\n  letter-spacing: -0.025em;\\n}\\n.text-\\\\[\\\\#0686fd\\\\]{\\n  --tw-text-opacity: 1;\\n  color: rgb(6 134 253 / var(--tw-text-opacity));\\n}\\n.text-\\\\[\\\\#2e1a03\\\\]{\\n  --tw-text-opacity: 1;\\n  color: rgb(46 26 3 / var(--tw-text-opacity));\\n}\\n.text-\\\\[antiquewhite\\\\]{\\n  --tw-text-opacity: 1;\\n  color: rgb(250 235 215 / var(--tw-text-opacity));\\n}\\n.text-\\\\[rgb\\\\(145\\\\2c 158\\\\2c 171\\\\)\\\\]{\\n  --tw-text-opacity: 1;\\n  color: rgb(145 158 171 / var(--tw-text-opacity));\\n}\\n.text-\\\\[whitesmoke\\\\]{\\n  --tw-text-opacity: 1;\\n  color: rgb(245 245 245 / var(--tw-text-opacity));\\n}\\n.text-black{\\n  --tw-text-opacity: 1;\\n  color: rgb(0 0 0 / var(--tw-text-opacity));\\n}\\n.text-blue-400{\\n  --tw-text-opacity: 1;\\n  color: rgb(96 165 250 / var(--tw-text-opacity));\\n}\\n.text-gray-300{\\n  --tw-text-opacity: 1;\\n  color: rgb(209 213 219 / var(--tw-text-opacity));\\n}\\n.text-gray-400{\\n  --tw-text-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-text-opacity));\\n}\\n.text-gray-600{\\n  --tw-text-opacity: 1;\\n  color: rgb(75 85 99 / var(--tw-text-opacity));\\n}\\n.text-gray-700{\\n  --tw-text-opacity: 1;\\n  color: rgb(55 65 81 / var(--tw-text-opacity));\\n}\\n.text-orange-400{\\n  --tw-text-opacity: 1;\\n  color: rgb(251 146 60 / var(--tw-text-opacity));\\n}\\n.text-orange-600{\\n  --tw-text-opacity: 1;\\n  color: rgb(234 88 12 / var(--tw-text-opacity));\\n}\\n.text-white{\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\n.decoration-\\\\[4px\\\\]{\\n  text-decoration-thickness: 4px;\\n}\\n.underline-offset-1{\\n  text-underline-offset: 1px;\\n}\\n.placeholder-gray-400::-moz-placeholder{\\n  --tw-placeholder-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\n}\\n.placeholder-gray-400::placeholder{\\n  --tw-placeholder-opacity: 1;\\n  color: rgb(156 163 175 / var(--tw-placeholder-opacity));\\n}\\n.opacity-0{\\n  opacity: 0;\\n}\\n.opacity-75{\\n  opacity: 0.75;\\n}\\n.opacity-\\\\[0\\\\.75\\\\]{\\n  opacity: 0.75;\\n}\\n.shadow{\\n  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.shadow-lg{\\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.shadow-sm{\\n  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);\\n  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.outline-none{\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\n.outline{\\n  outline-style: solid;\\n}\\n.outline-0{\\n  outline-width: 0px;\\n}\\n.blur{\\n  --tw-blur: blur(8px);\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\n.filter{\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\n.backdrop-blur-lg{\\n  --tw-backdrop-blur: blur(16px);\\n  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n          backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n}\\n.transition{\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, -webkit-backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter, -webkit-backdrop-filter;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.transition-all{\\n  transition-property: all;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.duration-200{\\n  transition-duration: 200ms;\\n}\\n.ease-in-out{\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n}\\n.ease-squared{\\n  transition-timing-function: cubic-bezier(1, 0, 0, 1);\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999\\\\] {\\n  z-index: 99999;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999\\\\] {\\n  z-index: 9999999999;\\n}\\n\\n\\n#__next {\\n  /* margin-top: 6rem; */\\n  min-height: 100vh;\\n  width: 100vw;\\n}\\n* {\\n  box-sizing: border-box;\\n}\\n\\nmain {\\n  padding-top: 6rem;\\n}\\n\\n*[data-animation=\\\"ripple\\\"]::-moz-selection {\\n\\tbackground: transparent;\\n\\t/* pointer-events: none; */\\n}\\n\\n*[data-animation=\\\"ripple\\\"]::selection {\\n\\tbackground: transparent;\\n\\t/* pointer-events: none; */\\n}\\n\\nheader {\\n\\tbackground: #00a3ac\\n}\\n\\nheader.backdropFilter {\\n\\t-webkit-backdrop-filter: blur(10px);\\n\\t        backdrop-filter: blur(10px);\\n}\\n\\nheader.moreBackdropFilter {\\n\\t-webkit-backdrop-filter: blur(100px);\\n\\t        backdrop-filter: blur(100px);\\n}\\n\\n.transparent {\\n  backgorund: #00366600;\\n}\\n\\n.carousel {\\n  display: inline-flex;\\n  overflow-x: hidden;\\n/*  scroll snap is a great feature which will center the image on snap on touch screen devices  */\\n  scroll-snap-type: x mandatory;\\n/* all below will hide the scrollbar on all browsers.    */\\n  -webkit-overflow-scrolling: touch;\\n  scrollbar-width: none; /* For Firefox */\\n  -ms-overflow-style: none; /* For Internet Explorer and Edge */\\n}\\n\\n.image-container span {\\n  transform: scale(0.9);\\n}\\n\\n.mapContainer {\\n  overflow: visible !important;\\n}\\n\\n.details input, textarea {\\n  z-index: 9999999999999999999999;\\n  width: 100%;\\n  padding: 5px;\\n  border-radius: 7.5px;\\n  background: hsla(0, 0%, 8%, 0.916);\\n  transition: all 0.4s ease-in-out, background-color 9999999999999999999999s linear, color 9999999999999999999999s linear;\\n  color: whitesmoke;\\n  padding-left: 7.5px;\\n  padding:0.8em;\\n  border-radius: 0.5em;\\n}\\n\\n.details input:focus, textarea:focus {\\n  outline: none\\n}\\n\\n.details input:focus-within, textarea:focus-within {\\n  box-shadow: 0 0 0 3px #ffeee799;\\n}\\n\\n.details div {\\n  z-index: 99999999999999999999999;\\n}\\n\\n.input-container {\\n  position: relative;\\n  width: 100%;\\n}\\n\\n.input-container:not(:last-child) {\\n  margin-bottom: 19px;\\n}\\n\\n\\n.input-container > input:focus-within + label{\\n  padding: 0 0.2em;\\n  position:absolute;\\n  top: -0.95em;\\n  left: 0.05em;\\n  background: transparent;\\n  color: whitesmoke;\\n  background: hsla(0, 0%, 8%, 0.916);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em\\n}\\n\\n.input-container > input.full + label{\\n  padding:0 0.2em;\\n  position:absolute;\\n  top: -0.95em;\\n  left: 0.05em;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 52%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em\\n}\\n\\n.input-container > input + label{\\n  padding:0 0.2em;\\n  position:absolute;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 0%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em;\\n  top: 0.75em;\\n  left: 0.25em;\\n  transition: all 0.4s ease-in-out;\\n  cursor: text;\\n}\\n\\n.input-container > textarea:focus-within + label{\\n  padding: 0 0.2em;\\n  position:absolute;\\n  top: -0.95em;\\n  left: 0.05em;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 32%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em\\n}\\n\\n.input-container > textarea.full + label{\\n  padding:0 0.2em;\\n  position:absolute;\\n  top: -0.95em;\\n  left: 0.05em;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 52%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em\\n}\\n\\n.input-container > textarea + label{\\n  padding:0 0.2em;\\n  position:absolute;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 0%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em;\\n  top: 0.75em;\\n  left: 0.25em;\\n  transition: all 0.4s ease-in-out;\\n  cursor: text;\\n}\\n\\nbr {\\n  height: 19px !important;\\n  content: \\\"\\\";\\n  width: auto !important;\\n  display: block;\\n}\\n\\n\\n.frame-container h2, h3 {\\n  margin-bottom: 10px;\\n  text-align: center;\\n}\\n\\n.frame-container form {\\n  display: inline-block;\\n}\\n\\n.login-box {\\n  background: hsl(183deg 100% 50% / 60%);\\n  box-shadow: 0 8px 32px 0 rgb(0 193 255 / 36%);\\n  backdrop-filter: blur( 6.5px );\\n  -webkit-backdrop-filter: blur( 6.5px );\\n  border-radius: 10px;\\n  border: 1px solid rgba( 255, 255, 255, 0.18 );\\n}\\n\\nh2.login-text {\\n  text-shadow: 10px -4px 23px #003e95;\\n}\\n\\nh1.login-text {\\n  text-shadow: 11px -4px 23px #0400ff;\\n}\\n\\n.login-main  input, textarea {\\n  z-index: 9999999999999999999999;\\n  width: 100%;\\n  padding: 5px;\\n  border-radius: 7.5px;\\n  background: hsla(0, 0%, 8%, 0.916);\\n  transition: all 0.4s ease-in-out, background-color 9999999999999999999999s linear, color 9999999999999999999999s linear;\\n  color: whitesmoke;\\n  padding-left: 7.5px;\\n  padding:0.8em;\\n  border-radius: 0.5em;\\n}\\n\\n.login-main input:focus, textarea:focus {\\n  outline: none\\n}\\n\\n.login-main input:focus-within, textarea:focus-within {\\n  box-shadow: 0 0 0 3px #ffeee799;\\n}\\n\\n.login-main div {\\n  z-index: 99999999999999999999999;\\n}\\n\\n#loading-container div {\\n  box-sizing: border-box;\\n  display: block;\\n  position: absolute;\\n  width: calc(100% * 0.96);\\n  height: calc(100% * 0.96);\\n  margin: 8px;\\n  border: 18px solid #04c5d0;\\n  border-radius: 50%;\\n  animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;\\n  border-color: #04c5d0 transparent transparent transparent;\\n}\\n\\n#loading-container div:nth-child(1) {\\n  animation-delay: -0.45s;\\n}\\n#loading-container div:nth-child(2) {\\n  animation-delay: -0.3s;\\n}\\n#loading-container div:nth-child(3) {\\n  animation-delay: -0.15s;\\n}\\n@keyframes lds-ring {\\n  0% {\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    transform: rotate(360deg);\\n  }\\n}\\n\\nmain {\\n  scroll-snap-type: y x mandatory;\\n}\\n\\n.view {\\n  scroll-snap-align: start;\\n}\\n\\n.placeholder\\\\:text-white::-moz-placeholder{\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\n\\n.placeholder\\\\:text-white::placeholder{\\n  --tw-text-opacity: 1;\\n  color: rgb(255 255 255 / var(--tw-text-opacity));\\n}\\n\\n.hover\\\\:scale-100:hover{\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n\\n.hover\\\\:scale-95:hover{\\n  --tw-scale-x: .95;\\n  --tw-scale-y: .95;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n\\n.hover\\\\:bg-\\\\[\\\\#035f7b\\\\]:hover{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(3 95 123 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-\\\\[\\\\#454545\\\\]:hover{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(69 69 69 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-\\\\[\\\\#90bdee32\\\\]:hover{\\n  background-color: #90bdee32;\\n}\\n\\n.hover\\\\:bg-\\\\[\\\\#9e9e9e\\\\]:hover{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(158 158 158 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-\\\\[hsl\\\\(0\\\\2c 0\\\\%\\\\2c 25\\\\%\\\\)\\\\]:hover{\\n  --tw-bg-opacity: 1;\\n  background-color: hsl(0 0% 25% / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:bg-slate-800:hover{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(30 41 59 / var(--tw-bg-opacity));\\n}\\n\\n.hover\\\\:text-\\\\[\\\\#0648fd\\\\]:hover{\\n  --tw-text-opacity: 1;\\n  color: rgb(6 72 253 / var(--tw-text-opacity));\\n}\\n\\n.hover\\\\:opacity-100:hover{\\n  opacity: 1;\\n}\\n\\n.hover\\\\:shadow-lg:hover{\\n  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n\\n.hover\\\\:saturate-150:hover{\\n  --tw-saturate: saturate(1.5);\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\n\\n.hover\\\\:backdrop-brightness-50:hover{\\n  --tw-backdrop-brightness: brightness(.5);\\n  -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n          backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);\\n}\\n\\n.focus\\\\:border-2:focus{\\n  border-width: 2px;\\n}\\n\\n.focus\\\\:border-\\\\[\\\\#3c4362\\\\]:focus{\\n  --tw-border-opacity: 1;\\n  border-color: rgb(60 67 98 / var(--tw-border-opacity));\\n}\\n\\n.focus\\\\:bg-\\\\[\\\\#2f3038b5\\\\]:focus{\\n  background-color: #2f3038b5;\\n}\\n\\n.focus\\\\:bg-\\\\[\\\\#454545\\\\]:focus{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(69 69 69 / var(--tw-bg-opacity));\\n}\\n\\n.focus\\\\:outline-none:focus{\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n}\\n\\n.focus\\\\:ring:focus{\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\n\\n.focus\\\\:ring-4:focus{\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\n\\n.focus\\\\:ring-\\\\[\\\\#436edc\\\\]:focus{\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(67 110 220 / var(--tw-ring-opacity));\\n}\\n\\n.focus\\\\:ring-slate-300:focus{\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(203 213 225 / var(--tw-ring-opacity));\\n}\\n\\n.active\\\\:bg-gray-700:active{\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(55 65 81 / var(--tw-bg-opacity));\\n}\\n\\n.active\\\\:text-\\\\[\\\\#032480\\\\]:active{\\n  --tw-text-opacity: 1;\\n  color: rgb(3 36 128 / var(--tw-text-opacity));\\n}\\n\\n@media (max-width: 640px){\\n  .xs\\\\:ml-\\\\[-50vw\\\\]{\\n    margin-left: -50vw;\\n  }\\n  .xs\\\\:block{\\n    display: block;\\n  }\\n  .xs\\\\:flex{\\n    display: flex;\\n  }\\n  .xs\\\\:hidden{\\n    display: none;\\n  }\\n  .xs\\\\:h-max{\\n    height: -moz-max-content;\\n    height: max-content;\\n  }\\n  .xs\\\\:w-screen{\\n    width: 100vw;\\n  }\\n  .xs\\\\:\\\\!p-8{\\n    padding: 2rem !important;\\n  }\\n}\\n\\n@media (min-width: 640px){\\n  .sm\\\\:col-span-2{\\n    grid-column: span 2 / span 2;\\n  }\\n  .sm\\\\:ml-\\\\[-25vw\\\\]{\\n    margin-left: -25vw;\\n  }\\n  .sm\\\\:block{\\n    display: block;\\n  }\\n  .sm\\\\:flex{\\n    display: flex;\\n  }\\n  .sm\\\\:hidden{\\n    display: none;\\n  }\\n  .sm\\\\:h-max{\\n    height: -moz-max-content;\\n    height: max-content;\\n  }\\n  .sm\\\\:w-\\\\[80vw\\\\]{\\n    width: 80vw;\\n  }\\n  .sm\\\\:w-fit{\\n    width: -moz-fit-content;\\n    width: fit-content;\\n  }\\n  .sm\\\\:w-screen{\\n    width: 100vw;\\n  }\\n  .sm\\\\:\\\\!p-8{\\n    padding: 2rem !important;\\n  }\\n  .sm\\\\:text-xl{\\n    font-size: 1.25rem;\\n    line-height: 1.75rem;\\n  }\\n}\\n\\n@media (min-width: 768px){\\n  .md\\\\:ml-\\\\[-25vw\\\\]{\\n    margin-left: -25vw;\\n  }\\n  .md\\\\:block{\\n    display: block;\\n  }\\n  .md\\\\:flex{\\n    display: flex;\\n  }\\n  .md\\\\:hidden{\\n    display: none;\\n  }\\n  .md\\\\:h-\\\\[calc\\\\(100vh-93px\\\\)\\\\]{\\n    height: calc(100vh - 93px);\\n  }\\n  .md\\\\:w-\\\\[40vw\\\\]{\\n    width: 40vw;\\n  }\\n  .md\\\\:w-\\\\[60vw\\\\]{\\n    width: 60vw;\\n  }\\n}\\n\\n@media (min-width: 1024px){\\n  .lg\\\\:mb-16{\\n    margin-bottom: 4rem;\\n  }\\n  .lg\\\\:ml-\\\\[-50vw\\\\]{\\n    margin-left: -50vw;\\n  }\\n  .lg\\\\:block{\\n    display: block;\\n  }\\n  .lg\\\\:flex{\\n    display: flex;\\n  }\\n  .lg\\\\:hidden{\\n    display: none;\\n  }\\n  .lg\\\\:h-\\\\[calc\\\\(100vh-93px\\\\)\\\\]{\\n    height: calc(100vh - 93px);\\n  }\\n  .lg\\\\:w-4\\\\/12{\\n    width: 33.333333%;\\n  }\\n  .lg\\\\:w-\\\\[40vw\\\\]{\\n    width: 40vw;\\n  }\\n  .lg\\\\:px-10{\\n    padding-left: 2.5rem;\\n    padding-right: 2.5rem;\\n  }\\n  .lg\\\\:py-16{\\n    padding-top: 4rem;\\n    padding-bottom: 4rem;\\n  }\\n  @media (min-width: 768px){\\n    .lg\\\\:md\\\\:w-\\\\[60vw\\\\]{\\n      width: 60vw;\\n    }\\n  }\\n}\\n\\n@media (min-width: 1280px){\\n  .xl\\\\:ml-\\\\[-50vw\\\\]{\\n    margin-left: -50vw;\\n  }\\n  .xl\\\\:block{\\n    display: block;\\n  }\\n  .xl\\\\:flex{\\n    display: flex;\\n  }\\n  .xl\\\\:hidden{\\n    display: none;\\n  }\\n  .xl\\\\:h-\\\\[calc\\\\(100vh-93px\\\\)\\\\]{\\n    height: calc(100vh - 93px);\\n  }\\n  .xl\\\\:w-\\\\[40vw\\\\]{\\n    width: 40vw;\\n  }\\n  @media (min-width: 768px){\\n    .xl\\\\:md\\\\:w-\\\\[60vw\\\\]{\\n      width: 60vw;\\n    }\\n  }\\n}\\n\\n@media (min-width: 1536px){\\n  .\\\\32xl\\\\:flex{\\n    display: flex;\\n  }\\n  .\\\\32xl\\\\:hidden{\\n    display: none;\\n  }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/globals.css\"],\"names\":[],\"mappings\":\"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AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA,wBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,qBAAmB;EAAnB;AAAmB;AAAnB;EAAA,yBAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA,gBAAmB;EAAnB,gBAAmB;EAAnB;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA,iBAAmB;EAAnB,iBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,uBAAmB;EAAnB,4DAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,+BAAmB;EAAnB;AAAmB;AAAnB;EAAA,+BAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB;AAAmB;AAAnB;EAAA,sBAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA;AAAmB;AAAnB;EAAA,kBAAmB;EAAnB;AAAmB;AAAnB;EAAA;AAAmB;AAAnB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AAAA;EAAA,oBAAA;EAAA;AAAA;;AAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA,wBAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;AAAA;;AAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA,wBAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA,uBAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA,kBAAA;IAAA;EAAA;AAAA;;AAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;AAAA;;AAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA,oBAAA;IAAA;EAAA;EAAA;IAAA,iBAAA;IAAA;EAAA;EAAA;IAAA;MAAA;IAAA;EAAA;AAAA;;AAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;EAAA;IAAA;MAAA;IAAA;EAAA;AAAA;;AAAA;EAAA;IAAA;EAAA;EAAA;IAAA;EAAA;AAAA\",\"sourcesContent\":[\"@import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Kdam+Thmor+Pro&family=Libre+Baskerville&family=Poppins&display=swap&family=Open+Sans:wght@300&display=swap');\\n/* @import \\\"./z-index.css\\\" */\\n@tailwind base;\\n@tailwind components;\\n@tailwind utilities;\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999\\\\] {\\n  z-index: 99999;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 9999999999999;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999\\\\] {\\n  z-index: 9999999999;\\n}\\n\\n\\n#__next {\\n  /* margin-top: 6rem; */\\n  min-height: 100vh;\\n  width: 100vw;\\n}\\n* {\\n  box-sizing: border-box;\\n}\\n\\nmain {\\n  padding-top: 6rem;\\n}\\n\\n*[data-animation=\\\"ripple\\\"]::selection {\\n\\tbackground: transparent;\\n\\t/* pointer-events: none; */\\n}\\n\\nheader {\\n\\tbackground: #00a3ac\\n}\\n\\nheader.backdropFilter {\\n\\tbackdrop-filter: blur(10px);\\n}\\n\\nheader.moreBackdropFilter {\\n\\tbackdrop-filter: blur(100px);\\n}\\n\\n.transparent {\\n  backgorund: #00366600;\\n}\\n\\n.carousel {\\n  display: inline-flex;\\n  overflow-x: hidden;\\n/*  scroll snap is a great feature which will center the image on snap on touch screen devices  */\\n  scroll-snap-type: x mandatory;\\n/* all below will hide the scrollbar on all browsers.    */\\n  -webkit-overflow-scrolling: touch;\\n  scrollbar-width: none; /* For Firefox */\\n  -ms-overflow-style: none; /* For Internet Explorer and Edge */\\n}\\n\\n.image-container span {\\n  transform: scale(0.9);\\n}\\n\\n.mapContainer {\\n  overflow: visible !important;\\n}\\n\\n.details input, textarea {\\n  z-index: 9999999999999999999999;\\n  width: 100%;\\n  padding: 5px;\\n  border-radius: 7.5px;\\n  background: hsla(0, 0%, 8%, 0.916);\\n  transition: all 0.4s ease-in-out, background-color 9999999999999999999999s linear, color 9999999999999999999999s linear;\\n  color: whitesmoke;\\n  padding-left: 7.5px;\\n  padding:0.8em;\\n  border-radius: 0.5em;\\n}\\n\\n.details input:focus, textarea:focus {\\n  outline: none\\n}\\n\\n.details input:focus-within, textarea:focus-within {\\n  box-shadow: 0 0 0 3px #ffeee799;\\n}\\n\\n.details div {\\n  z-index: 99999999999999999999999;\\n}\\n\\n.input-container {\\n  position: relative;\\n  width: 100%;\\n}\\n\\n.input-container:not(:last-child) {\\n  margin-bottom: 19px;\\n}\\n\\n\\n.input-container > input:focus-within + label{\\n  padding: 0 0.2em;\\n  position:absolute;\\n  top: -0.95em;\\n  left: 0.05em;\\n  background: transparent;\\n  color: whitesmoke;\\n  background: hsla(0, 0%, 8%, 0.916);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em\\n}\\n\\n.input-container > input.full + label{\\n  padding:0 0.2em;\\n  position:absolute;\\n  top: -0.95em;\\n  left: 0.05em;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 52%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em\\n}\\n\\n.input-container > input + label{\\n  padding:0 0.2em;\\n  position:absolute;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 0%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em;\\n  top: 0.75em;\\n  left: 0.25em;\\n  transition: all 0.4s ease-in-out;\\n  cursor: text;\\n}\\n\\n.input-container > textarea:focus-within + label{\\n  padding: 0 0.2em;\\n  position:absolute;\\n  top: -0.95em;\\n  left: 0.05em;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 32%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em\\n}\\n\\n.input-container > textarea.full + label{\\n  padding:0 0.2em;\\n  position:absolute;\\n  top: -0.95em;\\n  left: 0.05em;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 52%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em\\n}\\n\\n.input-container > textarea + label{\\n  padding:0 0.2em;\\n  position:absolute;\\n  background: transparent;\\n  color: white;\\n  background: rgba(0, 63, 167, 0%);\\n  border-radius: 15px;\\n  padding: 0px 0.3em 0px 0.3em;\\n  top: 0.75em;\\n  left: 0.25em;\\n  transition: all 0.4s ease-in-out;\\n  cursor: text;\\n}\\n\\nbr {\\n  height: 19px !important;\\n  content: \\\"\\\";\\n  width: auto !important;\\n  display: block;\\n}\\n\\n\\n.frame-container h2, h3 {\\n  margin-bottom: 10px;\\n  text-align: center;\\n}\\n\\n.frame-container form {\\n  display: inline-block;\\n}\\n\\n.login-box {\\n  background: hsl(183deg 100% 50% / 60%);\\n  box-shadow: 0 8px 32px 0 rgb(0 193 255 / 36%);\\n  backdrop-filter: blur( 6.5px );\\n  -webkit-backdrop-filter: blur( 6.5px );\\n  border-radius: 10px;\\n  border: 1px solid rgba( 255, 255, 255, 0.18 );\\n}\\n\\nh2.login-text {\\n  text-shadow: 10px -4px 23px #003e95;\\n}\\n\\nh1.login-text {\\n  text-shadow: 11px -4px 23px #0400ff;\\n}\\n\\n.login-main  input, textarea {\\n  z-index: 9999999999999999999999;\\n  width: 100%;\\n  padding: 5px;\\n  border-radius: 7.5px;\\n  background: hsla(0, 0%, 8%, 0.916);\\n  transition: all 0.4s ease-in-out, background-color 9999999999999999999999s linear, color 9999999999999999999999s linear;\\n  color: whitesmoke;\\n  padding-left: 7.5px;\\n  padding:0.8em;\\n  border-radius: 0.5em;\\n}\\n\\n.login-main input:focus, textarea:focus {\\n  outline: none\\n}\\n\\n.login-main input:focus-within, textarea:focus-within {\\n  box-shadow: 0 0 0 3px #ffeee799;\\n}\\n\\n.login-main div {\\n  z-index: 99999999999999999999999;\\n}\\n\\n#loading-container div {\\n  box-sizing: border-box;\\n  display: block;\\n  position: absolute;\\n  width: calc(100% * 0.96);\\n  height: calc(100% * 0.96);\\n  margin: 8px;\\n  border: 18px solid #04c5d0;\\n  border-radius: 50%;\\n  animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;\\n  border-color: #04c5d0 transparent transparent transparent;\\n}\\n\\n#loading-container div:nth-child(1) {\\n  animation-delay: -0.45s;\\n}\\n#loading-container div:nth-child(2) {\\n  animation-delay: -0.3s;\\n}\\n#loading-container div:nth-child(3) {\\n  animation-delay: -0.15s;\\n}\\n@keyframes lds-ring {\\n  0% {\\n    transform: rotate(0deg);\\n  }\\n  100% {\\n    transform: rotate(360deg);\\n  }\\n}\\n\\nmain {\\n  scroll-snap-type: y x mandatory;\\n}\\n\\n.view {\\n  scroll-snap-align: start;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vc3R5bGVzL2dsb2JhbHMuY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ3dIO0FBQ3hILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSw0T0FBNE8saVhBQWlYLDRCQUE0Qiw0QkFBNEIsZ0NBQWdDLGtDQUFrQyxVQUFVLHNCQUFzQixxQkFBcUIsR0FBRywyYUFBMmEsc0JBQXNCLDJDQUEyQyw2QkFBNkIsMEJBQTBCLG9CQUFvQixvSkFBb0osMENBQTBDLDRDQUE0QyxxREFBcUQsVUFBVSw0SkFBNEosZUFBZSxpQ0FBaUMsVUFBVSx1TkFBdU4sZUFBZSwyQkFBMkIsa0NBQWtDLFVBQVUsNkZBQTZGLDhDQUE4Qyw4Q0FBOEMsR0FBRyw4RkFBOEYsdUJBQXVCLHlCQUF5QixHQUFHLDZFQUE2RSxtQkFBbUIsNkJBQTZCLEdBQUcsdUVBQXVFLHdCQUF3QixHQUFHLHNTQUFzUyx5SEFBeUgsMENBQTBDLDRDQUE0QywyQkFBMkIsVUFBVSw2REFBNkQsbUJBQW1CLEdBQUcsdUdBQXVHLG1CQUFtQixtQkFBbUIsdUJBQXVCLDZCQUE2QixHQUFHLE9BQU8sb0JBQW9CLEdBQUcsT0FBTyxnQkFBZ0IsR0FBRyw0YUFBNGEsb0JBQW9CLGtDQUFrQyxzQ0FBc0MsVUFBVSw4TEFBOEwsMEJBQTBCLDJDQUEyQyw2Q0FBNkMsNEJBQTRCLGlDQUFpQyxpQ0FBaUMsb0NBQW9DLDJCQUEyQixzQkFBc0IsdUJBQXVCLFVBQVUsMEZBQTBGLHlCQUF5QixHQUFHLHNOQUFzTixnQ0FBZ0MsMENB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TUFBTSxLQUFLLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssTUFBTSxVQUFVLEtBQUssT0FBTyxLQUFLLEtBQUsscUJBQXFCLHFCQUFxQixLQUFLLE1BQU0sS0FBSyxLQUFLLFdBQVcsS0FBSyxPQUFPLEtBQUssS0FBSyxxQkFBcUIsb0JBQW9CLEtBQUssTUFBTSxLQUFLLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxpQkFBaUIsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssT0FBTyxXQUFXLFVBQVUsVUFBVSxLQUFLLE1BQU0sS0FBSyxLQUFLLFVBQVUsS0FBSyxNQUFNLEtBQUssS0FBSyxXQUFXLEtBQUssT0FBTyxLQUFLLEtBQUssb0JBQW9CLG9CQUFvQixLQUFLLE1BQU0sb0JBQW9CLG9CQUFvQixLQUFLLE1BQU0sS0FBSyxNQUFNLFVBQVUsS0FBSyxNQUFNLEtBQUssS0FBSyxVQUFVLEtBQUssUUFBUSxLQUFLLFlBQVksb0JBQW9CLHFCQUFxQixLQUFLLE1BQU0sS0FBSyxNQUFNLFVBQVUsVUFBVSxLQUFLLFdBQVcsS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssTUFBTSxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFdBQVcsTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLGFBQWEsYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxPQUFPLE1BQU0sWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssVUFBVSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxRQUFRLEtBQUssWUFBWSxhQUFhLFdBQVcsS0FBSyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEseUJBQXlCLHlCQUF5QixPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLFdBQVcsWUFBWSxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLE1BQU0sS0FBSyxZQUFZLFFBQVEsS0FBSyxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxNQUFNLEtBQUssVUFBVSxZQUFZLFdBQVcsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLE1BQU0sTUFBTSxLQUFLLFVBQVUsWUFBWSxhQUFhLFdBQVcsWUFBWSxhQUFhLGFBQWEsV0FBVyxVQUFVLFlBQVksV0FBVyxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsVUFBVSxZQUFZLFdBQVcsWUFBWSxhQUFhLE1BQU0sTUFBTSxLQUFLLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxXQUFXLFlBQVksYUFBYSxNQUFNLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLFdBQVcsVUFBVSxZQUFZLFdBQVcsTUFBTSxLQUFLLFlBQVksV0FBVyxZQUFZLFdBQVcsUUFBUSxLQUFLLFlBQVksYUFBYSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksV0FBVyxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLFlBQVksV0FBVyxZQUFZLGFBQWEsYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLE1BQU0sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sTUFBTSxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssVUFBVSxVQUFVLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxXQUFXLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLFdBQVcsS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssTUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFL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QkFBK0IsdUJBQXVCLG1FQUFtRSw4REFBOEQsR0FBRyx5Q0FBeUMsNEJBQTRCLEdBQUcsdUNBQXVDLDJCQUEyQixHQUFHLHVDQUF1Qyw0QkFBNEIsR0FBRyx1QkFBdUIsUUFBUSw4QkFBOEIsS0FBSyxVQUFVLGdDQUFnQyxLQUFLLEdBQUcsVUFBVSxvQ0FBb0MsR0FBRyxXQUFXLDZCQUE2QixHQUFHLHFCQUFxQjtBQUNwZ2tFO0FBQ0EsK0RBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL2dsb2JhbHMuY3NzPzRiYTIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIkBpbXBvcnQgdXJsKCdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2NzczI/ZmFtaWx5PURhbmNpbmcrU2NyaXB0OndnaHRANzAwJmZhbWlseT1LZGFtK1RobW9yK1BybyZmYW1pbHk9TGlicmUrQmFza2VydmlsbGUmZmFtaWx5PVBvcHBpbnMmZGlzcGxheT1zd2FwJmZhbWlseT1PcGVuK1NhbnM6d2dodEAzMDAmZGlzcGxheT1zd2FwJyk7XFxuLyogQGltcG9ydCBcXFwiLi96LWluZGV4LmNzc1xcXCIgKi9cXG4vKiAhIHRhaWx3aW5kY3NzIHYzLjQuNCB8IE1JVCBMaWNlbnNlIHwgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20gKi9cXG4vKlxcbjEuIFByZXZlbnQgcGFkZGluZyBhbmQgYm9yZGVyIGZyb20gYWZmZWN0aW5nIGVsZW1lbnQgd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzQpXFxuMi4gQWxsb3cgYWRkaW5nIGEgYm9yZGVyIHRvIGFuIGVsZW1lbnQgYnkganVzdCBhZGRpbmcgYSBib3JkZXItd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRjc3MvdGFpbHdpbmRjc3MvcHVsbC8xMTYpXFxuKi9cXG4qLFxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgYm9yZGVyLXdpZHRoOiAwOyAvKiAyICovXFxuICBib3JkZXItc3R5bGU6IHNvbGlkOyAvKiAyICovXFxuICBib3JkZXItY29sb3I6ICNlNWU3ZWI7IC8qIDIgKi9cXG59XFxuOjpiZWZvcmUsXFxuOjphZnRlciB7XFxuICAtLXR3LWNvbnRlbnQ6ICcnO1xcbn1cXG4vKlxcbjEuIFVzZSBhIGNvbnNpc3RlbnQgc2Vuc2libGUgbGluZS1oZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbjIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxcbjMuIFVzZSBhIG1vcmUgcmVhZGFibGUgdGFiIHNpemUuXFxuNC4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC1mYW1pbHkgYnkgZGVmYXVsdC5cXG41LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LWZlYXR1cmUtc2V0dGluZ3MgYnkgZGVmYXVsdC5cXG42LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LXZhcmlhdGlvbi1zZXR0aW5ncyBieSBkZWZhdWx0LlxcbjcuIERpc2FibGUgdGFwIGhpZ2hsaWdodHMgb24gaU9TXFxuKi9cXG5odG1sLFxcbjpob3N0IHtcXG4gIGxpbmUtaGVpZ2h0OiAxLjU7IC8qIDEgKi9cXG4gIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTsgLyogMiAqL1xcbiAgLW1vei10YWItc2l6ZTogNDsgLyogMyAqL1xcbiAgLW8tdGFiLXNpemU6IDQ7XFxuICAgICB0YWItc2l6ZTogNDsgLyogMyAqL1xcbiAgZm9udC1mYW1pbHk6IHVpLXNhbnMtc2VyaWYsIHN5c3RlbS11aSwgc2Fucy1zZXJpZiwgXFxcIkFwcGxlIENvbG9yIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIEVtb2ppXFxcIiwgXFxcIlNlZ29lIFVJIFN5bWJvbFxcXCIsIFxcXCJOb3RvIENvbG9yIEVtb2ppXFxcIjsgLyogNCAqL1xcbiAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBub3JtYWw7IC8qIDUgKi9cXG4gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiBub3JtYWw7IC8qIDYgKi9cXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDcgKi9cXG59XFxuLypcXG4xLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBhbGwgYnJvd3NlcnMuXFxuMi4gSW5oZXJpdCBsaW5lLWhlaWdodCBmcm9tIGBodG1sYCBzbyB1c2VycyBjYW4gc2V0IHRoZW0gYXMgYSBjbGFzcyBkaXJlY3RseSBvbiB0aGUgYGh0bWxgIGVsZW1lbnQuXFxuKi9cXG5ib2R5IHtcXG4gIG1hcmdpbjogMDsgLyogMSAqL1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IC8qIDIgKi9cXG59XFxuLypcXG4xLiBBZGQgdGhlIGNvcnJlY3QgaGVpZ2h0IGluIEZpcmVmb3guXFxuMi4gQ29ycmVjdCB0aGUgaW5oZXJpdGFuY2Ugb2YgYm9yZGVyIGNvbG9yIGluIEZpcmVmb3guIChodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTA2NTUpXFxuMy4gRW5zdXJlIGhvcml6b250YWwgcnVsZXMgYXJlIHZpc2libGUgYnkgZGVmYXVsdC5cXG4qL1xcbmhyIHtcXG4gIGhlaWdodDogMDsgLyogMSAqL1xcbiAgY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cXG4gIGJvcmRlci10b3Atd2lkdGg6IDFweDsgLyogMyAqL1xcbn1cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCB0ZXh0IGRlY29yYXRpb24gaW4gQ2hyb21lLCBFZGdlLCBhbmQgU2FmYXJpLlxcbiovXFxuYWJicjp3aGVyZShbdGl0bGVdKSB7XFxuICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG4gICAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbn1cXG4vKlxcblJlbW92ZSB0aGUgZGVmYXVsdCBmb250IHNpemUgYW5kIHdlaWdodCBmb3IgaGVhZGluZ3MuXFxuKi9cXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNiB7XFxuICBmb250LXNpemU6IGluaGVyaXQ7XFxuICBmb250LXdlaWdodDogaW5oZXJpdDtcXG59XFxuLypcXG5SZXNldCBsaW5rcyB0byBvcHRpbWl6ZSBmb3Igb3B0LWluIHN0eWxpbmcgaW5zdGVhZCBvZiBvcHQtb3V0LlxcbiovXFxuYSB7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcXG59XFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgZm9udCB3ZWlnaHQgaW4gRWRnZSBhbmQgU2FmYXJpLlxcbiovXFxuYixcXG5zdHJvbmcge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG59XFxuLypcXG4xLiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBtb25vYCBmb250LWZhbWlseSBieSBkZWZhdWx0LlxcbjIuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQtZmVhdHVyZS1zZXR0aW5ncyBieSBkZWZhdWx0LlxcbjMuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxuNC4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuY29kZSxcXG5rYmQsXFxuc2FtcCxcXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IG5vcm1hbDsgLyogMiAqL1xcbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IG5vcm1hbDsgLyogMyAqL1xcbiAgZm9udC1zaXplOiAxZW07IC8qIDQgKi9cXG59XFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgZm9udCBzaXplIGluIGFsbCBicm93c2Vycy5cXG4qL1xcbnNtYWxsIHtcXG4gIGZvbnQtc2l6ZTogODAlO1xcbn1cXG4vKlxcblByZXZlbnQgYHN1YmAgYW5kIGBzdXBgIGVsZW1lbnRzIGZyb20gYWZmZWN0aW5nIHRoZSBsaW5lIGhlaWdodCBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5zdWIsXFxuc3VwIHtcXG4gIGZvbnQtc2l6ZTogNzUlO1xcbiAgbGluZS1oZWlnaHQ6IDA7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB2ZXJ0aWNhbC1hbGlnbjogYmFzZWxpbmU7XFxufVxcbnN1YiB7XFxuICBib3R0b206IC0wLjI1ZW07XFxufVxcbnN1cCB7XFxuICB0b3A6IC0wLjVlbTtcXG59XFxuLypcXG4xLiBSZW1vdmUgdGV4dCBpbmRlbnRhdGlvbiBmcm9tIHRhYmxlIGNvbnRlbnRzIGluIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTk5MDg4LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjAxMjk3KVxcbjIuIENvcnJlY3QgdGFibGUgYm9yZGVyIGNvbG9yIGluaGVyaXRhbmNlIGluIGFsbCBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTkzNTcyOSwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE5NTAxNilcXG4zLiBSZW1vdmUgZ2FwcyBiZXR3ZWVuIHRhYmxlIGJvcmRlcnMgYnkgZGVmYXVsdC5cXG4qL1xcbnRhYmxlIHtcXG4gIHRleHQtaW5kZW50OiAwOyAvKiAxICovXFxuICBib3JkZXItY29sb3I6IGluaGVyaXQ7IC8qIDIgKi9cXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7IC8qIDMgKi9cXG59XFxuLypcXG4xLiBDaGFuZ2UgdGhlIGZvbnQgc3R5bGVzIGluIGFsbCBicm93c2Vycy5cXG4yLiBSZW1vdmUgdGhlIG1hcmdpbiBpbiBGaXJlZm94IGFuZCBTYWZhcmkuXFxuMy4gUmVtb3ZlIGRlZmF1bHQgcGFkZGluZyBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5idXR0b24sXFxuaW5wdXQsXFxub3B0Z3JvdXAsXFxuc2VsZWN0LFxcbnRleHRhcmVhIHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0OyAvKiAxICovXFxuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiBpbmhlcml0OyAvKiAxICovXFxuICBmb250LXNpemU6IDEwMCU7IC8qIDEgKi9cXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0OyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMSAqL1xcbiAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAxICovXFxuICBtYXJnaW46IDA7IC8qIDIgKi9cXG4gIHBhZGRpbmc6IDA7IC8qIDMgKi9cXG59XFxuLypcXG5SZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UgYW5kIEZpcmVmb3guXFxuKi9cXG5idXR0b24sXFxuc2VsZWN0IHtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbn1cXG4vKlxcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuMi4gUmVtb3ZlIGRlZmF1bHQgYnV0dG9uIHN0eWxlcy5cXG4qL1xcbmJ1dHRvbixcXG5pbnB1dDp3aGVyZShbdHlwZT0nYnV0dG9uJ10pLFxcbmlucHV0OndoZXJlKFt0eXBlPSdyZXNldCddKSxcXG5pbnB1dDp3aGVyZShbdHlwZT0nc3VibWl0J10pIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgLyogMiAqL1xcbiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTsgLyogMiAqL1xcbn1cXG4vKlxcblVzZSB0aGUgbW9kZXJuIEZpcmVmb3ggZm9jdXMgc3R5bGUgZm9yIGFsbCBmb2N1c2FibGUgZWxlbWVudHMuXFxuKi9cXG46LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogYXV0bztcXG59XFxuLypcXG5SZW1vdmUgdGhlIGFkZGl0aW9uYWwgYDppbnZhbGlkYCBzdHlsZXMgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzJmOWVhY2Q5ZDNkOTk1YzkzN2I0MjUxYTU1NTdkOTVkNDk0YzliZTEvbGF5b3V0L3N0eWxlL3Jlcy9mb3Jtcy5jc3MjTDcyOC1MNzM3KVxcbiovXFxuOi1tb3otdWktaW52YWxpZCB7XFxuICBib3gtc2hhZG93OiBub25lO1xcbn1cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lIGFuZCBGaXJlZm94LlxcbiovXFxucHJvZ3Jlc3Mge1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG4vKlxcbkNvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIFNhZmFyaS5cXG4qL1xcbjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG46Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG4vKlxcbjEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcbjIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcbiovXFxuW3R5cGU9J3NlYXJjaCddIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkOyAvKiAxICovXFxuICBvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xcbn1cXG4vKlxcblJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4qL1xcbjo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcbi8qXFxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4yLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuKi9cXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBmb250OiBpbmhlcml0OyAvKiAyICovXFxufVxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuKi9cXG5zdW1tYXJ5IHtcXG4gIGRpc3BsYXk6IGxpc3QtaXRlbTtcXG59XFxuLypcXG5SZW1vdmVzIHRoZSBkZWZhdWx0IHNwYWNpbmcgYW5kIGJvcmRlciBmb3IgYXBwcm9wcmlhdGUgZWxlbWVudHMuXFxuKi9cXG5ibG9ja3F1b3RlLFxcbmRsLFxcbmRkLFxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2LFxcbmhyLFxcbmZpZ3VyZSxcXG5wLFxcbnByZSB7XFxuICBtYXJnaW46IDA7XFxufVxcbmZpZWxkc2V0IHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcbmxlZ2VuZCB7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5vbCxcXG51bCxcXG5tZW51IHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG4vKlxcblJlc2V0IGRlZmF1bHQgc3R5bGluZyBmb3IgZGlhbG9ncy5cXG4qL1xcbmRpYWxvZyB7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG4vKlxcblByZXZlbnQgcmVzaXppbmcgdGV4dGFyZWFzIGhvcml6b250YWxseSBieSBkZWZhdWx0LlxcbiovXFxudGV4dGFyZWEge1xcbiAgcmVzaXplOiB2ZXJ0aWNhbDtcXG59XFxuLypcXG4xLiBSZXNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBvcGFjaXR5IGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2lzc3Vlcy8zMzAwKVxcbjIuIFNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBjb2xvciB0byB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgZ3JheSA0MDAgY29sb3IuXFxuKi9cXG5pbnB1dDo6LW1vei1wbGFjZWhvbGRlciwgdGV4dGFyZWE6Oi1tb3otcGxhY2Vob2xkZXIge1xcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xcbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cXG59XFxuaW5wdXQ6OnBsYWNlaG9sZGVyLFxcbnRleHRhcmVhOjpwbGFjZWhvbGRlciB7XFxuICBvcGFjaXR5OiAxOyAvKiAxICovXFxuICBjb2xvcjogIzljYTNhZjsgLyogMiAqL1xcbn1cXG4vKlxcblNldCB0aGUgZGVmYXVsdCBjdXJzb3IgZm9yIGJ1dHRvbnMuXFxuKi9cXG5idXR0b24sXFxuW3JvbGU9XFxcImJ1dHRvblxcXCJdIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLypcXG5NYWtlIHN1cmUgZGlzYWJsZWQgYnV0dG9ucyBkb24ndCBnZXQgdGhlIHBvaW50ZXIgY3Vyc29yLlxcbiovXFxuOmRpc2FibGVkIHtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuLypcXG4xLiBNYWtlIHJlcGxhY2VkIGVsZW1lbnRzIGBkaXNwbGF5OiBibG9ja2AgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXFxuMi4gQWRkIGB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlYCB0byBhbGlnbiByZXBsYWNlZCBlbGVtZW50cyBtb3JlIHNlbnNpYmx5IGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vamVuc2ltbW9ucy9jc3NyZW1lZHkvaXNzdWVzLzE0I2lzc3VlY29tbWVudC02MzQ5MzQyMTApXFxuICAgVGhpcyBjYW4gdHJpZ2dlciBhIHBvb3JseSBjb25zaWRlcmVkIGxpbnQgZXJyb3IgaW4gc29tZSB0b29scyBidXQgaXMgaW5jbHVkZWQgYnkgZGVzaWduLlxcbiovXFxuaW1nLFxcbnN2ZyxcXG52aWRlbyxcXG5jYW52YXMsXFxuYXVkaW8sXFxuaWZyYW1lLFxcbmVtYmVkLFxcbm9iamVjdCB7XFxuICBkaXNwbGF5OiBibG9jazsgLyogMSAqL1xcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTsgLyogMiAqL1xcbn1cXG4vKlxcbkNvbnN0cmFpbiBpbWFnZXMgYW5kIHZpZGVvcyB0byB0aGUgcGFyZW50IHdpZHRoIGFuZCBwcmVzZXJ2ZSB0aGVpciBpbnRyaW5zaWMgYXNwZWN0IHJhdGlvLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcXG4qL1xcbmltZyxcXG52aWRlbyB7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IGF1dG87XFxufVxcbi8qIE1ha2UgZWxlbWVudHMgd2l0aCB0aGUgSFRNTCBoaWRkZW4gYXR0cmlidXRlIHN0YXkgaGlkZGVuIGJ5IGRlZmF1bHQgKi9cXG5baGlkZGVuXSB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4qLCA6OmJlZm9yZSwgOjphZnRlcntcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteDogMDtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteTogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xcbiAgLS10dy1yb3RhdGU6IDA7XFxuICAtLXR3LXNrZXcteDogMDtcXG4gIC0tdHctc2tldy15OiAwO1xcbiAgLS10dy1zY2FsZS14OiAxO1xcbiAgLS10dy1zY2FsZS15OiAxO1xcbiAgLS10dy1wYW4teDogIDtcXG4gIC0tdHctcGFuLXk6ICA7XFxuICAtLXR3LXBpbmNoLXpvb206ICA7XFxuICAtLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6IHByb3hpbWl0eTtcXG4gIC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbjogIDtcXG4gIC0tdHctZ3JhZGllbnQtdmlhLXBvc2l0aW9uOiAgO1xcbiAgLS10dy1ncmFkaWVudC10by1wb3NpdGlvbjogIDtcXG4gIC0tdHctb3JkaW5hbDogIDtcXG4gIC0tdHctc2xhc2hlZC16ZXJvOiAgO1xcbiAgLS10dy1udW1lcmljLWZpZ3VyZTogIDtcXG4gIC0tdHctbnVtZXJpYy1zcGFjaW5nOiAgO1xcbiAgLS10dy1udW1lcmljLWZyYWN0aW9uOiAgO1xcbiAgLS10dy1yaW5nLWluc2V0OiAgO1xcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyAwLjUpO1xcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XFxuICAtLXR3LWJsdXI6ICA7XFxuICAtLXR3LWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWNvbnRyYXN0OiAgO1xcbiAgLS10dy1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWludmVydDogIDtcXG4gIC0tdHctc2F0dXJhdGU6ICA7XFxuICAtLXR3LXNlcGlhOiAgO1xcbiAgLS10dy1kcm9wLXNoYWRvdzogIDtcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogIDtcXG4gIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctYmFja2Ryb3AtY29udHJhc3Q6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaW52ZXJ0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1vcGFjaXR5OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2VwaWE6ICA7XFxuICAtLXR3LWNvbnRhaW4tc2l6ZTogIDtcXG4gIC0tdHctY29udGFpbi1sYXlvdXQ6ICA7XFxuICAtLXR3LWNvbnRhaW4tcGFpbnQ6ICA7XFxuICAtLXR3LWNvbnRhaW4tc3R5bGU6ICA7XFxufVxcbjo6YmFja2Ryb3B7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteTogMDtcXG4gIC0tdHctcm90YXRlOiAwO1xcbiAgLS10dy1za2V3LXg6IDA7XFxuICAtLXR3LXNrZXcteTogMDtcXG4gIC0tdHctc2NhbGUteDogMTtcXG4gIC0tdHctc2NhbGUteTogMTtcXG4gIC0tdHctcGFuLXg6ICA7XFxuICAtLXR3LXBhbi15OiAgO1xcbiAgLS10dy1waW5jaC16b29tOiAgO1xcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XFxuICAtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb246ICA7XFxuICAtLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbjogIDtcXG4gIC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246ICA7XFxuICAtLXR3LW9yZGluYWw6ICA7XFxuICAtLXR3LXNsYXNoZWQtemVybzogIDtcXG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XFxuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcXG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcXG4gIC0tdHctcmluZy1pbnNldDogIDtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcbiAgLS10dy1ibHVyOiAgO1xcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1jb250cmFzdDogIDtcXG4gIC0tdHctZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1pbnZlcnQ6ICA7XFxuICAtLXR3LXNhdHVyYXRlOiAgO1xcbiAgLS10dy1zZXBpYTogIDtcXG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcXG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xcbiAgLS10dy1jb250YWluLXNpemU6ICA7XFxuICAtLXR3LWNvbnRhaW4tbGF5b3V0OiAgO1xcbiAgLS10dy1jb250YWluLXBhaW50OiAgO1xcbiAgLS10dy1jb250YWluLXN0eWxlOiAgO1xcbn1cXG4uY29udGFpbmVye1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiA2NDBweCl7XFxuICAuY29udGFpbmVye1xcbiAgICBtYXgtd2lkdGg6IDY0MHB4O1xcbiAgfVxcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpe1xcbiAgLmNvbnRhaW5lcntcXG4gICAgbWF4LXdpZHRoOiA3NjhweDtcXG4gIH1cXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDEwMjRweCl7XFxuICAuY29udGFpbmVye1xcbiAgICBtYXgtd2lkdGg6IDEwMjRweDtcXG4gIH1cXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCl7XFxuICAuY29udGFpbmVye1xcbiAgICBtYXgtd2lkdGg6IDEyODBweDtcXG4gIH1cXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDE1MzZweCl7XFxuICAuY29udGFpbmVye1xcbiAgICBtYXgtd2lkdGg6IDE1MzZweDtcXG4gIH1cXG59XFxuLnZpc2libGV7XFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbn1cXG4uZml4ZWR7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxufVxcbi5hYnNvbHV0ZXtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLnJlbGF0aXZle1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG4uc3RpY2t5e1xcbiAgcG9zaXRpb246IHN0aWNreTtcXG59XFxuLi10b3AtXFxcXFsxMTBweFxcXFxde1xcbiAgdG9wOiAtMTEwcHg7XFxufVxcbi4tdG9wLVxcXFxbMjkwcHhcXFxcXXtcXG4gIHRvcDogLTI5MHB4O1xcbn1cXG4uLXRvcC1cXFxcWzJweFxcXFxde1xcbiAgdG9wOiAtMnB4O1xcbn1cXG4uYm90dG9tLTB7XFxuICBib3R0b206IDBweDtcXG59XFxuLmxlZnQtMntcXG4gIGxlZnQ6IDAuNXJlbTtcXG59XFxuLnJpZ2h0LTJ7XFxuICByaWdodDogMC41cmVtO1xcbn1cXG4ucmlnaHQtOHtcXG4gIHJpZ2h0OiAycmVtO1xcbn1cXG4udG9wLTB7XFxuICB0b3A6IDBweDtcXG59XFxuLnRvcC1cXFxcWzcwXFxcXC41cHhcXFxcXXtcXG4gIHRvcDogNzAuNXB4O1xcbn1cXG4uei0xMHtcXG4gIHotaW5kZXg6IDEwO1xcbn1cXG4uei1cXFxcWzEwMDAwMFxcXFxde1xcbiAgei1pbmRleDogMTAwMDAwO1xcbn1cXG4uei1cXFxcWzEwMDAwMVxcXFxde1xcbiAgei1pbmRleDogMTAwMDAxO1xcbn1cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxde1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5O1xcbn1cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXXtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk7XFxufVxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXXtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5O1xcbn1cXG4uei1cXFxcWzk5OTk5OTk5OTlcXFxcXXtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk7XFxufVxcbi56LVxcXFxbOTk5OTlcXFxcXXtcXG4gIHotaW5kZXg6IDk5OTk5O1xcbn1cXG4uZmxvYXQtcmlnaHR7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcbi5mbG9hdC1sZWZ0e1xcbiAgZmxvYXQ6IGxlZnQ7XFxufVxcbi5tLTF7XFxuICBtYXJnaW46IDAuMjVyZW07XFxufVxcbi5tLWF1dG97XFxuICBtYXJnaW46IGF1dG87XFxufVxcbi5teC1hdXRve1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxufVxcbi5tYi0we1xcbiAgbWFyZ2luLWJvdHRvbTogMHB4O1xcbn1cXG4ubWItMXtcXG4gIG1hcmdpbi1ib3R0b206IDAuMjVyZW07XFxufVxcbi5tYi0xMntcXG4gIG1hcmdpbi1ib3R0b206IDNyZW07XFxufVxcbi5tYi0ye1xcbiAgbWFyZ2luLWJvdHRvbTogMC41cmVtO1xcbn1cXG4ubWItM3tcXG4gIG1hcmdpbi1ib3R0b206IDAuNzVyZW07XFxufVxcbi5tYi00e1xcbiAgbWFyZ2luLWJvdHRvbTogMXJlbTtcXG59XFxuLm1iLTV7XFxuICBtYXJnaW4tYm90dG9tOiAxLjI1cmVtO1xcbn1cXG4ubWItNntcXG4gIG1hcmdpbi1ib3R0b206IDEuNXJlbTtcXG59XFxuLm1iLTh7XFxuICBtYXJnaW4tYm90dG9tOiAycmVtO1xcbn1cXG4ubWItXFxcXFs0MHB4XFxcXF17XFxuICBtYXJnaW4tYm90dG9tOiA0MHB4O1xcbn1cXG4ubWwtMntcXG4gIG1hcmdpbi1sZWZ0OiAwLjVyZW07XFxufVxcbi5tbC0ze1xcbiAgbWFyZ2luLWxlZnQ6IDAuNzVyZW07XFxufVxcbi5tci0xe1xcbiAgbWFyZ2luLXJpZ2h0OiAwLjI1cmVtO1xcbn1cXG4ubXItMntcXG4gIG1hcmdpbi1yaWdodDogMC41cmVtO1xcbn1cXG4ubXItNHtcXG4gIG1hcmdpbi1yaWdodDogMXJlbTtcXG59XFxuLm10LTE0e1xcbiAgbWFyZ2luLXRvcDogMy41cmVtO1xcbn1cXG4ubXQtMjB7XFxuICBtYXJnaW4tdG9wOiA1cmVtO1xcbn1cXG4ubXQtM3tcXG4gIG1hcmdpbi10b3A6IDAuNzVyZW07XFxufVxcbi5tdC00e1xcbiAgbWFyZ2luLXRvcDogMXJlbTtcXG59XFxuLm10LTZ7XFxuICBtYXJnaW4tdG9wOiAxLjVyZW07XFxufVxcbi5tdC04e1xcbiAgbWFyZ2luLXRvcDogMnJlbTtcXG59XFxuLm10LVxcXFxbMjRweFxcXFxde1xcbiAgbWFyZ2luLXRvcDogMjRweDtcXG59XFxuLm10LVxcXFxbNnJlbVxcXFxde1xcbiAgbWFyZ2luLXRvcDogNnJlbTtcXG59XFxuLm10LVxcXFxbOTNweFxcXFxde1xcbiAgbWFyZ2luLXRvcDogOTNweDtcXG59XFxuLmJsb2Nre1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5pbmxpbmUtYmxvY2t7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxufVxcbi5pbmxpbmV7XFxuICBkaXNwbGF5OiBpbmxpbmU7XFxufVxcbi5mbGV4e1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuLnRhYmxle1xcbiAgZGlzcGxheTogdGFibGU7XFxufVxcbi5ncmlke1xcbiAgZGlzcGxheTogZ3JpZDtcXG59XFxuLmhpZGRlbntcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5hc3BlY3Qtc3F1YXJle1xcbiAgYXNwZWN0LXJhdGlvOiAxIC8gMTtcXG59XFxuLmgtMXtcXG4gIGhlaWdodDogMC4yNXJlbTtcXG59XFxuLmgtMTB7XFxuICBoZWlnaHQ6IDIuNXJlbTtcXG59XFxuLmgtMntcXG4gIGhlaWdodDogMC41cmVtO1xcbn1cXG4uaC0yMHtcXG4gIGhlaWdodDogNXJlbTtcXG59XFxuLmgtMjR7XFxuICBoZWlnaHQ6IDZyZW07XFxufVxcbi5oLTN7XFxuICBoZWlnaHQ6IDAuNzVyZW07XFxufVxcbi5oLTMye1xcbiAgaGVpZ2h0OiA4cmVtO1xcbn1cXG4uaC01e1xcbiAgaGVpZ2h0OiAxLjI1cmVtO1xcbn1cXG4uaC04e1xcbiAgaGVpZ2h0OiAycmVtO1xcbn1cXG4uaC05NntcXG4gIGhlaWdodDogMjRyZW07XFxufVxcbi5oLVxcXFxbMFxcXFwuMzVyZW1cXFxcXXtcXG4gIGhlaWdodDogMC4zNXJlbTtcXG59XFxuLmgtXFxcXFsxMTAwcHhcXFxcXXtcXG4gIGhlaWdodDogMTEwMHB4O1xcbn1cXG4uaC1cXFxcWzE0cmVtXFxcXF17XFxuICBoZWlnaHQ6IDE0cmVtO1xcbn1cXG4uaC1cXFxcWzJcXFxcLjc1cmVtXFxcXF17XFxuICBoZWlnaHQ6IDIuNzVyZW07XFxufVxcbi5oLVxcXFxbMjgwcHhcXFxcXXtcXG4gIGhlaWdodDogMjgwcHg7XFxufVxcbi5oLVxcXFxbMzByZW1cXFxcXXtcXG4gIGhlaWdodDogMzByZW07XFxufVxcbi5oLVxcXFxbMzVweFxcXFxde1xcbiAgaGVpZ2h0OiAzNXB4O1xcbn1cXG4uaC1cXFxcWzQwMHB4XFxcXF17XFxuICBoZWlnaHQ6IDQwMHB4O1xcbn1cXG4uaC1cXFxcWzYwcHhcXFxcXXtcXG4gIGhlaWdodDogNjBweDtcXG59XFxuLmgtXFxcXFs4MHB4XFxcXF17XFxuICBoZWlnaHQ6IDgwcHg7XFxufVxcbi5oLVxcXFxbY2FsY1xcXFwoMTAwdmgtOTNweFxcXFwpXFxcXF17XFxuICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA5M3B4KTtcXG59XFxuLmgtYXV0b3tcXG4gIGhlaWdodDogYXV0bztcXG59XFxuLmgtZml0e1xcbiAgaGVpZ2h0OiAtbW96LWZpdC1jb250ZW50O1xcbiAgaGVpZ2h0OiBmaXQtY29udGVudDtcXG59XFxuLmgtZnVsbHtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuLmgtbWF4e1xcbiAgaGVpZ2h0OiAtbW96LW1heC1jb250ZW50O1xcbiAgaGVpZ2h0OiBtYXgtY29udGVudDtcXG59XFxuLmgtbWlue1xcbiAgaGVpZ2h0OiAtbW96LW1pbi1jb250ZW50O1xcbiAgaGVpZ2h0OiBtaW4tY29udGVudDtcXG59XFxuLmgtc2NyZWVue1xcbiAgaGVpZ2h0OiAxMDB2aDtcXG59XFxuLm1heC1oLXNjcmVlbntcXG4gIG1heC1oZWlnaHQ6IDEwMHZoO1xcbn1cXG4ubWluLWgtXFxcXFsxMHJlbVxcXFxde1xcbiAgbWluLWhlaWdodDogMTByZW07XFxufVxcbi5taW4taC1zY3JlZW57XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG59XFxuLnctMVxcXFwvMntcXG4gIHdpZHRoOiA1MCU7XFxufVxcbi53LTEwe1xcbiAgd2lkdGg6IDIuNXJlbTtcXG59XFxuLnctMntcXG4gIHdpZHRoOiAwLjVyZW07XFxufVxcbi53LTI4e1xcbiAgd2lkdGg6IDdyZW07XFxufVxcbi53LTN7XFxuICB3aWR0aDogMC43NXJlbTtcXG59XFxuLnctNXtcXG4gIHdpZHRoOiAxLjI1cmVtO1xcbn1cXG4udy01NntcXG4gIHdpZHRoOiAxNHJlbTtcXG59XFxuLnctOHtcXG4gIHdpZHRoOiAycmVtO1xcbn1cXG4udy05NntcXG4gIHdpZHRoOiAyNHJlbTtcXG59XFxuLnctXFxcXFsxNHJlbVxcXFxde1xcbiAgd2lkdGg6IDE0cmVtO1xcbn1cXG4udy1cXFxcWzE1OFxcXFwuNHB4XFxcXF17XFxuICB3aWR0aDogMTU4LjRweDtcXG59XFxuLnctXFxcXFsyMHJlbVxcXFxde1xcbiAgd2lkdGg6IDIwcmVtO1xcbn1cXG4udy1cXFxcWzI4OHB4XFxcXF17XFxuICB3aWR0aDogMjg4cHg7XFxufVxcbi53LVxcXFxbMjhyZW1cXFxcXXtcXG4gIHdpZHRoOiAyOHJlbTtcXG59XFxuLnctXFxcXFszXFxcXC41cmVtXFxcXF17XFxuICB3aWR0aDogMy41cmVtO1xcbn1cXG4udy1cXFxcWzMwMHB4XFxcXF17XFxuICB3aWR0aDogMzAwcHg7XFxufVxcbi53LVxcXFxbNDBcXFxcJVxcXFxde1xcbiAgd2lkdGg6IDQwJTtcXG59XFxuLnctXFxcXFs0NTJweFxcXFxde1xcbiAgd2lkdGg6IDQ1MnB4O1xcbn1cXG4udy1cXFxcWzQ4NHB4XFxcXF17XFxuICB3aWR0aDogNDg0cHg7XFxufVxcbi53LVxcXFxbNjAwcHhcXFxcXXtcXG4gIHdpZHRoOiA2MDBweDtcXG59XFxuLnctXFxcXFs3MFxcXFwlXFxcXF17XFxuICB3aWR0aDogNzAlO1xcbn1cXG4udy1cXFxcWzgwXFxcXCVcXFxcXXtcXG4gIHdpZHRoOiA4MCU7XFxufVxcbi53LVxcXFxbOTB2d1xcXFxde1xcbiAgd2lkdGg6IDkwdnc7XFxufVxcbi53LWF1dG97XFxuICB3aWR0aDogYXV0bztcXG59XFxuLnctZnVsbHtcXG4gIHdpZHRoOiAxMDAlO1xcbn1cXG4udy1zY3JlZW57XFxuICB3aWR0aDogMTAwdnc7XFxufVxcbi5taW4tdy0we1xcbiAgbWluLXdpZHRoOiAwcHg7XFxufVxcbi5taW4tdy1cXFxcWzQwXFxcXCVcXFxcXXtcXG4gIG1pbi13aWR0aDogNDAlO1xcbn1cXG4ubWF4LXctXFxcXFsxMDB2d1xcXFxde1xcbiAgbWF4LXdpZHRoOiAxMDB2dztcXG59XFxuLm1heC13LVxcXFxbNDhyZW1cXFxcXXtcXG4gIG1heC13aWR0aDogNDhyZW07XFxufVxcbi5tYXgtdy1cXFxcWzY2dndcXFxcXXtcXG4gIG1heC13aWR0aDogNjZ2dztcXG59XFxuLm1heC13LWZ1bGx7XFxuICBtYXgtd2lkdGg6IDEwMCU7XFxufVxcbi5tYXgtdy1zY3JlZW4tbWR7XFxuICBtYXgtd2lkdGg6IDc2OHB4O1xcbn1cXG4uZmxleC1hdXRve1xcbiAgZmxleDogMSAxIGF1dG87XFxufVxcbi5mbGV4LXNocmluay0we1xcbiAgZmxleC1zaHJpbms6IDA7XFxufVxcbi5ib3JkZXItY29sbGFwc2V7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG4udHJhbnNsYXRlLXgtXFxcXFsxcHhcXFxcXXtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IDFweDtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG4udHJhbnNsYXRlLXktM3tcXG4gIC0tdHctdHJhbnNsYXRlLXk6IDAuNzVyZW07XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcXG59XFxuLnNjYWxlLTEwNXtcXG4gIC0tdHctc2NhbGUteDogMS4wNTtcXG4gIC0tdHctc2NhbGUteTogMS4wNTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG4uc2NhbGUtMTUwe1xcbiAgLS10dy1zY2FsZS14OiAxLjU7XFxuICAtLXR3LXNjYWxlLXk6IDEuNTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG4uc2NhbGUtOTB7XFxuICAtLXR3LXNjYWxlLXg6IC45O1xcbiAgLS10dy1zY2FsZS15OiAuOTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG4uc2NhbGUtOTV7XFxuICAtLXR3LXNjYWxlLXg6IC45NTtcXG4gIC0tdHctc2NhbGUteTogLjk1O1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XFxufVxcbi5zY2FsZS1cXFxcWzBcXFxcLjdcXFxcXXtcXG4gIC0tdHctc2NhbGUteDogMC43O1xcbiAgLS10dy1zY2FsZS15OiAwLjc7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcXG59XFxuLnNjYWxlLVxcXFxbMFxcXFwuODVcXFxcXXtcXG4gIC0tdHctc2NhbGUteDogMC44NTtcXG4gIC0tdHctc2NhbGUteTogMC44NTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG4uc2NhbGUtXFxcXFswXFxcXC44XFxcXF17XFxuICAtLXR3LXNjYWxlLXg6IDAuODtcXG4gIC0tdHctc2NhbGUteTogMC44O1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XFxufVxcbi50cmFuc2Zvcm17XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSh2YXIoLS10dy10cmFuc2xhdGUteCksIHZhcigtLXR3LXRyYW5zbGF0ZS15KSkgcm90YXRlKHZhcigtLXR3LXJvdGF0ZSkpIHNrZXdYKHZhcigtLXR3LXNrZXcteCkpIHNrZXdZKHZhcigtLXR3LXNrZXcteSkpIHNjYWxlWCh2YXIoLS10dy1zY2FsZS14KSkgc2NhbGVZKHZhcigtLXR3LXNjYWxlLXkpKTtcXG59XFxuLmN1cnNvci1wb2ludGVye1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4ucmVzaXple1xcbiAgcmVzaXplOiBib3RoO1xcbn1cXG4uZmxleC1yb3d7XFxuICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbn1cXG4uZmxleC1jb2x7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4uZmxleC13cmFwe1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbn1cXG4ucGxhY2UtaXRlbXMtY2VudGVye1xcbiAgcGxhY2UtaXRlbXM6IGNlbnRlcjtcXG59XFxuLmNvbnRlbnQtY2VudGVye1xcbiAgYWxpZ24tY29udGVudDogY2VudGVyO1xcbn1cXG4uaXRlbXMtc3RhcnR7XFxuICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcXG59XFxuLml0ZW1zLWNlbnRlcntcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5qdXN0aWZ5LXN0YXJ0e1xcbiAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xcbn1cXG4uanVzdGlmeS1lbmR7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xcbn1cXG4uanVzdGlmeS1jZW50ZXJ7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuLmp1c3RpZnktYmV0d2VlbntcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcXG59XFxuLmp1c3RpZnktYXJvdW5ke1xcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XFxufVxcbi5qdXN0aWZ5LWV2ZW5seXtcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtZXZlbmx5O1xcbn1cXG4uZ2FwLTN7XFxuICBnYXA6IDAuNzVyZW07XFxufVxcbi5nYXAtXFxcXFsyMHB4XFxcXF17XFxuICBnYXA6IDIwcHg7XFxufVxcbi5zcGFjZS15LTggPiA6bm90KFtoaWRkZW5dKSB+IDpub3QoW2hpZGRlbl0pe1xcbiAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XFxuICBtYXJnaW4tdG9wOiBjYWxjKDJyZW0gKiBjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKSk7XFxuICBtYXJnaW4tYm90dG9tOiBjYWxjKDJyZW0gKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcXG59XFxuLm92ZXJmbG93LWhpZGRlbntcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcbi5vdmVyZmxvdy12aXNpYmxle1xcbiAgb3ZlcmZsb3c6IHZpc2libGU7XFxufVxcbi5vdmVyZmxvdy14LWhpZGRlbntcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG59XFxuLm92ZXJmbG93LXgtc2Nyb2xse1xcbiAgb3ZlcmZsb3cteDogc2Nyb2xsO1xcbn1cXG4ub3ZlcmZsb3cteS1zY3JvbGx7XFxuICBvdmVyZmxvdy15OiBzY3JvbGw7XFxufVxcbi5icmVhay13b3Jkc3tcXG4gIG92ZXJmbG93LXdyYXA6IGJyZWFrLXdvcmQ7XFxufVxcbi5yb3VuZGVke1xcbiAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcXG59XFxuLnJvdW5kZWQtMnhse1xcbiAgYm9yZGVyLXJhZGl1czogMXJlbTtcXG59XFxuLnJvdW5kZWQtXFxcXFszcmVtXFxcXF17XFxuICBib3JkZXItcmFkaXVzOiAzcmVtO1xcbn1cXG4ucm91bmRlZC1cXFxcWzRweFxcXFxde1xcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xcbn1cXG4ucm91bmRlZC1cXFxcWzVweFxcXFxde1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbn1cXG4ucm91bmRlZC1cXFxcWzhweFxcXFxde1xcbiAgYm9yZGVyLXJhZGl1czogOHB4O1xcbn1cXG4ucm91bmRlZC1mdWxse1xcbiAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xcbn1cXG4ucm91bmRlZC1sZ3tcXG4gIGJvcmRlci1yYWRpdXM6IDAuNXJlbTtcXG59XFxuLnJvdW5kZWQteGx7XFxuICBib3JkZXItcmFkaXVzOiAwLjc1cmVtO1xcbn1cXG4ucm91bmRlZC1iLVxcXFxbNXB4XFxcXF17XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNXB4O1xcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNXB4O1xcbn1cXG4ucm91bmRlZC10e1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogMC4yNXJlbTtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwLjI1cmVtO1xcbn1cXG4ucm91bmRlZC10ci1sZ3tcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiAwLjVyZW07XFxufVxcbi5ib3JkZXJ7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG59XFxuLmJvcmRlci0we1xcbiAgYm9yZGVyLXdpZHRoOiAwcHg7XFxufVxcbi5ib3JkZXItMntcXG4gIGJvcmRlci13aWR0aDogMnB4O1xcbn1cXG4uYm9yZGVyLWItMHtcXG4gIGJvcmRlci1ib3R0b20td2lkdGg6IDBweDtcXG59XFxuLmJvcmRlci1iLVxcXFxbM3B4XFxcXF17XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAzcHg7XFxufVxcbi5ib3JkZXItbC0we1xcbiAgYm9yZGVyLWxlZnQtd2lkdGg6IDBweDtcXG59XFxuLmJvcmRlci1yLTB7XFxuICBib3JkZXItcmlnaHQtd2lkdGg6IDBweDtcXG59XFxuLmJvcmRlci10LTB7XFxuICBib3JkZXItdG9wLXdpZHRoOiAwcHg7XFxufVxcbi5ib3JkZXItZ3JheS0zMDB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjA5IDIxMyAyMTkgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXG4uYm9yZGVyLXNsYXRlLTUwMHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigxMDAgMTE2IDEzOSAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5iZy1cXFxcW1xcXFwjMDBhM2FjXFxcXF17XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAxNjMgMTcyIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctXFxcXFtcXFxcIzA0YzZkMDk2XFxcXF17XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDRjNmQwOTY7XFxufVxcbi5iZy1cXFxcW1xcXFwjMDYwMDBmODZcXFxcXXtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwNjAwMGY4NjtcXG59XFxuLmJnLVxcXFxbXFxcXCMxNjFjMjRcXFxcXXtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMiAyOCAzNiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmJnLVxcXFxbXFxcXCMxODE4MTlcXFxcXXtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyNCAyNCAyNSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmJnLVxcXFxbXFxcXCMxZDAyNWNcXFxcXXtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyOSAyIDkyIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctXFxcXFtcXFxcIzJmMzAzODk0XFxcXF17XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMmYzMDM4OTQ7XFxufVxcbi5iZy1cXFxcW1xcXFwjMzAzMDMwXFxcXF17XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNDggNDggNDggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1cXFxcW1xcXFwjMzgwZmUyYTFcXFxcXXtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMzODBmZTJhMTtcXG59XFxuLmJnLVxcXFxbXFxcXCM1ZDAwNzc4MlxcXFxde1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzVkMDA3NzgyO1xcbn1cXG4uYmctXFxcXFtcXFxcIzYxNzE4YjZmXFxcXF17XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjNjE3MThiNmY7XFxufVxcbi5iZy1cXFxcW1xcXFwjYTVhNWE1NTJcXFxcXXtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNhNWE1YTU1MjtcXG59XFxuLmJnLVxcXFxbXFxcXCNjM2MzYzNcXFxcXXtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxOTUgMTk1IDE5NSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmJnLVxcXFxbXFxcXCNjZWNkY2RmYVxcXFxde1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2NlY2RjZGZhO1xcbn1cXG4uYmctXFxcXFtcXFxcI2YzZTNlM1xcXFxde1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0MyAyMjcgMjI3IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctXFxcXFtcXFxcI2ZmZmZmZjUwXFxcXF17XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmNTA7XFxufVxcbi5iZy1cXFxcW2JsYWNrXFxcXF17XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1cXFxcW2hzbFxcXFwoMFxcXFwyYyAwXFxcXCVcXFxcMmMgMTBcXFxcJVxcXFwpXFxcXF17XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2woMCAwJSAxMCUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1cXFxcW2hzbFxcXFwoMFxcXFwyYyAwXFxcXCVcXFxcMmMgMTVcXFxcJVxcXFwpXFxcXF17XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2woMCAwJSAxNSUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1cXFxcW2hzbFxcXFwoMFxcXFwyYyAwXFxcXCVcXFxcMmMgOFxcXFwlXFxcXClcXFxcXXtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IGhzbCgwIDAlIDglIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctXFxcXFtyZ2JcXFxcKDQ2XFxcXDJjIDUwXFxcXDJjIDU0XFxcXClcXFxcXXtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig0NiA1MCA1NCAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmJnLVxcXFxbcmdiYVxcXFwoMzFcXFxcMmMgMzFcXFxcMmMgMzFcXFxcMmMgMFxcXFwuNDZcXFxcKVxcXFxde1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgzMSwzMSwzMSwwLjQ2KTtcXG59XFxuLmJnLVxcXFxbcmdiYVxcXFwoNzFcXFxcMmMgODVcXFxcMmMgMTE1XFxcXDJjIDBcXFxcLjZcXFxcKVxcXFxde1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg3MSw4NSwxMTUsMC42KTtcXG59XFxuLmJnLVxcXFxbd2hpdGVzbW9rZVxcXFxde1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0NSAyNDUgMjQ1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctYmxhY2t7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCAwIDAgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1ncmF5LTMwMHtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMDkgMjEzIDIxOSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuLmJnLWdyYXktOTAwe1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDE3IDI0IDM5IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctc2xhdGUtNzAwe1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDUxIDY1IDg1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4uYmctdHJhbnNwYXJlbnR7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuLmJnLXdoaXRle1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG4ub2JqZWN0LWNvbnRhaW57XFxuICAtby1vYmplY3QtZml0OiBjb250YWluO1xcbiAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcXG59XFxuLnAtMTZ7XFxuICBwYWRkaW5nOiA0cmVtO1xcbn1cXG4ucC0ye1xcbiAgcGFkZGluZzogMC41cmVtO1xcbn1cXG4ucC0yXFxcXC41e1xcbiAgcGFkZGluZzogMC42MjVyZW07XFxufVxcbi5wLTR7XFxuICBwYWRkaW5nOiAxcmVtO1xcbn1cXG4ucC01e1xcbiAgcGFkZGluZzogMS4yNXJlbTtcXG59XFxuLnAtNntcXG4gIHBhZGRpbmc6IDEuNXJlbTtcXG59XFxuLnB4LTEwe1xcbiAgcGFkZGluZy1sZWZ0OiAyLjVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAyLjVyZW07XFxufVxcbi5weC0yNHtcXG4gIHBhZGRpbmctbGVmdDogNnJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDZyZW07XFxufVxcbi5weC0ze1xcbiAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbiAgcGFkZGluZy1yaWdodDogMC43NXJlbTtcXG59XFxuLnB4LTR7XFxuICBwYWRkaW5nLWxlZnQ6IDFyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAxcmVtO1xcbn1cXG4ucHgtNXtcXG4gIHBhZGRpbmctbGVmdDogMS4yNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDEuMjVyZW07XFxufVxcbi5weC02e1xcbiAgcGFkZGluZy1sZWZ0OiAxLjVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAxLjVyZW07XFxufVxcbi5weS0xMHtcXG4gIHBhZGRpbmctdG9wOiAyLjVyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMi41cmVtO1xcbn1cXG4ucHktM3tcXG4gIHBhZGRpbmctdG9wOiAwLjc1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuNzVyZW07XFxufVxcbi5weS04e1xcbiAgcGFkZGluZy10b3A6IDJyZW07XFxuICBwYWRkaW5nLWJvdHRvbTogMnJlbTtcXG59XFxuLnB5LVxcXFxbOTNweFxcXFxde1xcbiAgcGFkZGluZy10b3A6IDkzcHg7XFxuICBwYWRkaW5nLWJvdHRvbTogOTNweDtcXG59XFxuLnBiLTJ7XFxuICBwYWRkaW5nLWJvdHRvbTogMC41cmVtO1xcbn1cXG4ucGItM3tcXG4gIHBhZGRpbmctYm90dG9tOiAwLjc1cmVtO1xcbn1cXG4ucGItNXtcXG4gIHBhZGRpbmctYm90dG9tOiAxLjI1cmVtO1xcbn1cXG4ucGItOHtcXG4gIHBhZGRpbmctYm90dG9tOiAycmVtO1xcbn1cXG4ucGwtMTJ7XFxuICBwYWRkaW5nLWxlZnQ6IDNyZW07XFxufVxcbi5wbC0ye1xcbiAgcGFkZGluZy1sZWZ0OiAwLjVyZW07XFxufVxcbi5wbC0ze1xcbiAgcGFkZGluZy1sZWZ0OiAwLjc1cmVtO1xcbn1cXG4ucGwtMzJ7XFxuICBwYWRkaW5nLWxlZnQ6IDhyZW07XFxufVxcbi5wbC00e1xcbiAgcGFkZGluZy1sZWZ0OiAxcmVtO1xcbn1cXG4ucGwtNXtcXG4gIHBhZGRpbmctbGVmdDogMS4yNXJlbTtcXG59XFxuLnByLTEye1xcbiAgcGFkZGluZy1yaWdodDogM3JlbTtcXG59XFxuLnByLTJ7XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjVyZW07XFxufVxcbi5wci0ze1xcbiAgcGFkZGluZy1yaWdodDogMC43NXJlbTtcXG59XFxuLnByLTR7XFxuICBwYWRkaW5nLXJpZ2h0OiAxcmVtO1xcbn1cXG4ucHItNXtcXG4gIHBhZGRpbmctcmlnaHQ6IDEuMjVyZW07XFxufVxcbi5wdC0we1xcbiAgcGFkZGluZy10b3A6IDBweDtcXG59XFxuLnB0LTJ7XFxuICBwYWRkaW5nLXRvcDogMC41cmVtO1xcbn1cXG4ucHQtMjh7XFxuICBwYWRkaW5nLXRvcDogN3JlbTtcXG59XFxuLnB0LTN7XFxuICBwYWRkaW5nLXRvcDogMC43NXJlbTtcXG59XFxuLnB0LTV7XFxuICBwYWRkaW5nLXRvcDogMS4yNXJlbTtcXG59XFxuLnB0LTZ7XFxuICBwYWRkaW5nLXRvcDogMS41cmVtO1xcbn1cXG4ucHQtXFxcXFswcHhcXFxcXXtcXG4gIHBhZGRpbmctdG9wOiAwcHg7XFxufVxcbi5wdC1cXFxcWzUwMHB4XFxcXF17XFxuICBwYWRkaW5nLXRvcDogNTAwcHg7XFxufVxcbi5wdC1cXFxcWzkzcHhcXFxcXXtcXG4gIHBhZGRpbmctdG9wOiA5M3B4O1xcbn1cXG4udGV4dC1sZWZ0e1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuLnRleHQtY2VudGVye1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG4udGV4dC1yaWdodHtcXG4gIHRleHQtYWxpZ246IHJpZ2h0O1xcbn1cXG4udGV4dC1qdXN0aWZ5e1xcbiAgdGV4dC1hbGlnbjoganVzdGlmeTtcXG59XFxuLmZvbnQtXFxcXFtCYXJsb3dcXFxcMmMgc2Fucy1zZXJpZlxcXFxde1xcbiAgZm9udC1mYW1pbHk6IEJhcmxvdyxzYW5zLXNlcmlmO1xcbn1cXG4uZm9udC1kYW5jaW5ne1xcbiAgZm9udC1mYW1pbHk6IERhbmNpbmcgU2NyaXB0O1xcbn1cXG4uZm9udC1rZGFte1xcbiAgZm9udC1mYW1pbHk6IEtkYW0gVGhtb3IgUHJvO1xcbn1cXG4uZm9udC1vcGVuU2Fuc3tcXG4gIGZvbnQtZmFtaWx5OiAnT3BlbiBTYW5zJywgc2Fucy1zZXJpZjtcXG59XFxuLmZvbnQtcG9wcGluc3tcXG4gIGZvbnQtZmFtaWx5OiAnUG9wcGlucyc7XFxufVxcbi50ZXh0LTJ4bHtcXG4gIGZvbnQtc2l6ZTogMS41cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDJyZW07XFxufVxcbi50ZXh0LTN4bHtcXG4gIGZvbnQtc2l6ZTogMS44NzVyZW07XFxuICBsaW5lLWhlaWdodDogMi4yNXJlbTtcXG59XFxuLnRleHQtNHhse1xcbiAgZm9udC1zaXplOiAyLjI1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDIuNXJlbTtcXG59XFxuLnRleHQtNXhse1xcbiAgZm9udC1zaXplOiAzcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDE7XFxufVxcbi50ZXh0LVxcXFxbMXJlbVxcXFxde1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbn1cXG4udGV4dC1cXFxcWzNcXFxcLjVyZW1cXFxcXXtcXG4gIGZvbnQtc2l6ZTogMy41cmVtO1xcbn1cXG4udGV4dC1iYXNle1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNXJlbTtcXG59XFxuLnRleHQtbGd7XFxuICBmb250LXNpemU6IDEuMTI1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxufVxcbi50ZXh0LXNte1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjI1cmVtO1xcbn1cXG4udGV4dC14bHtcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjc1cmVtO1xcbn1cXG4udGV4dC14c3tcXG4gIGZvbnQtc2l6ZTogMC43NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxcmVtO1xcbn1cXG4uZm9udC1cXFxcWzQwMFxcXFxde1xcbiAgZm9udC13ZWlnaHQ6IDQwMDtcXG59XFxuLmZvbnQtYm9sZHtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcbi5mb250LWV4dHJhYm9sZHtcXG4gIGZvbnQtd2VpZ2h0OiA4MDA7XFxufVxcbi5mb250LWxpZ2h0e1xcbiAgZm9udC13ZWlnaHQ6IDMwMDtcXG59XFxuLmZvbnQtbWVkaXVte1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG59XFxuLnVwcGVyY2FzZXtcXG4gIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XFxufVxcbi5jYXBpdGFsaXple1xcbiAgdGV4dC10cmFuc2Zvcm06IGNhcGl0YWxpemU7XFxufVxcbi5sZWFkaW5nLVxcXFxbMVxcXFwuNzVcXFxcXXtcXG4gIGxpbmUtaGVpZ2h0OiAxLjc1O1xcbn1cXG4udHJhY2tpbmctdGlnaHR7XFxuICBsZXR0ZXItc3BhY2luZzogLTAuMDI1ZW07XFxufVxcbi50ZXh0LVxcXFxbXFxcXCMwNjg2ZmRcXFxcXXtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig2IDEzNCAyNTMgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtXFxcXFtcXFxcIzJlMWEwM1xcXFxde1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDQ2IDI2IDMgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtXFxcXFthbnRpcXVld2hpdGVcXFxcXXtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNTAgMjM1IDIxNSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG4udGV4dC1cXFxcW3JnYlxcXFwoMTQ1XFxcXDJjIDE1OFxcXFwyYyAxNzFcXFxcKVxcXFxde1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDE0NSAxNTggMTcxIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LVxcXFxbd2hpdGVzbW9rZVxcXFxde1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI0NSAyNDUgMjQ1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LWJsYWNre1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDAgMCAwIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LWJsdWUtNDAwe1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDk2IDE2NSAyNTAgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtZ3JheS0zMDB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjA5IDIxMyAyMTkgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtZ3JheS00MDB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtZ3JheS02MDB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNzUgODUgOTkgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtZ3JheS03MDB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNTUgNjUgODEgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLnRleHQtb3JhbmdlLTQwMHtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNTEgMTQ2IDYwIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LW9yYW5nZS02MDB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjM0IDg4IDEyIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi50ZXh0LXdoaXRle1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi5kZWNvcmF0aW9uLVxcXFxbNHB4XFxcXF17XFxuICB0ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzOiA0cHg7XFxufVxcbi51bmRlcmxpbmUtb2Zmc2V0LTF7XFxuICB0ZXh0LXVuZGVybGluZS1vZmZzZXQ6IDFweDtcXG59XFxuLnBsYWNlaG9sZGVyLWdyYXktNDAwOjotbW96LXBsYWNlaG9sZGVye1xcbiAgLS10dy1wbGFjZWhvbGRlci1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigxNTYgMTYzIDE3NSAvIHZhcigtLXR3LXBsYWNlaG9sZGVyLW9wYWNpdHkpKTtcXG59XFxuLnBsYWNlaG9sZGVyLWdyYXktNDAwOjpwbGFjZWhvbGRlcntcXG4gIC0tdHctcGxhY2Vob2xkZXItb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTU2IDE2MyAxNzUgLyB2YXIoLS10dy1wbGFjZWhvbGRlci1vcGFjaXR5KSk7XFxufVxcbi5vcGFjaXR5LTB7XFxuICBvcGFjaXR5OiAwO1xcbn1cXG4ub3BhY2l0eS03NXtcXG4gIG9wYWNpdHk6IDAuNzU7XFxufVxcbi5vcGFjaXR5LVxcXFxbMFxcXFwuNzVcXFxcXXtcXG4gIG9wYWNpdHk6IDAuNzU7XFxufVxcbi5zaGFkb3d7XFxuICAtLXR3LXNoYWRvdzogMCAxcHggM3B4IDAgcmdiKDAgMCAwIC8gMC4xKSwgMCAxcHggMnB4IC0xcHggcmdiKDAgMCAwIC8gMC4xKTtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMXB4IDNweCAwIHZhcigtLXR3LXNoYWRvdy1jb2xvciksIDAgMXB4IDJweCAtMXB4IHZhcigtLXR3LXNoYWRvdy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXJpbmctc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1zaGFkb3cpO1xcbn1cXG4uc2hhZG93LWxne1xcbiAgLS10dy1zaGFkb3c6IDAgMTBweCAxNXB4IC0zcHggcmdiKDAgMCAwIC8gMC4xKSwgMCA0cHggNnB4IC00cHggcmdiKDAgMCAwIC8gMC4xKTtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMTBweCAxNXB4IC0zcHggdmFyKC0tdHctc2hhZG93LWNvbG9yKSwgMCA0cHggNnB4IC00cHggdmFyKC0tdHctc2hhZG93LWNvbG9yKTtcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctcmluZy1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXNoYWRvdyk7XFxufVxcbi5zaGFkb3ctc217XFxuICAtLXR3LXNoYWRvdzogMCAxcHggMnB4IDAgcmdiKDAgMCAwIC8gMC4wNSk7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDFweCAycHggMCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxuLm91dGxpbmUtbm9uZXtcXG4gIG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIG91dGxpbmUtb2Zmc2V0OiAycHg7XFxufVxcbi5vdXRsaW5le1xcbiAgb3V0bGluZS1zdHlsZTogc29saWQ7XFxufVxcbi5vdXRsaW5lLTB7XFxuICBvdXRsaW5lLXdpZHRoOiAwcHg7XFxufVxcbi5ibHVye1xcbiAgLS10dy1ibHVyOiBibHVyKDhweCk7XFxuICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIpIHZhcigtLXR3LWJyaWdodG5lc3MpIHZhcigtLXR3LWNvbnRyYXN0KSB2YXIoLS10dy1ncmF5c2NhbGUpIHZhcigtLXR3LWh1ZS1yb3RhdGUpIHZhcigtLXR3LWludmVydCkgdmFyKC0tdHctc2F0dXJhdGUpIHZhcigtLXR3LXNlcGlhKSB2YXIoLS10dy1kcm9wLXNoYWRvdyk7XFxufVxcbi5maWx0ZXJ7XFxuICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIpIHZhcigtLXR3LWJyaWdodG5lc3MpIHZhcigtLXR3LWNvbnRyYXN0KSB2YXIoLS10dy1ncmF5c2NhbGUpIHZhcigtLXR3LWh1ZS1yb3RhdGUpIHZhcigtLXR3LWludmVydCkgdmFyKC0tdHctc2F0dXJhdGUpIHZhcigtLXR3LXNlcGlhKSB2YXIoLS10dy1kcm9wLXNoYWRvdyk7XFxufVxcbi5iYWNrZHJvcC1ibHVyLWxne1xcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiBibHVyKDE2cHgpO1xcbiAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IHZhcigtLXR3LWJhY2tkcm9wLWJsdXIpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0KSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhKTtcXG4gICAgICAgICAgYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHkpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSk7XFxufVxcbi50cmFuc2l0aW9ue1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIG9wYWNpdHksIGJveC1zaGFkb3csIHRyYW5zZm9ybSwgZmlsdGVyLCAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIGZpbHRlciwgYmFja2Ryb3AtZmlsdGVyO1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIG9wYWNpdHksIGJveC1zaGFkb3csIHRyYW5zZm9ybSwgZmlsdGVyLCBiYWNrZHJvcC1maWx0ZXIsIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxuLnRyYW5zaXRpb24tYWxse1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogYWxsO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxuLmR1cmF0aW9uLTIwMHtcXG4gIHRyYW5zaXRpb24tZHVyYXRpb246IDIwMG1zO1xcbn1cXG4uZWFzZS1pbi1vdXR7XFxuICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcXG59XFxuLmVhc2Utc3F1YXJlZHtcXG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMSwgMCwgMCwgMSk7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk7XFxufVxcblxcblxcbiNfX25leHQge1xcbiAgLyogbWFyZ2luLXRvcDogNnJlbTsgKi9cXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbiAgd2lkdGg6IDEwMHZ3O1xcbn1cXG4qIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbm1haW4ge1xcbiAgcGFkZGluZy10b3A6IDZyZW07XFxufVxcblxcbipbZGF0YS1hbmltYXRpb249XFxcInJpcHBsZVxcXCJdOjotbW96LXNlbGVjdGlvbiB7XFxuXFx0YmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuXFx0LyogcG9pbnRlci1ldmVudHM6IG5vbmU7ICovXFxufVxcblxcbipbZGF0YS1hbmltYXRpb249XFxcInJpcHBsZVxcXCJdOjpzZWxlY3Rpb24ge1xcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcblxcdC8qIHBvaW50ZXItZXZlbnRzOiBub25lOyAqL1xcbn1cXG5cXG5oZWFkZXIge1xcblxcdGJhY2tncm91bmQ6ICMwMGEzYWNcXG59XFxuXFxuaGVhZGVyLmJhY2tkcm9wRmlsdGVyIHtcXG5cXHQtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogYmx1cigxMHB4KTtcXG5cXHQgICAgICAgIGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMHB4KTtcXG59XFxuXFxuaGVhZGVyLm1vcmVCYWNrZHJvcEZpbHRlciB7XFxuXFx0LXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoMTAwcHgpO1xcblxcdCAgICAgICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDEwMHB4KTtcXG59XFxuXFxuLnRyYW5zcGFyZW50IHtcXG4gIGJhY2tnb3J1bmQ6ICMwMDM2NjYwMDtcXG59XFxuXFxuLmNhcm91c2VsIHtcXG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbi8qICBzY3JvbGwgc25hcCBpcyBhIGdyZWF0IGZlYXR1cmUgd2hpY2ggd2lsbCBjZW50ZXIgdGhlIGltYWdlIG9uIHNuYXAgb24gdG91Y2ggc2NyZWVuIGRldmljZXMgICovXFxuICBzY3JvbGwtc25hcC10eXBlOiB4IG1hbmRhdG9yeTtcXG4vKiBhbGwgYmVsb3cgd2lsbCBoaWRlIHRoZSBzY3JvbGxiYXIgb24gYWxsIGJyb3dzZXJzLiAgICAqL1xcbiAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xcbiAgc2Nyb2xsYmFyLXdpZHRoOiBub25lOyAvKiBGb3IgRmlyZWZveCAqL1xcbiAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lOyAvKiBGb3IgSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgKi9cXG59XFxuXFxuLmltYWdlLWNvbnRhaW5lciBzcGFuIHtcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC45KTtcXG59XFxuXFxuLm1hcENvbnRhaW5lciB7XFxuICBvdmVyZmxvdzogdmlzaWJsZSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uZGV0YWlscyBpbnB1dCwgdGV4dGFyZWEge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogNy41cHg7XFxuICBiYWNrZ3JvdW5kOiBoc2xhKDAsIDAlLCA4JSwgMC45MTYpO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuNHMgZWFzZS1pbi1vdXQsIGJhY2tncm91bmQtY29sb3IgOTk5OTk5OTk5OTk5OTk5OTk5OTk5OXMgbGluZWFyLCBjb2xvciA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5cyBsaW5lYXI7XFxuICBjb2xvcjogd2hpdGVzbW9rZTtcXG4gIHBhZGRpbmctbGVmdDogNy41cHg7XFxuICBwYWRkaW5nOjAuOGVtO1xcbiAgYm9yZGVyLXJhZGl1czogMC41ZW07XFxufVxcblxcbi5kZXRhaWxzIGlucHV0OmZvY3VzLCB0ZXh0YXJlYTpmb2N1cyB7XFxuICBvdXRsaW5lOiBub25lXFxufVxcblxcbi5kZXRhaWxzIGlucHV0OmZvY3VzLXdpdGhpbiwgdGV4dGFyZWE6Zm9jdXMtd2l0aGluIHtcXG4gIGJveC1zaGFkb3c6IDAgMCAwIDNweCAjZmZlZWU3OTk7XFxufVxcblxcbi5kZXRhaWxzIGRpdiB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTtcXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lciB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lcjpub3QoOmxhc3QtY2hpbGQpIHtcXG4gIG1hcmdpbi1ib3R0b206IDE5cHg7XFxufVxcblxcblxcbi5pbnB1dC1jb250YWluZXIgPiBpbnB1dDpmb2N1cy13aXRoaW4gKyBsYWJlbHtcXG4gIHBhZGRpbmc6IDAgMC4yZW07XFxuICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gIHRvcDogLTAuOTVlbTtcXG4gIGxlZnQ6IDAuMDVlbTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgY29sb3I6IHdoaXRlc21va2U7XFxuICBiYWNrZ3JvdW5kOiBoc2xhKDAsIDAlLCA4JSwgMC45MTYpO1xcbiAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIHBhZGRpbmc6IDBweCAwLjNlbSAwcHggMC4zZW1cXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lciA+IGlucHV0LmZ1bGwgKyBsYWJlbHtcXG4gIHBhZGRpbmc6MCAwLjJlbTtcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcbiAgdG9wOiAtMC45NWVtO1xcbiAgbGVmdDogMC4wNWVtO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDYzLCAxNjcsIDUyJSk7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgcGFkZGluZzogMHB4IDAuM2VtIDBweCAwLjNlbVxcbn1cXG5cXG4uaW5wdXQtY29udGFpbmVyID4gaW5wdXQgKyBsYWJlbHtcXG4gIHBhZGRpbmc6MCAwLjJlbTtcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDYzLCAxNjcsIDAlKTtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBwYWRkaW5nOiAwcHggMC4zZW0gMHB4IDAuM2VtO1xcbiAgdG9wOiAwLjc1ZW07XFxuICBsZWZ0OiAwLjI1ZW07XFxuICB0cmFuc2l0aW9uOiBhbGwgMC40cyBlYXNlLWluLW91dDtcXG4gIGN1cnNvcjogdGV4dDtcXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lciA+IHRleHRhcmVhOmZvY3VzLXdpdGhpbiArIGxhYmVse1xcbiAgcGFkZGluZzogMCAwLjJlbTtcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcbiAgdG9wOiAtMC45NWVtO1xcbiAgbGVmdDogMC4wNWVtO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDYzLCAxNjcsIDMyJSk7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgcGFkZGluZzogMHB4IDAuM2VtIDBweCAwLjNlbVxcbn1cXG5cXG4uaW5wdXQtY29udGFpbmVyID4gdGV4dGFyZWEuZnVsbCArIGxhYmVse1xcbiAgcGFkZGluZzowIDAuMmVtO1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICB0b3A6IC0wLjk1ZW07XFxuICBsZWZ0OiAwLjA1ZW07XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgNjMsIDE2NywgNTIlKTtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBwYWRkaW5nOiAwcHggMC4zZW0gMHB4IDAuM2VtXFxufVxcblxcbi5pbnB1dC1jb250YWluZXIgPiB0ZXh0YXJlYSArIGxhYmVse1xcbiAgcGFkZGluZzowIDAuMmVtO1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgNjMsIDE2NywgMCUpO1xcbiAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIHBhZGRpbmc6IDBweCAwLjNlbSAwcHggMC4zZW07XFxuICB0b3A6IDAuNzVlbTtcXG4gIGxlZnQ6IDAuMjVlbTtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjRzIGVhc2UtaW4tb3V0O1xcbiAgY3Vyc29yOiB0ZXh0O1xcbn1cXG5cXG5iciB7XFxuICBoZWlnaHQ6IDE5cHggIWltcG9ydGFudDtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgd2lkdGg6IGF1dG8gIWltcG9ydGFudDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG5cXG4uZnJhbWUtY29udGFpbmVyIGgyLCBoMyB7XFxuICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG5cXG4uZnJhbWUtY29udGFpbmVyIGZvcm0ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbn1cXG5cXG4ubG9naW4tYm94IHtcXG4gIGJhY2tncm91bmQ6IGhzbCgxODNkZWcgMTAwJSA1MCUgLyA2MCUpO1xcbiAgYm94LXNoYWRvdzogMCA4cHggMzJweCAwIHJnYigwIDE5MyAyNTUgLyAzNiUpO1xcbiAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKCA2LjVweCApO1xcbiAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IGJsdXIoIDYuNXB4ICk7XFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcbiAgYm9yZGVyOiAxcHggc29saWQgcmdiYSggMjU1LCAyNTUsIDI1NSwgMC4xOCApO1xcbn1cXG5cXG5oMi5sb2dpbi10ZXh0IHtcXG4gIHRleHQtc2hhZG93OiAxMHB4IC00cHggMjNweCAjMDAzZTk1O1xcbn1cXG5cXG5oMS5sb2dpbi10ZXh0IHtcXG4gIHRleHQtc2hhZG93OiAxMXB4IC00cHggMjNweCAjMDQwMGZmO1xcbn1cXG5cXG4ubG9naW4tbWFpbiAgaW5wdXQsIHRleHRhcmVhIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDcuNXB4O1xcbiAgYmFja2dyb3VuZDogaHNsYSgwLCAwJSwgOCUsIDAuOTE2KTtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjRzIGVhc2UtaW4tb3V0LCBiYWNrZ3JvdW5kLWNvbG9yIDk5OTk5OTk5OTk5OTk5OTk5OTk5OTlzIGxpbmVhciwgY29sb3IgOTk5OTk5OTk5OTk5OTk5OTk5OTk5OXMgbGluZWFyO1xcbiAgY29sb3I6IHdoaXRlc21va2U7XFxuICBwYWRkaW5nLWxlZnQ6IDcuNXB4O1xcbiAgcGFkZGluZzowLjhlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDAuNWVtO1xcbn1cXG5cXG4ubG9naW4tbWFpbiBpbnB1dDpmb2N1cywgdGV4dGFyZWE6Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZVxcbn1cXG5cXG4ubG9naW4tbWFpbiBpbnB1dDpmb2N1cy13aXRoaW4sIHRleHRhcmVhOmZvY3VzLXdpdGhpbiB7XFxuICBib3gtc2hhZG93OiAwIDAgMCAzcHggI2ZmZWVlNzk5O1xcbn1cXG5cXG4ubG9naW4tbWFpbiBkaXYge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk7XFxufVxcblxcbiNsb2FkaW5nLWNvbnRhaW5lciBkaXYge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgd2lkdGg6IGNhbGMoMTAwJSAqIDAuOTYpO1xcbiAgaGVpZ2h0OiBjYWxjKDEwMCUgKiAwLjk2KTtcXG4gIG1hcmdpbjogOHB4O1xcbiAgYm9yZGVyOiAxOHB4IHNvbGlkICMwNGM1ZDA7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBhbmltYXRpb246IGxkcy1yaW5nIDEuMnMgY3ViaWMtYmV6aWVyKDAuNSwgMCwgMC41LCAxKSBpbmZpbml0ZTtcXG4gIGJvcmRlci1jb2xvcjogIzA0YzVkMCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtcXG59XFxuXFxuI2xvYWRpbmctY29udGFpbmVyIGRpdjpudGgtY2hpbGQoMSkge1xcbiAgYW5pbWF0aW9uLWRlbGF5OiAtMC40NXM7XFxufVxcbiNsb2FkaW5nLWNvbnRhaW5lciBkaXY6bnRoLWNoaWxkKDIpIHtcXG4gIGFuaW1hdGlvbi1kZWxheTogLTAuM3M7XFxufVxcbiNsb2FkaW5nLWNvbnRhaW5lciBkaXY6bnRoLWNoaWxkKDMpIHtcXG4gIGFuaW1hdGlvbi1kZWxheTogLTAuMTVzO1xcbn1cXG5Aa2V5ZnJhbWVzIGxkcy1yaW5nIHtcXG4gIDAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICB9XFxuICAxMDAlIHtcXG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG4gIH1cXG59XFxuXFxubWFpbiB7XFxuICBzY3JvbGwtc25hcC10eXBlOiB5IHggbWFuZGF0b3J5O1xcbn1cXG5cXG4udmlldyB7XFxuICBzY3JvbGwtc25hcC1hbGlnbjogc3RhcnQ7XFxufVxcblxcbi5wbGFjZWhvbGRlclxcXFw6dGV4dC13aGl0ZTo6LW1vei1wbGFjZWhvbGRlcntcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNTUgMjU1IDI1NSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG5cXG4ucGxhY2Vob2xkZXJcXFxcOnRleHQtd2hpdGU6OnBsYWNlaG9sZGVye1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDI1NSAyNTUgMjU1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6c2NhbGUtMTAwOmhvdmVye1xcbiAgLS10dy1zY2FsZS14OiAxO1xcbiAgLS10dy1zY2FsZS15OiAxO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6c2NhbGUtOTU6aG92ZXJ7XFxuICAtLXR3LXNjYWxlLXg6IC45NTtcXG4gIC0tdHctc2NhbGUteTogLjk1O1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUodmFyKC0tdHctdHJhbnNsYXRlLXgpLCB2YXIoLS10dy10cmFuc2xhdGUteSkpIHJvdGF0ZSh2YXIoLS10dy1yb3RhdGUpKSBza2V3WCh2YXIoLS10dy1za2V3LXgpKSBza2V3WSh2YXIoLS10dy1za2V3LXkpKSBzY2FsZVgodmFyKC0tdHctc2NhbGUteCkpIHNjYWxlWSh2YXIoLS10dy1zY2FsZS15KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctXFxcXFtcXFxcIzAzNWY3YlxcXFxdOmhvdmVye1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDMgOTUgMTIzIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLVxcXFxbXFxcXCM0NTQ1NDVcXFxcXTpob3ZlcntcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig2OSA2OSA2OSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1cXFxcW1xcXFwjOTBiZGVlMzJcXFxcXTpob3ZlcntcXG4gIGJhY2tncm91bmQtY29sb3I6ICM5MGJkZWUzMjtcXG59XFxuXFxuLmhvdmVyXFxcXDpiZy1cXFxcW1xcXFwjOWU5ZTllXFxcXF06aG92ZXJ7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMTU4IDE1OCAxNTggLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctXFxcXFtoc2xcXFxcKDBcXFxcMmMgMFxcXFwlXFxcXDJjIDI1XFxcXCVcXFxcKVxcXFxdOmhvdmVye1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaHNsKDAgMCUgMjUlIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJnLXNsYXRlLTgwMDpob3ZlcntcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigzMCA0MSA1OSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuXFxuLmhvdmVyXFxcXDp0ZXh0LVxcXFxbXFxcXCMwNjQ4ZmRcXFxcXTpob3ZlcntcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig2IDcyIDI1MyAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOm9wYWNpdHktMTAwOmhvdmVye1xcbiAgb3BhY2l0eTogMTtcXG59XFxuXFxuLmhvdmVyXFxcXDpzaGFkb3ctbGc6aG92ZXJ7XFxuICAtLXR3LXNoYWRvdzogMCAxMHB4IDE1cHggLTNweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDRweCA2cHggLTRweCByZ2IoMCAwIDAgLyAwLjEpO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAxMHB4IDE1cHggLTNweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpLCAwIDRweCA2cHggLTRweCB2YXIoLS10dy1zaGFkb3ctY29sb3IpO1xcbiAgYm94LXNoYWRvdzogdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93LCAwIDAgIzAwMDApLCB2YXIoLS10dy1yaW5nLXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctc2hhZG93KTtcXG59XFxuXFxuLmhvdmVyXFxcXDpzYXR1cmF0ZS0xNTA6aG92ZXJ7XFxuICAtLXR3LXNhdHVyYXRlOiBzYXR1cmF0ZSgxLjUpO1xcbiAgZmlsdGVyOiB2YXIoLS10dy1ibHVyKSB2YXIoLS10dy1icmlnaHRuZXNzKSB2YXIoLS10dy1jb250cmFzdCkgdmFyKC0tdHctZ3JheXNjYWxlKSB2YXIoLS10dy1odWUtcm90YXRlKSB2YXIoLS10dy1pbnZlcnQpIHZhcigtLXR3LXNhdHVyYXRlKSB2YXIoLS10dy1zZXBpYSkgdmFyKC0tdHctZHJvcC1zaGFkb3cpO1xcbn1cXG5cXG4uaG92ZXJcXFxcOmJhY2tkcm9wLWJyaWdodG5lc3MtNTA6aG92ZXJ7XFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6IGJyaWdodG5lc3MoLjUpO1xcbiAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IHZhcigtLXR3LWJhY2tkcm9wLWJsdXIpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0KSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhKTtcXG4gICAgICAgICAgYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHkpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSk7XFxufVxcblxcbi5mb2N1c1xcXFw6Ym9yZGVyLTI6Zm9jdXN7XFxuICBib3JkZXItd2lkdGg6IDJweDtcXG59XFxuXFxuLmZvY3VzXFxcXDpib3JkZXItXFxcXFtcXFxcIzNjNDM2MlxcXFxdOmZvY3Vze1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDYwIDY3IDk4IC8gdmFyKC0tdHctYm9yZGVyLW9wYWNpdHkpKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1cXFxcW1xcXFwjMmYzMDM4YjVcXFxcXTpmb2N1c3tcXG4gIGJhY2tncm91bmQtY29sb3I6ICMyZjMwMzhiNTtcXG59XFxuXFxuLmZvY3VzXFxcXDpiZy1cXFxcW1xcXFwjNDU0NTQ1XFxcXF06Zm9jdXN7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoNjkgNjkgNjkgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcblxcbi5mb2N1c1xcXFw6b3V0bGluZS1ub25lOmZvY3Vze1xcbiAgb3V0bGluZTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgb3V0bGluZS1vZmZzZXQ6IDJweDtcXG59XFxuXFxuLmZvY3VzXFxcXDpyaW5nOmZvY3Vze1xcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSB2YXIoLS10dy1yaW5nLW9mZnNldC1jb2xvcik7XFxuICAtLXR3LXJpbmctc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCBjYWxjKDNweCArIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSkgdmFyKC0tdHctcmluZy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdywgMCAwICMwMDAwKTtcXG59XFxuXFxuLmZvY3VzXFxcXDpyaW5nLTQ6Zm9jdXN7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpIHZhcigtLXR3LXJpbmctb2Zmc2V0LWNvbG9yKTtcXG4gIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIGNhbGMoNHB4ICsgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpKSB2YXIoLS10dy1yaW5nLWNvbG9yKTtcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93LCAwIDAgIzAwMDApO1xcbn1cXG5cXG4uZm9jdXNcXFxcOnJpbmctXFxcXFtcXFxcIzQzNmVkY1xcXFxdOmZvY3Vze1xcbiAgLS10dy1yaW5nLW9wYWNpdHk6IDE7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig2NyAxMTAgMjIwIC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxufVxcblxcbi5mb2N1c1xcXFw6cmluZy1zbGF0ZS0zMDA6Zm9jdXN7XFxuICAtLXR3LXJpbmctb3BhY2l0eTogMTtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDIwMyAyMTMgMjI1IC8gdmFyKC0tdHctcmluZy1vcGFjaXR5KSk7XFxufVxcblxcbi5hY3RpdmVcXFxcOmJnLWdyYXktNzAwOmFjdGl2ZXtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYig1NSA2NSA4MSAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG59XFxuXFxuLmFjdGl2ZVxcXFw6dGV4dC1cXFxcW1xcXFwjMDMyNDgwXFxcXF06YWN0aXZle1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDMgMzYgMTI4IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcblxcbkBtZWRpYSAobWF4LXdpZHRoOiA2NDBweCl7XFxuICAueHNcXFxcOm1sLVxcXFxbLTUwdndcXFxcXXtcXG4gICAgbWFyZ2luLWxlZnQ6IC01MHZ3O1xcbiAgfVxcbiAgLnhzXFxcXDpibG9ja3tcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxuICAueHNcXFxcOmZsZXh7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuICAueHNcXFxcOmhpZGRlbntcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG4gIC54c1xcXFw6aC1tYXh7XFxuICAgIGhlaWdodDogLW1vei1tYXgtY29udGVudDtcXG4gICAgaGVpZ2h0OiBtYXgtY29udGVudDtcXG4gIH1cXG4gIC54c1xcXFw6dy1zY3JlZW57XFxuICAgIHdpZHRoOiAxMDB2dztcXG4gIH1cXG4gIC54c1xcXFw6XFxcXCFwLTh7XFxuICAgIHBhZGRpbmc6IDJyZW0gIWltcG9ydGFudDtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KXtcXG4gIC5zbVxcXFw6Y29sLXNwYW4tMntcXG4gICAgZ3JpZC1jb2x1bW46IHNwYW4gMiAvIHNwYW4gMjtcXG4gIH1cXG4gIC5zbVxcXFw6bWwtXFxcXFstMjV2d1xcXFxde1xcbiAgICBtYXJnaW4tbGVmdDogLTI1dnc7XFxuICB9XFxuICAuc21cXFxcOmJsb2Nre1xcbiAgICBkaXNwbGF5OiBibG9jaztcXG4gIH1cXG4gIC5zbVxcXFw6ZmxleHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gIH1cXG4gIC5zbVxcXFw6aGlkZGVue1xcbiAgICBkaXNwbGF5OiBub25lO1xcbiAgfVxcbiAgLnNtXFxcXDpoLW1heHtcXG4gICAgaGVpZ2h0OiAtbW96LW1heC1jb250ZW50O1xcbiAgICBoZWlnaHQ6IG1heC1jb250ZW50O1xcbiAgfVxcbiAgLnNtXFxcXDp3LVxcXFxbODB2d1xcXFxde1xcbiAgICB3aWR0aDogODB2dztcXG4gIH1cXG4gIC5zbVxcXFw6dy1maXR7XFxuICAgIHdpZHRoOiAtbW96LWZpdC1jb250ZW50O1xcbiAgICB3aWR0aDogZml0LWNvbnRlbnQ7XFxuICB9XFxuICAuc21cXFxcOnctc2NyZWVue1xcbiAgICB3aWR0aDogMTAwdnc7XFxuICB9XFxuICAuc21cXFxcOlxcXFwhcC04e1xcbiAgICBwYWRkaW5nOiAycmVtICFpbXBvcnRhbnQ7XFxuICB9XFxuICAuc21cXFxcOnRleHQteGx7XFxuICAgIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDEuNzVyZW07XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiA3NjhweCl7XFxuICAubWRcXFxcOm1sLVxcXFxbLTI1dndcXFxcXXtcXG4gICAgbWFyZ2luLWxlZnQ6IC0yNXZ3O1xcbiAgfVxcbiAgLm1kXFxcXDpibG9ja3tcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxuICAubWRcXFxcOmZsZXh7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuICAubWRcXFxcOmhpZGRlbntcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG4gIC5tZFxcXFw6aC1cXFxcW2NhbGNcXFxcKDEwMHZoLTkzcHhcXFxcKVxcXFxde1xcbiAgICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA5M3B4KTtcXG4gIH1cXG4gIC5tZFxcXFw6dy1cXFxcWzQwdndcXFxcXXtcXG4gICAgd2lkdGg6IDQwdnc7XFxuICB9XFxuICAubWRcXFxcOnctXFxcXFs2MHZ3XFxcXF17XFxuICAgIHdpZHRoOiA2MHZ3O1xcbiAgfVxcbn1cXG5cXG5AbWVkaWEgKG1pbi13aWR0aDogMTAyNHB4KXtcXG4gIC5sZ1xcXFw6bWItMTZ7XFxuICAgIG1hcmdpbi1ib3R0b206IDRyZW07XFxuICB9XFxuICAubGdcXFxcOm1sLVxcXFxbLTUwdndcXFxcXXtcXG4gICAgbWFyZ2luLWxlZnQ6IC01MHZ3O1xcbiAgfVxcbiAgLmxnXFxcXDpibG9ja3tcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxuICAubGdcXFxcOmZsZXh7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuICAubGdcXFxcOmhpZGRlbntcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG4gIC5sZ1xcXFw6aC1cXFxcW2NhbGNcXFxcKDEwMHZoLTkzcHhcXFxcKVxcXFxde1xcbiAgICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA5M3B4KTtcXG4gIH1cXG4gIC5sZ1xcXFw6dy00XFxcXC8xMntcXG4gICAgd2lkdGg6IDMzLjMzMzMzMyU7XFxuICB9XFxuICAubGdcXFxcOnctXFxcXFs0MHZ3XFxcXF17XFxuICAgIHdpZHRoOiA0MHZ3O1xcbiAgfVxcbiAgLmxnXFxcXDpweC0xMHtcXG4gICAgcGFkZGluZy1sZWZ0OiAyLjVyZW07XFxuICAgIHBhZGRpbmctcmlnaHQ6IDIuNXJlbTtcXG4gIH1cXG4gIC5sZ1xcXFw6cHktMTZ7XFxuICAgIHBhZGRpbmctdG9wOiA0cmVtO1xcbiAgICBwYWRkaW5nLWJvdHRvbTogNHJlbTtcXG4gIH1cXG4gIEBtZWRpYSAobWluLXdpZHRoOiA3NjhweCl7XFxuICAgIC5sZ1xcXFw6bWRcXFxcOnctXFxcXFs2MHZ3XFxcXF17XFxuICAgICAgd2lkdGg6IDYwdnc7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDEyODBweCl7XFxuICAueGxcXFxcOm1sLVxcXFxbLTUwdndcXFxcXXtcXG4gICAgbWFyZ2luLWxlZnQ6IC01MHZ3O1xcbiAgfVxcbiAgLnhsXFxcXDpibG9ja3tcXG4gICAgZGlzcGxheTogYmxvY2s7XFxuICB9XFxuICAueGxcXFxcOmZsZXh7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICB9XFxuICAueGxcXFxcOmhpZGRlbntcXG4gICAgZGlzcGxheTogbm9uZTtcXG4gIH1cXG4gIC54bFxcXFw6aC1cXFxcW2NhbGNcXFxcKDEwMHZoLTkzcHhcXFxcKVxcXFxde1xcbiAgICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA5M3B4KTtcXG4gIH1cXG4gIC54bFxcXFw6dy1cXFxcWzQwdndcXFxcXXtcXG4gICAgd2lkdGg6IDQwdnc7XFxuICB9XFxuICBAbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpe1xcbiAgICAueGxcXFxcOm1kXFxcXDp3LVxcXFxbNjB2d1xcXFxde1xcbiAgICAgIHdpZHRoOiA2MHZ3O1xcbiAgICB9XFxuICB9XFxufVxcblxcbkBtZWRpYSAobWluLXdpZHRoOiAxNTM2cHgpe1xcbiAgLlxcXFwzMnhsXFxcXDpmbGV4e1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgfVxcbiAgLlxcXFwzMnhsXFxcXDpoaWRkZW57XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxuICB9XFxufVxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zdHlsZXMvZ2xvYmFscy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsaU1BQWlNO0FBQ2pNLDRCQUE0QjtBQUM1QixpRUFBYztBQUFkOzs7Q0FBYztBQUFkOzs7RUFBQSxzQkFBYyxFQUFkLE1BQWM7RUFBZCxlQUFjLEVBQWQsTUFBYztFQUFkLG1CQUFjLEVBQWQsTUFBYztFQUFkLHFCQUFjLEVBQWQsTUFBYztBQUFBO0FBQWQ7O0VBQUEsZ0JBQWM7QUFBQTtBQUFkOzs7Ozs7OztDQUFjO0FBQWQ7O0VBQUEsZ0JBQWMsRUFBZCxNQUFjO0VBQWQsOEJBQWMsRUFBZCxNQUFjO0VBQWQsZ0JBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYztLQUFkLFdBQWMsRUFBZCxNQUFjO0VBQWQsK0hBQWMsRUFBZCxNQUFjO0VBQWQsNkJBQWMsRUFBZCxNQUFjO0VBQWQsK0JBQWMsRUFBZCxNQUFjO0VBQWQsd0NBQWMsRUFBZCxNQUFjO0FBQUE7QUFBZDs7O0NBQWM7QUFBZDtFQUFBLFNBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0FBQUE7QUFBZDs7OztDQUFjO0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0VBQWQscUJBQWMsRUFBZCxNQUFjO0FBQUE7QUFBZDs7Q0FBYztBQUFkO0VBQUEseUNBQWM7VUFBZCxpQ0FBYztBQUFBO0FBQWQ7O0NBQWM7QUFBZDs7Ozs7O0VBQUEsa0JBQWM7RUFBZCxvQkFBYztBQUFBO0FBQWQ7O0NBQWM7QUFBZDtFQUFBLGNBQWM7RUFBZCx3QkFBYztBQUFBO0FBQWQ7O0NBQWM7QUFBZDs7RUFBQSxtQkFBYztBQUFBO0FBQWQ7Ozs7O0NBQWM7QUFBZDs7OztFQUFBLCtHQUFjLEVBQWQsTUFBYztFQUFkLDZCQUFjLEVBQWQsTUFBYztFQUFkLCtCQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0FBQUE7QUFBZDs7Q0FBYztBQUFkO0VBQUEsY0FBYztBQUFBO0FBQWQ7O0NBQWM7QUFBZDs7RUFBQSxjQUFjO0VBQWQsY0FBYztFQUFkLGtCQUFjO0VBQWQsd0JBQWM7QUFBQTtBQUFkO0VBQUEsZUFBYztBQUFBO0FBQWQ7RUFBQSxXQUFjO0FBQUE7QUFBZDs7OztDQUFjO0FBQWQ7RUFBQSxjQUFjLEVBQWQsTUFBYztFQUFkLHFCQUFjLEVBQWQsTUFBYztFQUFkLHlCQUFjLEVBQWQsTUFBYztBQUFBO0FBQWQ7Ozs7Q0FBYztBQUFkOzs7OztFQUFBLG9CQUFjLEVBQWQsTUFBYztFQUFkLDhCQUFjLEVBQWQsTUFBYztFQUFkLGdDQUFjLEVBQWQsTUFBYztFQUFkLGVBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsdUJBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7RUFBZCxTQUFjLEVBQWQsTUFBYztFQUFkLFVBQWMsRUFBZCxNQUFjO0FBQUE7QUFBZDs7Q0FBYztBQUFkOztFQUFBLG9CQUFjO0FBQUE7QUFBZDs7O0NBQWM7QUFBZDs7OztFQUFBLDBCQUFjLEVBQWQsTUFBYztFQUFkLDZCQUFjLEVBQWQsTUFBYztFQUFkLHNCQUFjLEVBQWQsTUFBYztBQUFBO0FBQWQ7O0NBQWM7QUFBZDtFQUFBLGFBQWM7QUFBQTtBQUFkOztDQUFjO0FBQWQ7RUFBQSxnQkFBYztBQUFBO0FBQWQ7O0NBQWM7QUFBZDtFQUFBLHdCQUFjO0FBQUE7QUFBZDs7Q0FBYztBQUFkOztFQUFBLFlBQWM7QUFBQTtBQUFkOzs7Q0FBYztBQUFkO0VBQUEsNkJBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0FBQUE7QUFBZDs7Q0FBYztBQUFkO0VBQUEsd0JBQWM7QUFBQTtBQUFkOzs7Q0FBYztBQUFkO0VBQUEsMEJBQWMsRUFBZCxNQUFjO0VBQWQsYUFBYyxFQUFkLE1BQWM7QUFBQTtBQUFkOztDQUFjO0FBQWQ7RUFBQSxrQkFBYztBQUFBO0FBQWQ7O0NBQWM7QUFBZDs7Ozs7Ozs7Ozs7OztFQUFBLFNBQWM7QUFBQTtBQUFkO0VBQUEsU0FBYztFQUFkLFVBQWM7QUFBQTtBQUFkO0VBQUEsVUFBYztBQUFBO0FBQWQ7OztFQUFBLGdCQUFjO0VBQWQsU0FBYztFQUFkLFVBQWM7QUFBQTtBQUFkOztDQUFjO0FBQWQ7RUFBQSxVQUFjO0FBQUE7QUFBZDs7Q0FBYztBQUFkO0VBQUEsZ0JBQWM7QUFBQTtBQUFkOzs7Q0FBYztBQUFkO0VBQUEsVUFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjLEVBQWQsTUFBYztBQUFBO0FBQWQ7O0VBQUEsVUFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjLEVBQWQsTUFBYztBQUFBO0FBQWQ7O0NBQWM7QUFBZDs7RUFBQSxlQUFjO0FBQUE7QUFBZDs7Q0FBYztBQUFkO0VBQUEsZUFBYztBQUFBO0FBQWQ7Ozs7Q0FBYztBQUFkOzs7Ozs7OztFQUFBLGNBQWMsRUFBZCxNQUFjO0VBQWQsc0JBQWMsRUFBZCxNQUFjO0FBQUE7QUFBZDs7Q0FBYztBQUFkOztFQUFBLGVBQWM7RUFBZCxZQUFjO0FBQUE7QUFBZCx3RUFBYztBQUFkO0VBQUEsYUFBYztBQUFBO0FBQWQ7RUFBQSx3QkFBYztFQUFkLHdCQUFjO0VBQWQsbUJBQWM7RUFBZCxtQkFBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGVBQWM7RUFBZCxlQUFjO0VBQWQsYUFBYztFQUFkLGFBQWM7RUFBZCxrQkFBYztFQUFkLHNDQUFjO0VBQWQsOEJBQWM7RUFBZCw2QkFBYztFQUFkLDRCQUFjO0VBQWQsZUFBYztFQUFkLG9CQUFjO0VBQWQsc0JBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQsa0JBQWM7RUFBZCwyQkFBYztFQUFkLDRCQUFjO0VBQWQsc0NBQWM7RUFBZCxrQ0FBYztFQUFkLDJCQUFjO0VBQWQsc0JBQWM7RUFBZCw4QkFBYztFQUFkLFlBQWM7RUFBZCxrQkFBYztFQUFkLGdCQUFjO0VBQWQsaUJBQWM7RUFBZCxrQkFBYztFQUFkLGNBQWM7RUFBZCxnQkFBYztFQUFkLGFBQWM7RUFBZCxtQkFBYztFQUFkLHFCQUFjO0VBQWQsMkJBQWM7RUFBZCx5QkFBYztFQUFkLDBCQUFjO0VBQWQsMkJBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQseUJBQWM7RUFBZCxzQkFBYztFQUFkLG9CQUFjO0VBQWQsc0JBQWM7RUFBZCxxQkFBYztFQUFkO0FBQWM7QUFBZDtFQUFBLHdCQUFjO0VBQWQsd0JBQWM7RUFBZCxtQkFBYztFQUFkLG1CQUFjO0VBQWQsY0FBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsZUFBYztFQUFkLGVBQWM7RUFBZCxhQUFjO0VBQWQsYUFBYztFQUFkLGtCQUFjO0VBQWQsc0NBQWM7RUFBZCw4QkFBYztFQUFkLDZCQUFjO0VBQWQsNEJBQWM7RUFBZCxlQUFjO0VBQWQsb0JBQWM7RUFBZCxzQkFBYztFQUFkLHVCQUFjO0VBQWQsd0JBQWM7RUFBZCxrQkFBYztFQUFkLDJCQUFjO0VBQWQsNEJBQWM7RUFBZCxzQ0FBYztFQUFkLGtDQUFjO0VBQWQsMkJBQWM7RUFBZCxzQkFBYztFQUFkLDhCQUFjO0VBQWQsWUFBYztFQUFkLGtCQUFjO0VBQWQsZ0JBQWM7RUFBZCxpQkFBYztFQUFkLGtCQUFjO0VBQWQsY0FBYztFQUFkLGdCQUFjO0VBQWQsYUFBYztFQUFkLG1CQUFjO0VBQWQscUJBQWM7RUFBZCwyQkFBYztFQUFkLHlCQUFjO0VBQWQsMEJBQWM7RUFBZCwyQkFBYztFQUFkLHVCQUFjO0VBQWQsd0JBQWM7RUFBZCx5QkFBYztFQUFkLHNCQUFjO0VBQWQsb0JBQWM7RUFBZCxzQkFBYztFQUFkLHFCQUFjO0VBQWQ7QUFBYztBQUNkO0VBQUE7QUFBb0I7QUFBcEI7RUFBQTtJQUFBO0VBQW9CO0FBQUE7QUFBcEI7RUFBQTtJQUFBO0VBQW9CO0FBQUE7QUFBcEI7RUFBQTtJQUFBO0VBQW9CO0FBQUE7QUFBcEI7RUFBQTtJQUFBO0VBQW9CO0FBQUE7QUFBcEI7RUFBQTtJQUFBO0VBQW9CO0FBQUE7QUFDcEI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsd0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSx3QkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLHFCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLHlCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQixrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkIsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsZ0JBQW1CO0VBQW5CLGdCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQixpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxpQkFBbUI7RUFBbkIsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGlCQUFtQjtFQUFuQixpQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSx1QkFBbUI7RUFBbkIsNERBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsK0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsK0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBLGtCQUFtQjtFQUFuQjtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsc0JBQW1CO0tBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEscUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsb0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsaUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsbUJBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsa0JBQW1CO0VBQW5CO0FBQW1CO0FBQW5CO0VBQUEsZUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUEsZUFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxtQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxrQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQTtBQUFtQjtBQUFuQjtFQUFBO0FBQW1CO0FBQW5CO0VBQUE7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7RUFBQSxvQkFBbUI7RUFBbkI7QUFBbUI7QUFBbkI7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QUFBQTs7QUFBQTtFQUFBLDJHQUFBO0VBQUEseUdBQUE7RUFBQTtBQUFBOztBQUFBO0VBQUEsMkdBQUE7RUFBQSx5R0FBQTtFQUFBO0FBQUE7O0FBQUE7RUFBQSxvQkFBQTtFQUFBO0FBQUE7O0FBQUE7RUFBQSxvQkFBQTtFQUFBO0FBQUE7O0FBQUE7RUFBQSxrQkFBQTtFQUFBO0FBQUE7O0FBQUE7RUFBQSxvQkFBQTtFQUFBO0FBQUE7O0FBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBLHdCQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtBQUFBOztBQUFBO0VBQUE7SUFBQTtFQUFBO0VBQUE7SUFBQTtFQUFBO0VBQUE7SUFBQTtFQUFBO0VBQUE7SUFBQTtFQUFBO0VBQUE7SUFBQTtFQUFBO0VBQUE7SUFBQSx3QkFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBLHVCQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUEsa0JBQUE7SUFBQTtFQUFBO0FBQUE7O0FBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7QUFBQTs7QUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUE7RUFBQTtFQUFBO0lBQUEsb0JBQUE7SUFBQTtFQUFBO0VBQUE7SUFBQSxpQkFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO01BQUE7SUFBQTtFQUFBO0FBQUE7O0FBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO01BQUE7SUFBQTtFQUFBO0FBQUE7O0FBQUE7RUFBQTtJQUFBO0VBQUE7RUFBQTtJQUFBO0VBQUE7QUFBQVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAaW1wb3J0IHVybCgnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3MyP2ZhbWlseT1EYW5jaW5nK1NjcmlwdDp3Z2h0QDcwMCZmYW1pbHk9S2RhbStUaG1vcitQcm8mZmFtaWx5PUxpYnJlK0Jhc2tlcnZpbGxlJmZhbWlseT1Qb3BwaW5zJmRpc3BsYXk9c3dhcCZmYW1pbHk9T3BlbitTYW5zOndnaHRAMzAwJmRpc3BsYXk9c3dhcCcpO1xcbi8qIEBpbXBvcnQgXFxcIi4vei1pbmRleC5jc3NcXFwiICovXFxuQHRhaWx3aW5kIGJhc2U7XFxuQHRhaWx3aW5kIGNvbXBvbmVudHM7XFxuQHRhaWx3aW5kIHV0aWxpdGllcztcXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk7XFxufVxcblxcblxcbiNfX25leHQge1xcbiAgLyogbWFyZ2luLXRvcDogNnJlbTsgKi9cXG4gIG1pbi1oZWlnaHQ6IDEwMHZoO1xcbiAgd2lkdGg6IDEwMHZ3O1xcbn1cXG4qIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbm1haW4ge1xcbiAgcGFkZGluZy10b3A6IDZyZW07XFxufVxcblxcbipbZGF0YS1hbmltYXRpb249XFxcInJpcHBsZVxcXCJdOjpzZWxlY3Rpb24ge1xcblxcdGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcblxcdC8qIHBvaW50ZXItZXZlbnRzOiBub25lOyAqL1xcbn1cXG5cXG5oZWFkZXIge1xcblxcdGJhY2tncm91bmQ6ICMwMGEzYWNcXG59XFxuXFxuaGVhZGVyLmJhY2tkcm9wRmlsdGVyIHtcXG5cXHRiYWNrZHJvcC1maWx0ZXI6IGJsdXIoMTBweCk7XFxufVxcblxcbmhlYWRlci5tb3JlQmFja2Ryb3BGaWx0ZXIge1xcblxcdGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMDBweCk7XFxufVxcblxcbi50cmFuc3BhcmVudCB7XFxuICBiYWNrZ29ydW5kOiAjMDAzNjY2MDA7XFxufVxcblxcbi5jYXJvdXNlbCB7XFxuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcXG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcXG4vKiAgc2Nyb2xsIHNuYXAgaXMgYSBncmVhdCBmZWF0dXJlIHdoaWNoIHdpbGwgY2VudGVyIHRoZSBpbWFnZSBvbiBzbmFwIG9uIHRvdWNoIHNjcmVlbiBkZXZpY2VzICAqL1xcbiAgc2Nyb2xsLXNuYXAtdHlwZTogeCBtYW5kYXRvcnk7XFxuLyogYWxsIGJlbG93IHdpbGwgaGlkZSB0aGUgc2Nyb2xsYmFyIG9uIGFsbCBicm93c2Vycy4gICAgKi9cXG4gIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcXG4gIHNjcm9sbGJhci13aWR0aDogbm9uZTsgLyogRm9yIEZpcmVmb3ggKi9cXG4gIC1tcy1vdmVyZmxvdy1zdHlsZTogbm9uZTsgLyogRm9yIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlICovXFxufVxcblxcbi5pbWFnZS1jb250YWluZXIgc3BhbiB7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuOSk7XFxufVxcblxcbi5tYXBDb250YWluZXIge1xcbiAgb3ZlcmZsb3c6IHZpc2libGUgIWltcG9ydGFudDtcXG59XFxuXFxuLmRldGFpbHMgaW5wdXQsIHRleHRhcmVhIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBhZGRpbmc6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDcuNXB4O1xcbiAgYmFja2dyb3VuZDogaHNsYSgwLCAwJSwgOCUsIDAuOTE2KTtcXG4gIHRyYW5zaXRpb246IGFsbCAwLjRzIGVhc2UtaW4tb3V0LCBiYWNrZ3JvdW5kLWNvbG9yIDk5OTk5OTk5OTk5OTk5OTk5OTk5OTlzIGxpbmVhciwgY29sb3IgOTk5OTk5OTk5OTk5OTk5OTk5OTk5OXMgbGluZWFyO1xcbiAgY29sb3I6IHdoaXRlc21va2U7XFxuICBwYWRkaW5nLWxlZnQ6IDcuNXB4O1xcbiAgcGFkZGluZzowLjhlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDAuNWVtO1xcbn1cXG5cXG4uZGV0YWlscyBpbnB1dDpmb2N1cywgdGV4dGFyZWE6Zm9jdXMge1xcbiAgb3V0bGluZTogbm9uZVxcbn1cXG5cXG4uZGV0YWlscyBpbnB1dDpmb2N1cy13aXRoaW4sIHRleHRhcmVhOmZvY3VzLXdpdGhpbiB7XFxuICBib3gtc2hhZG93OiAwIDAgMCAzcHggI2ZmZWVlNzk5O1xcbn1cXG5cXG4uZGV0YWlscyBkaXYge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OTk7XFxufVxcblxcbi5pbnB1dC1jb250YWluZXIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IDEwMCU7XFxufVxcblxcbi5pbnB1dC1jb250YWluZXI6bm90KDpsYXN0LWNoaWxkKSB7XFxuICBtYXJnaW4tYm90dG9tOiAxOXB4O1xcbn1cXG5cXG5cXG4uaW5wdXQtY29udGFpbmVyID4gaW5wdXQ6Zm9jdXMtd2l0aGluICsgbGFiZWx7XFxuICBwYWRkaW5nOiAwIDAuMmVtO1xcbiAgcG9zaXRpb246YWJzb2x1dGU7XFxuICB0b3A6IC0wLjk1ZW07XFxuICBsZWZ0OiAwLjA1ZW07XFxuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcXG4gIGNvbG9yOiB3aGl0ZXNtb2tlO1xcbiAgYmFja2dyb3VuZDogaHNsYSgwLCAwJSwgOCUsIDAuOTE2KTtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBwYWRkaW5nOiAwcHggMC4zZW0gMHB4IDAuM2VtXFxufVxcblxcbi5pbnB1dC1jb250YWluZXIgPiBpbnB1dC5mdWxsICsgbGFiZWx7XFxuICBwYWRkaW5nOjAgMC4yZW07XFxuICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gIHRvcDogLTAuOTVlbTtcXG4gIGxlZnQ6IDAuMDVlbTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCA2MywgMTY3LCA1MiUpO1xcbiAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIHBhZGRpbmc6IDBweCAwLjNlbSAwcHggMC4zZW1cXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lciA+IGlucHV0ICsgbGFiZWx7XFxuICBwYWRkaW5nOjAgMC4yZW07XFxuICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCA2MywgMTY3LCAwJSk7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgcGFkZGluZzogMHB4IDAuM2VtIDBweCAwLjNlbTtcXG4gIHRvcDogMC43NWVtO1xcbiAgbGVmdDogMC4yNWVtO1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuNHMgZWFzZS1pbi1vdXQ7XFxuICBjdXJzb3I6IHRleHQ7XFxufVxcblxcbi5pbnB1dC1jb250YWluZXIgPiB0ZXh0YXJlYTpmb2N1cy13aXRoaW4gKyBsYWJlbHtcXG4gIHBhZGRpbmc6IDAgMC4yZW07XFxuICBwb3NpdGlvbjphYnNvbHV0ZTtcXG4gIHRvcDogLTAuOTVlbTtcXG4gIGxlZnQ6IDAuMDVlbTtcXG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCA2MywgMTY3LCAzMiUpO1xcbiAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIHBhZGRpbmc6IDBweCAwLjNlbSAwcHggMC4zZW1cXG59XFxuXFxuLmlucHV0LWNvbnRhaW5lciA+IHRleHRhcmVhLmZ1bGwgKyBsYWJlbHtcXG4gIHBhZGRpbmc6MCAwLjJlbTtcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcbiAgdG9wOiAtMC45NWVtO1xcbiAgbGVmdDogMC4wNWVtO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDYzLCAxNjcsIDUyJSk7XFxuICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgcGFkZGluZzogMHB4IDAuM2VtIDBweCAwLjNlbVxcbn1cXG5cXG4uaW5wdXQtY29udGFpbmVyID4gdGV4dGFyZWEgKyBsYWJlbHtcXG4gIHBhZGRpbmc6MCAwLjJlbTtcXG4gIHBvc2l0aW9uOmFic29sdXRlO1xcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDYzLCAxNjcsIDAlKTtcXG4gIGJvcmRlci1yYWRpdXM6IDE1cHg7XFxuICBwYWRkaW5nOiAwcHggMC4zZW0gMHB4IDAuM2VtO1xcbiAgdG9wOiAwLjc1ZW07XFxuICBsZWZ0OiAwLjI1ZW07XFxuICB0cmFuc2l0aW9uOiBhbGwgMC40cyBlYXNlLWluLW91dDtcXG4gIGN1cnNvcjogdGV4dDtcXG59XFxuXFxuYnIge1xcbiAgaGVpZ2h0OiAxOXB4ICFpbXBvcnRhbnQ7XFxuICBjb250ZW50OiBcXFwiXFxcIjtcXG4gIHdpZHRoOiBhdXRvICFpbXBvcnRhbnQ7XFxuICBkaXNwbGF5OiBibG9jaztcXG59XFxuXFxuXFxuLmZyYW1lLWNvbnRhaW5lciBoMiwgaDMge1xcbiAgbWFyZ2luLWJvdHRvbTogMTBweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuXFxuLmZyYW1lLWNvbnRhaW5lciBmb3JtIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG59XFxuXFxuLmxvZ2luLWJveCB7XFxuICBiYWNrZ3JvdW5kOiBoc2woMTgzZGVnIDEwMCUgNTAlIC8gNjAlKTtcXG4gIGJveC1zaGFkb3c6IDAgOHB4IDMycHggMCByZ2IoMCAxOTMgMjU1IC8gMzYlKTtcXG4gIGJhY2tkcm9wLWZpbHRlcjogYmx1ciggNi41cHggKTtcXG4gIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiBibHVyKCA2LjVweCApO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoIDI1NSwgMjU1LCAyNTUsIDAuMTggKTtcXG59XFxuXFxuaDIubG9naW4tdGV4dCB7XFxuICB0ZXh0LXNoYWRvdzogMTBweCAtNHB4IDIzcHggIzAwM2U5NTtcXG59XFxuXFxuaDEubG9naW4tdGV4dCB7XFxuICB0ZXh0LXNoYWRvdzogMTFweCAtNHB4IDIzcHggIzA0MDBmZjtcXG59XFxuXFxuLmxvZ2luLW1haW4gIGlucHV0LCB0ZXh0YXJlYSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBwYWRkaW5nOiA1cHg7XFxuICBib3JkZXItcmFkaXVzOiA3LjVweDtcXG4gIGJhY2tncm91bmQ6IGhzbGEoMCwgMCUsIDglLCAwLjkxNik7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC40cyBlYXNlLWluLW91dCwgYmFja2dyb3VuZC1jb2xvciA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5cyBsaW5lYXIsIGNvbG9yIDk5OTk5OTk5OTk5OTk5OTk5OTk5OTlzIGxpbmVhcjtcXG4gIGNvbG9yOiB3aGl0ZXNtb2tlO1xcbiAgcGFkZGluZy1sZWZ0OiA3LjVweDtcXG4gIHBhZGRpbmc6MC44ZW07XFxuICBib3JkZXItcmFkaXVzOiAwLjVlbTtcXG59XFxuXFxuLmxvZ2luLW1haW4gaW5wdXQ6Zm9jdXMsIHRleHRhcmVhOmZvY3VzIHtcXG4gIG91dGxpbmU6IG5vbmVcXG59XFxuXFxuLmxvZ2luLW1haW4gaW5wdXQ6Zm9jdXMtd2l0aGluLCB0ZXh0YXJlYTpmb2N1cy13aXRoaW4ge1xcbiAgYm94LXNoYWRvdzogMCAwIDAgM3B4ICNmZmVlZTc5OTtcXG59XFxuXFxuLmxvZ2luLW1haW4gZGl2IHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5O1xcbn1cXG5cXG4jbG9hZGluZy1jb250YWluZXIgZGl2IHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHdpZHRoOiBjYWxjKDEwMCUgKiAwLjk2KTtcXG4gIGhlaWdodDogY2FsYygxMDAlICogMC45Nik7XFxuICBtYXJnaW46IDhweDtcXG4gIGJvcmRlcjogMThweCBzb2xpZCAjMDRjNWQwO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgYW5pbWF0aW9uOiBsZHMtcmluZyAxLjJzIGN1YmljLWJlemllcigwLjUsIDAsIDAuNSwgMSkgaW5maW5pdGU7XFxuICBib3JkZXItY29sb3I6ICMwNGM1ZDAgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7XFxufVxcblxcbiNsb2FkaW5nLWNvbnRhaW5lciBkaXY6bnRoLWNoaWxkKDEpIHtcXG4gIGFuaW1hdGlvbi1kZWxheTogLTAuNDVzO1xcbn1cXG4jbG9hZGluZy1jb250YWluZXIgZGl2Om50aC1jaGlsZCgyKSB7XFxuICBhbmltYXRpb24tZGVsYXk6IC0wLjNzO1xcbn1cXG4jbG9hZGluZy1jb250YWluZXIgZGl2Om50aC1jaGlsZCgzKSB7XFxuICBhbmltYXRpb24tZGVsYXk6IC0wLjE1cztcXG59XFxuQGtleWZyYW1lcyBsZHMtcmluZyB7XFxuICAwJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICB9XFxufVxcblxcbm1haW4ge1xcbiAgc2Nyb2xsLXNuYXAtdHlwZTogeSB4IG1hbmRhdG9yeTtcXG59XFxuXFxuLnZpZXcge1xcbiAgc2Nyb2xsLXNuYXAtYWxpZ246IHN0YXJ0O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/z-index.css":
/*!********************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/z-index.css ***!
  \********************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999\\\\] {\\n  z-index: 99999;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999\\\\] {\\n  z-index: 9999999999;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/z-index.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,4CAA4C;AAC9C;;AAEA;EAaE,0CAA0C;AAX5C;;AAcA;EAaE,4CAA4C;AAX9C;;AAcA;EACE,cAAc;AAChB;;AAEA;EAaE,0CAA0C;AAX5C;;AAcA;EAaE,4CAA4C;AAX9C;;AAcA;EAaE,wCAAwC;AAX1C;;AAcA;EAaE,0CAA0C;AAX5C;;AAcA;EACE,mBAAmB;AACrB\",\"sourcesContent\":[\".z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999\\\\] {\\n  z-index: 99999;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 9999999999999;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[999999999999999999999999\\\\] {\\n  z-index: 999999999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[99999999999999999999\\\\] {\\n  z-index: 99999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999999999999999\\\\] {\\n  z-index: 9999999999999999999999 !important;\\n}\\n\\n.z-\\\\[9999999999\\\\] {\\n  z-index: 9999999999;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZls4XS51c2VbMV0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vc3R5bGVzL3otaW5kZXguY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ3dIO0FBQ3hILDhCQUE4QixrSEFBMkI7QUFDekQ7QUFDQSw2RUFBNkUsaURBQWlELEdBQUcscUNBQXFDLCtDQUErQyxHQUFHLHVDQUF1QyxpREFBaUQsR0FBRyxvQkFBb0IsbUJBQW1CLEdBQUcscUNBQXFDLCtDQUErQyxHQUFHLHVDQUF1QyxpREFBaUQsR0FBRyxtQ0FBbUMsNkNBQTZDLEdBQUcscUNBQXFDLCtDQUErQyxHQUFHLHlCQUF5Qix3QkFBd0IsR0FBRyxTQUFTLG1GQUFtRixZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxVQUFVLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLDZEQUE2RCxpREFBaUQsR0FBRyxxQ0FBcUMsK0NBQStDLEdBQUcscUNBQXFDLCtDQUErQyxHQUFHLHFDQUFxQywrQ0FBK0MsR0FBRyxxQ0FBcUMsK0NBQStDLEdBQUcsdUNBQXVDLGlEQUFpRCxHQUFHLHVDQUF1QyxpREFBaUQsR0FBRyx1Q0FBdUMsaURBQWlELEdBQUcsdUNBQXVDLGlEQUFpRCxHQUFHLG9CQUFvQixtQkFBbUIsR0FBRyxxQ0FBcUMsK0NBQStDLEdBQUcscUNBQXFDLCtDQUErQyxHQUFHLHFDQUFxQywrQ0FBK0MsR0FBRyxxQ0FBcUMsK0NBQStDLEdBQUcsdUNBQXVDLDJCQUEyQixHQUFHLHVDQUF1QyxpREFBaUQsR0FBRyx1Q0FBdUMsaURBQWlELEdBQUcsdUNBQXVDLGlEQUFpRCxHQUFHLG1DQUFtQyw2Q0FBNkMsR0FBRyxtQ0FBbUMsNkNBQTZDLEdBQUcsbUNBQW1DLDZDQUE2QyxHQUFHLG1DQUFtQyw2Q0FBNkMsR0FBRyxxQ0FBcUMsK0NBQStDLEdBQUcscUNBQXFDLCtDQUErQyxHQUFHLHFDQUFxQywrQ0FBK0MsR0FBRyxxQ0FBcUMsK0NBQStDLEdBQUcseUJBQXlCLHdCQUF3QixHQUFHLHFCQUFxQjtBQUN6eEc7QUFDQSwrREFBZSx1QkFBdUIsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zdHlsZXMvei1pbmRleC5jc3M/NzBlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3N0eWxlcy96LWluZGV4LmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLDRDQUE0QztBQUM5Qzs7QUFFQTtFQWFFLDBDQUEwQztBQVg1Qzs7QUFjQTtFQWFFLDRDQUE0QztBQVg5Qzs7QUFjQTtFQUNFLGNBQWM7QUFDaEI7O0FBRUE7RUFhRSwwQ0FBMEM7QUFYNUM7O0FBY0E7RUFhRSw0Q0FBNEM7QUFYOUM7O0FBY0E7RUFhRSx3Q0FBd0M7QUFYMUM7O0FBY0E7RUFhRSwwQ0FBMEM7QUFYNUM7O0FBY0E7RUFDRSxtQkFBbUI7QUFDckJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTk5OTk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5OTk5OTk5OTk5OTk5ICFpbXBvcnRhbnQ7XFxufVxcblxcbi56LVxcXFxbOTk5OTk5OTk5OTk5OTk5OTk5OTk5OVxcXFxdIHtcXG4gIHotaW5kZXg6IDk5OTk5OTk5OTk5OTk5OTk5OTk5OTkgIWltcG9ydGFudDtcXG59XFxuXFxuLnotXFxcXFs5OTk5OTk5OTk5OTk5OTk5OTk5OTk5XFxcXF0ge1xcbiAgei1pbmRleDogOTk5OTk5OTk5OTk5OTk5OTk5OTk5OSAhaW1wb3J0YW50O1xcbn1cXG5cXG4uei1cXFxcWzk5OTk5OTk5OTlcXFxcXSB7XFxuICB6LWluZGV4OiA5OTk5OTk5OTk5O1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/z-index.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module) {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return '@media '.concat(item[2], ' {').concat(content, '}');\n            }\n            return content;\n        }).join('');\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === 'string') {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    ''\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = ''.concat(mediaQuery, ' and ').concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || '' // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === 'function') {\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return '/*# sourceURL='.concat(cssMapping.sourceRoot || '').concat(source, ' */');\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join('\\n');\n    }\n    return [\n        content\n    ].join('\\n');\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(base64);\n    return '/*# '.concat(data, ' */');\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanM/Y2E0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gIE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG4gIEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovIC8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICA7XG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQG1lZGlhICcuY29uY2F0KGl0ZW1bMl0sICcgeycpLmNvbmNhdChjb250ZW50LCAnfScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH0gLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcbiAgICA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBtb2R1bGVzID0gW1xuICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlcyxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgICAgIGlmIChkZWR1cGUpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspe1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuICAgICAgICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gJycuY29uY2F0KG1lZGlhUXVlcnksICcgYW5kICcpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBsaXN0O1xufTtcbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIDtcbiAgICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gICAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuICAgICAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gJy8qIyBzb3VyY2VVUkw9Jy5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCAnICovJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgY29udGVudFxuICAgICAgICBdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW1xuICAgICAgICAgICAgc291cmNlTWFwcGluZ1xuICAgICAgICBdKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29udGVudFxuICAgIF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnLmNvbmNhdChiYXNlNjQpO1xuICAgIHJldHVybiAnLyojICcuY29uY2F0KGRhdGEsICcgKi8nKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/cGFnZT0lMkZfYXBwJmFic29sdXRlUGFnZVBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxpREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzYzZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app!\n");

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./globals.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRWpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHVlQUErTztBQUNyUDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVlQUErTzs7QUFFelE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL2dsb2JhbHMuY3NzP2M5ODMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vZ2xvYmFscy5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/globals.css\n");

/***/ }),

/***/ "./styles/z-index.css":
/*!****************************!*\
  !*** ./styles/z-index.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! !../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./z-index.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/z-index.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                // These elements should always exist. If they do not,\n                // this code should fail.\n                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');\n                var parentNode = anchorElement.parentNode// Normally <head>\n                ;\n                // Each style tag should be placed right before our\n                // anchor. By inserting before and not after, we do not\n                // need to track the last inserted element.\n                parentNode.insertBefore(element, anchorElement);\n            };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === 'default') {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./z-index.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/z-index.css\",\n      function () {\n        content = __webpack_require__(/*! !!../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./z-index.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[3].oneOf[8].use[2]!./styles/z-index.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvei1pbmRleC5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLG9OQUF3RztBQUMxSCwwQkFBMEIsbUJBQU8sQ0FBQyx1ZUFBK087O0FBRWpSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLGlCQUFpQjtBQUNyQixNQUFNLHVlQUErTztBQUNyUDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLHVlQUErTzs7QUFFelE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFVBQVU7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRSxVQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3R5bGVzL3otaW5kZXguY3NzPzczM2UiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vei1pbmRleC5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vei1pbmRleC5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzhdLnVzZVsxXSEuLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbOF0udXNlWzJdIS4vei1pbmRleC5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/z-index.css\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === 'undefined') {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTarget = function getTarget() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === 'undefined') {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + ' ' + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement('style');\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === 'undefined') {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === 'function') {\n        options.insert(style);\n    } else {\n        const target = getTarget(options.insert || 'head');\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join('\\n');\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? '' : obj.media ? '@media ' + obj.media + ' {' + obj.css + '}' : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute('media', media);\n    } else {\n        style.removeAttribute('media');\n    }\n    if (sourceMap && typeof btoa !== 'undefined') {\n        css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */';\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== 'boolean') {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== '[object Array]') {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcz8yNmVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gICAgbGV0IG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgICAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xufSgpO1xuY29uc3QgZ2V0VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0VGFyZ2V0KCkge1xuICAgIGNvbnN0IG1lbW8gPSB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbGV0IHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gICAgfTtcbn0oKTtcbmNvbnN0IHN0eWxlc0luRG9tID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgbGV0IHJlc3VsdCA9IC0xO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRDb3VudE1hcCA9IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWQgKyAnICcgKyBjb3VudC50b1N0cmluZygpO1xuICAgICAgICBpZENvdW50TWFwW2lkXSA9IGNvdW50ICsgMTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgICAgY29uc3Qgb2JqID0ge1xuICAgICAgICAgICAgY3NzOiBpdGVtWzFdLFxuICAgICAgICAgICAgbWVkaWE6IGl0ZW1bMl0sXG4gICAgICAgICAgICBzb3VyY2VNYXA6IGl0ZW1bM11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS51cGRhdGVyKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IG9wdGlvbnMuYXR0cmlidXRlcyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAgIHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvcHRpb25zLmluc2VydChzdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi8gY29uc3QgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgICBjb25zdCB0ZXh0U3RvcmUgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyAnQG1lZGlhICcgKyBvYmoubWVkaWEgKyAnIHsnICsgb2JqLmNzcyArICd9JyA6IG9iai5jc3M7XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICAgIGxldCBjc3MgPSBvYmouY3NzO1xuICAgIGNvbnN0IG1lZGlhID0gb2JqLm1lZGlhO1xuICAgIGNvbnN0IHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICAgIH1cbiAgICBpZiAoc291cmNlTWFwICYmIHR5cGVvZiBidG9hICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjc3MgKz0gJ1xcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsJyArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyAnICovJztcbiAgICB9XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgfVxufVxubGV0IHNpbmdsZXRvbiA9IG51bGw7XG5sZXQgc2luZ2xldG9uQ291bnRlciA9IDA7XG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgICBsZXQgc3R5bGU7XG4gICAgbGV0IHVwZGF0ZTtcbiAgICBsZXQgcmVtb3ZlO1xuICAgIGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuICAgICAgICBjb25zdCBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuICAgICAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUgPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlKG9iaik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgICAgICBpZiAobmV3T2JqKSB7XG4gICAgICAgICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmUoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgICAvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG4gICAgaWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09ICdib29sZWFuJykge1xuICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgICB9XG4gICAgbGlzdCA9IGxpc3QgfHwgW107XG4gICAgbGV0IGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICAgICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICAgIGZvcihsZXQgaTEgPSAwOyBpMSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkxKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpMV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaWYgKHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgICB9O1xufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./elements/hamburger.tsx":
/*!********************************!*\
  !*** ./elements/hamburger.tsx ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Hamburger; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _nav__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nav */ \"./elements/nav.tsx\");\n\n\n\n\nvar _s = $RefreshSig$();\nfunction Hamburger() {\n    var _this = this;\n    _s();\n    var router = (0,next_router__WEBPACK_IMPORTED_MODULE_1__.useRouter)();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false), open = ref[0], setOpen = ref[1];\n    var handleOpen = function() {\n        setOpen(!open);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                onClick: handleOpen,\n                className: \"w-[3.5rem] h-[2.75rem] cursor-pointer flex flex-col items-center justify-between mr-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"h-[0.35rem] rounded-lg bg-[#cecdcdfa] transition-all w-full\",\n                            style: {\n                                transformOrigin: \"0% 0%\",\n                                transform: open ? \"rotate(45deg) translate(0.5325rem, -0.5325rem)\" : \"\"\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/kabirchawla/Mathston/firetag/elements/hamburger.tsx\",\n                            lineNumber: 18,\n                            columnNumber: 25\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"h-[0.35rem] rounded-lg bg-[#cecdcdfa] transition-all w-\".concat(!open ? \"full\" : \"[0rem]\")\n                        }, void 0, false, {\n                            fileName: \"/Users/kabirchawla/Mathston/firetag/elements/hamburger.tsx\",\n                            lineNumber: 19,\n                            columnNumber: 25\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                            className: \"h-[0.35rem] rounded-lg bg-[#cecdcdfa] transition-all w-full\",\n                            style: {\n                                transformOrigin: \"0% 100%\",\n                                transform: open ? \"rotate(-45deg) translate(0.5325rem, 0.5325rem)\" : \"\"\n                            }\n                        }, void 0, false, {\n                            fileName: \"/Users/kabirchawla/Mathston/firetag/elements/hamburger.tsx\",\n                            lineNumber: 20,\n                            columnNumber: 25\n                        }, this)\n                    ]\n                }, void 0, true)\n            }, void 0, false, {\n                fileName: \"/Users/kabirchawla/Mathston/firetag/elements/hamburger.tsx\",\n                lineNumber: 14,\n                columnNumber: 13\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full bg-[#161c24] transition-all duration-200 flex flex-col justify-center items-center\",\n                style: {\n                    height: \"calc(100vh - 96px)\",\n                    top: \"96px\",\n                    position: \"absolute\",\n                    right: open ? \"0%\" : \"100%\"\n                },\n                children: _nav__WEBPACK_IMPORTED_MODULE_3__.navRoutes.map(function(param, index) {\n                    var name = param.name, href = param.href;\n                    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        onClick: function() {\n                            router.push(href);\n                            setOpen(false);\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                textDecorationSkipInk: \"none\"\n                            },\n                            className: \"nav-div p-4 text-white rounded-lg text-3xl cursor-pointer h-[80px] decoration-[4px] underline-offset-1\",\n                            children: name\n                        }, void 0, false, {\n                            fileName: \"/Users/kabirchawla/Mathston/firetag/elements/hamburger.tsx\",\n                            lineNumber: 36,\n                            columnNumber: 29\n                        }, _this)\n                    }, \"nav-\".concat(index), false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/elements/hamburger.tsx\",\n                        lineNumber: 32,\n                        columnNumber: 25\n                    }, _this);\n                })\n            }, void 0, false, {\n                fileName: \"/Users/kabirchawla/Mathston/firetag/elements/hamburger.tsx\",\n                lineNumber: 24,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true);\n};\n_s(Hamburger, \"kip7PLEoj5zu8mMumTu/W/gd4s8=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_1__.useRouter\n    ];\n});\n_c = Hamburger;\nvar _c;\n$RefreshReg$(_c, \"Hamburger\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9lbGVtZW50cy9oYW1idXJnZXIudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDd0M7QUFDUjtBQUNFOztBQUVuQixTQUFTRyxTQUFTLEdBQUc7OztJQUNoQyxJQUFNQyxNQUFNLEdBQUdKLHNEQUFTLEVBQUU7SUFDMUIsSUFBd0JDLEdBQWUsR0FBZkEsK0NBQVEsQ0FBQyxLQUFLLENBQUMsRUFQM0MsSUFPZSxHQUFhQSxHQUFlLEdBQTVCLEVBUGYsT0FPd0IsR0FBSUEsR0FBZSxHQUFuQjtJQUNwQixJQUFNTSxVQUFVLEdBQUcsV0FBTTtRQUNyQkQsT0FBTyxDQUFDLENBQUNELElBQUksQ0FBQyxDQUFDO0tBQ2xCO0lBQ0QscUJBQ0k7OzBCQUNJLDhEQUFDRyxLQUFHO2dCQUFDQyxPQUFPLEVBQUVGLFVBQVU7Z0JBQUVHLFNBQVMsRUFBQyx1RkFBdUY7MEJBR25IOztzQ0FDSSw4REFBQ0MsTUFBSTs0QkFBQ0QsU0FBUyxFQUFHLDZEQUEyRDs0QkFBR0UsS0FBSyxFQUFFO2dDQUFDQyxlQUFlLEVBQUUsT0FBTztnQ0FBRUMsU0FBUyxFQUFFVCxJQUFJLEdBQUcsZ0RBQWdELEdBQUcsRUFBRTs2QkFBQzs7Ozs7Z0NBQVM7c0NBQ25NLDhEQUFDTSxNQUFJOzRCQUFDRCxTQUFTLEVBQUUseURBQXdELENBQTRCLE9BQTFCLENBQUNMLElBQUksR0FBRyxNQUFNLEdBQUcsUUFBUSxDQUFFOzs7OztnQ0FBUztzQ0FDL0csOERBQUNNLE1BQUk7NEJBQUNELFNBQVMsRUFBRyw2REFBMkQ7NEJBQUdFLEtBQUssRUFBRTtnQ0FBQ0MsZUFBZSxFQUFFLFNBQVM7Z0NBQUVDLFNBQVMsRUFBRVQsSUFBSSxHQUFHLGdEQUFnRCxHQUFHLEVBQUU7NkJBQUM7Ozs7O2dDQUFTOztnQ0FDdE07Ozs7O29CQUVMOzBCQUNOLDhEQUFDRyxLQUFHO2dCQUFDRSxTQUFTLEVBQUMsMkZBQTJGO2dCQUFDRSxLQUFLLEVBQUU7b0JBQzlHRyxNQUFNLEVBQUUsb0JBQW9CO29CQUM1QkMsR0FBRyxFQUFFLE1BQU07b0JBQ1hDLFFBQVEsRUFBRSxVQUFVO29CQUNwQkMsS0FBSyxFQUFFYixJQUFJLEdBQUcsSUFBSSxHQUFHLE1BQU07aUJBQzlCOzBCQUVPSCwrQ0FBYSxDQUFDLGdCQUFla0IsS0FBSzt3QkFBbEJDLElBQUksU0FBSkEsSUFBSSxFQUFFQyxJQUFJLFNBQUpBLElBQUk7eUNBQ3RCLDhEQUFDZCxLQUFHO3dCQUFDQyxPQUFPLEVBQUUsV0FBTTs0QkFDaEJMLE1BQU0sQ0FBQ21CLElBQUksQ0FBQ0QsSUFBSSxDQUFDLENBQUM7NEJBQ2xCaEIsT0FBTyxDQUFDLEtBQUssQ0FBQzt5QkFDakI7a0NBQ0csNEVBQUNFLEtBQUc7NEJBQ0FJLEtBQUssRUFBRTtnQ0FDSFkscUJBQXFCLEVBQUcsTUFBTTs2QkFDakM7NEJBQ0RkLFNBQVMsRUFBQyx3R0FBd0c7c0NBQ3BIVyxJQUFJOzs7OztpQ0FBTzt1QkFOVCxNQUFLLENBQVEsT0FBTkQsS0FBSyxDQUFFOzs7OzZCQU9oQjtpQkFDVCxDQUFDOzs7OztvQkFFSjs7b0JBQ1AsQ0FDTjtDQUNKO0dBMUN1QmpCLFNBQVM7O1FBQ2RILGtEQUFTOzs7QUFESkcsS0FBQUEsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9lbGVtZW50cy9oYW1idXJnZXIudHN4P2I3OTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvcm91dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiXG5pbXBvcnQgeyBuYXZSb3V0ZXMgfSBmcm9tIFwiLi9uYXZcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGFtYnVyZ2VyKCkge1xuICAgIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gICAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGhhbmRsZU9wZW4gPSAoKSA9PiB7XG4gICAgICAgIHNldE9wZW4oIW9wZW4pO1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXtoYW5kbGVPcGVufSBjbGFzc05hbWU9XCJ3LVszLjVyZW1dIGgtWzIuNzVyZW1dIGN1cnNvci1wb2ludGVyIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBtci0yXCI+XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17YGgtWzAuMzVyZW1dIHJvdW5kZWQtbGcgYmctWyNjZWNkY2RmYV0gdHJhbnNpdGlvbi1hbGwgdy1mdWxsYH0gc3R5bGU9e3t0cmFuc2Zvcm1PcmlnaW46IFwiMCUgMCVcIiwgdHJhbnNmb3JtOiBvcGVuID8gXCJyb3RhdGUoNDVkZWcpIHRyYW5zbGF0ZSgwLjUzMjVyZW0sIC0wLjUzMjVyZW0pXCIgOiBcIlwifX0+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgaC1bMC4zNXJlbV0gcm91bmRlZC1sZyBiZy1bI2NlY2RjZGZhXSB0cmFuc2l0aW9uLWFsbCB3LSR7IW9wZW4gPyBcImZ1bGxcIiA6IFwiWzByZW1dXCJ9YH0+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtgaC1bMC4zNXJlbV0gcm91bmRlZC1sZyBiZy1bI2NlY2RjZGZhXSB0cmFuc2l0aW9uLWFsbCB3LWZ1bGxgfSBzdHlsZT17e3RyYW5zZm9ybU9yaWdpbjogXCIwJSAxMDAlXCIsIHRyYW5zZm9ybTogb3BlbiA/IFwicm90YXRlKC00NWRlZykgdHJhbnNsYXRlKDAuNTMyNXJlbSwgMC41MzI1cmVtKVwiIDogXCJcIn19Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBiZy1bIzE2MWMyNF0gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiY2FsYygxMDB2aCAtIDk2cHgpXCIsXG4gICAgICAgICAgICAgICAgdG9wOiBcIjk2cHhcIixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiBvcGVuID8gXCIwJVwiIDogXCIxMDAlXCJcbiAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2Um91dGVzLm1hcCgoe25hbWUsIGhyZWZ9LCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyLnB1c2goaHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3BlbihmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH19IGtleT17YG5hdi0ke2luZGV4fWB9ID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVjb3JhdGlvblNraXBJbmsgOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibmF2LWRpdiBwLTQgdGV4dC13aGl0ZSByb3VuZGVkLWxnIHRleHQtM3hsIGN1cnNvci1wb2ludGVyIGgtWzgwcHhdIGRlY29yYXRpb24tWzRweF0gdW5kZXJsaW5lLW9mZnNldC0xXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA+e25hbWV9PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgKVxufSJdLCJuYW1lcyI6WyJ1c2VSb3V0ZXIiLCJ1c2VTdGF0ZSIsIm5hdlJvdXRlcyIsIkhhbWJ1cmdlciIsInJvdXRlciIsIm9wZW4iLCJzZXRPcGVuIiwiaGFuZGxlT3BlbiIsImRpdiIsIm9uQ2xpY2siLCJjbGFzc05hbWUiLCJzcGFuIiwic3R5bGUiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJ0cmFuc2Zvcm0iLCJoZWlnaHQiLCJ0b3AiLCJwb3NpdGlvbiIsInJpZ2h0IiwibWFwIiwiaW5kZXgiLCJuYW1lIiwiaHJlZiIsInB1c2giLCJ0ZXh0RGVjb3JhdGlvblNraXBJbmsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./elements/hamburger.tsx\n");

/***/ }),

/***/ "./elements/header.tsx":
/*!*****************************!*\
  !*** ./elements/header.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Header; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _react_google_maps_api__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @react-google-maps/api */ \"./node_modules/@react-google-maps/api/dist/esm.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"./node_modules/next/image.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_image__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! recoil */ \"./node_modules/recoil/es/index.js\");\n/* harmony import */ var _state_coords__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../state/coords */ \"./state/coords.ts\");\n/* harmony import */ var _utils_empty__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/empty */ \"./utils/empty.ts\");\n/* harmony import */ var _hamburger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./hamburger */ \"./elements/hamburger.tsx\");\n/* harmony import */ var _nav__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./nav */ \"./elements/nav.tsx\");\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s1, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s1 = _i.next()).done); _n = true){\n            _arr.push(_s1.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\n\n\n\n\n\n\n\n\n\nvar _s = $RefreshSig$();\nvar libraries = [\n    \"places\"\n];\nfunction Header(param) {\n    var transparent = param.transparent, blur = param.blur;\n    _s();\n    var router = (0,next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    var ref5 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)({\n        y: 0,\n        x: 0\n    }), dimensions = ref5[0], setDimensions = ref5[1];\n    var ref1 = _slicedToArray((0,recoil__WEBPACK_IMPORTED_MODULE_4__.useRecoilState)(_state_coords__WEBPACK_IMPORTED_MODULE_5__.coords), 2), ref2 = _slicedToArray(ref1[0], 2), latitude = ref2[0], longitude = ref2[1], setCoords = ref1[1];\n    var ref3 = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null), autocomplete = ref3[0], setAutocomplete = ref3[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_3__.useEffect)(function() {\n        setDimensions({\n            y: window.innerHeight,\n            x: window.innerWidth\n        });\n        window.addEventListener(\"resize\", function() {\n            setDimensions({\n                y: window.innerHeight,\n                x: window.innerWidth\n            });\n        });\n        if (transparent) {\n            document.addEventListener(\"scroll\", function(e) {\n                (0,_utils_empty__WEBPACK_IMPORTED_MODULE_6__[\"default\"])();\n                var scroll = window.scrollY;\n                if (scroll !== 0) {\n                    document.querySelector(\"header\").classList.add(\"moreBackdropFilter\");\n                } else if (scroll === 0) {\n                    document.querySelector(\"header\").classList.remove(\"moreBackdropFilter\");\n                }\n            });\n        } else {\n            document.querySelector(\"header\").classList.add(\"backdropFilter\");\n            document.addEventListener(\"scroll\", function(e) {\n                var scroll = window.scrollY;\n                if (scroll !== 0) {\n                    document.querySelector(\"header\").style.backgroundColor = \"#00366600\";\n                } else if (scroll === 0) {\n                    document.querySelector(\"header\").style.backgroundColor = \"#000000\";\n                }\n            });\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    console.log(blur, \"blur\");\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n            style: {\n                zIndex: 999,\n                backdropFilter: \"blur(\".concat(blur || 10, \"px)\")\n            },\n            className: \"bg-[hsl(0,0%,8%)] h-24 transition-all z-[99999] w-full \".concat(transparent ? \"bg-transparent\" : \"bg-[#161c24]\", \" border-b-[3px] \", \" fixed flex items-center justify-between\"),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    id: \"logo-button\",\n                    className: \"ml-3 rounded-lg z-[100001] w-[158.4px] h-[80px] \".concat(dimensions.x < 730 ? \"image-container\" : \"\"),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_image__WEBPACK_IMPORTED_MODULE_1___default()), {\n                        style: JSON.parse(JSON.stringify({\n                            WebkitUserDrag: \"none\"\n                        })),\n                        src: \"/logo.png\",\n                        alt: \"logo\",\n                        width: \"158.4\",\n                        height: \"80\",\n                        className: \"w-[288px] rounded-lg bg-[whitesmoke] h-full flex items-center ml-2 cursor-pointer\"\n                    }, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n                        lineNumber: 86,\n                        columnNumber: 11\n                    }, this)\n                }, void 0, false, {\n                    fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n                    lineNumber: 80,\n                    columnNumber: 9\n                }, this),\n                dimensions.x < 750 ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_hamburger__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n                        lineNumber: 112,\n                        columnNumber: 13\n                    }, this)\n                }, void 0, false) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_nav__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                            slug: router.asPath.toLocaleLowerCase()\n                        }, void 0, false, {\n                            fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n                            lineNumber: 116,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"right h-full w-auto flex justify-end items-center\",\n                            children: router.route === \"/\" && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                id: \"search\",\n                                className: \"h-fit mr-4\",\n                                style: {\n                                    zIndex: \"100001\"\n                                },\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_9__.LoadScript, {\n                                    libraries: libraries,\n                                    googleMapsApiKey: \"AIzaSyB-eIfHtsnqsbc4oXdpYpjlheBiWWKjw4Q\",\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_google_maps_api__WEBPACK_IMPORTED_MODULE_9__.Autocomplete, {\n                                        className: \"md:hidden sm:hidden lg:block xl:block xs:block\",\n                                        onLoad: function(i) {\n                                            return setAutocomplete(i);\n                                        },\n                                        onPlaceChanged: function() {\n                                            if (autocomplete) {\n                                                var ref, ref4;\n                                                console.log(autocomplete.getPlace());\n                                                var coordinates = [\n                                                    (ref = autocomplete.getPlace().geometry) === null || ref === void 0 ? void 0 : ref.location.lat(),\n                                                    (ref4 = autocomplete.getPlace().geometry) === null || ref4 === void 0 ? void 0 : ref4.location.lng(), \n                                                ];\n                                                setCoords(coordinates);\n                                            }\n                                        },\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"text\",\n                                                placeholder: \"Search\",\n                                                className: \"placeholder:text-white font-bold text-base font-openSans pt-2 pb-2 pr-3 pl-3 transition-all bg-[#303030] focus:bg-[#454545]\",\n                                                style: {\n                                                    boxSizing: \"border-box\",\n                                                    border: \"1px solid transparent\",\n                                                    // width: `50vw`,\n                                                    height: \"auto\",\n                                                    borderRadius: \"5px\",\n                                                    fontSize: \"17.5px\",\n                                                    outline: \"none\",\n                                                    textOverflow: \"ellipses\",\n                                                    // position: \"absolute\",\n                                                    // left: \"50%\",\n                                                    // marginLeft: \"-25vw\",\n                                                    // transform:\n                                                    //   dimensions.x < 750 ? `translateY(-32px)` : \"\",\n                                                    zIndex: \"100001\",\n                                                    color: \"whitesmoke\",\n                                                    backdropFilter: \"blur(15px)\"\n                                                }\n                                            }, void 0, false, {\n                                                fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n                                                lineNumber: 144,\n                                                columnNumber: 23\n                                            }, this)\n                                        }, void 0, false)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n                                        lineNumber: 129,\n                                        columnNumber: 19\n                                    }, this)\n                                }, void 0, false, {\n                                    fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n                                    lineNumber: 125,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n                                lineNumber: 120,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n                            lineNumber: 118,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/kabirchawla/Mathston/firetag/elements/header.tsx\",\n            lineNumber: 74,\n            columnNumber: 7\n        }, this)\n    }, void 0, false);\n};\n_s(Header, \"c4TT2hLazn8k5wEtbdEC23mfdZY=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_2__.useRouter,\n        recoil__WEBPACK_IMPORTED_MODULE_4__.useRecoilState\n    ];\n});\n_c = Header;\nvar _c;\n$RefreshReg$(_c, \"Header\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Qjt5Q0FDRjtrREFFQztzREFDRSw0RUFBQ0ssT0FBSztnREFDSkMsSUFBSSxFQUFDLE1BQU07Z0RBQ1hDLFdBQVcsRUFBQyxRQUFRO2dEQUNwQjVCLFNBQVMsRUFBQyw2SEFBNkg7Z0RBQ3ZJUCxLQUFLLEVBQUU7b0RBQ0xvQyxTQUFTLEVBQUcsWUFBVTtvREFDdEJDLE1BQU0sRUFBRyx1QkFBcUI7b0RBQzlCLGlCQUFpQjtvREFDakJwQixNQUFNLEVBQUcsTUFBSTtvREFDYnFCLFlBQVksRUFBRyxLQUFHO29EQUNsQkMsUUFBUSxFQUFHLFFBQU07b0RBQ2pCQyxPQUFPLEVBQUcsTUFBSTtvREFDZEMsWUFBWSxFQUFHLFVBQVE7b0RBQ3ZCLHdCQUF3QjtvREFDeEIsZUFBZTtvREFDZix1QkFBdUI7b0RBQ3ZCLGFBQWE7b0RBQ2IsbURBQW1EO29EQUNuRHBDLE1BQU0sRUFBRSxRQUFRO29EQUNoQnFDLEtBQUssRUFBRSxZQUFZO29EQUNuQnBDLGNBQWMsRUFBRSxZQUFZO2lEQUM3Qjs7Ozs7b0RBQ0Q7eURBRUQ7Ozs7OzRDQUNVOzs7Ozt3Q0FDSjs7Ozs7b0NBQ1Q7Ozs7O2dDQVlGOztnQ0FDTDs7Ozs7O2dCQUVFO3FCQUNSLENBQ0g7Q0FDSDtHQS9LdUIvQixNQUFNOztRQU9iVCxrREFBUztRQVFwQkcsa0RBQWM7OztBQWZJTSxLQUFBQSxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2VsZW1lbnRzL2hlYWRlci50c3g/NTQ3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBdXRvY29tcGxldGUsIExvYWRTY3JpcHQgfSBmcm9tIFwiQHJlYWN0LWdvb2dsZS1tYXBzL2FwaVwiO1xuaW1wb3J0IEltYWdlIGZyb20gXCJuZXh0L2ltYWdlXCI7XG5pbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XG5pbXBvcnQgcm91dGVyLCB7IHVzZVJvdXRlciB9IGZyb20gXCJuZXh0L3JvdXRlclwiO1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUmVjb2lsU3RhdGUgfSBmcm9tIFwicmVjb2lsXCI7XG5pbXBvcnQgeyBjb29yZHMgfSBmcm9tIFwiLi4vc3RhdGUvY29vcmRzXCI7XG5pbXBvcnQgZW1wdHkgZnJvbSBcIi4uL3V0aWxzL2VtcHR5XCI7XG5pbXBvcnQgSGFtYnVyZ2VyIGZyb20gXCIuL2hhbWJ1cmdlclwiO1xuaW1wb3J0IE5hdiBmcm9tIFwiLi9uYXZcIjtcblxuY29uc3QgbGlicmFyaWVzOiBhbnkgPSBbXCJwbGFjZXNcIl07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhlYWRlcih7XG4gIHRyYW5zcGFyZW50LFxuICBibHVyLFxufToge1xuICB0cmFuc3BhcmVudDogYm9vbGVhbjtcbiAgYmx1cjogbnVtYmVyIHwgbnVsbDtcbn0pIHtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIGNvbnN0IFtkaW1lbnNpb25zLCBzZXREaW1lbnNpb25zXSA9IHVzZVN0YXRlKHtcbiAgICB5OiAwLFxuICAgIHg6IDAsXG4gIH0pO1xuICBjb25zdCBbW2xhdGl0dWRlLCBsb25naXR1ZGVdLCBzZXRDb29yZHNdOiBbXG4gICAgW251bGwgfCBudW1iZXIsIG51bGwgfCBudW1iZXJdLFxuICAgIFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPFtudW1iZXIsIG51bWJlcl0gfCBbbnVsbCwgbnVsbF0+PlxuICBdID0gdXNlUmVjb2lsU3RhdGUoY29vcmRzKTtcbiAgY29uc3QgW1xuICAgIGF1dG9jb21wbGV0ZSxcbiAgICBzZXRBdXRvY29tcGxldGUsXG4gIF0gPSB1c2VTdGF0ZTxhbnk+KG51bGwpXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgc2V0RGltZW5zaW9ucyh7XG4gICAgICB5OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICB4OiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKSA9PiB7XG4gICAgICBzZXREaW1lbnNpb25zKHtcbiAgICAgICAgeTogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICB4OiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmICh0cmFuc3BhcmVudCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCAoZSkgPT4ge1xuICAgICAgICBlbXB0eSgpO1xuICAgICAgICBjb25zdCBzY3JvbGwgPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICAgICAgaWYgKHNjcm9sbCAhPT0gMCkge1xuICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkZXJcIikuY2xhc3NMaXN0LmFkZChcIm1vcmVCYWNrZHJvcEZpbHRlclwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChzY3JvbGwgPT09IDApIHtcbiAgICAgICAgICBkb2N1bWVudFxuICAgICAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoXCJoZWFkZXJcIilcbiAgICAgICAgICAgIC5jbGFzc0xpc3QucmVtb3ZlKFwibW9yZUJhY2tkcm9wRmlsdGVyXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImhlYWRlclwiKS5jbGFzc0xpc3QuYWRkKFwiYmFja2Ryb3BGaWx0ZXJcIik7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIChlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjcm9sbCA9IHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICBpZiAoc2Nyb2xsICE9PSAwKSB7XG4gICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImhlYWRlclwiKS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiMwMDM2NjYwMFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbCA9PT0gMCkge1xuICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkZXJcIikuc3R5bGUuYmFja2dyb3VuZENvbG9yID1cbiAgICAgICAgICAgIFwiIzAwMDAwMFwiO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIGNvbnNvbGUubG9nKGJsdXIsIFwiYmx1clwiKTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGhlYWRlclxuICAgICAgICBzdHlsZT17eyB6SW5kZXg6IDk5OSwgYmFja2Ryb3BGaWx0ZXI6IGBibHVyKCR7Ymx1ciB8fCAxMH1weClgIH19XG4gICAgICAgIGNsYXNzTmFtZT17YGJnLVtoc2woMCwwJSw4JSldIGgtMjQgdHJhbnNpdGlvbi1hbGwgei1bOTk5OTldIHctZnVsbCAke1xuICAgICAgICAgIHRyYW5zcGFyZW50ID8gXCJiZy10cmFuc3BhcmVudFwiIDogXCJiZy1bIzE2MWMyNF1cIlxuICAgICAgICB9IGJvcmRlci1iLVszcHhdICR7XCJcIn0gZml4ZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuYH1cbiAgICAgID5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGlkPVwibG9nby1idXR0b25cIlxuICAgICAgICAgIGNsYXNzTmFtZT17YG1sLTMgcm91bmRlZC1sZyB6LVsxMDAwMDFdIHctWzE1OC40cHhdIGgtWzgwcHhdICR7XG4gICAgICAgICAgICBkaW1lbnNpb25zLnggPCA3MzAgPyBcImltYWdlLWNvbnRhaW5lclwiIDogXCJcIlxuICAgICAgICAgIH1gfVxuICAgICAgICA+XG4gICAgICAgICAgPEltYWdlXG4gICAgICAgICAgICBzdHlsZT17SlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIFdlYmtpdFVzZXJEcmFnOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICBzcmM9XCIvbG9nby5wbmdcIlxuICAgICAgICAgICAgYWx0PVwibG9nb1wiXG4gICAgICAgICAgICB3aWR0aD1cIjE1OC40XCJcbiAgICAgICAgICAgIGhlaWdodD1cIjgwXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17YHctWzI4OHB4XSByb3VuZGVkLWxnIGJnLVt3aGl0ZXNtb2tlXSBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIgbWwtMiBjdXJzb3ItcG9pbnRlcmB9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIHtkaW1lbnNpb25zLnggPCA3NTAgPyAoXG4gICAgICAgICAgPD5cbiAgICAgICAgICAgIHsvKiA8YnV0dG9uXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLVsjMDBhM2FjXSBtci00IHJvdW5kZWQtWzhweF0gaG92ZXI6YmctWyMwMzVmN2JdIGN1cnNvci1wb2ludGVyIHRyYW5zaXRpb24tYWxsIHRleHQtd2hpdGUgZm9udC1ib2xkIHRleHQtYmFzZVwiXG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHJvdXRlci5yZXBsYWNlKFwiL2xvZ2luXCIpfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgdy1mdWxsIGN1cnNvci1wb2ludGVyIGgtZnVsbCBwdC0yIHBiLTIgcHItNSBwbC01IHJvdW5kZWQtWzhweF1gfVxuICAgICAgICAgICAgICAgIGRhdGEtYW5pbWF0aW9uPVwicmlwcGxlXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIExvZ2luXG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9idXR0b24+ICovfVxuICAgICAgICAgICAgPEhhbWJ1cmdlciAvPlxuICAgICAgICAgIDwvPlxuICAgICAgICApIDogKFxuICAgICAgICAgIDw+XG4gICAgICAgICAgICA8TmF2IHNsdWc9e3JvdXRlci5hc1BhdGgudG9Mb2NhbGVMb3dlckNhc2UoKX0+PC9OYXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmlnaHQgaC1mdWxsIHctYXV0byBmbGV4IGp1c3RpZnktZW5kIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICB7cm91dGVyLnJvdXRlID09PSBcIi9cIiAmJiBcbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGlkPVwic2VhcmNoXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BoLWZpdCBtci00YH1cbiAgICAgICAgICAgICAgICBzdHlsZT17eyB6SW5kZXg6IFwiMTAwMDAxXCIgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxMb2FkU2NyaXB0XG4gICAgICAgICAgICAgICAgICBsaWJyYXJpZXM9e2xpYnJhcmllc31cbiAgICAgICAgICAgICAgICAgIGdvb2dsZU1hcHNBcGlLZXk9XCJBSXphU3lCLWVJZkh0c25xc2JjNG9YZHBZcGpsaGVCaVdXS2p3NFFcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxBdXRvY29tcGxldGVcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1kOmhpZGRlbiBzbTpoaWRkZW4gbGc6YmxvY2sgeGw6YmxvY2sgeHM6YmxvY2tcIlxuICAgICAgICAgICAgICAgICAgb25Mb2FkPXsoaSkgPT4gc2V0QXV0b2NvbXBsZXRlKGkpfVxuICAgICAgICAgICAgICAgICAgb25QbGFjZUNoYW5nZWQ9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGF1dG9jb21wbGV0ZS5nZXRQbGFjZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb29yZGluYXRlczogW251bWJlciwgbnVtYmVyXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZS5nZXRQbGFjZSgpLmdlb21ldHJ5Py5sb2NhdGlvbi5sYXQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9jb21wbGV0ZS5nZXRQbGFjZSgpLmdlb21ldHJ5Py5sb2NhdGlvbi5sbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgIHNldENvb3Jkcyhjb29yZGluYXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlYXJjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwbGFjZWhvbGRlcjp0ZXh0LXdoaXRlIGZvbnQtYm9sZCB0ZXh0LWJhc2UgZm9udC1vcGVuU2FucyBwdC0yIHBiLTIgcHItMyBwbC0zIHRyYW5zaXRpb24tYWxsIGJnLVsjMzAzMDMwXSBmb2N1czpiZy1bIzQ1NDU0NV1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYm94U2l6aW5nOiBgYm9yZGVyLWJveGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogYDFweCBzb2xpZCB0cmFuc3BhcmVudGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpZHRoOiBgNTB2d2AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogYGF1dG9gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IGA1cHhgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogYDE3LjVweGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dGxpbmU6IGBub25lYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE92ZXJmbG93OiBgZWxsaXBzZXNgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsZWZ0OiBcIjUwJVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXJnaW5MZWZ0OiBcIi0yNXZ3XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkaW1lbnNpb25zLnggPCA3NTAgPyBgdHJhbnNsYXRlWSgtMzJweClgIDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgekluZGV4OiBcIjEwMDAwMVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCJ3aGl0ZXNtb2tlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tkcm9wRmlsdGVyOiBcImJsdXIoMTVweClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgICAgLz5cblxuICAgICAgICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICAgICAgIDwvQXV0b2NvbXBsZXRlPlxuICAgICAgICAgICAgICAgIDwvTG9hZFNjcmlwdD5cbiAgICAgICAgICAgICAgPC9kaXY+fVxuICAgICAgICAgICAgICB7LyogPGJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJnLVsjMzAzMDMwXSBob3ZlcjpiZy1bIzQ1NDU0NV0gcm91bmRlZC1bNXB4XSB6LVsxMDAwMDFdIG1yLTQgY3Vyc29yLXBvaW50ZXIgaC1taW4gdHJhbnNpdGlvbi1hbGwgdGV4dC13aGl0ZSBmb250LWJvbGQgdGV4dC1iYXNlIGZvbnQtb3BlblNhbnNcIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHJvdXRlci5yZXBsYWNlKFwiL2xvZ2luXCIpfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgdy1mdWxsIGgtbWluIHB0LTIgcGItMiBwci01IHBsLTUgcm91bmRlZC1bNXB4XWB9XG4gICAgICAgICAgICAgICAgICBkYXRhLWFuaW1hdGlvbj1cInJpcHBsZVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgTG9naW5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9idXR0b24+ICovfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC8+XG4gICAgICAgICl9XG4gICAgICA8L2hlYWRlcj5cbiAgICA8Lz5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJBdXRvY29tcGxldGUiLCJMb2FkU2NyaXB0IiwiSW1hZ2UiLCJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsInVzZVJlY29pbFN0YXRlIiwiY29vcmRzIiwiZW1wdHkiLCJIYW1idXJnZXIiLCJOYXYiLCJsaWJyYXJpZXMiLCJIZWFkZXIiLCJ0cmFuc3BhcmVudCIsImJsdXIiLCJyb3V0ZXIiLCJ5IiwieCIsImRpbWVuc2lvbnMiLCJzZXREaW1lbnNpb25zIiwibGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJzZXRDb29yZHMiLCJhdXRvY29tcGxldGUiLCJzZXRBdXRvY29tcGxldGUiLCJ3aW5kb3ciLCJpbm5lckhlaWdodCIsImlubmVyV2lkdGgiLCJhZGRFdmVudExpc3RlbmVyIiwiZG9jdW1lbnQiLCJlIiwic2Nyb2xsIiwic2Nyb2xsWSIsInF1ZXJ5U2VsZWN0b3IiLCJjbGFzc0xpc3QiLCJhZGQiLCJyZW1vdmUiLCJzdHlsZSIsImJhY2tncm91bmRDb2xvciIsImNvbnNvbGUiLCJsb2ciLCJoZWFkZXIiLCJ6SW5kZXgiLCJiYWNrZHJvcEZpbHRlciIsImNsYXNzTmFtZSIsImJ1dHRvbiIsImlkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiV2Via2l0VXNlckRyYWciLCJzcmMiLCJhbHQiLCJ3aWR0aCIsImhlaWdodCIsInNsdWciLCJhc1BhdGgiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsImRpdiIsInJvdXRlIiwiZ29vZ2xlTWFwc0FwaUtleSIsIm9uTG9hZCIsImkiLCJvblBsYWNlQ2hhbmdlZCIsImdldFBsYWNlIiwiY29vcmRpbmF0ZXMiLCJnZW9tZXRyeSIsImxvY2F0aW9uIiwibGF0IiwibG5nIiwiaW5wdXQiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJib3hTaXppbmciLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJmb250U2l6ZSIsIm91dGxpbmUiLCJ0ZXh0T3ZlcmZsb3ciLCJjb2xvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./elements/header.tsx\n");

/***/ }),

/***/ "./elements/nav.tsx":
/*!**************************!*\
  !*** ./elements/nav.tsx ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Nav; },\n/* harmony export */   \"navRoutes\": function() { return /* binding */ navRoutes; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/router */ \"./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nvar _s = $RefreshSig$();\nvar navRoutes = [\n    {\n        href: \"/\",\n        name: \"Home\"\n    },\n    {\n        href: \"/about\",\n        name: \"About\"\n    },\n    {\n        href: \"/portal\",\n        name: \"Portal\"\n    },\n    {\n        href: \"/support-us\",\n        name: \"Support Us\"\n    }, \n];\nvar widths = [\n    52.609,\n    52.961,\n    51.023,\n    98.359\n];\nvar margins = [\n    49,\n    widths[1 - 1] + 32 * 1 + 49,\n    widths[1 - 1] + widths[2 - 1] + 32 * 2 + 49,\n    widths[1 - 1] + widths[2 - 1] + widths[3 - 1] + 32 * 3 + 49,\n    widths[1 - 1] + widths[2 - 1] + widths[3 - 1] + widths[4 - 1] + 32 * 4 + 49, \n];\nfunction Nav(param1) {\n    var slug = param1.slug;\n    var _this = this;\n    _s();\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_2__.useReducer)(function(x) {\n        return x + 1;\n    }, 0), forceUpdate = ref[1];\n    var router = (0,next_router__WEBPACK_IMPORTED_MODULE_1__.useRouter)();\n    var home = router.asPath === \"/\";\n    var calculatedPreLocation = false;\n    var preLocation = -1;\n    console.log(\"\".concat(router.asPath.trim()));\n    if (!calculatedPreLocation) {\n        console.log(slug);\n        switch(slug){\n            case \"/\":\n                console.log(\"caught\");\n                preLocation = 0;\n                calculatedPreLocation = true;\n                break;\n            case \"/about\":\n                preLocation = 1;\n                calculatedPreLocation = true;\n                break;\n            case \"/portal\":\n                preLocation = 2;\n                console.log(\"?\", slug);\n                calculatedPreLocation = true;\n                break;\n            case \"/support-us\":\n                preLocation = 4;\n                calculatedPreLocation = true;\n                break;\n        }\n    }\n    var ref1 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(preLocation), location = ref1[0], setLocation = ref1[1];\n    console.log(\"location\", location);\n    var ref2 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false), hovered = ref2[0], setHovered = ref2[1];\n    var ref3 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false), clicked = ref3[0], setClicked = ref3[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function() {\n        if (!hovered) {\n            if (location !== preLocation) {\n                setLocation(preLocation);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        hovered\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function() {\n        console.log(\"setup event listener\");\n        document.getElementById(\"logo-button\").addEventListener(\"click\", function() {\n            setClicked(true);\n            setLocation(1);\n            setTimeout(function() {\n                router.replace(\"/\");\n                setClicked(true);\n                setLocation(1);\n            }, 0);\n        });\n    }, [\n        router\n    ]);\n    var _location;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                className: \"flex flex-col p-4 text-white z-[100000] fixed w-screen items-center justify-center\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    id: \"container\",\n                    className: \"flex items-center justify-center w-[484px]\",\n                    children: navRoutes.map(function(param, index) {\n                        var name = param.name, href = param.href;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            id: \"nav-\".concat(index),\n                            onClick: function() {\n                                setClicked(true);\n                                setLocation(index);\n                                setTimeout(function() {\n                                    router.replace(href);\n                                    setClicked(true);\n                                    setLocation(index);\n                                }, 0);\n                            },\n                            onMouseEnter: function() {\n                                setHovered(true);\n                                setLocation(index);\n                                setClicked(false);\n                            },\n                            onMouseOver: function() {\n                                setHovered(true);\n                                setLocation(index);\n                                setClicked(false);\n                            },\n                            onMouseLeave: function() {\n                                if (!clicked) {\n                                    setHovered(false);\n                                }\n                            },\n                            style: {},\n                            className: \"nav-div p-4 text-white rounded-lg text-xl cursor-pointer h-[60px]\",\n                            children: name\n                        }, \"nav-\".concat(index), false, {\n                            fileName: \"/Users/kabirchawla/Mathston/firetag/elements/nav.tsx\",\n                            lineNumber: 100,\n                            columnNumber: 13\n                        }, _this);\n                    })\n                }, void 0, false, {\n                    fileName: \"/Users/kabirchawla/Mathston/firetag/elements/nav.tsx\",\n                    lineNumber: 95,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/kabirchawla/Mathston/firetag/elements/nav.tsx\",\n                lineNumber: 92,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"fixed w-[452px] h-1 translate-y-3\",\n                style: {\n                    margin: \"0 calc((100vw - 452px)/2)\"\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"transition-all ease-squared rounded-[4px] bg-[#f3e3e3] h-full translate-x-[1px]\",\n                    id: \"bar\",\n                    style: {\n                        width: \"\".concat((_location = widths[location]) !== null && _location !== void 0 ? _location : 0, \"px\"),\n                        marginLeft: \"\".concat(margins[location], \"px\")\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/kabirchawla/Mathston/firetag/elements/nav.tsx\",\n                    lineNumber: 140,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/kabirchawla/Mathston/firetag/elements/nav.tsx\",\n                lineNumber: 136,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n};\n_s(Nav, \"HlHORw4ZvHACOKd4X4p6oFNsERo=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_1__.useRouter\n    ];\n});\n_c = Nav;\nvar _c;\n$RefreshReg$(_c, \"Nav\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVcsQ0FBQ2UsS0FBSyxDQUFDLENBQUM7Z0NBQ25CWCxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7NkJBQ25COzRCQUNEZSxZQUFZLEVBQUUsV0FBTTtnQ0FDbEIsSUFBSSxDQUFDaEIsT0FBTyxFQUFFO29DQUNaRCxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7aUNBQ25COzZCQUNGOzRCQUNEa0IsS0FBSyxFQUFFLEVBQUU7NEJBRVRULFNBQVMsRUFBQyxtRUFBbUU7c0NBRTVFM0IsSUFBSTsyQkFIQSxNQUFLLENBQVEsT0FBTitCLEtBQUssQ0FBRTs7OztpQ0FJZjtxQkFDUCxDQUFDOzs7Ozt3QkFDRTs7Ozs7b0JBRUY7MEJBQ04sOERBQUNILEtBQUc7Z0JBQ0ZELFNBQVMsRUFBRyxtQ0FBcUM7Z0JBQ2pEUyxLQUFLLEVBQUU7b0JBQUVDLE1BQU0sRUFBRSwyQkFBMkI7aUJBQUU7MEJBRTlDLDRFQUFDVCxLQUFHO29CQUNGRCxTQUFTLEVBQUMsaUZBQWlGO29CQUMzRkUsRUFBRSxFQUFDLEtBQUs7b0JBQ1JPLEtBQUssRUFBRTt3QkFDTEUsS0FBSyxFQUFFLEVBQUMsQ0FBd0IsTUFBRSxDQUF4QnJDLENBQUFBLFNBQWdCLEdBQWhCQSxNQUFNLENBQUNjLFFBQVEsQ0FBQyxjQUFoQmQsU0FBZ0IsY0FBaEJBLFNBQWdCLEdBQUksQ0FBQyxFQUFDLElBQUUsQ0FBQzt3QkFDbkNzQyxVQUFVLEVBQUUsRUFBQyxDQUFvQixNQUFFLENBQXBCckMsT0FBTyxDQUFDYSxRQUFRLENBQUMsRUFBQyxJQUFFLENBQUM7cUJBQ3JDOzs7Ozt3QkFDSTs7Ozs7b0JBQ0g7O29CQUNMLENBQ0g7Q0FDSDtHQXJIdUJaLEdBQUc7O1FBRVZULGtEQUFTOzs7QUFGRlMsS0FBQUEsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9lbGVtZW50cy9uYXYudHN4PzMwOGIiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQG5leHQvbmV4dC9saW5rLXBhc3NocmVmICovXG5pbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tIFwibmV4dC9yb3V0ZXJcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVkdWNlciwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGNvbnN0IG5hdlJvdXRlcyA9IFtcbiAge1xuICAgIGhyZWY6IFwiL1wiLFxuICAgIG5hbWU6IFwiSG9tZVwiLFxuICB9LFxuICB7XG4gICAgaHJlZjogXCIvYWJvdXRcIixcbiAgICBuYW1lOiBcIkFib3V0XCIsXG4gIH0sXG4gIHtcbiAgICBocmVmOiBcIi9wb3J0YWxcIixcbiAgICBuYW1lOiBcIlBvcnRhbFwiLFxuICB9LFxuICB7XG4gICAgaHJlZjogXCIvc3VwcG9ydC11c1wiLFxuICAgIG5hbWU6IFwiU3VwcG9ydCBVc1wiLFxuICB9LFxuXTtcblxuY29uc3Qgd2lkdGhzID0gWzUyLjYwOSwgNTIuOTYxLCA1MS4wMjMsIDk4LjM1OV07XG5jb25zdCBtYXJnaW5zID0gW1xuICA0OSxcbiAgd2lkdGhzWzEgLSAxXSArIDMyICogMSArIDQ5LFxuICB3aWR0aHNbMSAtIDFdICsgd2lkdGhzWzIgLSAxXSArIDMyICogMiArIDQ5LFxuICB3aWR0aHNbMSAtIDFdICsgd2lkdGhzWzIgLSAxXSArIHdpZHRoc1szIC0gMV0gKyAzMiAqIDMgKyA0OSxcbiAgd2lkdGhzWzEgLSAxXSArIHdpZHRoc1syIC0gMV0gKyB3aWR0aHNbMyAtIDFdICsgd2lkdGhzWzQgLSAxXSArIDMyICogNCArIDQ5LFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTmF2KHsgc2x1ZyB9OiB7IHNsdWc6IHN0cmluZyB9KSB7XG4gIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoKHgpID0+IHggKyAxLCAwKTtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIGxldCBob21lID0gcm91dGVyLmFzUGF0aCA9PT0gXCIvXCI7XG4gIGxldCBjYWxjdWxhdGVkUHJlTG9jYXRpb24gPSBmYWxzZTtcbiAgbGV0IHByZUxvY2F0aW9uID0gLTE7XG4gIGNvbnNvbGUubG9nKGAke3JvdXRlci5hc1BhdGgudHJpbSgpfWApO1xuICBpZiAoIWNhbGN1bGF0ZWRQcmVMb2NhdGlvbikge1xuICAgIGNvbnNvbGUubG9nKHNsdWcpO1xuICAgIHN3aXRjaCAoc2x1Zykge1xuICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgY29uc29sZS5sb2coXCJjYXVnaHRcIik7XG4gICAgICAgIHByZUxvY2F0aW9uID0gMDtcbiAgICAgICAgY2FsY3VsYXRlZFByZUxvY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiL2Fib3V0XCI6XG4gICAgICAgIHByZUxvY2F0aW9uID0gMTtcbiAgICAgICAgY2FsY3VsYXRlZFByZUxvY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiL3BvcnRhbFwiOlxuICAgICAgICBwcmVMb2NhdGlvbiA9IDI7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiP1wiLCBzbHVnKTtcbiAgICAgICAgY2FsY3VsYXRlZFByZUxvY2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiL3N1cHBvcnQtdXNcIjpcbiAgICAgICAgcHJlTG9jYXRpb24gPSA0O1xuICAgICAgICBjYWxjdWxhdGVkUHJlTG9jYXRpb24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgW2xvY2F0aW9uLCBzZXRMb2NhdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXI+KHByZUxvY2F0aW9uKTtcbiAgY29uc29sZS5sb2coXCJsb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gIGNvbnN0IFtob3ZlcmVkLCBzZXRIb3ZlcmVkXSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgW2NsaWNrZWQsIHNldENsaWNrZWRdID0gdXNlU3RhdGU8Ym9vbGVhbj4oZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaG92ZXJlZCkge1xuICAgICAgaWYgKGxvY2F0aW9uICE9PSBwcmVMb2NhdGlvbikge1xuICAgICAgICBzZXRMb2NhdGlvbihwcmVMb2NhdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2hvdmVyZWRdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwic2V0dXAgZXZlbnQgbGlzdGVuZXJcIik7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsb2dvLWJ1dHRvblwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgc2V0Q2xpY2tlZCh0cnVlKTtcbiAgICAgIHNldExvY2F0aW9uKDEpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHJvdXRlci5yZXBsYWNlKFwiL1wiKTtcbiAgICAgICAgc2V0Q2xpY2tlZCh0cnVlKTtcbiAgICAgICAgc2V0TG9jYXRpb24oMSk7XG4gICAgICB9LCAwKTtcbiAgICB9KTtcbiAgfSwgW3JvdXRlcl0pO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxuYXZcbiAgICAgICAgY2xhc3NOYW1lPXtgZmxleCBmbGV4LWNvbCBwLTQgdGV4dC13aGl0ZSB6LVsxMDAwMDBdIGZpeGVkIHctc2NyZWVuIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlcmB9XG4gICAgICA+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBpZD1cImNvbnRhaW5lclwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgdy1bNDg0cHhdXCJcbiAgICAgICAgPlxuICAgICAgICAgIHtuYXZSb3V0ZXMubWFwKCh7IG5hbWUsIGhyZWYgfSwgaW5kZXgpID0+IChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgaWQ9e2BuYXYtJHtpbmRleH1gfVxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Q2xpY2tlZCh0cnVlKTtcbiAgICAgICAgICAgICAgICBzZXRMb2NhdGlvbihpbmRleCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICByb3V0ZXIucmVwbGFjZShocmVmKTtcbiAgICAgICAgICAgICAgICAgIHNldENsaWNrZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICBzZXRMb2NhdGlvbihpbmRleCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldEhvdmVyZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2V0TG9jYXRpb24oaW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldENsaWNrZWQoZmFsc2UpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBvbk1vdXNlT3Zlcj17KCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldEhvdmVyZWQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgc2V0TG9jYXRpb24oaW5kZXgpO1xuICAgICAgICAgICAgICAgIHNldENsaWNrZWQoZmFsc2UpO1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICBvbk1vdXNlTGVhdmU9eygpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWNsaWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgIHNldEhvdmVyZWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgc3R5bGU9e3t9fVxuICAgICAgICAgICAgICBrZXk9e2BuYXYtJHtpbmRleH1gfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJuYXYtZGl2IHAtNCB0ZXh0LXdoaXRlIHJvdW5kZWQtbGcgdGV4dC14bCBjdXJzb3ItcG9pbnRlciBoLVs2MHB4XVwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtuYW1lfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7Lyoge3JvdXRlci5hc1BhdGggPT09IFwiL1wiICYmIDxoMSBjbGFzc05hbWU9XCJwYi0zIHRleHQtbGdcIj5QcmVzcyBvbiBzaGFyZSBteSBsb2NhdGlvbiB0byByZXBvcnQgYSBmaXJlPC9oMT59ICovfVxuICAgICAgPC9uYXY+XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17YGZpeGVkIHctWzQ1MnB4XSBoLTEgJHsndHJhbnNsYXRlLXktMyd9YH1cbiAgICAgICAgc3R5bGU9e3sgbWFyZ2luOiBcIjAgY2FsYygoMTAwdncgLSA0NTJweCkvMilcIiB9fVxuICAgICAgPlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwidHJhbnNpdGlvbi1hbGwgZWFzZS1zcXVhcmVkIHJvdW5kZWQtWzRweF0gYmctWyNmM2UzZTNdIGgtZnVsbCB0cmFuc2xhdGUteC1bMXB4XVwiXG4gICAgICAgICAgaWQ9XCJiYXJcIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICB3aWR0aDogYCR7d2lkdGhzW2xvY2F0aW9uXSA/PyAwfXB4YCxcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IGAke21hcmdpbnNbbG9jYXRpb25dfXB4YCxcbiAgICAgICAgICB9fVxuICAgICAgICA+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VSb3V0ZXIiLCJ1c2VFZmZlY3QiLCJ1c2VSZWR1Y2VyIiwidXNlU3RhdGUiLCJuYXZSb3V0ZXMiLCJocmVmIiwibmFtZSIsIndpZHRocyIsIm1hcmdpbnMiLCJOYXYiLCJzbHVnIiwieCIsImZvcmNlVXBkYXRlIiwicm91dGVyIiwiaG9tZSIsImFzUGF0aCIsImNhbGN1bGF0ZWRQcmVMb2NhdGlvbiIsInByZUxvY2F0aW9uIiwiY29uc29sZSIsImxvZyIsInRyaW0iLCJsb2NhdGlvbiIsInNldExvY2F0aW9uIiwiaG92ZXJlZCIsInNldEhvdmVyZWQiLCJjbGlja2VkIiwic2V0Q2xpY2tlZCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJhZGRFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsInJlcGxhY2UiLCJuYXYiLCJjbGFzc05hbWUiLCJkaXYiLCJpZCIsIm1hcCIsImluZGV4Iiwib25DbGljayIsIm9uTW91c2VFbnRlciIsIm9uTW91c2VPdmVyIiwib25Nb3VzZUxlYXZlIiwic3R5bGUiLCJtYXJnaW4iLCJ3aWR0aCIsIm1hcmdpbkxlZnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./elements/nav.tsx\n");

/***/ }),

/***/ "./elements/views/loading.tsx":
/*!************************************!*\
  !*** ./elements/views/loading.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Loading; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _hooks_useLoading__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../hooks/useLoading */ \"./hooks/useLoading.ts\");\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s1, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s1 = _i.next()).done); _n = true){\n            _arr.push(_s1.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\n\nvar _s = $RefreshSig$();\nfunction Loading() {\n    _s();\n    var ref = _slicedToArray((0,_hooks_useLoading__WEBPACK_IMPORTED_MODULE_1__.useLoading)(), 1), loading = ref[0];\n    if (loading) {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                zIndex: 99998,\n                height: \"calc(100vh - 93px)\"\n            },\n            className: \"w-screen absolute mt-[93px] flex justify-center items-center backdrop-blur-lg bg-[rgba(71,85,115,0.6)]\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    zIndex: 99999\n                },\n                id: \"loading-container\",\n                className: \"h-[14rem] w-[14rem] aspect-square relative\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/elements/views/loading.tsx\",\n                        lineNumber: 9,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/elements/views/loading.tsx\",\n                        lineNumber: 10,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/elements/views/loading.tsx\",\n                        lineNumber: 11,\n                        columnNumber: 21\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/elements/views/loading.tsx\",\n                        lineNumber: 12,\n                        columnNumber: 21\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/kabirchawla/Mathston/firetag/elements/views/loading.tsx\",\n                lineNumber: 8,\n                columnNumber: 17\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/kabirchawla/Mathston/firetag/elements/views/loading.tsx\",\n            lineNumber: 7,\n            columnNumber: 13\n        }, this);\n    } else {\n        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, void 0, false);\n    }\n};\n_s(Loading, \"S+vrfMBtxAJZeJsJ1XBZnjFAvkc=\", false, function() {\n    return [\n        _hooks_useLoading__WEBPACK_IMPORTED_MODULE_1__.useLoading\n    ];\n});\n_c = Loading;\nvar _c;\n$RefreshReg$(_c, \"Loading\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9lbGVtZW50cy92aWV3cy9sb2FkaW5nLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1EOztBQUVwQyxTQUFTQyxPQUFPLEdBQUc7O0lBQzlCLElBQWtCRCxHQUFZLGtCQUFaQSw2REFBVSxFQUFFLE1BQXZCRSxPQUFPLEdBQUlGLEdBQVksR0FBaEI7SUFDZCxJQUFHRSxPQUFPLEVBQUU7UUFDUixxQkFDSSw4REFBQ0MsS0FBRztZQUFDQyxLQUFLLEVBQUU7Z0JBQUNDLE1BQU0sRUFBRSxLQUFLO2dCQUFFQyxNQUFNLEVBQUUsb0JBQW9CO2FBQUM7WUFBRUMsU0FBUyxFQUFDLHdHQUF3RztzQkFDekssNEVBQUNKLEtBQUc7Z0JBQUNDLEtBQUssRUFBRTtvQkFBQ0MsTUFBTSxFQUFFLEtBQUs7aUJBQUM7Z0JBQUVHLEVBQUUsRUFBQyxtQkFBbUI7Z0JBQUNELFNBQVMsRUFBQyw0Q0FBNEM7O2tDQUN0Ryw4REFBQ0osS0FBRzs7Ozs0QkFBTztrQ0FDWCw4REFBQ0EsS0FBRzs7Ozs0QkFBTztrQ0FDWCw4REFBQ0EsS0FBRzs7Ozs0QkFBTztrQ0FDWCw4REFBQ0EsS0FBRzs7Ozs0QkFBTzs7Ozs7O29CQUNUOzs7OztnQkFDSixDQUNUO0tBQ0osTUFBTTtRQUNILHFCQUNJLDZJQUNHLENBQ047S0FDSjtDQUNKO0dBbkJ1QkYsT0FBTzs7UUFDVEQseURBQVU7OztBQURSQyxLQUFBQSxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2VsZW1lbnRzL3ZpZXdzL2xvYWRpbmcudHN4PzJjZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlTG9hZGluZyB9IGZyb20gXCIuLi8uLi9ob29rcy91c2VMb2FkaW5nXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gTG9hZGluZygpIHtcbiAgICBjb25zdCBbbG9hZGluZ10gPSB1c2VMb2FkaW5nKClcbiAgICBpZihsb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IHN0eWxlPXt7ekluZGV4OiA5OTk5OCwgaGVpZ2h0OiBcImNhbGMoMTAwdmggLSA5M3B4KVwifX0gY2xhc3NOYW1lPVwidy1zY3JlZW4gYWJzb2x1dGUgbXQtWzkzcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIGJhY2tkcm9wLWJsdXItbGcgYmctW3JnYmEoNzEsODUsMTE1LDAuNildXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17e3pJbmRleDogOTk5OTl9fSBpZD1cImxvYWRpbmctY29udGFpbmVyXCIgY2xhc3NOYW1lPVwiaC1bMTRyZW1dIHctWzE0cmVtXSBhc3BlY3Qtc3F1YXJlIHJlbGF0aXZlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgPC8+XG4gICAgICAgIClcbiAgICB9XG59Il0sIm5hbWVzIjpbInVzZUxvYWRpbmciLCJMb2FkaW5nIiwibG9hZGluZyIsImRpdiIsInN0eWxlIiwiekluZGV4IiwiaGVpZ2h0IiwiY2xhc3NOYW1lIiwiaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./elements/views/loading.tsx\n");

/***/ }),

/***/ "./hooks/useLoading.ts":
/*!*****************************!*\
  !*** ./hooks/useLoading.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useLoading\": function() { return /* binding */ useLoading; }\n/* harmony export */ });\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! recoil */ \"./node_modules/recoil/es/index.js\");\n/* harmony import */ var _state_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../state/index */ \"./state/index.ts\");\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\n\nvar useLoading = function() {\n    var ref = _slicedToArray((0,recoil__WEBPACK_IMPORTED_MODULE_0__.useRecoilState)(_state_index__WEBPACK_IMPORTED_MODULE_1__.loading), 2), loading = ref[0], setLoading = ref[1];\n    var modifiedSetLoading = function() {\n        var toLoading = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !loading;\n        setLoading(toLoading);\n    };\n    return [\n        loading,\n        modifiedSetLoading\n    ];\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ob29rcy91c2VMb2FkaW5nLnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdEO0FBQ0Q7QUFFaEQsSUFBTUcsVUFBVSxHQUE4QyxXQUFNO0lBQ3ZFLElBQThCSCxHQUEyQixrQkFBM0JBLHNEQUFjLENBQUNFLGlEQUFXLENBQUMsTUFBbERELE9BQU8sR0FBZ0JELEdBQTJCLEdBQTNDLEVBQUVJLFVBQVUsR0FBSUosR0FBMkIsR0FBL0I7SUFDMUIsSUFBTUssa0JBQWtCLEdBQTRCLFdBQW1DO1lBQWxDQyxTQUFrQixvRUFBRyxDQUFDTCxPQUFPO1FBQzlFRyxVQUFVLENBQUNFLFNBQVMsQ0FBQyxDQUFDO0tBQ3pCO0lBQ0QsT0FBTztRQUFDTCxPQUFPO1FBQUVJLGtCQUFrQjtLQUFDO0NBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZUxvYWRpbmcudHM/YThjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTZXR0ZXJPclVwZGF0ZXIsIHVzZVJlY29pbFN0YXRlIH0gZnJvbSBcInJlY29pbFwiXG5pbXBvcnQgeyBsb2FkaW5nIGFzIGxvYWRpbmdBdG9tIH0gZnJvbSBcIi4uL3N0YXRlL2luZGV4XCJcblxuZXhwb3J0IGNvbnN0IHVzZUxvYWRpbmc6ICgpID0+IFtib29sZWFuLCAodmFsPzogYm9vbGVhbikgPT4gdm9pZCBdID0gKCkgPT4ge1xuICAgIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVJlY29pbFN0YXRlKGxvYWRpbmdBdG9tKTtcbiAgICBjb25zdCBtb2RpZmllZFNldExvYWRpbmc6ICh2YWw/OiBib29sZWFuKSA9PiB2b2lkID0gKHRvTG9hZGluZzogYm9vbGVhbiA9ICFsb2FkaW5nKSA9PiB7XG4gICAgICAgIHNldExvYWRpbmcodG9Mb2FkaW5nKTtcbiAgICB9O1xuICAgIHJldHVybiBbbG9hZGluZywgbW9kaWZpZWRTZXRMb2FkaW5nXVxufSJdLCJuYW1lcyI6WyJ1c2VSZWNvaWxTdGF0ZSIsImxvYWRpbmciLCJsb2FkaW5nQXRvbSIsInVzZUxvYWRpbmciLCJzZXRMb2FkaW5nIiwibW9kaWZpZWRTZXRMb2FkaW5nIiwidG9Mb2FkaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./hooks/useLoading.ts\n");

/***/ }),

/***/ "./node_modules/next/dist/client/image.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/image.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s2, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s2 = _i.next()).done); _n = true){\n            _arr.push(_s2.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = Image;\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nvar _head = _interopRequireDefault(__webpack_require__(/*! ../shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\"));\nvar _imageConfig = __webpack_require__(/*! ../shared/lib/image-config */ \"./node_modules/next/dist/shared/lib/image-config.js\");\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nvar _imageConfigContext = __webpack_require__(/*! ../shared/lib/image-config-context */ \"./node_modules/next/dist/shared/lib/image-config-context.js\");\nvar _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _normalizeTrailingSlash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nfunction Image(_param) {\n    _s();\n    var src = _param.src, sizes = _param.sizes, _unoptimized = _param.unoptimized, unoptimized = _unoptimized === void 0 ? false : _unoptimized, _priority = _param.priority, priority = _priority === void 0 ? false : _priority, loading = _param.loading, _lazyRoot = _param.lazyRoot, lazyRoot = _lazyRoot === void 0 ? null : _lazyRoot, _lazyBoundary = _param.lazyBoundary, lazyBoundary = _lazyBoundary === void 0 ? \"200px\" : _lazyBoundary, className = _param.className, quality = _param.quality, width = _param.width, height = _param.height, style = _param.style, objectFit = _param.objectFit, objectPosition = _param.objectPosition, onLoadingComplete = _param.onLoadingComplete, onError = _param.onError, _placeholder = _param.placeholder, placeholder = _placeholder === void 0 ? \"empty\" : _placeholder, blurDataURL = _param.blurDataURL, all = _objectWithoutProperties(_param, [\n        \"src\",\n        \"sizes\",\n        \"unoptimized\",\n        \"priority\",\n        \"loading\",\n        \"lazyRoot\",\n        \"lazyBoundary\",\n        \"className\",\n        \"quality\",\n        \"width\",\n        \"height\",\n        \"style\",\n        \"objectFit\",\n        \"objectPosition\",\n        \"onLoadingComplete\",\n        \"onError\",\n        \"placeholder\",\n        \"blurDataURL\"\n    ]);\n    var configContext = (0, _react).useContext(_imageConfigContext.ImageConfigContext);\n    var config = (0, _react).useMemo(function() {\n        var c = configEnv || configContext || _imageConfig.imageConfigDefault;\n        var allSizes = _toConsumableArray(c.deviceSizes).concat(_toConsumableArray(c.imageSizes)).sort(function(a, b) {\n            return a - b;\n        });\n        var deviceSizes = c.deviceSizes.sort(function(a, b) {\n            return a - b;\n        });\n        return _objectSpread({}, c, {\n            allSizes: allSizes,\n            deviceSizes: deviceSizes\n        });\n    }, [\n        configContext\n    ]);\n    var rest = all;\n    var layout = sizes ? \"responsive\" : \"intrinsic\";\n    if (\"layout\" in rest) {\n        // Override default layout if the user specified one:\n        if (rest.layout) layout = rest.layout;\n        // Remove property so it's not spread on <img>:\n        delete rest.layout;\n    }\n    var loader = defaultImageLoader;\n    if (\"loader\" in rest) {\n        if (rest.loader) {\n            var customImageLoader = rest.loader;\n            var _tmp;\n            _tmp = function(obj) {\n                var _ = obj.config, opts = _objectWithoutProperties(obj, [\n                    \"config\"\n                ]);\n                // The config object is internal only so we must\n                // not pass it to the user-defined loader()\n                return customImageLoader(opts);\n            }, loader = _tmp, _tmp;\n        }\n        // Remove property so it's not spread on <img>\n        delete rest.loader;\n    }\n    var staticSrc = \"\";\n    if (isStaticImport(src)) {\n        var staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \".concat(JSON.stringify(staticImageData)));\n        }\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!layout || layout !== \"fill\") {\n            height = height || staticImageData.height;\n            width = width || staticImageData.width;\n            if (!staticImageData.height || !staticImageData.width) {\n                throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \".concat(JSON.stringify(staticImageData)));\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    var widthInt = getInt(width);\n    var heightInt = getInt(height);\n    var qualityInt = getInt(quality);\n    var isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if ( true && loadedImageURLs.has(src)) {\n        isLazy = false;\n    }\n    var ref2 = _slicedToArray((0, _react).useState(false), 2), blurComplete = ref2[0], setBlurComplete = ref2[1];\n    var ref1 = _slicedToArray((0, _useIntersection).useIntersection({\n        rootRef: lazyRoot,\n        rootMargin: lazyBoundary,\n        disabled: !isLazy\n    }), 3), setIntersection = ref1[0], isIntersected = ref1[1], resetIntersected = ref1[2];\n    var isVisible = !isLazy || isIntersected;\n    var wrapperStyle = {\n        boxSizing: \"border-box\",\n        display: \"block\",\n        overflow: \"hidden\",\n        width: \"initial\",\n        height: \"initial\",\n        background: \"none\",\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    var sizerStyle = {\n        boxSizing: \"border-box\",\n        display: \"block\",\n        width: \"initial\",\n        height: \"initial\",\n        background: \"none\",\n        opacity: 1,\n        border: 0,\n        margin: 0,\n        padding: 0\n    };\n    var hasSizer = false;\n    var sizerSvgUrl;\n    var layoutStyle = {\n        position: \"absolute\",\n        top: 0,\n        left: 0,\n        bottom: 0,\n        right: 0,\n        boxSizing: \"border-box\",\n        padding: 0,\n        border: \"none\",\n        margin: \"auto\",\n        display: \"block\",\n        width: 0,\n        height: 0,\n        minWidth: \"100%\",\n        maxWidth: \"100%\",\n        minHeight: \"100%\",\n        maxHeight: \"100%\",\n        objectFit: objectFit,\n        objectPosition: objectPosition\n    };\n    if ( true && layout !== \"raw\" && style) {}\n    if (true) {\n        if (!src) {\n            throw new Error('Image is missing required \"src\" property. Make sure you pass \"src\" in props to the `next/image` component. Received: '.concat(JSON.stringify({\n                width: width,\n                height: height,\n                quality: quality\n            })));\n        }\n        if (!VALID_LAYOUT_VALUES.includes(layout)) {\n            throw new Error('Image with src \"'.concat(src, '\" has invalid \"layout\" property. Provided \"').concat(layout, '\" should be one of ').concat(VALID_LAYOUT_VALUES.map(String).join(\",\"), \".\"));\n        }\n        if (layout === \"raw\" && !experimentalLayoutRaw) {\n            throw new Error('The \"raw\" layout is currently experimental and may be subject to breaking changes. To use layout=\"raw\", include `experimental: { images: { layoutRaw: true } }` in your next.config.js file.');\n        }\n        if (typeof widthInt !== \"undefined\" && isNaN(widthInt) || typeof heightInt !== \"undefined\" && isNaN(heightInt)) {\n            throw new Error('Image with src \"'.concat(src, '\" has invalid \"width\" or \"height\" property. These should be numeric values.'));\n        }\n        if (layout === \"fill\" && (width || height)) {\n            (0, _utils).warnOnce('Image with src \"'.concat(src, '\" and \"layout=\\'fill\\'\" has unused properties assigned. Please remove \"width\" and \"height\".'));\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"'.concat(src, '\" has invalid \"loading\" property. Provided \"').concat(loading, '\" should be one of ').concat(VALID_LOADING_VALUES.map(String).join(\",\"), \".\"));\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"'.concat(src, '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.'));\n        }\n        if (layout === \"raw\" && (objectFit || objectPosition)) {\n            throw new Error('Image with src \"'.concat(src, \"\\\" has \\\"layout='raw'\\\" and 'objectFit' or 'objectPosition'. For raw images, these and other styles should be specified using the 'style' attribute.\"));\n        }\n        if (sizes && layout !== \"fill\" && layout !== \"responsive\" && layout !== \"raw\") {\n            (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has \"sizes\" property but it will be ignored. Only use \"sizes\" with \"layout=\\'fill\\'\", \"layout=\\'responsive\\'\", or \"layout=\\'raw\\''));\n        }\n        if (placeholder === \"blur\") {\n            if (layout !== \"fill\" && (widthInt || 0) * (heightInt || 0) < 1600) {\n                (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is smaller than 40x40. Consider removing the \"placeholder=\\'blur\\'\" property to improve performance.'));\n            }\n            if (!blurDataURL) {\n                var VALID_BLUR_EXT = [\n                    \"jpeg\",\n                    \"png\",\n                    \"webp\",\n                    \"avif\"\n                ] // should match next-image-loader\n                ;\n                throw new Error('Image with src \"'.concat(src, '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n          Possible solutions:\\n            - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n            - Change the \"src\" property to a static import with one of the supported file types: ').concat(VALID_BLUR_EXT.join(\",\"), '\\n            - Remove the \"placeholder\" property, effectively no blur effect\\n          Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url'));\n            }\n        }\n        if (\"ref\" in rest) {\n            (0, _utils).warnOnce('Image with src \"'.concat(src, '\" is using unsupported \"ref\" property. Consider using the \"onLoadingComplete\" property instead.'));\n        }\n        if (!unoptimized && loader !== defaultImageLoader) {\n            var urlStr = loader({\n                config: config,\n                src: src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            var url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _utils).warnOnce('Image with src \"'.concat(src, '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (style && layout !== \"raw\") {\n            var overwrittenStyles = Object.keys(style).filter(function(key) {\n                return key in layoutStyle;\n            });\n            if (overwrittenStyles.length) {\n                (0, _utils).warnOnce(\"Image with src \".concat(src, \" is assigned the following styles, which are overwritten by automatically-generated styles: \").concat(overwrittenStyles.join(\", \")));\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver(function(entryList) {\n                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                try {\n                    for(var _iterator = entryList.getEntries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                        var entry = _step.value;\n                        var ref1;\n                        // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                        var imgSrc = (entry === null || entry === void 0 ? void 0 : (ref1 = entry.element) === null || ref1 === void 0 ? void 0 : ref1.src) || \"\";\n                        var lcpImage = allImgs.get(imgSrc);\n                        if (lcpImage && !lcpImage.priority && lcpImage.placeholder !== \"blur\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                            // https://web.dev/lcp/#measure-lcp-in-javascript\n                            (0, _utils).warnOnce('Image with src \"'.concat(lcpImage.src, '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.') + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                        }\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n                            _iterator.return();\n                        }\n                    } finally{\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    var imgStyle = Object.assign({}, style, layout === \"raw\" ? {\n        aspectRatio: \"\".concat(widthInt, \" / \").concat(heightInt)\n    } : layoutStyle);\n    var blurStyle = placeholder === \"blur\" && !blurComplete ? {\n        filter: \"blur(20px)\",\n        backgroundSize: objectFit || \"cover\",\n        backgroundImage: 'url(\"'.concat(blurDataURL, '\")'),\n        backgroundPosition: objectPosition || \"0% 0%\"\n    } : {};\n    if (layout === \"fill\") {\n        // <Image src=\"i.png\" layout=\"fill\" />\n        wrapperStyle.display = \"block\";\n        wrapperStyle.position = \"absolute\";\n        wrapperStyle.top = 0;\n        wrapperStyle.left = 0;\n        wrapperStyle.bottom = 0;\n        wrapperStyle.right = 0;\n    } else if (typeof widthInt !== \"undefined\" && typeof heightInt !== \"undefined\") {\n        // <Image src=\"i.png\" width=\"100\" height=\"100\" />\n        var quotient = heightInt / widthInt;\n        var paddingTop = isNaN(quotient) ? \"100%\" : \"\".concat(quotient * 100, \"%\");\n        if (layout === \"responsive\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"responsive\" />\n            wrapperStyle.display = \"block\";\n            wrapperStyle.position = \"relative\";\n            hasSizer = true;\n            sizerStyle.paddingTop = paddingTop;\n        } else if (layout === \"intrinsic\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"intrinsic\" />\n            wrapperStyle.display = \"inline-block\";\n            wrapperStyle.position = \"relative\";\n            wrapperStyle.maxWidth = \"100%\";\n            hasSizer = true;\n            sizerStyle.maxWidth = \"100%\";\n            sizerSvgUrl = \"data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%27\".concat(widthInt, \"%27%20height=%27\").concat(heightInt, \"%27/%3e\");\n        } else if (layout === \"fixed\") {\n            // <Image src=\"i.png\" width=\"100\" height=\"100\" layout=\"fixed\" />\n            wrapperStyle.display = \"inline-block\";\n            wrapperStyle.position = \"relative\";\n            wrapperStyle.width = widthInt;\n            wrapperStyle.height = heightInt;\n        }\n    } else {\n        // <Image src=\"i.png\" />\n        if (true) {\n            throw new Error('Image with src \"'.concat(src, '\" must use \"width\" and \"height\" properties or \"layout=\\'fill\\'\" property.'));\n        }\n    }\n    var imgAttributes = {\n        src: emptyDataURL,\n        srcSet: undefined,\n        sizes: undefined\n    };\n    if (isVisible) {\n        imgAttributes = generateImgAttrs({\n            config: config,\n            src: src,\n            unoptimized: unoptimized,\n            layout: layout,\n            width: widthInt,\n            quality: qualityInt,\n            sizes: sizes,\n            loader: loader\n        });\n    }\n    var srcString = src;\n    if (true) {\n        if (true) {\n            var fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src: src,\n                priority: priority,\n                placeholder: placeholder\n            });\n        }\n    }\n    var imageSrcSetPropName = \"imagesrcset\";\n    var imageSizesPropName = \"imagesizes\";\n    if (false) {}\n    var _obj;\n    var linkProps = (_obj = {}, // Note: imagesrcset and imagesizes are not in the link element type with react 17.\n    _defineProperty(_obj, imageSrcSetPropName, imgAttributes.srcSet), _defineProperty(_obj, imageSizesPropName, imgAttributes.sizes), _obj);\n    var useLayoutEffect =  false ? 0 : _react.default.useLayoutEffect;\n    var onLoadingCompleteRef = (0, _react).useRef(onLoadingComplete);\n    var previousImageSrc = (0, _react).useRef(src);\n    (0, _react).useEffect(function() {\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    useLayoutEffect(function() {\n        if (previousImageSrc.current !== src) {\n            resetIntersected();\n            previousImageSrc.current = src;\n        }\n    }, [\n        resetIntersected,\n        src\n    ]);\n    var imgElementArgs = _objectSpread({\n        isLazy: isLazy,\n        imgAttributes: imgAttributes,\n        heightInt: heightInt,\n        widthInt: widthInt,\n        qualityInt: qualityInt,\n        layout: layout,\n        className: className,\n        imgStyle: imgStyle,\n        blurStyle: blurStyle,\n        loading: loading,\n        config: config,\n        unoptimized: unoptimized,\n        placeholder: placeholder,\n        loader: loader,\n        srcString: srcString,\n        onLoadingCompleteRef: onLoadingCompleteRef,\n        setBlurComplete: setBlurComplete,\n        setIntersection: setIntersection,\n        isVisible: isVisible\n    }, rest);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, layout === \"raw\" ? /*#__PURE__*/ _react.default.createElement(ImageElement, Object.assign({}, imgElementArgs)) : /*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: wrapperStyle\n    }, hasSizer ? /*#__PURE__*/ _react.default.createElement(\"span\", {\n        style: sizerStyle\n    }, sizerSvgUrl ? /*#__PURE__*/ _react.default.createElement(\"img\", {\n        style: {\n            display: \"block\",\n            maxWidth: \"100%\",\n            width: \"initial\",\n            height: \"initial\",\n            background: \"none\",\n            opacity: 1,\n            border: 0,\n            margin: 0,\n            padding: 0\n        },\n        alt: \"\",\n        \"aria-hidden\": true,\n        src: sizerSvgUrl\n    }) : null) : null, /*#__PURE__*/ _react.default.createElement(ImageElement, Object.assign({}, imgElementArgs))), priority ? // for browsers that do not support `imagesrcset`, and in those cases\n    // it would likely cause the incorrect image to be preloaded.\n    //\n    // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n    /*#__PURE__*/ _react.default.createElement(_head.default, null, /*#__PURE__*/ _react.default.createElement(\"link\", Object.assign({\n        key: \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes,\n        rel: \"preload\",\n        as: \"image\",\n        href: imgAttributes.srcSet ? undefined : imgAttributes.src\n    }, linkProps))) : null);\n}\n_s(Image, \"JC32V8ZswcgqIp1SSTncST29uwM=\");\n_c = Image;\nfunction _defineProperty1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {};\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nfunction _objectSpread(target) {\n    var _arguments = arguments, _loop = function(i) {\n        var source = _arguments[i] != null ? _arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty1(target, key, source[key]);\n        });\n    };\n    for(var i = 1; i < arguments.length; i++)_loop(i);\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nvar ref;\nvar experimentalLayoutRaw = (ref = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"experimentalLayoutRaw\":false,\"domains\":[]}) === null || ref === void 0 ? void 0 : ref.experimentalLayoutRaw;\nvar configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"experimentalLayoutRaw\":false,\"domains\":[]};\nvar loadedImageURLs = new Set();\nvar allImgs = new Map();\nvar perfObserver;\nvar emptyDataURL = \"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\";\nif (false) {}\nvar VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nvar loaders = new Map([\n    [\n        \"default\",\n        defaultLoader\n    ],\n    [\n        \"imgix\",\n        imgixLoader\n    ],\n    [\n        \"cloudinary\",\n        cloudinaryLoader\n    ],\n    [\n        \"akamai\",\n        akamaiLoader\n    ],\n    [\n        \"custom\",\n        customLoader\n    ], \n]);\nvar VALID_LAYOUT_VALUES = [\n    \"fill\",\n    \"fixed\",\n    \"intrinsic\",\n    \"responsive\",\n    \"raw\",\n    undefined, \n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nfunction getWidths(param, width, layout, sizes) {\n    var deviceSizes = param.deviceSizes, allSizes = param.allSizes;\n    if (sizes && (layout === \"fill\" || layout === \"responsive\" || layout === \"raw\")) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        var viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        var percentSizes = [];\n        for(var match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            var _Math;\n            var smallestRatio = (_Math = Math).min.apply(_Math, _toConsumableArray(percentSizes)) * 0.01;\n            return {\n                widths: allSizes.filter(function(s) {\n                    return s >= deviceSizes[0] * smallestRatio;\n                }),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\" || layout === \"fill\" || layout === \"responsive\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    var widths = _toConsumableArray(new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n    // > blue colors. Showing a 3x resolution image in the app vs a 2x\n    // > resolution image will be visually the same, though the 3x image\n    // > takes significantly more data. Even true 3x resolution screens are\n    // > wasteful as the human eye cannot see that level of detail without\n    // > something like a magnifying glass.\n    // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n    [\n        width,\n        width * 2 /*, width * 3*/ \n    ].map(function(w) {\n        return allSizes.find(function(p) {\n            return p >= w;\n        }) || allSizes[allSizes.length - 1];\n    })));\n    return {\n        widths: widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    var config = param.config, src = param.src, unoptimized = param.unoptimized, layout = param.layout, width = param.width, quality = param.quality, sizes = param.sizes, loader = param.loader;\n    if (unoptimized) {\n        return {\n            src: src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    var ref3 = getWidths(config, width, layout, sizes), widths = ref3.widths, kind = ref3.kind;\n    var last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map(function(w, i) {\n            return \"\".concat(loader({\n                config: config,\n                src: src,\n                quality: quality,\n                width: w\n            }), \" \").concat(kind === \"w\" ? w : i + 1).concat(kind);\n        }).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config: config,\n            src: src,\n            quality: quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getInt(x) {\n    if (typeof x === \"number\") {\n        return x;\n    }\n    if (typeof x === \"string\") {\n        return parseInt(x, 10);\n    }\n    return undefined;\n}\nfunction defaultImageLoader(loaderProps) {\n    var ref2;\n    var loaderKey = ((ref2 = loaderProps.config) === null || ref2 === void 0 ? void 0 : ref2.loader) || \"default\";\n    var load = loaders.get(loaderKey);\n    if (load) {\n        return load(loaderProps);\n    }\n    throw new Error('Unknown \"loader\" found in \"next.config.js\". Expected: '.concat(_imageConfig.VALID_LOADERS.join(\", \"), \". Received: \").concat(loaderKey));\n}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, src, layout, placeholder, onLoadingCompleteRef, setBlurComplete) {\n    if (!img || img.src === emptyDataURL || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    var p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(function() {}).then(function() {\n        if (!img.parentNode) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        loadedImageURLs.add(src);\n        if (placeholder === \"blur\") {\n            setBlurComplete(true);\n        }\n        if (onLoadingCompleteRef === null || onLoadingCompleteRef === void 0 ? void 0 : onLoadingCompleteRef.current) {\n            var naturalWidth = img.naturalWidth, naturalHeight = img.naturalHeight;\n            // Pass back read-only primitive values but not the\n            // underlying DOM element because it could be misused.\n            onLoadingCompleteRef.current({\n                naturalWidth: naturalWidth,\n                naturalHeight: naturalHeight\n            });\n        }\n        if (true) {\n            var ref3;\n            if ((ref3 = img.parentElement) === null || ref3 === void 0 ? void 0 : ref3.parentElement) {\n                var parent = getComputedStyle(img.parentElement.parentElement);\n                if (!parent.position) {\n                // The parent has not been rendered to the dom yet and therefore it has no position. Skip the warnings for such cases.\n                } else if (layout === \"responsive\" && parent.display === \"flex\") {\n                    (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly as a child of a flex container. Consider wrapping the image with a div to configure the width.'));\n                } else if (layout === \"fill\" && parent.position !== \"relative\" && parent.position !== \"fixed\" && parent.position !== \"absolute\") {\n                    (0, _utils).warnOnce('Image with src \"'.concat(src, '\" may not render properly with a parent using position:\"').concat(parent.position, '\". Consider changing the parent style to position:\"relative\" with a width and height.'));\n                }\n            }\n        }\n    });\n}\nvar ImageElement = function(_param) {\n    _s1();\n    var imgAttributes = _param.imgAttributes, heightInt = _param.heightInt, widthInt = _param.widthInt, qualityInt = _param.qualityInt, layout = _param.layout, className = _param.className, imgStyle = _param.imgStyle, blurStyle = _param.blurStyle, isLazy = _param.isLazy, placeholder = _param.placeholder, loading = _param.loading, srcString = _param.srcString, config = _param.config, unoptimized = _param.unoptimized, loader = _param.loader, onLoadingCompleteRef = _param.onLoadingCompleteRef, setBlurComplete = _param.setBlurComplete, setIntersection = _param.setIntersection, onError = _param.onError, isVisible = _param.isVisible, rest = _objectWithoutProperties(_param, [\n        \"imgAttributes\",\n        \"heightInt\",\n        \"widthInt\",\n        \"qualityInt\",\n        \"layout\",\n        \"className\",\n        \"imgStyle\",\n        \"blurStyle\",\n        \"isLazy\",\n        \"placeholder\",\n        \"loading\",\n        \"srcString\",\n        \"config\",\n        \"unoptimized\",\n        \"loader\",\n        \"onLoadingCompleteRef\",\n        \"setBlurComplete\",\n        \"setIntersection\",\n        \"onError\",\n        \"isVisible\"\n    ]);\n    return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement(\"img\", Object.assign({}, rest, imgAttributes, layout === \"raw\" && !imgAttributes.sizes ? {\n        height: heightInt,\n        width: widthInt\n    } : {}, {\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        className: className,\n        style: _objectSpread({}, imgStyle, blurStyle),\n        ref: (0, _react).useCallback(function(img) {\n            setIntersection(img);\n            if (img === null || img === void 0 ? void 0 : img.complete) {\n                handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n            }\n        }, [\n            setIntersection,\n            srcString,\n            layout,\n            placeholder,\n            onLoadingCompleteRef,\n            setBlurComplete, \n        ]),\n        onLoad: function(event) {\n            var img = event.currentTarget;\n            handleLoading(img, srcString, layout, placeholder, onLoadingCompleteRef, setBlurComplete);\n        },\n        onError: function(event) {\n            if (placeholder === \"blur\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    })), (isLazy || placeholder === \"blur\") && /*#__PURE__*/ _react.default.createElement(\"noscript\", null, /*#__PURE__*/ _react.default.createElement(\"img\", Object.assign({}, rest, generateImgAttrs({\n        config: config,\n        src: srcString,\n        unoptimized: unoptimized,\n        layout: layout,\n        width: widthInt,\n        quality: qualityInt,\n        sizes: imgAttributes.sizes,\n        loader: loader\n    }), layout === \"raw\" && !imgAttributes.sizes ? {\n        height: heightInt,\n        width: widthInt\n    } : {}, {\n        decoding: \"async\",\n        \"data-nimg\": layout,\n        style: imgStyle,\n        className: className,\n        // @ts-ignore - TODO: upgrade to `@types/react@17`\n        loading: loading || \"lazy\"\n    }))));\n};\n_s1(ImageElement, \"epj4qY15NHsef74wNqHIp5fdZmg=\");\n_c1 = ImageElement;\nfunction normalizeSrc(src) {\n    return src[0] === \"/\" ? src.slice(1) : src;\n}\nfunction imgixLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    // Demo: https://static.imgix.net/daisy.png?auto=format&fit=max&w=300\n    var url = new URL(\"\".concat(config.path).concat(normalizeSrc(src)));\n    var params = url.searchParams;\n    params.set(\"auto\", params.get(\"auto\") || \"format\");\n    params.set(\"fit\", params.get(\"fit\") || \"max\");\n    params.set(\"w\", params.get(\"w\") || width.toString());\n    if (quality) {\n        params.set(\"q\", quality.toString());\n    }\n    return url.href;\n}\nfunction akamaiLoader(param) {\n    var config = param.config, src = param.src, width = param.width;\n    return \"\".concat(config.path).concat(normalizeSrc(src), \"?imwidth=\").concat(width);\n}\nfunction cloudinaryLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    // Demo: https://res.cloudinary.com/demo/image/upload/w_300,c_limit,q_auto/turtles.jpg\n    var params = [\n        \"f_auto\",\n        \"c_limit\",\n        \"w_\" + width,\n        \"q_\" + (quality || \"auto\")\n    ];\n    var paramsString = params.join(\",\") + \"/\";\n    return \"\".concat(config.path).concat(paramsString).concat(normalizeSrc(src));\n}\nfunction customLoader(param) {\n    var src = param.src;\n    throw new Error('Image with src \"'.concat(src, '\" is missing \"loader\" prop.') + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n}\nfunction defaultLoader(param) {\n    var config = param.config, src = param.src, width = param.width, quality = param.quality;\n    if (true) {\n        var missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \".concat(missingValues.join(\", \"), \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \").concat(JSON.stringify({\n                src: src,\n                width: width,\n                quality: quality\n            })));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)'));\n        }\n        if (!src.startsWith(\"/\") && config.domains) {\n            var parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"'.concat(src, '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)'));\n            }\n            if ( true && !config.domains.includes(parsedSrc.hostname)) {\n                throw new Error(\"Invalid src prop (\".concat(src, ') on `next/image`, hostname \"').concat(parsedSrc.hostname, '\" is not configured under images in your `next.config.js`\\n') + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n            }\n        }\n    }\n    if (src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        return src;\n    }\n    return \"\".concat((0, _normalizeTrailingSlash).normalizePathTrailingSlash(config.path), \"?url=\").concat(encodeURIComponent(src), \"&w=\").concat(width, \"&q=\").concat(quality || 75);\n}\nif (typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) {\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Image\");\n$RefreshReg$(_c1, \"ImageElement\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNiQSw4Q0FBNkM7SUFDekNHLEtBQUssRUFBRSxJQUFJO0NBQ2QsRUFBQyxDQUFDO0FBQ0hELGtCQUFlLEdBQUdHLEtBQUssQ0FBQztBQUN4QixJQUFJQyxNQUFNLEdBQUdDLHVCQUF1QixDQUFDQyxtQkFBTyxDQUFDLDRDQUFPLENBQUMsQ0FBQztBQUN0RCxJQUFJQyxLQUFLLEdBQUdDLHNCQUFzQixDQUFDRixtQkFBTyxDQUFDLHVFQUFvQixDQUFDLENBQUM7QUFDakUsSUFBSUcsWUFBWSxHQUFHSCxtQkFBTyxDQUFDLHVGQUE0QixDQUFDO0FBQ3hELElBQUlJLGdCQUFnQixHQUFHSixtQkFBTyxDQUFDLCtFQUFvQixDQUFDO0FBQ3BELElBQUlLLG1CQUFtQixHQUFHTCxtQkFBTyxDQUFDLHVHQUFvQyxDQUFDO0FBQ3ZFLElBQUlNLE1BQU0sR0FBR04sbUJBQU8sQ0FBQyx5RUFBcUIsQ0FBQztBQUMzQyxJQUFJTyx1QkFBdUIsR0FBR1AsbUJBQU8sQ0FBQywrRkFBNEIsQ0FBQztBQUNuRSxTQUFTSCxLQUFLLENBQUNXLE1BQU0sRUFBRTs7SUFDbkIsSUFBTUMsR0FBRyxHQUF1UEQsTUFBTSxDQUFoUUMsR0FBRyxFQUFHQyxLQUFLLEdBQStPRixNQUFNLENBQTFQRSxLQUFLLGlCQUErT0YsTUFBTSxDQUFsUEcsV0FBVyxFQUFYQSxXQUFXLDZCQUFFLEtBQUssNkJBQTBOSCxNQUFNLENBQTdOSSxRQUFRLEVBQVJBLFFBQVEsMEJBQUUsS0FBSyxjQUFHQyxPQUFPLEdBQThMTCxNQUFNLENBQTNNSyxPQUFPLGNBQThMTCxNQUFNLENBQWpNTSxRQUFRLEVBQVJBLFFBQVEsMEJBQUUsSUFBSSw4QkFBNktOLE1BQU0sQ0FBaExP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TUFBdUIsQ0FBbkcsQ0FBQyxDQUFDLEVBQUUzUSx1QkFBdUIsQ0FBQyxDQUFDNFEsMEJBQTBCLENBQUNuUCxNQUFNLENBQUN1TyxJQUFJLENBQUMsRUFBQyxPQUFLLENBQTBCLENBQUtyUCxNQUFLLENBQWxDZ1Esa0JBQWtCLENBQUN6USxHQUFHLENBQUMsRUFBQyxLQUFHLENBQVEsQ0FBS1EsTUFBYSxDQUF4QkMsS0FBSyxFQUFDLEtBQUcsQ0FBZ0IsUUFBZEQsT0FBTyxJQUFJLEVBQUUsQ0FBRSxDQUFDO0NBQ2pKO0FBRUQsSUFBSSxPQUFPdkIsT0FBTyxDQUFDRSxPQUFPLEtBQUssVUFBVSxJQUFLLE9BQU9GLE9BQU8sQ0FBQ0UsT0FBTyxLQUFLLFFBQVEsSUFBSUYsT0FBTyxDQUFDRSxPQUFPLEtBQUssSUFBSSxFQUFHO0lBQzlHSixNQUFNLENBQUNxSixNQUFNLENBQUNuSixPQUFPLENBQUNFLE9BQU8sRUFBRUYsT0FBTyxDQUFDLENBQUM7SUFDeEMwUixNQUFNLENBQUMxUixPQUFPLEdBQUdBLE9BQU8sQ0FBQ0UsT0FBTyxDQUFDO0NBQ2xDLENBRUQsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLmpzPzgyZjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbWFnZTtcbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwicmVhY3RcIikpO1xudmFyIF9oZWFkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9oZWFkXCIpKTtcbnZhciBfaW1hZ2VDb25maWcgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWdcIik7XG52YXIgX3VzZUludGVyc2VjdGlvbiA9IHJlcXVpcmUoXCIuL3VzZS1pbnRlcnNlY3Rpb25cIik7XG52YXIgX2ltYWdlQ29uZmlnQ29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0XCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzXCIpO1xudmFyIF9ub3JtYWxpemVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLXRyYWlsaW5nLXNsYXNoXCIpO1xuZnVuY3Rpb24gSW1hZ2UoX3BhcmFtKSB7XG4gICAgdmFyIHsgc3JjICwgc2l6ZXMgLCB1bm9wdGltaXplZCA9ZmFsc2UgLCBwcmlvcml0eSA9ZmFsc2UgLCBsb2FkaW5nICwgbGF6eVJvb3QgPW51bGwgLCBsYXp5Qm91bmRhcnkgPScyMDBweCcgLCBjbGFzc05hbWUgLCBxdWFsaXR5ICwgd2lkdGggLCBoZWlnaHQgLCBzdHlsZSAsIG9iamVjdEZpdCAsIG9iamVjdFBvc2l0aW9uICwgb25Mb2FkaW5nQ29tcGxldGUgLCBvbkVycm9yICwgcGxhY2Vob2xkZXIgPSdlbXB0eScgLCBibHVyRGF0YVVSTCAgfSA9IF9wYXJhbSwgYWxsID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wYXJhbSwgW1xuICAgICAgICBcInNyY1wiLFxuICAgICAgICBcInNpemVzXCIsXG4gICAgICAgIFwidW5vcHRpbWl6ZWRcIixcbiAgICAgICAgXCJwcmlvcml0eVwiLFxuICAgICAgICBcImxvYWRpbmdcIixcbiAgICAgICAgXCJsYXp5Um9vdFwiLFxuICAgICAgICBcImxhenlCb3VuZGFyeVwiLFxuICAgICAgICBcImNsYXNzTmFtZVwiLFxuICAgICAgICBcInF1YWxpdHlcIixcbiAgICAgICAgXCJ3aWR0aFwiLFxuICAgICAgICBcImhlaWdodFwiLFxuICAgICAgICBcInN0eWxlXCIsXG4gICAgICAgIFwib2JqZWN0Rml0XCIsXG4gICAgICAgIFwib2JqZWN0UG9zaXRpb25cIixcbiAgICAgICAgXCJvbkxvYWRpbmdDb21wbGV0ZVwiLFxuICAgICAgICBcIm9uRXJyb3JcIixcbiAgICAgICAgXCJwbGFjZWhvbGRlclwiLFxuICAgICAgICBcImJsdXJEYXRhVVJMXCJcbiAgICBdKTtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdCkudXNlQ29udGV4dChfaW1hZ2VDb25maWdDb250ZXh0LkltYWdlQ29uZmlnQ29udGV4dCk7XG4gICAgY29uc3QgY29uZmlnID0gKDAsIF9yZWFjdCkudXNlTWVtbygoKT0+e1xuICAgICAgICBjb25zdCBjID0gY29uZmlnRW52IHx8IGNvbmZpZ0NvbnRleHQgfHwgX2ltYWdlQ29uZmlnLmltYWdlQ29uZmlnRGVmYXVsdDtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGRldmljZVNpemVzID0gYy5kZXZpY2VTaXplcy5zb3J0KChhLCBiKT0+YSAtIGJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoe30sIGMsIHtcbiAgICAgICAgICAgIGFsbFNpemVzLFxuICAgICAgICAgICAgZGV2aWNlU2l6ZXNcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBjb25maWdDb250ZXh0XG4gICAgXSk7XG4gICAgbGV0IHJlc3QgPSBhbGw7XG4gICAgbGV0IGxheW91dCA9IHNpemVzID8gJ3Jlc3BvbnNpdmUnIDogJ2ludHJpbnNpYyc7XG4gICAgaWYgKCdsYXlvdXQnIGluIHJlc3QpIHtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBsYXlvdXQgaWYgdGhlIHVzZXIgc3BlY2lmaWVkIG9uZTpcbiAgICAgICAgaWYgKHJlc3QubGF5b3V0KSBsYXlvdXQgPSByZXN0LmxheW91dDtcbiAgICAgICAgLy8gUmVtb3ZlIHByb3BlcnR5IHNvIGl0J3Mgbm90IHNwcmVhZCBvbiA8aW1nPjpcbiAgICAgICAgZGVsZXRlIHJlc3QubGF5b3V0O1xuICAgIH1cbiAgICBsZXQgbG9hZGVyID0gZGVmYXVsdEltYWdlTG9hZGVyO1xuICAgIGlmICgnbG9hZGVyJyBpbiByZXN0KSB7XG4gICAgICAgIGlmIChyZXN0LmxvYWRlcikge1xuICAgICAgICAgICAgY29uc3QgY3VzdG9tSW1hZ2VMb2FkZXIgPSByZXN0LmxvYWRlcjtcbiAgICAgICAgICAgIHZhciBfdG1wO1xuICAgICAgICAgICAgX3RtcCA9IChvYmopPT57XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb25maWc6IF8gIH0gPSBvYmosIG9wdHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBbXG4gICAgICAgICAgICAgICAgICAgIFwiY29uZmlnXCJcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29uZmlnIG9iamVjdCBpcyBpbnRlcm5hbCBvbmx5IHNvIHdlIG11c3RcbiAgICAgICAgICAgICAgICAvLyBub3QgcGFzcyBpdCB0byB0aGUgdXNlci1kZWZpbmVkIGxvYWRlcigpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUltYWdlTG9hZGVyKG9wdHMpO1xuICAgICAgICAgICAgfSwgbG9hZGVyID0gX3RtcCwgX3RtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgcHJvcGVydHkgc28gaXQncyBub3Qgc3ByZWFkIG9uIDxpbWc+XG4gICAgICAgIGRlbGV0ZSByZXN0LmxvYWRlcjtcbiAgICB9XG4gICAgbGV0IHN0YXRpY1NyYyA9ICcnO1xuICAgIGlmIChpc1N0YXRpY0ltcG9ydChzcmMpKSB7XG4gICAgICAgIGNvbnN0IHN0YXRpY0ltYWdlRGF0YSA9IGlzU3RhdGljUmVxdWlyZShzcmMpID8gc3JjLmRlZmF1bHQgOiBzcmM7XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLnNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIHNyYy4gUmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeShzdGF0aWNJbWFnZURhdGEpfWApO1xuICAgICAgICB9XG4gICAgICAgIGJsdXJEYXRhVVJMID0gYmx1ckRhdGFVUkwgfHwgc3RhdGljSW1hZ2VEYXRhLmJsdXJEYXRhVVJMO1xuICAgICAgICBzdGF0aWNTcmMgPSBzdGF0aWNJbWFnZURhdGEuc3JjO1xuICAgICAgICBpZiAoIWxheW91dCB8fCBsYXlvdXQgIT09ICdmaWxsJykge1xuICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICB3aWR0aCA9IHdpZHRoIHx8IHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIGhlaWdodCBhbmQgd2lkdGguIFJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSAnc3RyaW5nJyA/IHNyYyA6IHN0YXRpY1NyYztcbiAgICBjb25zdCB3aWR0aEludCA9IGdldEludCh3aWR0aCk7XG4gICAgY29uc3QgaGVpZ2h0SW50ID0gZ2V0SW50KGhlaWdodCk7XG4gICAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KTtcbiAgICBsZXQgaXNMYXp5ID0gIXByaW9yaXR5ICYmIChsb2FkaW5nID09PSAnbGF6eScgfHwgdHlwZW9mIGxvYWRpbmcgPT09ICd1bmRlZmluZWQnKTtcbiAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgfHwgc3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6JykpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGxvYWRlZEltYWdlVVJMcy5oYXMoc3JjKSkge1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgW2JsdXJDb21wbGV0ZSwgc2V0Qmx1ckNvbXBsZXRlXSA9ICgwLCBfcmVhY3QpLnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uLCBpc0ludGVyc2VjdGVkLCByZXNldEludGVyc2VjdGVkXSA9ICgwLCBfdXNlSW50ZXJzZWN0aW9uKS51c2VJbnRlcnNlY3Rpb24oe1xuICAgICAgICByb290UmVmOiBsYXp5Um9vdCxcbiAgICAgICAgcm9vdE1hcmdpbjogbGF6eUJvdW5kYXJ5LFxuICAgICAgICBkaXNhYmxlZDogIWlzTGF6eVxuICAgIH0pO1xuICAgIGNvbnN0IGlzVmlzaWJsZSA9ICFpc0xhenkgfHwgaXNJbnRlcnNlY3RlZDtcbiAgICBjb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHdpZHRoOiAnaW5pdGlhbCcsXG4gICAgICAgIGhlaWdodDogJ2luaXRpYWwnLFxuICAgICAgICBiYWNrZ3JvdW5kOiAnbm9uZScsXG4gICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICBwYWRkaW5nOiAwXG4gICAgfTtcbiAgICBjb25zdCBzaXplclN0eWxlID0ge1xuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcbiAgICAgICAgaGVpZ2h0OiAnaW5pdGlhbCcsXG4gICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDBcbiAgICB9O1xuICAgIGxldCBoYXNTaXplciA9IGZhbHNlO1xuICAgIGxldCBzaXplclN2Z1VybDtcbiAgICBjb25zdCBsYXlvdXRTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICBtYXJnaW46ICdhdXRvJyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgbWluV2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWF4V2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWluSGVpZ2h0OiAnMTAwJScsXG4gICAgICAgIG1heEhlaWdodDogJzEwMCUnLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBsYXlvdXQgIT09ICdyYXcnICYmIHN0eWxlKSB7fVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghc3JjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJzcmNcIiBwcm9wZXJ0eS4gTWFrZSBzdXJlIHlvdSBwYXNzIFwic3JjXCIgaW4gcHJvcHMgdG8gdGhlIFxcYG5leHQvaW1hZ2VcXGAgY29tcG9uZW50LiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHF1YWxpdHlcbiAgICAgICAgICAgIH0pfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghVkFMSURfTEFZT1VUX1ZBTFVFUy5pbmNsdWRlcyhsYXlvdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJsYXlvdXRcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xheW91dH1cIiBzaG91bGQgYmUgb25lIG9mICR7VkFMSURfTEFZT1VUX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKCcsJyl9LmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXlvdXQgPT09ICdyYXcnICYmICFleHBlcmltZW50YWxMYXlvdXRSYXcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwicmF3XCIgbGF5b3V0IGlzIGN1cnJlbnRseSBleHBlcmltZW50YWwgYW5kIG1heSBiZSBzdWJqZWN0IHRvIGJyZWFraW5nIGNoYW5nZXMuIFRvIHVzZSBsYXlvdXQ9XCJyYXdcIiwgaW5jbHVkZSBcXGBleHBlcmltZW50YWw6IHsgaW1hZ2VzOiB7IGxheW91dFJhdzogdHJ1ZSB9IH1cXGAgaW4geW91ciBuZXh0LmNvbmZpZy5qcyBmaWxlLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGhJbnQgIT09ICd1bmRlZmluZWQnICYmIGlzTmFOKHdpZHRoSW50KSB8fCB0eXBlb2YgaGVpZ2h0SW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hTihoZWlnaHRJbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGludmFsaWQgXCJ3aWR0aFwiIG9yIFwiaGVpZ2h0XCIgcHJvcGVydHkuIFRoZXNlIHNob3VsZCBiZSBudW1lcmljIHZhbHVlcy5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGF5b3V0ID09PSAnZmlsbCcgJiYgKHdpZHRoIHx8IGhlaWdodCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGFuZCBcImxheW91dD0nZmlsbCdcIiBoYXMgdW51c2VkIHByb3BlcnRpZXMgYXNzaWduZWQuIFBsZWFzZSByZW1vdmUgXCJ3aWR0aFwiIGFuZCBcImhlaWdodFwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghVkFMSURfTE9BRElOR19WQUxVRVMuaW5jbHVkZXMobG9hZGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCIke2xvYWRpbmd9XCIgc2hvdWxkIGJlIG9uZSBvZiAke1ZBTElEX0xPQURJTkdfVkFMVUVTLm1hcChTdHJpbmcpLmpvaW4oJywnKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByaW9yaXR5ICYmIGxvYWRpbmcgPT09ICdsYXp5Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPSdsYXp5J1wiIHByb3BlcnRpZXMuIE9ubHkgb25lIHNob3VsZCBiZSB1c2VkLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXlvdXQgPT09ICdyYXcnICYmIChvYmplY3RGaXQgfHwgb2JqZWN0UG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIFwibGF5b3V0PSdyYXcnXCIgYW5kICdvYmplY3RGaXQnIG9yICdvYmplY3RQb3NpdGlvbicuIEZvciByYXcgaW1hZ2VzLCB0aGVzZSBhbmQgb3RoZXIgc3R5bGVzIHNob3VsZCBiZSBzcGVjaWZpZWQgdXNpbmcgdGhlICdzdHlsZScgYXR0cmlidXRlLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplcyAmJiBsYXlvdXQgIT09ICdmaWxsJyAmJiBsYXlvdXQgIT09ICdyZXNwb25zaXZlJyAmJiBsYXlvdXQgIT09ICdyYXcnKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJzaXplc1wiIHByb3BlcnR5IGJ1dCBpdCB3aWxsIGJlIGlnbm9yZWQuIE9ubHkgdXNlIFwic2l6ZXNcIiB3aXRoIFwibGF5b3V0PSdmaWxsJ1wiLCBcImxheW91dD0ncmVzcG9uc2l2ZSdcIiwgb3IgXCJsYXlvdXQ9J3JhdydgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09ICdibHVyJykge1xuICAgICAgICAgICAgaWYgKGxheW91dCAhPT0gJ2ZpbGwnICYmICh3aWR0aEludCB8fCAwKSAqIChoZWlnaHRJbnQgfHwgMCkgPCAxNjAwKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFibHVyRGF0YVVSTCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFZBTElEX0JMVVJfRVhUID0gW1xuICAgICAgICAgICAgICAgICAgICAnanBlZycsXG4gICAgICAgICAgICAgICAgICAgICdwbmcnLFxuICAgICAgICAgICAgICAgICAgICAnd2VicCcsXG4gICAgICAgICAgICAgICAgICAgICdhdmlmJ1xuICAgICAgICAgICAgICAgIF0gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBoYXMgXCJwbGFjZWhvbGRlcj0nYmx1cidcIiBwcm9wZXJ0eSBidXQgaXMgbWlzc2luZyB0aGUgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LlxuICAgICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcbiAgICAgICAgICAgIC0gQWRkIGEgXCJibHVyRGF0YVVSTFwiIHByb3BlcnR5LCB0aGUgY29udGVudHMgc2hvdWxkIGJlIGEgc21hbGwgRGF0YSBVUkwgdG8gcmVwcmVzZW50IHRoZSBpbWFnZVxuICAgICAgICAgICAgLSBDaGFuZ2UgdGhlIFwic3JjXCIgcHJvcGVydHkgdG8gYSBzdGF0aWMgaW1wb3J0IHdpdGggb25lIG9mIHRoZSBzdXBwb3J0ZWQgZmlsZSB0eXBlczogJHtWQUxJRF9CTFVSX0VYVC5qb2luKCcsJyl9XG4gICAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxuICAgICAgICAgIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcGxhY2Vob2xkZXItYmx1ci1kYXRhLXVybGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgncmVmJyBpbiByZXN0KSB7XG4gICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke3NyY31cIiBpcyB1c2luZyB1bnN1cHBvcnRlZCBcInJlZlwiIHByb3BlcnR5LiBDb25zaWRlciB1c2luZyB0aGUgXCJvbkxvYWRpbmdDb21wbGV0ZVwiIHByb3BlcnR5IGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1bm9wdGltaXplZCAmJiBsb2FkZXIgIT09IGRlZmF1bHRJbWFnZUxvYWRlcikge1xuICAgICAgICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlscykud2Fybk9uY2UoYEltYWdlIHdpdGggc3JjIFwiJHtzcmN9XCIgaGFzIGEgXCJsb2FkZXJcIiBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IGltcGxlbWVudCB3aWR0aC4gUGxlYXNlIGltcGxlbWVudCBpdCBvciB1c2UgdGhlIFwidW5vcHRpbWl6ZWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0eWxlICYmIGxheW91dCAhPT0gJ3JhdycpIHtcbiAgICAgICAgICAgIGxldCBvdmVyd3JpdHRlblN0eWxlcyA9IE9iamVjdC5rZXlzKHN0eWxlKS5maWx0ZXIoKGtleSk9PmtleSBpbiBsYXlvdXRTdHlsZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChvdmVyd3JpdHRlblN0eWxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgJHtzcmN9IGlzIGFzc2lnbmVkIHRoZSBmb2xsb3dpbmcgc3R5bGVzLCB3aGljaCBhcmUgb3ZlcndyaXR0ZW4gYnkgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgc3R5bGVzOiAke292ZXJ3cml0dGVuU3R5bGVzLmpvaW4oJywgJyl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICFwZXJmT2JzZXJ2ZXIgJiYgd2luZG93LlBlcmZvcm1hbmNlT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHBlcmZPYnNlcnZlciA9IG5ldyBQZXJmb3JtYW5jZU9ic2VydmVyKChlbnRyeUxpc3QpPT57XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyeUxpc3QuZ2V0RW50cmllcygpKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZjE7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBtaXNzaW5nIFwiTGFyZ2VzdENvbnRlbnRmdWxQYWludFwiIGNsYXNzIHdpdGggXCJlbGVtZW50XCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdTcmMgPSAoZW50cnkgPT09IG51bGwgfHwgZW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChyZWYxID0gZW50cnkuZWxlbWVudCkgPT09IG51bGwgfHwgcmVmMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmMS5zcmMpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsY3BJbWFnZSA9IGFsbEltZ3MuZ2V0KGltZ1NyYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsY3BJbWFnZSAmJiAhbGNwSW1hZ2UucHJpb3JpdHkgJiYgbGNwSW1hZ2UucGxhY2Vob2xkZXIgIT09ICdibHVyJyAmJiAhbGNwSW1hZ2Uuc3JjLnN0YXJ0c1dpdGgoJ2RhdGE6JykgJiYgIWxjcEltYWdlLnNyYy5zdGFydHNXaXRoKCdibG9iOicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3V0aWxzKS53YXJuT25jZShgSW1hZ2Ugd2l0aCBzcmMgXCIke2xjcEltYWdlLnNyY31cIiB3YXMgZGV0ZWN0ZWQgYXMgdGhlIExhcmdlc3QgQ29udGVudGZ1bCBQYWludCAoTENQKS4gUGxlYXNlIGFkZCB0aGUgXCJwcmlvcml0eVwiIHByb3BlcnR5IGlmIHRoaXMgaW1hZ2UgaXMgYWJvdmUgdGhlIGZvbGQuYCArIGBcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBlcmZPYnNlcnZlci5vYnNlcnZlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xhcmdlc3QtY29udGVudGZ1bC1wYWludCcsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGNyYXNoIHRoZSBhcHBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKHt9LCBzdHlsZSwgbGF5b3V0ID09PSAncmF3JyA/IHtcbiAgICAgICAgYXNwZWN0UmF0aW86IGAke3dpZHRoSW50fSAvICR7aGVpZ2h0SW50fWBcbiAgICB9IDogbGF5b3V0U3R5bGUpO1xuICAgIGNvbnN0IGJsdXJTdHlsZSA9IHBsYWNlaG9sZGVyID09PSAnYmx1cicgJiYgIWJsdXJDb21wbGV0ZSA/IHtcbiAgICAgICAgZmlsdGVyOiAnYmx1cigyMHB4KScsXG4gICAgICAgIGJhY2tncm91bmRTaXplOiBvYmplY3RGaXQgfHwgJ2NvdmVyJyxcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKFwiJHtibHVyRGF0YVVSTH1cIilgLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IG9iamVjdFBvc2l0aW9uIHx8ICcwJSAwJSdcbiAgICB9IDoge307XG4gICAgaWYgKGxheW91dCA9PT0gJ2ZpbGwnKSB7XG4gICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIGxheW91dD1cImZpbGxcIiAvPlxuICAgICAgICB3cmFwcGVyU3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHdyYXBwZXJTdHlsZS50b3AgPSAwO1xuICAgICAgICB3cmFwcGVyU3R5bGUubGVmdCA9IDA7XG4gICAgICAgIHdyYXBwZXJTdHlsZS5ib3R0b20gPSAwO1xuICAgICAgICB3cmFwcGVyU3R5bGUucmlnaHQgPSAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpZHRoSW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgaGVpZ2h0SW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIC8+XG4gICAgICAgIGNvbnN0IHF1b3RpZW50ID0gaGVpZ2h0SW50IC8gd2lkdGhJbnQ7XG4gICAgICAgIGNvbnN0IHBhZGRpbmdUb3AgPSBpc05hTihxdW90aWVudCkgPyAnMTAwJScgOiBgJHtxdW90aWVudCAqIDEwMH0lYDtcbiAgICAgICAgaWYgKGxheW91dCA9PT0gJ3Jlc3BvbnNpdmUnKSB7XG4gICAgICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiIGxheW91dD1cInJlc3BvbnNpdmVcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgd3JhcHBlclN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIGhhc1NpemVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHNpemVyU3R5bGUucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3A7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09PSAnaW50cmluc2ljJykge1xuICAgICAgICAgICAgLy8gPEltYWdlIHNyYz1cImkucG5nXCIgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBsYXlvdXQ9XCJpbnRyaW5zaWNcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUubWF4V2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICBoYXNTaXplciA9IHRydWU7XG4gICAgICAgICAgICBzaXplclN0eWxlLm1heFdpZHRoID0gJzEwMCUnO1xuICAgICAgICAgICAgc2l6ZXJTdmdVcmwgPSBgZGF0YTppbWFnZS9zdmcreG1sLCUzY3N2ZyUyMHhtbG5zPSUyN2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJTI3JTIwdmVyc2lvbj0lMjcxLjElMjclMjB3aWR0aD0lMjcke3dpZHRoSW50fSUyNyUyMGhlaWdodD0lMjcke2hlaWdodEludH0lMjcvJTNlYDtcbiAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgICAgIC8vIDxJbWFnZSBzcmM9XCJpLnBuZ1wiIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgbGF5b3V0PVwiZml4ZWRcIiAvPlxuICAgICAgICAgICAgd3JhcHBlclN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB3cmFwcGVyU3R5bGUud2lkdGggPSB3aWR0aEludDtcbiAgICAgICAgICAgIHdyYXBwZXJTdHlsZS5oZWlnaHQgPSBoZWlnaHRJbnQ7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyA8SW1hZ2Ugc3JjPVwiaS5wbmdcIiAvPlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIG11c3QgdXNlIFwid2lkdGhcIiBhbmQgXCJoZWlnaHRcIiBwcm9wZXJ0aWVzIG9yIFwibGF5b3V0PSdmaWxsJ1wiIHByb3BlcnR5LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBpbWdBdHRyaWJ1dGVzID0ge1xuICAgICAgICBzcmM6IGVtcHR5RGF0YVVSTCxcbiAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemVzOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgICAgICBxdWFsaXR5OiBxdWFsaXR5SW50LFxuICAgICAgICAgICAgc2l6ZXMsXG4gICAgICAgICAgICBsb2FkZXJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBzcmNTdHJpbmcgPSBzcmM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBsZXQgZnVsbFVybDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGZ1bGxVcmwgPSBuZXcgVVJMKGltZ0F0dHJpYnV0ZXMuc3JjLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxJbWdzLnNldChmdWxsVXJsLmhyZWYsIHtcbiAgICAgICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBpbWFnZVNyY1NldFByb3BOYW1lID0gJ2ltYWdlc3Jjc2V0JztcbiAgICBsZXQgaW1hZ2VTaXplc1Byb3BOYW1lID0gJ2ltYWdlc2l6ZXMnO1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfUkVBQ1RfUk9PVCkge1xuICAgICAgICBpbWFnZVNyY1NldFByb3BOYW1lID0gJ2ltYWdlU3JjU2V0JztcbiAgICAgICAgaW1hZ2VTaXplc1Byb3BOYW1lID0gJ2ltYWdlU2l6ZXMnO1xuICAgIH1cbiAgICBjb25zdCBsaW5rUHJvcHMgPSB7XG4gICAgICAgIC8vIE5vdGU6IGltYWdlc3Jjc2V0IGFuZCBpbWFnZXNpemVzIGFyZSBub3QgaW4gdGhlIGxpbmsgZWxlbWVudCB0eXBlIHdpdGggcmVhY3QgMTcuXG4gICAgICAgIFtpbWFnZVNyY1NldFByb3BOYW1lXTogaW1nQXR0cmlidXRlcy5zcmNTZXQsXG4gICAgICAgIFtpbWFnZVNpemVzUHJvcE5hbWVdOiBpbWdBdHRyaWJ1dGVzLnNpemVzXG4gICAgfTtcbiAgICBjb25zdCB1c2VMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCA6IF9yZWFjdC5kZWZhdWx0LnVzZUxheW91dEVmZmVjdDtcbiAgICBjb25zdCBvbkxvYWRpbmdDb21wbGV0ZVJlZiA9ICgwLCBfcmVhY3QpLnVzZVJlZihvbkxvYWRpbmdDb21wbGV0ZSk7XG4gICAgY29uc3QgcHJldmlvdXNJbWFnZVNyYyA9ICgwLCBfcmVhY3QpLnVzZVJlZihzcmMpO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50ID0gb25Mb2FkaW5nQ29tcGxldGU7XG4gICAgfSwgW1xuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVxuICAgIF0pO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAocHJldmlvdXNJbWFnZVNyYy5jdXJyZW50ICE9PSBzcmMpIHtcbiAgICAgICAgICAgIHJlc2V0SW50ZXJzZWN0ZWQoKTtcbiAgICAgICAgICAgIHByZXZpb3VzSW1hZ2VTcmMuY3VycmVudCA9IHNyYztcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgcmVzZXRJbnRlcnNlY3RlZCxcbiAgICAgICAgc3JjXG4gICAgXSk7XG4gICAgY29uc3QgaW1nRWxlbWVudEFyZ3MgPSBfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgaXNMYXp5LFxuICAgICAgICBpbWdBdHRyaWJ1dGVzLFxuICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgIHdpZHRoSW50LFxuICAgICAgICBxdWFsaXR5SW50LFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgaW1nU3R5bGUsXG4gICAgICAgIGJsdXJTdHlsZSxcbiAgICAgICAgbG9hZGluZyxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICAgIGxvYWRlcixcbiAgICAgICAgc3JjU3RyaW5nLFxuICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZixcbiAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb24sXG4gICAgICAgIGlzVmlzaWJsZVxuICAgIH0sIHJlc3QpO1xuICAgIHJldHVybigvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIGxheW91dCA9PT0gJ3JhdycgPyAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoSW1hZ2VFbGVtZW50LCBPYmplY3QuYXNzaWduKHt9LCBpbWdFbGVtZW50QXJncykpIDogLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgICAgIHN0eWxlOiB3cmFwcGVyU3R5bGVcbiAgICB9LCBoYXNTaXplciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgICAgICBzdHlsZTogc2l6ZXJTdHlsZVxuICAgIH0sIHNpemVyU3ZnVXJsID8gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgICAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgd2lkdGg6ICdpbml0aWFsJyxcbiAgICAgICAgICAgIGhlaWdodDogJ2luaXRpYWwnLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDBcbiAgICAgICAgfSxcbiAgICAgICAgYWx0OiBcIlwiLFxuICAgICAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgICAgIHNyYzogc2l6ZXJTdmdVcmxcbiAgICB9KSA6IG51bGwpIDogbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KEltYWdlRWxlbWVudCwgT2JqZWN0LmFzc2lnbih7fSwgaW1nRWxlbWVudEFyZ3MpKSksIHByaW9yaXR5ID8gLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgIC8vIGZvciBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IGBpbWFnZXNyY3NldGAsIGFuZCBpbiB0aG9zZSBjYXNlc1xuICAgIC8vIGl0IHdvdWxkIGxpa2VseSBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI2F0dHItbGluay1pbWFnZXNyY3NldFxuICAgIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChfaGVhZC5kZWZhdWx0LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBrZXk6ICdfX25pbWctJyArIGltZ0F0dHJpYnV0ZXMuc3JjICsgaW1nQXR0cmlidXRlcy5zcmNTZXQgKyBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICBhczogXCJpbWFnZVwiLFxuICAgICAgICBocmVmOiBpbWdBdHRyaWJ1dGVzLnNyY1NldCA/IHVuZGVmaW5lZCA6IGltZ0F0dHJpYnV0ZXMuc3JjXG4gICAgfSwgbGlua1Byb3BzKSkpIDogbnVsbCkpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgICAgIGRlZmF1bHQ6IG9ialxuICAgIH07XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgICBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IHt9O1xuICAgICAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvcih2YXIga2V5IGluIG9iail7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDoge307XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXNjLmdldCB8fCBkZXNjLnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3T2JqLmRlZmF1bHQgPSBvYmo7XG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfVxufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHtcbiAgICBmb3IodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307XG4gICAgICAgIHZhciBvd25LZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG93bktleXMgPSBvd25LZXlzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSkuZmlsdGVyKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwgc3ltKS5lbnVtZXJhYmxlO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG93bktleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gICAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gICAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICAgIHZhciBrZXksIGk7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICAgIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICAgIHZhciB0YXJnZXQgPSB7fTtcbiAgICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBmb3IoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbnZhciByZWY7XG5jb25zdCBleHBlcmltZW50YWxMYXlvdXRSYXcgPSAocmVmID0gcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFMpID09PSBudWxsIHx8IHJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVmLmV4cGVyaW1lbnRhbExheW91dFJhdztcbmNvbnN0IGNvbmZpZ0VudiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9JTUFHRV9PUFRTO1xuY29uc3QgbG9hZGVkSW1hZ2VVUkxzID0gbmV3IFNldCgpO1xuY29uc3QgYWxsSW1ncyA9IG5ldyBNYXAoKTtcbmxldCBwZXJmT2JzZXJ2ZXI7XG5jb25zdCBlbXB0eURhdGFVUkwgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3JztcbmlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIGdsb2JhbC5fX05FWFRfSU1BR0VfSU1QT1JURUQgPSB0cnVlO1xufVxuY29uc3QgVkFMSURfTE9BRElOR19WQUxVRVMgPSBbXG4gICAgJ2xhenknLFxuICAgICdlYWdlcicsXG4gICAgdW5kZWZpbmVkXG5dO1xuY29uc3QgbG9hZGVycyA9IG5ldyBNYXAoW1xuICAgIFtcbiAgICAgICAgJ2RlZmF1bHQnLFxuICAgICAgICBkZWZhdWx0TG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdpbWdpeCcsXG4gICAgICAgIGltZ2l4TG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdjbG91ZGluYXJ5JyxcbiAgICAgICAgY2xvdWRpbmFyeUxvYWRlclxuICAgIF0sXG4gICAgW1xuICAgICAgICAnYWthbWFpJyxcbiAgICAgICAgYWthbWFpTG9hZGVyXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdjdXN0b20nLFxuICAgICAgICBjdXN0b21Mb2FkZXJcbiAgICBdLCBcbl0pO1xuY29uc3QgVkFMSURfTEFZT1VUX1ZBTFVFUyA9IFtcbiAgICAnZmlsbCcsXG4gICAgJ2ZpeGVkJyxcbiAgICAnaW50cmluc2ljJyxcbiAgICAncmVzcG9uc2l2ZScsXG4gICAgJ3JhdycsXG4gICAgdW5kZWZpbmVkLCBcbl07XG5mdW5jdGlvbiBpc1N0YXRpY1JlcXVpcmUoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5kZWZhdWx0ICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0ltYWdlRGF0YShzcmMpIHtcbiAgICByZXR1cm4gc3JjLnNyYyAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbXBvcnQoc3JjKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmZ1bmN0aW9uIGdldFdpZHRocyh7IGRldmljZVNpemVzICwgYWxsU2l6ZXMgIH0sIHdpZHRoLCBsYXlvdXQsIHNpemVzKSB7XG4gICAgaWYgKHNpemVzICYmIChsYXlvdXQgPT09ICdmaWxsJyB8fCBsYXlvdXQgPT09ICdyZXNwb25zaXZlJyB8fCBsYXlvdXQgPT09ICdyYXcnKSkge1xuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoUmUgPSAvKF58XFxzKSgxP1xcZD9cXGQpdncvZztcbiAgICAgICAgY29uc3QgcGVyY2VudFNpemVzID0gW107XG4gICAgICAgIGZvcihsZXQgbWF0Y2g7IG1hdGNoID0gdmlld3BvcnRXaWR0aFJlLmV4ZWMoc2l6ZXMpOyBtYXRjaCl7XG4gICAgICAgICAgICBwZXJjZW50U2l6ZXMucHVzaChwYXJzZUludChtYXRjaFsyXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJjZW50U2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMuZmlsdGVyKChzKT0+cyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW9cbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGtpbmQ6ICd3J1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBhbGxTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6ICd3J1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAnbnVtYmVyJyB8fCBsYXlvdXQgPT09ICdmaWxsJyB8fCBsYXlvdXQgPT09ICdyZXNwb25zaXZlJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBkZXZpY2VTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6ICd3J1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB3aWR0aHMgPSBbXG4gICAgICAgIC4uLm5ldyBTZXQoLy8gPiBUaGlzIG1lYW5zIHRoYXQgbW9zdCBPTEVEIHNjcmVlbnMgdGhhdCBzYXkgdGhleSBhcmUgM3ggcmVzb2x1dGlvbixcbiAgICAgICAgLy8gPiBhcmUgYWN0dWFsbHkgM3ggaW4gdGhlIGdyZWVuIGNvbG9yLCBidXQgb25seSAxLjV4IGluIHRoZSByZWQgYW5kXG4gICAgICAgIC8vID4gYmx1ZSBjb2xvcnMuIFNob3dpbmcgYSAzeCByZXNvbHV0aW9uIGltYWdlIGluIHRoZSBhcHAgdnMgYSAyeFxuICAgICAgICAvLyA+IHJlc29sdXRpb24gaW1hZ2Ugd2lsbCBiZSB2aXN1YWxseSB0aGUgc2FtZSwgdGhvdWdoIHRoZSAzeCBpbWFnZVxuICAgICAgICAvLyA+IHRha2VzIHNpZ25pZmljYW50bHkgbW9yZSBkYXRhLiBFdmVuIHRydWUgM3ggcmVzb2x1dGlvbiBzY3JlZW5zIGFyZVxuICAgICAgICAvLyA+IHdhc3RlZnVsIGFzIHRoZSBodW1hbiBleWUgY2Fubm90IHNlZSB0aGF0IGxldmVsIG9mIGRldGFpbCB3aXRob3V0XG4gICAgICAgIC8vID4gc29tZXRoaW5nIGxpa2UgYSBtYWduaWZ5aW5nIGdsYXNzLlxuICAgICAgICAvLyBodHRwczovL2Jsb2cudHdpdHRlci5jb20vZW5naW5lZXJpbmcvZW5fdXMvdG9waWNzL2luZnJhc3RydWN0dXJlLzIwMTkvY2FwcGluZy1pbWFnZS1maWRlbGl0eS1vbi11bHRyYS1oaWdoLXJlc29sdXRpb24tZGV2aWNlcy5odG1sXG4gICAgICAgIFtcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgd2lkdGggKiAyIC8qLCB3aWR0aCAqIDMqLyBcbiAgICAgICAgXS5tYXAoKHcpPT5hbGxTaXplcy5maW5kKChwKT0+cCA+PSB3XG4gICAgICAgICAgICApIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdXG4gICAgICAgICkpLCBcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRocyxcbiAgICAgICAga2luZDogJ3gnXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1nQXR0cnMoeyBjb25maWcgLCBzcmMgLCB1bm9wdGltaXplZCAsIGxheW91dCAsIHdpZHRoICwgcXVhbGl0eSAsIHNpemVzICwgbG9hZGVyICB9KSB7XG4gICAgaWYgKHVub3B0aW1pemVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBzcmNTZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHNpemVzOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyB3aWR0aHMgLCBraW5kICB9ID0gZ2V0V2lkdGhzKGNvbmZpZywgd2lkdGgsIGxheW91dCwgc2l6ZXMpO1xuICAgIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplczogIXNpemVzICYmIGtpbmQgPT09ICd3JyA/ICcxMDB2dycgOiBzaXplcyxcbiAgICAgICAgc3JjU2V0OiB3aWR0aHMubWFwKCh3LCBpKT0+YCR7bG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdcbiAgICAgICAgICAgIH0pfSAke2tpbmQgPT09ICd3JyA/IHcgOiBpICsgMX0ke2tpbmR9YFxuICAgICAgICApLmpvaW4oJywgJyksXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgc3JjYCB0aGUgbGFzdCBhdHRyaWJ1dGUgYmVjYXVzZSBSZWFjdCB1cGRhdGVzXG4gICAgICAgIC8vIGF0dHJpYnV0ZXMgaW4gb3JkZXIuIElmIHdlIGtlZXAgYHNyY2AgdGhlIGZpcnN0IG9uZSwgU2FmYXJpIHdpbGxcbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgc3RhcnQgdG8gZmV0Y2ggYHNyY2AsIGJlZm9yZSBgc2l6ZXNgIGFuZCBgc3JjU2V0YCBhcmUgZXZlblxuICAgICAgICAvLyB1cGRhdGVkIGJ5IFJlYWN0LiBUaGF0IGNhdXNlcyBtdWx0aXBsZSB1bm5lY2Vzc2FyeSByZXF1ZXN0cyBpZiBgc3JjU2V0YFxuICAgICAgICAvLyBhbmQgYHNpemVzYCBhcmUgZGVmaW5lZC5cbiAgICAgICAgLy8gVGhpcyBidWcgY2Fubm90IGJlIHJlcHJvZHVjZWQgaW4gQ2hyb21lIG9yIEZpcmVmb3guXG4gICAgICAgIHNyYzogbG9hZGVyKHtcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHF1YWxpdHksXG4gICAgICAgICAgICB3aWR0aDogd2lkdGhzW2xhc3RdXG4gICAgICAgIH0pXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEludCh4KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZGVmYXVsdEltYWdlTG9hZGVyKGxvYWRlclByb3BzKSB7XG4gICAgdmFyIHJlZjI7XG4gICAgY29uc3QgbG9hZGVyS2V5ID0gKChyZWYyID0gbG9hZGVyUHJvcHMuY29uZmlnKSA9PT0gbnVsbCB8fCByZWYyID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWYyLmxvYWRlcikgfHwgJ2RlZmF1bHQnO1xuICAgIGNvbnN0IGxvYWQgPSBsb2FkZXJzLmdldChsb2FkZXJLZXkpO1xuICAgIGlmIChsb2FkKSB7XG4gICAgICAgIHJldHVybiBsb2FkKGxvYWRlclByb3BzKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFwibG9hZGVyXCIgZm91bmQgaW4gXCJuZXh0LmNvbmZpZy5qc1wiLiBFeHBlY3RlZDogJHtfaW1hZ2VDb25maWcuVkFMSURfTE9BREVSUy5qb2luKCcsICcpfS4gUmVjZWl2ZWQ6ICR7bG9hZGVyS2V5fWApO1xufVxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTc3NzgzMy8yNjY1MzUgZm9yIHdoeSB3ZSB1c2UgdGhpcyByZWZcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmMsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUpIHtcbiAgICBpZiAoIWltZyB8fCBpbWcuc3JjID09PSBlbXB0eURhdGFVUkwgfHwgaW1nWydkYXRhLWxvYWRlZC1zcmMnXSA9PT0gc3JjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW1nWydkYXRhLWxvYWRlZC1zcmMnXSA9IHNyYztcbiAgICBjb25zdCBwID0gJ2RlY29kZScgaW4gaW1nID8gaW1nLmRlY29kZSgpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgcC5jYXRjaCgoKT0+e30pLnRoZW4oKCk9PntcbiAgICAgICAgaWYgKCFpbWcucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpbiBjYXNlIG9mIHJhY2UgY29uZGl0aW9uOlxuICAgICAgICAgICAgLy8gLSBvbmxvYWQoKSBpcyBjYWxsZWRcbiAgICAgICAgICAgIC8vIC0gZGVjb2RlKCkgaXMgY2FsbGVkIGJ1dCBpbmNvbXBsZXRlXG4gICAgICAgICAgICAvLyAtIHVubW91bnQgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyAtIGRlY29kZSgpIGNvbXBsZXRlc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvYWRlZEltYWdlVVJMcy5hZGQoc3JjKTtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSAnYmx1cicpIHtcbiAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWYgPT09IG51bGwgfHwgb25Mb2FkaW5nQ29tcGxldGVSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmF0dXJhbFdpZHRoICwgbmF0dXJhbEhlaWdodCAgfSA9IGltZztcbiAgICAgICAgICAgIC8vIFBhc3MgYmFjayByZWFkLW9ubHkgcHJpbWl0aXZlIHZhbHVlcyBidXQgbm90IHRoZVxuICAgICAgICAgICAgLy8gdW5kZXJseWluZyBET00gZWxlbWVudCBiZWNhdXNlIGl0IGNvdWxkIGJlIG1pc3VzZWQuXG4gICAgICAgICAgICBvbkxvYWRpbmdDb21wbGV0ZVJlZi5jdXJyZW50KHtcbiAgICAgICAgICAgICAgICBuYXR1cmFsV2lkdGgsXG4gICAgICAgICAgICAgICAgbmF0dXJhbEhlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHZhciByZWYzO1xuICAgICAgICAgICAgaWYgKChyZWYzID0gaW1nLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IHJlZjMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZjMucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGdldENvbXB1dGVkU3R5bGUoaW1nLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcGFyZW50IGhhcyBub3QgYmVlbiByZW5kZXJlZCB0byB0aGUgZG9tIHlldCBhbmQgdGhlcmVmb3JlIGl0IGhhcyBubyBwb3NpdGlvbi4gU2tpcCB0aGUgd2FybmluZ3MgZm9yIHN1Y2ggY2FzZXMuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXlvdXQgPT09ICdyZXNwb25zaXZlJyAmJiBwYXJlbnQuZGlzcGxheSA9PT0gJ2ZsZXgnKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIG1heSBub3QgcmVuZGVyIHByb3Blcmx5IGFzIGEgY2hpbGQgb2YgYSBmbGV4IGNvbnRhaW5lci4gQ29uc2lkZXIgd3JhcHBpbmcgdGhlIGltYWdlIHdpdGggYSBkaXYgdG8gY29uZmlndXJlIHRoZSB3aWR0aC5gKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheW91dCA9PT0gJ2ZpbGwnICYmIHBhcmVudC5wb3NpdGlvbiAhPT0gJ3JlbGF0aXZlJyAmJiBwYXJlbnQucG9zaXRpb24gIT09ICdmaXhlZCcgJiYgcGFyZW50LnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCBfdXRpbHMpLndhcm5PbmNlKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIG1heSBub3QgcmVuZGVyIHByb3Blcmx5IHdpdGggYSBwYXJlbnQgdXNpbmcgcG9zaXRpb246XCIke3BhcmVudC5wb3NpdGlvbn1cIi4gQ29uc2lkZXIgY2hhbmdpbmcgdGhlIHBhcmVudCBzdHlsZSB0byBwb3NpdGlvbjpcInJlbGF0aXZlXCIgd2l0aCBhIHdpZHRoIGFuZCBoZWlnaHQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5jb25zdCBJbWFnZUVsZW1lbnQgPSAoX3BhcmFtKT0+e1xuICAgIHZhciB7IGltZ0F0dHJpYnV0ZXMgLCBoZWlnaHRJbnQgLCB3aWR0aEludCAsIHF1YWxpdHlJbnQgLCBsYXlvdXQgLCBjbGFzc05hbWUgLCBpbWdTdHlsZSAsIGJsdXJTdHlsZSAsIGlzTGF6eSAsIHBsYWNlaG9sZGVyICwgbG9hZGluZyAsIHNyY1N0cmluZyAsIGNvbmZpZyAsIHVub3B0aW1pemVkICwgbG9hZGVyICwgb25Mb2FkaW5nQ29tcGxldGVSZWYgLCBzZXRCbHVyQ29tcGxldGUgLCBzZXRJbnRlcnNlY3Rpb24gLCBvbkVycm9yICwgaXNWaXNpYmxlICB9ID0gX3BhcmFtLCByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wYXJhbSwgW1xuICAgICAgICBcImltZ0F0dHJpYnV0ZXNcIixcbiAgICAgICAgXCJoZWlnaHRJbnRcIixcbiAgICAgICAgXCJ3aWR0aEludFwiLFxuICAgICAgICBcInF1YWxpdHlJbnRcIixcbiAgICAgICAgXCJsYXlvdXRcIixcbiAgICAgICAgXCJjbGFzc05hbWVcIixcbiAgICAgICAgXCJpbWdTdHlsZVwiLFxuICAgICAgICBcImJsdXJTdHlsZVwiLFxuICAgICAgICBcImlzTGF6eVwiLFxuICAgICAgICBcInBsYWNlaG9sZGVyXCIsXG4gICAgICAgIFwibG9hZGluZ1wiLFxuICAgICAgICBcInNyY1N0cmluZ1wiLFxuICAgICAgICBcImNvbmZpZ1wiLFxuICAgICAgICBcInVub3B0aW1pemVkXCIsXG4gICAgICAgIFwibG9hZGVyXCIsXG4gICAgICAgIFwib25Mb2FkaW5nQ29tcGxldGVSZWZcIixcbiAgICAgICAgXCJzZXRCbHVyQ29tcGxldGVcIixcbiAgICAgICAgXCJzZXRJbnRlcnNlY3Rpb25cIixcbiAgICAgICAgXCJvbkVycm9yXCIsXG4gICAgICAgIFwiaXNWaXNpYmxlXCJcbiAgICBdKTtcbiAgICByZXR1cm4oLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9yZWFjdC5kZWZhdWx0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgT2JqZWN0LmFzc2lnbih7fSwgcmVzdCwgaW1nQXR0cmlidXRlcywgbGF5b3V0ID09PSAncmF3JyAmJiAhaW1nQXR0cmlidXRlcy5zaXplcyA/IHtcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRJbnQsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludFxuICAgIH0gOiB7fSwge1xuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBsYXlvdXQsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZTogX29iamVjdFNwcmVhZCh7fSwgaW1nU3R5bGUsIGJsdXJTdHlsZSksXG4gICAgICAgIHJlZjogKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKGltZyk9PntcbiAgICAgICAgICAgIHNldEludGVyc2VjdGlvbihpbWcpO1xuICAgICAgICAgICAgaWYgKGltZyA9PT0gbnVsbCB8fCBpbWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmNTdHJpbmcsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgICBzZXRJbnRlcnNlY3Rpb24sXG4gICAgICAgICAgICBzcmNTdHJpbmcsXG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcixcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlLCBcbiAgICAgICAgXSksXG4gICAgICAgIG9uTG9hZDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBzcmNTdHJpbmcsIGxheW91dCwgcGxhY2Vob2xkZXIsIG9uTG9hZGluZ0NvbXBsZXRlUmVmLCBzZXRCbHVyQ29tcGxldGUpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVycm9yOiAoZXZlbnQpPT57XG4gICAgICAgICAgICBpZiAocGxhY2Vob2xkZXIgPT09ICdibHVyJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBzdGlsbCByZW1vdmUgdGhlIHBsYWNlaG9sZGVyLlxuICAgICAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSksIChpc0xhenkgfHwgcGxhY2Vob2xkZXIgPT09ICdibHVyJykgJiYgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibm9zY3JpcHRcIiwgbnVsbCwgLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaW1nXCIsIE9iamVjdC5hc3NpZ24oe30sIHJlc3QsIGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIHNyYzogc3JjU3RyaW5nLFxuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICB3aWR0aDogd2lkdGhJbnQsXG4gICAgICAgIHF1YWxpdHk6IHF1YWxpdHlJbnQsXG4gICAgICAgIHNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBsb2FkZXJcbiAgICB9KSwgbGF5b3V0ID09PSAncmF3JyAmJiAhaW1nQXR0cmlidXRlcy5zaXplcyA/IHtcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRJbnQsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludFxuICAgIH0gOiB7fSwge1xuICAgICAgICBkZWNvZGluZzogXCJhc3luY1wiLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBsYXlvdXQsXG4gICAgICAgIHN0eWxlOiBpbWdTdHlsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3RAMTdgXG4gICAgICAgIGxvYWRpbmc6IGxvYWRpbmcgfHwgJ2xhenknXG4gICAgfSkpKSkpO1xufTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNyYyhzcmMpIHtcbiAgICByZXR1cm4gc3JjWzBdID09PSAnLycgPyBzcmMuc2xpY2UoMSkgOiBzcmM7XG59XG5mdW5jdGlvbiBpbWdpeExvYWRlcih7IGNvbmZpZyAsIHNyYyAsIHdpZHRoICwgcXVhbGl0eSAgfSkge1xuICAgIC8vIERlbW86IGh0dHBzOi8vc3RhdGljLmltZ2l4Lm5ldC9kYWlzeS5wbmc/YXV0bz1mb3JtYXQmZml0PW1heCZ3PTMwMFxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7Y29uZmlnLnBhdGh9JHtub3JtYWxpemVTcmMoc3JjKX1gKTtcbiAgICBjb25zdCBwYXJhbXMgPSB1cmwuc2VhcmNoUGFyYW1zO1xuICAgIHBhcmFtcy5zZXQoJ2F1dG8nLCBwYXJhbXMuZ2V0KCdhdXRvJykgfHwgJ2Zvcm1hdCcpO1xuICAgIHBhcmFtcy5zZXQoJ2ZpdCcsIHBhcmFtcy5nZXQoJ2ZpdCcpIHx8ICdtYXgnKTtcbiAgICBwYXJhbXMuc2V0KCd3JywgcGFyYW1zLmdldCgndycpIHx8IHdpZHRoLnRvU3RyaW5nKCkpO1xuICAgIGlmIChxdWFsaXR5KSB7XG4gICAgICAgIHBhcmFtcy5zZXQoJ3EnLCBxdWFsaXR5LnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsLmhyZWY7XG59XG5mdW5jdGlvbiBha2FtYWlMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAgfSkge1xuICAgIHJldHVybiBgJHtjb25maWcucGF0aH0ke25vcm1hbGl6ZVNyYyhzcmMpfT9pbXdpZHRoPSR7d2lkdGh9YDtcbn1cbmZ1bmN0aW9uIGNsb3VkaW5hcnlMb2FkZXIoeyBjb25maWcgLCBzcmMgLCB3aWR0aCAsIHF1YWxpdHkgIH0pIHtcbiAgICAvLyBEZW1vOiBodHRwczovL3Jlcy5jbG91ZGluYXJ5LmNvbS9kZW1vL2ltYWdlL3VwbG9hZC93XzMwMCxjX2xpbWl0LHFfYXV0by90dXJ0bGVzLmpwZ1xuICAgIGNvbnN0IHBhcmFtcyA9IFtcbiAgICAgICAgJ2ZfYXV0bycsXG4gICAgICAgICdjX2xpbWl0JyxcbiAgICAgICAgJ3dfJyArIHdpZHRoLFxuICAgICAgICAncV8nICsgKHF1YWxpdHkgfHwgJ2F1dG8nKVxuICAgIF07XG4gICAgY29uc3QgcGFyYW1zU3RyaW5nID0gcGFyYW1zLmpvaW4oJywnKSArICcvJztcbiAgICByZXR1cm4gYCR7Y29uZmlnLnBhdGh9JHtwYXJhbXNTdHJpbmd9JHtub3JtYWxpemVTcmMoc3JjKX1gO1xufVxuZnVuY3Rpb24gY3VzdG9tTG9hZGVyKHsgc3JjICB9KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbWFnZSB3aXRoIHNyYyBcIiR7c3JjfVwiIGlzIG1pc3NpbmcgXCJsb2FkZXJcIiBwcm9wLmAgKyBgXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyYCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0TG9hZGVyKHsgY29uZmlnICwgc3JjICwgd2lkdGggLCBxdWFsaXR5ICB9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgbWlzc2luZ1ZhbHVlcyA9IFtdO1xuICAgICAgICAvLyB0aGVzZSBzaG91bGQgYWx3YXlzIGJlIHByb3ZpZGVkIGJ1dCBtYWtlIHN1cmUgdGhleSBhcmVcbiAgICAgICAgaWYgKCFzcmMpIG1pc3NpbmdWYWx1ZXMucHVzaCgnc3JjJyk7XG4gICAgICAgIGlmICghd2lkdGgpIG1pc3NpbmdWYWx1ZXMucHVzaCgnd2lkdGgnKTtcbiAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXh0IEltYWdlIE9wdGltaXphdGlvbiByZXF1aXJlcyAke21pc3NpbmdWYWx1ZXMuam9pbignLCAnKX0gdG8gYmUgcHJvdmlkZWQuIE1ha2Ugc3VyZSB5b3UgcGFzcyB0aGVtIGFzIHByb3BzIHRvIHRoZSBcXGBuZXh0L2ltYWdlXFxgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNyYyBcIiR7c3JjfVwiIG9uIFxcYG5leHQvaW1hZ2VcXGAsIHByb3RvY29sLXJlbGF0aXZlIFVSTCAoLy8pIG11c3QgYmUgY2hhbmdlZCB0byBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzcmMuc3RhcnRzV2l0aCgnLycpICYmIGNvbmZpZy5kb21haW5zKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkU3JjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJHtzcmN9XCIgb24gXFxgbmV4dC9pbWFnZVxcYCwgaWYgdXNpbmcgcmVsYXRpdmUgaW1hZ2UgaXQgbXVzdCBzdGFydCB3aXRoIGEgbGVhZGluZyBzbGFzaCBcIi9cIiBvciBiZSBhbiBhYnNvbHV0ZSBVUkwgKGh0dHA6Ly8gb3IgaHR0cHM6Ly8pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiAhY29uZmlnLmRvbWFpbnMuaW5jbHVkZXMocGFyc2VkU3JjLmhvc3RuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzcmMgcHJvcCAoJHtzcmN9KSBvbiBcXGBuZXh0L2ltYWdlXFxgLCBob3N0bmFtZSBcIiR7cGFyc2VkU3JjLmhvc3RuYW1lfVwiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIFxcYG5leHQuY29uZmlnLmpzXFxgXFxuYCArIGBTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNyYy5lbmRzV2l0aCgnLnN2ZycpICYmICFjb25maWcuZGFuZ2Vyb3VzbHlBbGxvd1NWRykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gbWFrZSBzdmcgc2VydmUgYXMtaXMgdG8gYXZvaWQgcHJveHlpbmdcbiAgICAgICAgLy8gdGhyb3VnaCB0aGUgYnVpbHQtaW4gSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG4gICAgcmV0dXJuIGAkeygwLCBfbm9ybWFsaXplVHJhaWxpbmdTbGFzaCkubm9ybWFsaXplUGF0aFRyYWlsaW5nU2xhc2goY29uZmlnLnBhdGgpfT91cmw9JHtlbmNvZGVVUklDb21wb25lbnQoc3JjKX0mdz0ke3dpZHRofSZxPSR7cXVhbGl0eSB8fCA3NX1gO1xufVxuXG5pZiAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkge1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJkZWZhdWx0IiwiSW1hZ2UiLCJfcmVhY3QiLCJfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCIsInJlcXVpcmUiLCJfaGVhZCIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfaW1hZ2VDb25maWciLCJfdXNlSW50ZXJzZWN0aW9uIiwiX2ltYWdlQ29uZmlnQ29udGV4dCIsIl91dGlscyIsIl9ub3JtYWxpemVUcmFpbGluZ1NsYXNoIiwiX3BhcmFtIiwic3JjIiwic2l6ZXMiLCJ1bm9wdGltaXplZCIsInByaW9yaXR5IiwibG9hZGluZyIsImxhenlSb290IiwibGF6eUJvdW5kYXJ5IiwiY2xhc3NOYW1lIiwicXVhbGl0eSIsIndpZHRoIiwiaGVpZ2h0Iiwic3R5bGUiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsIm9uTG9hZGluZ0NvbXBsZXRlIiwib25FcnJvciIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJhbGwiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJjb25maWdDb250ZXh0IiwidXNlQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsImNvbmZpZyIsInVzZU1lbW8iLCJjIiwiY29uZmlnRW52IiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiYWxsU2l6ZXMiLCJkZXZpY2VTaXplcyIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJfb2JqZWN0U3ByZWFkIiwicmVzdCIsImxheW91dCIsImxvYWRlciIsImRlZmF1bHRJbWFnZUxvYWRlciIsImN1c3RvbUltYWdlTG9hZGVyIiwiX3RtcCIsIm9iaiIsIl8iLCJvcHRzIiwic3RhdGljU3JjIiwiaXNTdGF0aWNJbXBvcnQiLCJzdGF0aWNJbWFnZURhdGEiLCJpc1N0YXRpY1JlcXVpcmUiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJ3aWR0aEludCIsImdldEludCIsImhlaWdodEludCIsInF1YWxpdHlJbnQiLCJpc0xhenkiLCJzdGFydHNXaXRoIiwibG9hZGVkSW1hZ2VVUkxzIiwiaGFzIiwidXNlU3RhdGUiLCJibHVyQ29tcGxldGUiLCJzZXRCbHVyQ29tcGxldGUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJyb290UmVmIiwicm9vdE1hcmdpbiIsImRpc2FibGVkIiwic2V0SW50ZXJzZWN0aW9uIiwiaXNJbnRlcnNlY3RlZCIsInJlc2V0SW50ZXJzZWN0ZWQiLCJpc1Zpc2libGUiLCJ3cmFwcGVyU3R5bGUiLCJib3hTaXppbmciLCJkaXNwbGF5Iiwib3ZlcmZsb3ciLCJiYWNrZ3JvdW5kIiwib3BhY2l0eSIsImJvcmRlciIsIm1hcmdpbiIsInBhZGRpbmciLCJzaXplclN0eWxlIiwiaGFzU2l6ZXIiLCJzaXplclN2Z1VybCIsImxheW91dFN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiYm90dG9tIiwicmlnaHQiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwibWluSGVpZ2h0IiwibWF4SGVpZ2h0IiwicHJvY2VzcyIsIlZBTElEX0xBWU9VVF9WQUxVRVMiLCJpbmNsdWRlcyIsIm1hcCIsIlN0cmluZyIsImpvaW4iLCJleHBlcmltZW50YWxMYXlvdXRSYXciLCJpc05hTiIsIndhcm5PbmNlIiwiVkFMSURfTE9BRElOR19WQUxVRVMiLCJWQUxJRF9CTFVSX0VYVCIsInVybFN0ciIsInVybCIsIlVSTCIsImVyciIsInBhdGhuYW1lIiwic2VhcmNoIiwib3ZlcndyaXR0ZW5TdHlsZXMiLCJrZXlzIiwiZmlsdGVyIiwia2V5IiwibGVuZ3RoIiwicGVyZk9ic2VydmVyIiwid2luZG93IiwiUGVyZm9ybWFuY2VPYnNlcnZlciIsImVudHJ5TGlzdCIsImdldEVudHJpZXMiLCJlbnRyeSIsInJlZjEiLCJpbWdTcmMiLCJlbGVtZW50IiwibGNwSW1hZ2UiLCJhbGxJbWdzIiwiZ2V0Iiwib2JzZXJ2ZSIsInR5cGUiLCJidWZmZXJlZCIsImNvbnNvbGUiLCJlcnJvciIsImltZ1N0eWxlIiwiYXNzaWduIiwiYXNwZWN0UmF0aW8iLCJibHVyU3R5bGUiLCJiYWNrZ3JvdW5kU2l6ZSIsImJhY2tncm91bmRJbWFnZSIsImJhY2tncm91bmRQb3NpdGlvbiIsInF1b3RpZW50IiwicGFkZGluZ1RvcCIsImltZ0F0dHJpYnV0ZXMiLCJlbXB0eURhdGFVUkwiLCJzcmNTZXQiLCJ1bmRlZmluZWQiLCJnZW5lcmF0ZUltZ0F0dHJzIiwic3JjU3RyaW5nIiwiZnVsbFVybCIsImUiLCJsb2NhdGlvbiIsImhyZWYiLCJzZXQiLCJpbWFnZVNyY1NldFByb3BOYW1lIiwiaW1hZ2VTaXplc1Byb3BOYW1lIiwiZW52IiwiX19ORVhUX1JFQUNUX1JPT1QiLCJsaW5rUHJvcHMiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJvbkxvYWRpbmdDb21wbGV0ZVJlZiIsInVzZVJlZiIsInByZXZpb3VzSW1hZ2VTcmMiLCJjdXJyZW50IiwiaW1nRWxlbWVudEFyZ3MiLCJjcmVhdGVFbGVtZW50IiwiRnJhZ21lbnQiLCJJbWFnZUVsZW1lbnQiLCJhbHQiLCJyZWwiLCJhcyIsIl9kZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fZXNNb2R1bGUiLCJuZXdPYmoiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidGFyZ2V0Iiwic291cmNlIiwiYXJndW1lbnRzIiwiaSIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJjb25jYXQiLCJzeW0iLCJmb3JFYWNoIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJpbmRleE9mIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJzb3VyY2VLZXlzIiwicmVmIiwiX19ORVhUX0lNQUdFX09QVFMiLCJTZXQiLCJNYXAiLCJnbG9iYWwiLCJfX05FWFRfSU1BR0VfSU1QT1JURUQiLCJsb2FkZXJzIiwiZGVmYXVsdExvYWRlciIsImltZ2l4TG9hZGVyIiwiY2xvdWRpbmFyeUxvYWRlciIsImFrYW1haUxvYWRlciIsImN1c3RvbUxvYWRlciIsImlzU3RhdGljSW1hZ2VEYXRhIiwiZ2V0V2lkdGhzIiwidmlld3BvcnRXaWR0aFJlIiwicGVyY2VudFNpemVzIiwibWF0Y2giLCJleGVjIiwicHVzaCIsInBhcnNlSW50IiwiTWF0aCIsInNtYWxsZXN0UmF0aW8iLCJtaW4iLCJ3aWR0aHMiLCJzIiwia2luZCIsInciLCJmaW5kIiwicCIsImxhc3QiLCJ4IiwibG9hZGVyUHJvcHMiLCJyZWYyIiwibG9hZGVyS2V5IiwibG9hZCIsIlZBTElEX0xPQURFUlMiLCJoYW5kbGVMb2FkaW5nIiwiaW1nIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJwYXJlbnROb2RlIiwiYWRkIiwibmF0dXJhbFdpZHRoIiwibmF0dXJhbEhlaWdodCIsInJlZjMiLCJwYXJlbnRFbGVtZW50IiwicGFyZW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImRlY29kaW5nIiwidXNlQ2FsbGJhY2siLCJjb21wbGV0ZSIsIm9uTG9hZCIsImV2ZW50IiwiY3VycmVudFRhcmdldCIsIm5vcm1hbGl6ZVNyYyIsInNsaWNlIiwicGF0aCIsInBhcmFtcyIsInNlYXJjaFBhcmFtcyIsInRvU3RyaW5nIiwicGFyYW1zU3RyaW5nIiwibWlzc2luZ1ZhbHVlcyIsImRvbWFpbnMiLCJwYXJzZWRTcmMiLCJob3N0bmFtZSIsImVuZHNXaXRoIiwiZGFuZ2Vyb3VzbHlBbGxvd1NWRyIsImVuY29kZVVSSUNvbXBvbmVudCIsIm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/image.js\n");

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArrayLimit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s1, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s1 = _i.next()).done); _n = true){\n            _arr.push(_s1.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.useIntersection = useIntersection;\nvar _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nvar hasIntersectionObserver = typeof IntersectionObserver !== \"undefined\";\nfunction useIntersection(param) {\n    var rootRef = param.rootRef, rootMargin = param.rootMargin, disabled = param.disabled;\n    _s();\n    var isDisabled = disabled || !hasIntersectionObserver;\n    var unobserve = (0, _react).useRef();\n    var ref = _slicedToArray((0, _react).useState(false), 2), visible = ref[0], setVisible = ref[1];\n    var ref1 = _slicedToArray((0, _react).useState(rootRef ? rootRef.current : null), 2), root = ref1[0], setRoot = ref1[1];\n    var setRef = (0, _react).useCallback(function(el) {\n        if (unobserve.current) {\n            unobserve.current();\n            unobserve.current = undefined;\n        }\n        if (isDisabled || visible) return;\n        if (el && el.tagName) {\n            unobserve.current = observe(el, function(isVisible) {\n                return isVisible && setVisible(isVisible);\n            }, {\n                root: root,\n                rootMargin: rootMargin\n            });\n        }\n    }, [\n        isDisabled,\n        root,\n        rootMargin,\n        visible\n    ]);\n    var resetVisible = (0, _react).useCallback(function() {\n        setVisible(false);\n    }, []);\n    (0, _react).useEffect(function() {\n        if (!hasIntersectionObserver) {\n            if (!visible) {\n                var idleCallback = (0, _requestIdleCallback).requestIdleCallback(function() {\n                    return setVisible(true);\n                });\n                return function() {\n                    return (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n                };\n            }\n        }\n    }, [\n        visible\n    ]);\n    (0, _react).useEffect(function() {\n        if (rootRef) setRoot(rootRef.current);\n    }, [\n        rootRef\n    ]);\n    return [\n        setRef,\n        visible,\n        resetVisible\n    ];\n}\n_s(useIntersection, \"v899qx2Oxsy68lv6LR1+qv/1rnU=\");\nfunction observe(element, callback, options) {\n    var ref = createObserver(options), id = ref.id, observer = ref.observer, elements = ref.elements;\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            var index = idList.findIndex(function(obj) {\n                return obj.root === id.root && obj.margin === id.margin;\n            });\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nvar observers = new Map();\nvar idList = [];\nfunction createObserver(options) {\n    var id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    var existing = idList.find(function(obj) {\n        return obj.root === id.root && obj.margin === id.margin;\n    });\n    var instance;\n    if (existing) {\n        instance = observers.get(existing);\n    } else {\n        instance = observers.get(id);\n        idList.push(id);\n    }\n    if (instance) {\n        return instance;\n    }\n    var elements = new Map();\n    var observer = new IntersectionObserver(function(entries) {\n        entries.forEach(function(entry) {\n            var callback = elements.get(entry.target);\n            var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    observers.set(id, instance = {\n        id: id,\n        observer: observer,\n        elements: elements\n    });\n    return instance;\n}\nif (typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) {\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0lBQ3pDRyxLQUFLLEVBQUUsSUFBSTtDQUNkLEVBQUMsQ0FBQztBQUNIRCx1QkFBdUIsR0FBR0UsZUFBZSxDQUFDO0FBQzFDLElBQUlDLE1BQU0sR0FBR0MsbUJBQU8sQ0FBQyw0Q0FBTyxDQUFDO0FBQzdCLElBQUlDLG9CQUFvQixHQUFHRCxtQkFBTyxDQUFDLHlGQUF5QixDQUFDO0FBQzdELElBQU1FLHVCQUF1QixHQUFHLE9BQU9DLG9CQUFvQixLQUFLLFdBQVc7QUFDM0UsU0FBU0wsZUFBZSxDQUFDLEtBQW9DLEVBQUU7UUFBcENNLE9BQU8sR0FBVCxLQUFvQyxDQUFsQ0EsT0FBTyxFQUFHQyxVQUFVLEdBQXRCLEtBQW9DLENBQXhCQSxVQUFVLEVBQUdDLFFBQVEsR0FBakMsS0FBb0MsQ0FBWEEsUUFBUTs7SUFDdEQsSUFBTUMsVUFBVSxHQUFHRCxRQUFRLElBQUksQ0FBQ0osdUJBQXVCO0lBQ3ZELElBQU1NLFNBQVMsR0FBRyxDQUFDLENBQUMsRUFBRVQsTUFBTSxDQUFDLENBQUNVLE1BQU0sRUFBRTtJQUN0QyxJQUE4QixHQUEyQixrQkFBM0IsQ0FBQyxDQUFDLEVBQUVWLE1BQU0sQ0FBQyxDQUFDVyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQWxEQyxPQUFPLEdBQWdCLEdBQTJCLEdBQTNDLEVBQUVDLFVBQVUsR0FBSSxHQUEyQixHQUEvQjtJQUMxQixJQUF3QixJQUFzRCxrQkFBdEQsQ0FBQyxDQUFDLEVBQUViLE1BQU0sQ0FBQyxDQUFDVyxRQUFRLENBQUNOLE9BQU8sR0FBR0EsT0FBTyxDQUFDUyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQXZFQyxJQUFJLEdBQWEsSUFBc0QsR0FBbkUsRUFBRUMsT0FBTyxHQUFJLElBQXNELEdBQTFEO0lBQ3BCLElBQU1DLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRWpCLE1BQU0sQ0FBQyxDQUFDa0IsV0FBVyxDQUFDLFNBQUNDLEVBQUUsRUFBRztRQUN6QyxJQUFJVixTQUFTLENBQUNLLE9BQU8sRUFBRTtZQUNuQkwsU0FBUyxDQUFDSyxPQUFPLEVBQUUsQ0FBQztZQUNwQkwsU0FBUyxDQUFDSyxPQUFPLEdBQUdNLFNBQVMsQ0FBQztTQUNqQztRQUNELElBQUlaLFVBQVUsSUFBSUksT0FBTyxFQUFFLE9BQU87UUFDbEMsSUFBSU8sRUFBRSxJQUFJQSxFQUFFLENBQUNFLE9BQU8sRUFBRTtZQUNsQlosU0FBUyxDQUFDSyxPQUFPLEdBQUdRLE9BQU8sQ0FBQ0gsRUFBRSxFQUFFLFNBQUNJLFNBQVM7dUJBQUdBLFNBQVMsSUFBSVYsVUFBVSxDQUFDVSxTQUFTLENBQUM7YUFBQSxFQUM3RTtnQkFDRVIsSUFBSSxFQUFKQSxJQUFJO2dCQUNKVCxVQUFVLEVBQVZBLFVBQVU7YUFDYixDQUFDLENBQUM7U0FDTjtLQUNKLEVBQUU7UUFDQ0UsVUFBVTtRQUNWTyxJQUFJO1FBQ0pULFVBQVU7UUFDVk0sT0FBTztLQUNWLENBQUM7SUFDRixJQUFNWSxZQUFZLEdBQUcsQ0FBQyxDQUFDLEVBQUV4QixNQUFNLENBQUMsQ0FBQ2tCLFdBQVcsQ0FBQyxXQUFJO1FBQzdDTCxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDckIsRUFBRSxFQUFFLENBQUM7SUFDTixDQUFDLENBQUMsRUFBRWIsTUFBTSxDQUFDLENBQUN5QixTQUFTLENBQUMsV0FBSTtRQUN0QixJQUFJLENBQUN0Qix1QkFBdUIsRUFBRTtZQUMxQixJQUFJLENBQUNTLE9BQU8sRUFBRTtnQkFDVixJQUFNYyxZQUFZLEdBQUcsQ0FBQyxDQUFDLEVBQUV4QixvQkFBb0IsQ0FBQyxDQUFDeUIsbUJBQW1CLENBQUM7MkJBQUlkLFVBQVUsQ0FBQyxJQUFJLENBQUM7aUJBQUEsQ0FDdEY7Z0JBQ0QsT0FBTzsyQkFBSSxDQUFDLENBQUMsRUFBRVgsb0JBQW9CLENBQUMsQ0FBQzBCLGtCQUFrQixDQUFDRixZQUFZLENBQUM7aUJBQUEsQ0FDcEU7YUFDSjtTQUNKO0tBQ0osRUFBRTtRQUNDZCxPQUFPO0tBQ1YsQ0FBQyxDQUFDO0lBQ0gsQ0FBQyxDQUFDLEVBQUVaLE1BQU0sQ0FBQyxDQUFDeUIsU0FBUyxDQUFDLFdBQUk7UUFDdEIsSUFBSXBCLE9BQU8sRUFBRVcsT0FBTyxDQUFDWCxPQUFPLENBQUNTLE9BQU8sQ0FBQyxDQUFDO0tBQ3pDLEVBQUU7UUFDQ1QsT0FBTztLQUNWLENBQUMsQ0FBQztJQUNILE9BQU87UUFDSFksTUFBTTtRQUNOTCxPQUFPO1FBQ1BZLFlBQVk7S0FDZixDQUFDO0NBQ0w7R0FqRFF6QixlQUFlO0FBa0R4QixTQUFTdUIsT0FBTyxDQUFDTyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsT0FBTyxFQUFFO0lBQ3pDLElBQXNDQyxHQUF1QixHQUF2QkEsY0FBYyxDQUFDRCxPQUFPLENBQUMsRUFBckRFLEVBQUUsR0FBNEJELEdBQXVCLENBQXJEQyxFQUFFLEVBQUdDLFFBQVEsR0FBaUJGLEdBQXVCLENBQWhERSxRQUFRLEVBQUdDLFFBQVEsR0FBTUgsR0FBdUIsQ0FBckNHLFFBQVE7SUFDaENBLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDUCxPQUFPLEVBQUVDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hDSSxRQUFRLENBQUNaLE9BQU8sQ0FBQ08sT0FBTyxDQUFDLENBQUM7SUFDMUIsT0FBTyxTQUFTcEIsU0FBUyxHQUFHO1FBQ3hCMEIsUUFBUSxDQUFDRSxNQUFNLENBQUNSLE9BQU8sQ0FBQyxDQUFDO1FBQ3pCSyxRQUFRLENBQUN6QixTQUFTLENBQUNvQixPQUFPLENBQUMsQ0FBQztRQUM1Qix1REFBdUQ7UUFDdkQsSUFBSU0sUUFBUSxDQUFDRyxJQUFJLEtBQUssQ0FBQyxFQUFFO1lBQ3JCSixRQUFRLENBQUNLLFVBQVUsRUFBRSxDQUFDO1lBQ3RCQyxTQUFTLENBQUNILE1BQU0sQ0FBQ0osRUFBRSxDQUFDLENBQUM7WUFDckIsSUFBSVEsS0FBSyxHQUFHQyxNQUFNLENBQUNDLFNBQVMsQ0FBQyxTQUFDQyxHQUFHO3VCQUFHQSxHQUFHLENBQUM3QixJQUFJLEtBQUtrQixFQUFFLENBQUNsQixJQUFJLElBQUk2QixHQUFHLENBQUNDLE1BQU0sS0FBS1osRUFBRSxDQUFDWSxNQUFNO2FBQUEsQ0FDbkY7WUFDRCxJQUFJSixLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUU7Z0JBQ1pDLE1BQU0sQ0FBQ0ksTUFBTSxDQUFDTCxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDM0I7U0FDSjtLQUNKLENBQUM7Q0FDTDtBQUNELElBQU1ELFNBQVMsR0FBRyxJQUFJTyxHQUFHLEVBQUU7QUFDM0IsSUFBTUwsTUFBTSxHQUFHLEVBQUU7QUFDakIsU0FBU1YsY0FBYyxDQUFDRCxPQUFPLEVBQUU7SUFDN0IsSUFBTUUsRUFBRSxHQUFHO1FBQ1BsQixJQUFJLEVBQUVnQixPQUFPLENBQUNoQixJQUFJLElBQUksSUFBSTtRQUMxQjhCLE1BQU0sRUFBRWQsT0FBTyxDQUFDekIsVUFBVSxJQUFJLEVBQUU7S0FDbkM7SUFDRCxJQUFJMEMsUUFBUSxHQUFHTixNQUFNLENBQUNPLElBQUksQ0FBQyxTQUFDTCxHQUFHO2VBQUdBLEdBQUcsQ0FBQzdCLElBQUksS0FBS2tCLEVBQUUsQ0FBQ2xCLElBQUksSUFBSTZCLEdBQUcsQ0FBQ0MsTUFBTSxLQUFLWixFQUFFLENBQUNZLE1BQU07S0FBQSxDQUNqRjtJQUNELElBQUlLLFFBQVE7SUFDWixJQUFJRixRQUFRLEVBQUU7UUFDVkUsUUFBUSxHQUFHVixTQUFTLENBQUNXLEdBQUcsQ0FBQ0gsUUFBUSxDQUFDLENBQUM7S0FDdEMsTUFBTTtRQUNIRSxRQUFRLEdBQUdWLFNBQVMsQ0FBQ1csR0FBRyxDQUFDbEIsRUFBRSxDQUFDLENBQUM7UUFDN0JTLE1BQU0sQ0FBQ1UsSUFBSSxDQUFDbkIsRUFBRSxDQUFDLENBQUM7S0FDbkI7SUFDRCxJQUFJaUIsUUFBUSxFQUFFO1FBQ1YsT0FBT0EsUUFBUSxDQUFDO0tBQ25CO0lBQ0QsSUFBTWYsUUFBUSxHQUFHLElBQUlZLEdBQUcsRUFBRTtJQUMxQixJQUFNYixRQUFRLEdBQUcsSUFBSTlCLG9CQUFvQixDQUFDLFNBQUNpRCxPQUFPLEVBQUc7UUFDakRBLE9BQU8sQ0FBQ0MsT0FBTyxDQUFDLFNBQUNDLEtBQUssRUFBRztZQUNyQixJQUFNekIsUUFBUSxHQUFHSyxRQUFRLENBQUNnQixHQUFHLENBQUNJLEtBQUssQ0FBQ0MsTUFBTSxDQUFDO1lBQzNDLElBQU1qQyxTQUFTLEdBQUdnQyxLQUFLLENBQUNFLGNBQWMsSUFBSUYsS0FBSyxDQUFDRyxpQkFBaUIsR0FBRyxDQUFDO1lBQ3JFLElBQUk1QixRQUFRLElBQUlQLFNBQVMsRUFBRTtnQkFDdkJPLFFBQVEsQ0FBQ1AsU0FBUyxDQUFDLENBQUM7YUFDdkI7U0FDSixDQUFDLENBQUM7S0FDTixFQUFFUSxPQUFPLENBQUM7SUFDWFMsU0FBUyxDQUFDSixHQUFHLENBQUNILEVBQUUsRUFBRWlCLFFBQVEsR0FBRztRQUN6QmpCLEVBQUUsRUFBRkEsRUFBRTtRQUNGQyxRQUFRLEVBQVJBLFFBQVE7UUFDUkMsUUFBUSxFQUFSQSxRQUFRO0tBQ1gsQ0FBQyxDQUFDO0lBQ0gsT0FBT2UsUUFBUSxDQUFDO0NBQ25CO0FBRUQsSUFBSSxPQUFPckQsT0FBTyxDQUFDOEQsT0FBTyxLQUFLLFVBQVUsSUFBSyxPQUFPOUQsT0FBTyxDQUFDOEQsT0FBTyxLQUFLLFFBQVEsSUFBSTlELE9BQU8sQ0FBQzhELE9BQU8sS0FBSyxJQUFJLEVBQUc7SUFDOUdoRSxNQUFNLENBQUNpRSxNQUFNLENBQUMvRCxPQUFPLENBQUM4RCxPQUFPLEVBQUU5RCxPQUFPLENBQUMsQ0FBQztJQUN4Q2dFLE1BQU0sQ0FBQ2hFLE9BQU8sR0FBR0EsT0FBTyxDQUFDOEQsT0FBTyxDQUFDO0NBQ2xDLENBRUQsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L3VzZS1pbnRlcnNlY3Rpb24uanM/ZmQ5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudXNlSW50ZXJzZWN0aW9uID0gdXNlSW50ZXJzZWN0aW9uO1xudmFyIF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBfcmVxdWVzdElkbGVDYWxsYmFjayA9IHJlcXVpcmUoXCIuL3JlcXVlc3QtaWRsZS1jYWxsYmFja1wiKTtcbmNvbnN0IGhhc0ludGVyc2VjdGlvbk9ic2VydmVyID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIHVzZUludGVyc2VjdGlvbih7IHJvb3RSZWYgLCByb290TWFyZ2luICwgZGlzYWJsZWQgIH0pIHtcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGNvbnN0IHVub2JzZXJ2ZSA9ICgwLCBfcmVhY3QpLnVzZVJlZigpO1xuICAgIGNvbnN0IFt2aXNpYmxlLCBzZXRWaXNpYmxlXSA9ICgwLCBfcmVhY3QpLnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcm9vdCwgc2V0Um9vdF0gPSAoMCwgX3JlYWN0KS51c2VTdGF0ZShyb290UmVmID8gcm9vdFJlZi5jdXJyZW50IDogbnVsbCk7XG4gICAgY29uc3Qgc2V0UmVmID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICBpZiAodW5vYnNlcnZlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50KCk7XG4gICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEaXNhYmxlZCB8fCB2aXNpYmxlKSByZXR1cm47XG4gICAgICAgIGlmIChlbCAmJiBlbC50YWdOYW1lKSB7XG4gICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IG9ic2VydmUoZWwsIChpc1Zpc2libGUpPT5pc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpXG4gICAgICAgICAgICAsIHtcbiAgICAgICAgICAgICAgICByb290LFxuICAgICAgICAgICAgICAgIHJvb3RNYXJnaW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBpc0Rpc2FibGVkLFxuICAgICAgICByb290LFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICB2aXNpYmxlXG4gICAgXSk7XG4gICAgY29uc3QgcmVzZXRWaXNpYmxlID0gKDAsIF9yZWFjdCkudXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgc2V0VmlzaWJsZShmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAoIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlQ2FsbGJhY2sgPSAoMCwgX3JlcXVlc3RJZGxlQ2FsbGJhY2spLnJlcXVlc3RJZGxlQ2FsbGJhY2soKCk9PnNldFZpc2libGUodHJ1ZSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKT0+KDAsIF9yZXF1ZXN0SWRsZUNhbGxiYWNrKS5jYW5jZWxJZGxlQ2FsbGJhY2soaWRsZUNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgdmlzaWJsZVxuICAgIF0pO1xuICAgICgwLCBfcmVhY3QpLnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICBpZiAocm9vdFJlZikgc2V0Um9vdChyb290UmVmLmN1cnJlbnQpO1xuICAgIH0sIFtcbiAgICAgICAgcm9vdFJlZlxuICAgIF0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNldFJlZixcbiAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgcmVzZXRWaXNpYmxlXG4gICAgXTtcbn1cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGlkICwgb2JzZXJ2ZXIgLCBlbGVtZW50cyAgfSA9IGNyZWF0ZU9ic2VydmVyKG9wdGlvbnMpO1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCkge1xuICAgICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgICAgICBpZiAoZWxlbWVudHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIGlkTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlkTGlzdCA9IFtdO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0ge1xuICAgICAgICByb290OiBvcHRpb25zLnJvb3QgfHwgbnVsbCxcbiAgICAgICAgbWFyZ2luOiBvcHRpb25zLnJvb3RNYXJnaW4gfHwgJydcbiAgICB9O1xuICAgIGxldCBleGlzdGluZyA9IGlkTGlzdC5maW5kKChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW5cbiAgICApO1xuICAgIGxldCBpbnN0YW5jZTtcbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGV4aXN0aW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZSA9IG9ic2VydmVycy5nZXQoaWQpO1xuICAgICAgICBpZExpc3QucHVzaChpZCk7XG4gICAgfVxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBvYnNlcnZlcnMuc2V0KGlkLCBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH0pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbn1cblxuaWYgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpIHtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlLWludGVyc2VjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RJZGxlQ2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwicm9vdFJlZiIsInJvb3RNYXJnaW4iLCJkaXNhYmxlZCIsImlzRGlzYWJsZWQiLCJ1bm9ic2VydmUiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInZpc2libGUiLCJzZXRWaXNpYmxlIiwiY3VycmVudCIsInJvb3QiLCJzZXRSb290Iiwic2V0UmVmIiwidXNlQ2FsbGJhY2siLCJlbCIsInVuZGVmaW5lZCIsInRhZ05hbWUiLCJvYnNlcnZlIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwidXNlRWZmZWN0IiwiaWRsZUNhbGxiYWNrIiwicmVxdWVzdElkbGVDYWxsYmFjayIsImNhbmNlbElkbGVDYWxsYmFjayIsImVsZW1lbnQiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJjcmVhdGVPYnNlcnZlciIsImlkIiwib2JzZXJ2ZXIiLCJlbGVtZW50cyIsInNldCIsImRlbGV0ZSIsInNpemUiLCJkaXNjb25uZWN0Iiwib2JzZXJ2ZXJzIiwiaW5kZXgiLCJpZExpc3QiLCJmaW5kSW5kZXgiLCJvYmoiLCJtYXJnaW4iLCJzcGxpY2UiLCJNYXAiLCJleGlzdGluZyIsImZpbmQiLCJpbnN0YW5jZSIsImdldCIsInB1c2giLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwidGFyZ2V0IiwiaXNJbnRlcnNlY3RpbmciLCJpbnRlcnNlY3Rpb25SYXRpbyIsImRlZmF1bHQiLCJhc3NpZ24iLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n");

/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/head */ \"./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _elements_header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../elements/header */ \"./elements/header.tsx\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _styles_z_index_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/z-index.css */ \"./styles/z-index.css\");\n/* harmony import */ var _styles_z_index_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_z_index_css__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var next_progress__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next-progress */ \"./node_modules/next-progress/dist/index.js\");\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! recoil */ \"./node_modules/recoil/es/index.js\");\n/* harmony import */ var _elements_views_loading__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../elements/views/loading */ \"./elements/views/loading.tsx\");\nfunction _defineProperty(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        });\n    }\n    return target;\n}\n\n\n\n\n\n\n\n\n\nvar _s = $RefreshSig$();\nfunction MyApp(param) {\n    var Component = param.Component, pageProps = param.pageProps;\n    _s();\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function() {\n        document.getElementsByTagName(\"html\")[0].style.backgroundColor = \"#161c24\";\n    }, []);\n    var _title;\n    var title = (_title = Component.title) !== null && _title !== void 0 ? _title : null;\n    var transparent = Boolean(Component.transparent);\n    var _blur;\n    var blur = (_blur = Component.blur) !== null && _blur !== void 0 ? _blur : null;\n    console.log(Component.transparent);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_1___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"theme-color\",\n                        content: \"#161c24\"\n                    }, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                        lineNumber: 21,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"link\", {\n                        rel: \"manifest\",\n                        href: \"/manifest.json\"\n                    }, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                        lineNumber: 22,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"mobile-web-app-capable\",\n                        content: \"yes\"\n                    }, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                        lineNumber: 23,\n                        columnNumber: 9\n                    }, this),\n                    title && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: title\n                    }, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                        lineNumber: 24,\n                        columnNumber: 19\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                lineNumber: 20,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_progress__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                delay: 0,\n                options: {\n                    showSpinner: false\n                }\n            }, void 0, false, {\n                fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                lineNumber: 26,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(recoil__WEBPACK_IMPORTED_MODULE_7__.RecoilRoot, {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_elements_header__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        blur: blur,\n                        transparent: transparent\n                    }, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                        lineNumber: 28,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_elements_views_loading__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                        lineNumber: 29,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, _objectSpread({}, pageProps), void 0, false, {\n                        fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                        lineNumber: 30,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/kabirchawla/Mathston/firetag/pages/_app.tsx\",\n                lineNumber: 27,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(MyApp, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n_c = MyApp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyApp);\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEI7QUFDSztBQUNNO0FBQ1I7QUFDQTtBQUNVO0FBQ1A7QUFDYzs7QUFFaEQsU0FBU00sS0FBSyxDQUFDLEtBQXdCLEVBQUU7UUFBeEJDLFNBQVMsR0FBWCxLQUF3QixDQUF0QkEsU0FBUyxFQUFFQyxTQUFTLEdBQXRCLEtBQXdCLENBQVhBLFNBQVM7O0lBQ25DUCxnREFBUyxDQUFDLFdBQU07UUFDZFEsUUFBUSxDQUFDQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQ0MsS0FBSyxDQUFDQyxlQUFlLEdBQUcsU0FBUztLQUMzRSxFQUFFLEVBQUUsQ0FBQztRQUNnQkwsTUFBZTtJQUFyQyxJQUFNTSxLQUFLLEdBQVdOLENBQUFBLE1BQWUsR0FBZkEsU0FBUyxDQUFDTSxLQUFLLGNBQWZOLE1BQWUsY0FBZkEsTUFBZSxHQUFJLElBQUk7SUFDN0MsSUFBTU8sV0FBVyxHQUFHQyxPQUFPLENBQUNSLFNBQVMsQ0FBQ08sV0FBVyxDQUFDO1FBQ3RCUCxLQUFjO0lBQTFDLElBQU1TLElBQUksR0FBa0JULENBQUFBLEtBQWMsR0FBZEEsU0FBUyxDQUFDUyxJQUFJLGNBQWRULEtBQWMsY0FBZEEsS0FBYyxHQUFJLElBQUk7SUFDbERVLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDWCxTQUFTLENBQUNPLFdBQVcsQ0FBQztJQUNsQyxxQkFDRTs7MEJBQ0UsOERBQUNkLGtEQUFJOztrQ0FDSCw4REFBQ21CLE1BQUk7d0JBQUNDLElBQUksRUFBQyxhQUFhO3dCQUFDQyxPQUFPLEVBQUUsU0FBUzs7Ozs7NEJBQUk7a0NBQy9DLDhEQUFDQyxNQUFJO3dCQUFDQyxHQUFHLEVBQUMsVUFBVTt3QkFBQ0MsSUFBSSxFQUFDLGdCQUFnQjs7Ozs7NEJBQUc7a0NBQzdDLDhEQUFDTCxNQUFJO3dCQUFDQyxJQUFJLEVBQUMsd0JBQXdCO3dCQUFDQyxPQUFPLEVBQUMsS0FBSzs7Ozs7NEJBQUc7b0JBQ25EUixLQUFLLGtCQUFJLDhEQUFDQSxPQUFLO2tDQUFFQSxLQUFLOzs7Ozs0QkFBUzs7Ozs7O29CQUMzQjswQkFDUCw4REFBQ1YscURBQVk7Z0JBQUNzQixLQUFLLEVBQUUsQ0FBQztnQkFBRUMsT0FBTyxFQUFFO29CQUFFQyxXQUFXLEVBQUUsS0FBSztpQkFBRTs7Ozs7b0JBQUk7MEJBQzNELDhEQUFDdkIsOENBQVU7O2tDQUNULDhEQUFDRix3REFBTTt3QkFBQ2MsSUFBSSxFQUFFQSxJQUFJO3dCQUFFRixXQUFXLEVBQUVBLFdBQVc7Ozs7OzRCQUFHO2tDQUMvQyw4REFBQ1QsK0RBQU87Ozs7NEJBQUU7a0NBQ1YsOERBQUNFLFNBQVMsb0JBQUtDLFNBQVM7Ozs7NEJBQUk7Ozs7OztvQkFDakI7O29CQUNaLENBQ0o7Q0FDRjtHQXhCUUYsS0FBSztBQUFMQSxLQUFBQSxLQUFLO0FBMEJkLCtEQUFlQSxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3BhZ2VzL19hcHAudHN4PzJmYmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJ1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgSGVhZGVyIGZyb20gJy4uL2VsZW1lbnRzL2hlYWRlcidcbmltcG9ydCBcIi4uL3N0eWxlcy9nbG9iYWxzLmNzc1wiO1xuaW1wb3J0IFwiLi4vc3R5bGVzL3otaW5kZXguY3NzXCI7XG5pbXBvcnQgTmV4dFByb2dyZXNzIGZyb20gXCJuZXh0LXByb2dyZXNzXCI7XG5pbXBvcnQge1JlY29pbFJvb3R9IGZyb20gXCJyZWNvaWxcIjtcbmltcG9ydCBMb2FkaW5nIGZyb20gJy4uL2VsZW1lbnRzL3ZpZXdzL2xvYWRpbmcnO1xuXG5mdW5jdGlvbiBNeUFwcCh7IENvbXBvbmVudCwgcGFnZVByb3BzIH0pIHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImh0bWxcIilbMF0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCIjMTYxYzI0XCJcbiAgfSwgW10pXG4gIGNvbnN0IHRpdGxlOiBzdHJpbmcgPSBDb21wb25lbnQudGl0bGUgPz8gbnVsbDtcbiAgY29uc3QgdHJhbnNwYXJlbnQgPSBCb29sZWFuKENvbXBvbmVudC50cmFuc3BhcmVudCk7XG4gIGNvbnN0IGJsdXI6IG51bGwgfCBudW1iZXIgPSBDb21wb25lbnQuYmx1ciA/PyBudWxsO1xuICBjb25zb2xlLmxvZyhDb21wb25lbnQudHJhbnNwYXJlbnQpXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8bWV0YSBuYW1lPVwidGhlbWUtY29sb3JcIiBjb250ZW50PXtcIiMxNjFjMjRcIn0gLz5cbiAgICAgICAgPGxpbmsgcmVsPSdtYW5pZmVzdCcgaHJlZj0nL21hbmlmZXN0Lmpzb24nIC8+XG4gICAgICAgIDxtZXRhIG5hbWU9J21vYmlsZS13ZWItYXBwLWNhcGFibGUnIGNvbnRlbnQ9J3llcycgLz5cbiAgICAgICAge3RpdGxlICYmIDx0aXRsZT57dGl0bGV9PC90aXRsZT59XG4gICAgICA8L0hlYWQ+XG4gICAgICA8TmV4dFByb2dyZXNzIGRlbGF5PXswfSBvcHRpb25zPXt7IHNob3dTcGlubmVyOiBmYWxzZSB9fSAvPlxuICAgICAgPFJlY29pbFJvb3Q+XG4gICAgICAgIDxIZWFkZXIgYmx1cj17Ymx1cn0gdHJhbnNwYXJlbnQ9e3RyYW5zcGFyZW50fS8+XG4gICAgICAgIDxMb2FkaW5nLz5cbiAgICAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxuICAgICAgPC9SZWNvaWxSb290PlxuICAgIDwvPlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IE15QXBwXG4iXSwibmFtZXMiOlsiSGVhZCIsInVzZUVmZmVjdCIsIkhlYWRlciIsIk5leHRQcm9ncmVzcyIsIlJlY29pbFJvb3QiLCJMb2FkaW5nIiwiTXlBcHAiLCJDb21wb25lbnQiLCJwYWdlUHJvcHMiLCJkb2N1bWVudCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJ0aXRsZSIsInRyYW5zcGFyZW50IiwiQm9vbGVhbiIsImJsdXIiLCJjb25zb2xlIiwibG9nIiwibWV0YSIsIm5hbWUiLCJjb250ZW50IiwibGluayIsInJlbCIsImhyZWYiLCJkZWxheSIsIm9wdGlvbnMiLCJzaG93U3Bpbm5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/_app.tsx\n");

/***/ }),

/***/ "./state/coords.ts":
/*!*************************!*\
  !*** ./state/coords.ts ***!
  \*************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"coords\": function() { return /* binding */ coords; }\n/* harmony export */ });\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! recoil */ \"./node_modules/recoil/es/index.js\");\n\nvar coords = (0,recoil__WEBPACK_IMPORTED_MODULE_0__.atom)({\n    key: \"coords\",\n    default: [\n        null,\n        null\n    ]\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdGF0ZS9jb29yZHMudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEI7QUFFdkIsSUFBTUMsTUFBTSxHQUFHRCw0Q0FBSSxDQUFrQztJQUMxREUsR0FBRyxFQUFFLFFBQVE7SUFDYkMsT0FBTyxFQUFFO1FBQUMsSUFBSTtRQUFFLElBQUk7S0FBQztDQUN0QixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3RhdGUvY29vcmRzLnRzP2QxM2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXRvbSB9IGZyb20gXCJyZWNvaWxcIjtcblxuZXhwb3J0IGNvbnN0IGNvb3JkcyA9IGF0b208W251bWJlciwgbnVtYmVyXSB8IFtudWxsLCBudWxsXT4oe1xuICBrZXk6IFwiY29vcmRzXCIsIC8vIHVuaXF1ZSBJRCAod2l0aCByZXNwZWN0IHRvIG90aGVyIGF0b21zL3NlbGVjdG9ycylcbiAgZGVmYXVsdDogW251bGwsIG51bGxdLCAvLyBkZWZhdWx0IHZhbHVlIChha2EgaW5pdGlhbCB2YWx1ZSlcbn0pOyJdLCJuYW1lcyI6WyJhdG9tIiwiY29vcmRzIiwia2V5IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./state/coords.ts\n");

/***/ }),

/***/ "./state/index.ts":
/*!************************!*\
  !*** ./state/index.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"loading\": function() { return /* binding */ loading; }\n/* harmony export */ });\n/* harmony import */ var recoil__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! recoil */ \"./node_modules/recoil/es/index.js\");\n\nvar loading = (0,recoil__WEBPACK_IMPORTED_MODULE_0__.atom)({\n    key: \"loading\",\n    default: false\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdGF0ZS9pbmRleC50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE4QjtBQUV2QixJQUFNQyxPQUFPLEdBQUdELDRDQUFJLENBQUM7SUFDMUJFLEdBQUcsRUFBRSxTQUFTO0lBQ2RDLE9BQU8sRUFBRSxLQUFLO0NBQ2YsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0YXRlL2luZGV4LnRzPzU4NjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXRvbSB9IGZyb20gXCJyZWNvaWxcIjtcblxuZXhwb3J0IGNvbnN0IGxvYWRpbmcgPSBhdG9tKHtcbiAga2V5OiBcImxvYWRpbmdcIiwgLy8gdW5pcXVlIElEICh3aXRoIHJlc3BlY3QgdG8gb3RoZXIgYXRvbXMvc2VsZWN0b3JzKVxuICBkZWZhdWx0OiBmYWxzZSwgLy8gZGVmYXVsdCB2YWx1ZSAoYWthIGluaXRpYWwgdmFsdWUpXG59KTsiXSwibmFtZXMiOlsiYXRvbSIsImxvYWRpbmciLCJrZXkiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./state/index.ts\n");

/***/ }),

/***/ "./utils/empty.ts":
/*!************************!*\
  !*** ./utils/empty.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ empty; }\n/* harmony export */ });\nfunction empty() {};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9lbXB0eS50cy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWUsU0FBU0EsS0FBSyxHQUFHLEVBRS9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2VtcHR5LnRzP2IxMzUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgXG59Il0sIm5hbWVzIjpbImVtcHR5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/empty.ts\n");

/***/ }),

/***/ "./node_modules/next/head.js":
/*!***********************************!*\
  !*** ./node_modules/next/head.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"./node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlIQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9oZWFkLmpzPzg4NDkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3Qvc2hhcmVkL2xpYi9oZWFkJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/head.js\n");

/***/ }),

/***/ "./node_modules/next/image.js":
/*!************************************!*\
  !*** ./node_modules/next/image.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/client/image */ \"./node_modules/next/dist/client/image.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9pbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyR0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvaW1hZ2UuanM/MDUzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9jbGllbnQvaW1hZ2UnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/image.js\n");

/***/ }),

/***/ "./node_modules/nprogress/nprogress.js":
/*!*********************************************!*\
  !*** ./node_modules/nprogress/nprogress.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress\n * @license MIT */\n\n;(function(root, factory) {\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})(this, function() {\n  var NProgress = {};\n\n  NProgress.version = '0.2.0';\n\n  var Settings = NProgress.settings = {\n    minimum: 0.08,\n    easing: 'ease',\n    positionUsing: '',\n    speed: 200,\n    trickle: true,\n    trickleRate: 0.02,\n    trickleSpeed: 800,\n    showSpinner: true,\n    barSelector: '[role=\"bar\"]',\n    spinnerSelector: '[role=\"spinner\"]',\n    parent: 'body',\n    template: '<div class=\"bar\" role=\"bar\"><div class=\"peg\"></div></div><div class=\"spinner\" role=\"spinner\"><div class=\"spinner-icon\"></div></div>'\n  };\n\n  /**\n   * Updates configuration.\n   *\n   *     NProgress.configure({\n   *       minimum: 0.1\n   *     });\n   */\n  NProgress.configure = function(options) {\n    var key, value;\n    for (key in options) {\n      value = options[key];\n      if (value !== undefined && options.hasOwnProperty(key)) Settings[key] = value;\n    }\n\n    return this;\n  };\n\n  /**\n   * Last number.\n   */\n\n  NProgress.status = null;\n\n  /**\n   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.\n   *\n   *     NProgress.set(0.4);\n   *     NProgress.set(1.0);\n   */\n\n  NProgress.set = function(n) {\n    var started = NProgress.isStarted();\n\n    n = clamp(n, Settings.minimum, 1);\n    NProgress.status = (n === 1 ? null : n);\n\n    var progress = NProgress.render(!started),\n        bar      = progress.querySelector(Settings.barSelector),\n        speed    = Settings.speed,\n        ease     = Settings.easing;\n\n    progress.offsetWidth; /* Repaint */\n\n    queue(function(next) {\n      // Set positionUsing if it hasn't already been set\n      if (Settings.positionUsing === '') Settings.positionUsing = NProgress.getPositioningCSS();\n\n      // Add transition\n      css(bar, barPositionCSS(n, speed, ease));\n\n      if (n === 1) {\n        // Fade out\n        css(progress, { \n          transition: 'none', \n          opacity: 1 \n        });\n        progress.offsetWidth; /* Repaint */\n\n        setTimeout(function() {\n          css(progress, { \n            transition: 'all ' + speed + 'ms linear', \n            opacity: 0 \n          });\n          setTimeout(function() {\n            NProgress.remove();\n            next();\n          }, speed);\n        }, speed);\n      } else {\n        setTimeout(next, speed);\n      }\n    });\n\n    return this;\n  };\n\n  NProgress.isStarted = function() {\n    return typeof NProgress.status === 'number';\n  };\n\n  /**\n   * Shows the progress bar.\n   * This is the same as setting the status to 0%, except that it doesn't go backwards.\n   *\n   *     NProgress.start();\n   *\n   */\n  NProgress.start = function() {\n    if (!NProgress.status) NProgress.set(0);\n\n    var work = function() {\n      setTimeout(function() {\n        if (!NProgress.status) return;\n        NProgress.trickle();\n        work();\n      }, Settings.trickleSpeed);\n    };\n\n    if (Settings.trickle) work();\n\n    return this;\n  };\n\n  /**\n   * Hides the progress bar.\n   * This is the *sort of* the same as setting the status to 100%, with the\n   * difference being `done()` makes some placebo effect of some realistic motion.\n   *\n   *     NProgress.done();\n   *\n   * If `true` is passed, it will show the progress bar even if its hidden.\n   *\n   *     NProgress.done(true);\n   */\n\n  NProgress.done = function(force) {\n    if (!force && !NProgress.status) return this;\n\n    return NProgress.inc(0.3 + 0.5 * Math.random()).set(1);\n  };\n\n  /**\n   * Increments by a random amount.\n   */\n\n  NProgress.inc = function(amount) {\n    var n = NProgress.status;\n\n    if (!n) {\n      return NProgress.start();\n    } else {\n      if (typeof amount !== 'number') {\n        amount = (1 - n) * clamp(Math.random() * n, 0.1, 0.95);\n      }\n\n      n = clamp(n + amount, 0, 0.994);\n      return NProgress.set(n);\n    }\n  };\n\n  NProgress.trickle = function() {\n    return NProgress.inc(Math.random() * Settings.trickleRate);\n  };\n\n  /**\n   * Waits for all supplied jQuery promises and\n   * increases the progress as the promises resolve.\n   *\n   * @param $promise jQUery Promise\n   */\n  (function() {\n    var initial = 0, current = 0;\n\n    NProgress.promise = function($promise) {\n      if (!$promise || $promise.state() === \"resolved\") {\n        return this;\n      }\n\n      if (current === 0) {\n        NProgress.start();\n      }\n\n      initial++;\n      current++;\n\n      $promise.always(function() {\n        current--;\n        if (current === 0) {\n            initial = 0;\n            NProgress.done();\n        } else {\n            NProgress.set((initial - current) / initial);\n        }\n      });\n\n      return this;\n    };\n\n  })();\n\n  /**\n   * (Internal) renders the progress bar markup based on the `template`\n   * setting.\n   */\n\n  NProgress.render = function(fromStart) {\n    if (NProgress.isRendered()) return document.getElementById('nprogress');\n\n    addClass(document.documentElement, 'nprogress-busy');\n    \n    var progress = document.createElement('div');\n    progress.id = 'nprogress';\n    progress.innerHTML = Settings.template;\n\n    var bar      = progress.querySelector(Settings.barSelector),\n        perc     = fromStart ? '-100' : toBarPerc(NProgress.status || 0),\n        parent   = document.querySelector(Settings.parent),\n        spinner;\n    \n    css(bar, {\n      transition: 'all 0 linear',\n      transform: 'translate3d(' + perc + '%,0,0)'\n    });\n\n    if (!Settings.showSpinner) {\n      spinner = progress.querySelector(Settings.spinnerSelector);\n      spinner && removeElement(spinner);\n    }\n\n    if (parent != document.body) {\n      addClass(parent, 'nprogress-custom-parent');\n    }\n\n    parent.appendChild(progress);\n    return progress;\n  };\n\n  /**\n   * Removes the element. Opposite of render().\n   */\n\n  NProgress.remove = function() {\n    removeClass(document.documentElement, 'nprogress-busy');\n    removeClass(document.querySelector(Settings.parent), 'nprogress-custom-parent');\n    var progress = document.getElementById('nprogress');\n    progress && removeElement(progress);\n  };\n\n  /**\n   * Checks if the progress bar is rendered.\n   */\n\n  NProgress.isRendered = function() {\n    return !!document.getElementById('nprogress');\n  };\n\n  /**\n   * Determine which positioning CSS rule to use.\n   */\n\n  NProgress.getPositioningCSS = function() {\n    // Sniff on document.body.style\n    var bodyStyle = document.body.style;\n\n    // Sniff prefixes\n    var vendorPrefix = ('WebkitTransform' in bodyStyle) ? 'Webkit' :\n                       ('MozTransform' in bodyStyle) ? 'Moz' :\n                       ('msTransform' in bodyStyle) ? 'ms' :\n                       ('OTransform' in bodyStyle) ? 'O' : '';\n\n    if (vendorPrefix + 'Perspective' in bodyStyle) {\n      // Modern browsers with 3D support, e.g. Webkit, IE10\n      return 'translate3d';\n    } else if (vendorPrefix + 'Transform' in bodyStyle) {\n      // Browsers without 3D support, e.g. IE9\n      return 'translate';\n    } else {\n      // Browsers without translate() support, e.g. IE7-8\n      return 'margin';\n    }\n  };\n\n  /**\n   * Helpers\n   */\n\n  function clamp(n, min, max) {\n    if (n < min) return min;\n    if (n > max) return max;\n    return n;\n  }\n\n  /**\n   * (Internal) converts a percentage (`0..1`) to a bar translateX\n   * percentage (`-100%..0%`).\n   */\n\n  function toBarPerc(n) {\n    return (-1 + n) * 100;\n  }\n\n\n  /**\n   * (Internal) returns the correct CSS for changing the bar's\n   * position given an n percentage, and speed and ease from Settings\n   */\n\n  function barPositionCSS(n, speed, ease) {\n    var barCSS;\n\n    if (Settings.positionUsing === 'translate3d') {\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' };\n    } else if (Settings.positionUsing === 'translate') {\n      barCSS = { transform: 'translate('+toBarPerc(n)+'%,0)' };\n    } else {\n      barCSS = { 'margin-left': toBarPerc(n)+'%' };\n    }\n\n    barCSS.transition = 'all '+speed+'ms '+ease;\n\n    return barCSS;\n  }\n\n  /**\n   * (Internal) Queues a function to be executed.\n   */\n\n  var queue = (function() {\n    var pending = [];\n    \n    function next() {\n      var fn = pending.shift();\n      if (fn) {\n        fn(next);\n      }\n    }\n\n    return function(fn) {\n      pending.push(fn);\n      if (pending.length == 1) next();\n    };\n  })();\n\n  /**\n   * (Internal) Applies css properties to an element, similar to the jQuery \n   * css method.\n   *\n   * While this helper does assist with vendor prefixed property names, it \n   * does not perform any manipulation of values prior to setting styles.\n   */\n\n  var css = (function() {\n    var cssPrefixes = [ 'Webkit', 'O', 'Moz', 'ms' ],\n        cssProps    = {};\n\n    function camelCase(string) {\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n        return letter.toUpperCase();\n      });\n    }\n\n    function getVendorProp(name) {\n      var style = document.body.style;\n      if (name in style) return name;\n\n      var i = cssPrefixes.length,\n          capName = name.charAt(0).toUpperCase() + name.slice(1),\n          vendorName;\n      while (i--) {\n        vendorName = cssPrefixes[i] + capName;\n        if (vendorName in style) return vendorName;\n      }\n\n      return name;\n    }\n\n    function getStyleProp(name) {\n      name = camelCase(name);\n      return cssProps[name] || (cssProps[name] = getVendorProp(name));\n    }\n\n    function applyCss(element, prop, value) {\n      prop = getStyleProp(prop);\n      element.style[prop] = value;\n    }\n\n    return function(element, properties) {\n      var args = arguments,\n          prop, \n          value;\n\n      if (args.length == 2) {\n        for (prop in properties) {\n          value = properties[prop];\n          if (value !== undefined && properties.hasOwnProperty(prop)) applyCss(element, prop, value);\n        }\n      } else {\n        applyCss(element, args[1], args[2]);\n      }\n    }\n  })();\n\n  /**\n   * (Internal) Determines if an element or space separated list of class names contains a class name.\n   */\n\n  function hasClass(element, name) {\n    var list = typeof element == 'string' ? element : classList(element);\n    return list.indexOf(' ' + name + ' ') >= 0;\n  }\n\n  /**\n   * (Internal) Adds a class to an element.\n   */\n\n  function addClass(element, name) {\n    var oldList = classList(element),\n        newList = oldList + name;\n\n    if (hasClass(oldList, name)) return; \n\n    // Trim the opening space.\n    element.className = newList.substring(1);\n  }\n\n  /**\n   * (Internal) Removes a class from an element.\n   */\n\n  function removeClass(element, name) {\n    var oldList = classList(element),\n        newList;\n\n    if (!hasClass(element, name)) return;\n\n    // Replace the class name.\n    newList = oldList.replace(' ' + name + ' ', ' ');\n\n    // Trim the opening and closing spaces.\n    element.className = newList.substring(1, newList.length - 1);\n  }\n\n  /**\n   * (Internal) Gets a space separated list of the class names on the element. \n   * The list is wrapped with a single space on each end to facilitate finding \n   * matches within the list.\n   */\n\n  function classList(element) {\n    return (' ' + (element.className || '') + ' ').replace(/\\s+/gi, ' ');\n  }\n\n  /**\n   * (Internal) Removes an element from the DOM.\n   */\n\n  function removeElement(element) {\n    element && element.parentNode && element.parentNode.removeChild(element);\n  }\n\n  return NProgress;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbnByb2dyZXNzL25wcm9ncmVzcy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBLENBQUM7O0FBRUQsTUFBTSxJQUEwQztBQUNoRCxJQUFJLG9DQUFPLE9BQU87QUFBQTtBQUFBO0FBQUE7QUFBQSxrR0FBQztBQUNuQixJQUFJLEtBQUssRUFJTjs7QUFFSCxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixNQUFNO0FBQ04saUJBQWlCO0FBQ2pCLE1BQU07QUFDTixpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbnByb2dyZXNzL25wcm9ncmVzcy5qcz81NzA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIE5Qcm9ncmVzcywgKGMpIDIwMTMsIDIwMTQgUmljbyBTdGEuIENydXogLSBodHRwOi8vcmljb3N0YWNydXouY29tL25wcm9ncmVzc1xuICogQGxpY2Vuc2UgTUlUICovXG5cbjsoZnVuY3Rpb24ocm9vdCwgZmFjdG9yeSkge1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgcm9vdC5OUHJvZ3Jlc3MgPSBmYWN0b3J5KCk7XG4gIH1cblxufSkodGhpcywgZnVuY3Rpb24oKSB7XG4gIHZhciBOUHJvZ3Jlc3MgPSB7fTtcblxuICBOUHJvZ3Jlc3MudmVyc2lvbiA9ICcwLjIuMCc7XG5cbiAgdmFyIFNldHRpbmdzID0gTlByb2dyZXNzLnNldHRpbmdzID0ge1xuICAgIG1pbmltdW06IDAuMDgsXG4gICAgZWFzaW5nOiAnZWFzZScsXG4gICAgcG9zaXRpb25Vc2luZzogJycsXG4gICAgc3BlZWQ6IDIwMCxcbiAgICB0cmlja2xlOiB0cnVlLFxuICAgIHRyaWNrbGVSYXRlOiAwLjAyLFxuICAgIHRyaWNrbGVTcGVlZDogODAwLFxuICAgIHNob3dTcGlubmVyOiB0cnVlLFxuICAgIGJhclNlbGVjdG9yOiAnW3JvbGU9XCJiYXJcIl0nLFxuICAgIHNwaW5uZXJTZWxlY3RvcjogJ1tyb2xlPVwic3Bpbm5lclwiXScsXG4gICAgcGFyZW50OiAnYm9keScsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwiYmFyXCIgcm9sZT1cImJhclwiPjxkaXYgY2xhc3M9XCJwZWdcIj48L2Rpdj48L2Rpdj48ZGl2IGNsYXNzPVwic3Bpbm5lclwiIHJvbGU9XCJzcGlubmVyXCI+PGRpdiBjbGFzcz1cInNwaW5uZXItaWNvblwiPjwvZGl2PjwvZGl2PidcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyBjb25maWd1cmF0aW9uLlxuICAgKlxuICAgKiAgICAgTlByb2dyZXNzLmNvbmZpZ3VyZSh7XG4gICAqICAgICAgIG1pbmltdW06IDAuMVxuICAgKiAgICAgfSk7XG4gICAqL1xuICBOUHJvZ3Jlc3MuY29uZmlndXJlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBrZXksIHZhbHVlO1xuICAgIGZvciAoa2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIHZhbHVlID0gb3B0aW9uc1trZXldO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBTZXR0aW5nc1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIExhc3QgbnVtYmVyLlxuICAgKi9cblxuICBOUHJvZ3Jlc3Muc3RhdHVzID0gbnVsbDtcblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJvZ3Jlc3MgYmFyIHN0YXR1cywgd2hlcmUgYG5gIGlzIGEgbnVtYmVyIGZyb20gYDAuMGAgdG8gYDEuMGAuXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3Muc2V0KDAuNCk7XG4gICAqICAgICBOUHJvZ3Jlc3Muc2V0KDEuMCk7XG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5zZXQgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIHN0YXJ0ZWQgPSBOUHJvZ3Jlc3MuaXNTdGFydGVkKCk7XG5cbiAgICBuID0gY2xhbXAobiwgU2V0dGluZ3MubWluaW11bSwgMSk7XG4gICAgTlByb2dyZXNzLnN0YXR1cyA9IChuID09PSAxID8gbnVsbCA6IG4pO1xuXG4gICAgdmFyIHByb2dyZXNzID0gTlByb2dyZXNzLnJlbmRlcighc3RhcnRlZCksXG4gICAgICAgIGJhciAgICAgID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5iYXJTZWxlY3RvciksXG4gICAgICAgIHNwZWVkICAgID0gU2V0dGluZ3Muc3BlZWQsXG4gICAgICAgIGVhc2UgICAgID0gU2V0dGluZ3MuZWFzaW5nO1xuXG4gICAgcHJvZ3Jlc3Mub2Zmc2V0V2lkdGg7IC8qIFJlcGFpbnQgKi9cblxuICAgIHF1ZXVlKGZ1bmN0aW9uKG5leHQpIHtcbiAgICAgIC8vIFNldCBwb3NpdGlvblVzaW5nIGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW4gc2V0XG4gICAgICBpZiAoU2V0dGluZ3MucG9zaXRpb25Vc2luZyA9PT0gJycpIFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPSBOUHJvZ3Jlc3MuZ2V0UG9zaXRpb25pbmdDU1MoKTtcblxuICAgICAgLy8gQWRkIHRyYW5zaXRpb25cbiAgICAgIGNzcyhiYXIsIGJhclBvc2l0aW9uQ1NTKG4sIHNwZWVkLCBlYXNlKSk7XG5cbiAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgIC8vIEZhZGUgb3V0XG4gICAgICAgIGNzcyhwcm9ncmVzcywgeyBcbiAgICAgICAgICB0cmFuc2l0aW9uOiAnbm9uZScsIFxuICAgICAgICAgIG9wYWNpdHk6IDEgXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9ncmVzcy5vZmZzZXRXaWR0aDsgLyogUmVwYWludCAqL1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY3NzKHByb2dyZXNzLCB7IFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogJ2FsbCAnICsgc3BlZWQgKyAnbXMgbGluZWFyJywgXG4gICAgICAgICAgICBvcGFjaXR5OiAwIFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBOUHJvZ3Jlc3MucmVtb3ZlKCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfSwgc3BlZWQpO1xuICAgICAgICB9LCBzcGVlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KG5leHQsIHNwZWVkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIE5Qcm9ncmVzcy5pc1N0YXJ0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHlwZW9mIE5Qcm9ncmVzcy5zdGF0dXMgPT09ICdudW1iZXInO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTaG93cyB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBUaGlzIGlzIHRoZSBzYW1lIGFzIHNldHRpbmcgdGhlIHN0YXR1cyB0byAwJSwgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBnbyBiYWNrd2FyZHMuXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3Muc3RhcnQoKTtcbiAgICpcbiAgICovXG4gIE5Qcm9ncmVzcy5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghTlByb2dyZXNzLnN0YXR1cykgTlByb2dyZXNzLnNldCgwKTtcblxuICAgIHZhciB3b3JrID0gZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIU5Qcm9ncmVzcy5zdGF0dXMpIHJldHVybjtcbiAgICAgICAgTlByb2dyZXNzLnRyaWNrbGUoKTtcbiAgICAgICAgd29yaygpO1xuICAgICAgfSwgU2V0dGluZ3MudHJpY2tsZVNwZWVkKTtcbiAgICB9O1xuXG4gICAgaWYgKFNldHRpbmdzLnRyaWNrbGUpIHdvcmsoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBUaGlzIGlzIHRoZSAqc29ydCBvZiogdGhlIHNhbWUgYXMgc2V0dGluZyB0aGUgc3RhdHVzIHRvIDEwMCUsIHdpdGggdGhlXG4gICAqIGRpZmZlcmVuY2UgYmVpbmcgYGRvbmUoKWAgbWFrZXMgc29tZSBwbGFjZWJvIGVmZmVjdCBvZiBzb21lIHJlYWxpc3RpYyBtb3Rpb24uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuZG9uZSgpO1xuICAgKlxuICAgKiBJZiBgdHJ1ZWAgaXMgcGFzc2VkLCBpdCB3aWxsIHNob3cgdGhlIHByb2dyZXNzIGJhciBldmVuIGlmIGl0cyBoaWRkZW4uXG4gICAqXG4gICAqICAgICBOUHJvZ3Jlc3MuZG9uZSh0cnVlKTtcbiAgICovXG5cbiAgTlByb2dyZXNzLmRvbmUgPSBmdW5jdGlvbihmb3JjZSkge1xuICAgIGlmICghZm9yY2UgJiYgIU5Qcm9ncmVzcy5zdGF0dXMpIHJldHVybiB0aGlzO1xuXG4gICAgcmV0dXJuIE5Qcm9ncmVzcy5pbmMoMC4zICsgMC41ICogTWF0aC5yYW5kb20oKSkuc2V0KDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIGJ5IGEgcmFuZG9tIGFtb3VudC5cbiAgICovXG5cbiAgTlByb2dyZXNzLmluYyA9IGZ1bmN0aW9uKGFtb3VudCkge1xuICAgIHZhciBuID0gTlByb2dyZXNzLnN0YXR1cztcblxuICAgIGlmICghbikge1xuICAgICAgcmV0dXJuIE5Qcm9ncmVzcy5zdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGFtb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgYW1vdW50ID0gKDEgLSBuKSAqIGNsYW1wKE1hdGgucmFuZG9tKCkgKiBuLCAwLjEsIDAuOTUpO1xuICAgICAgfVxuXG4gICAgICBuID0gY2xhbXAobiArIGFtb3VudCwgMCwgMC45OTQpO1xuICAgICAgcmV0dXJuIE5Qcm9ncmVzcy5zZXQobik7XG4gICAgfVxuICB9O1xuXG4gIE5Qcm9ncmVzcy50cmlja2xlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE5Qcm9ncmVzcy5pbmMoTWF0aC5yYW5kb20oKSAqIFNldHRpbmdzLnRyaWNrbGVSYXRlKTtcbiAgfTtcblxuICAvKipcbiAgICogV2FpdHMgZm9yIGFsbCBzdXBwbGllZCBqUXVlcnkgcHJvbWlzZXMgYW5kXG4gICAqIGluY3JlYXNlcyB0aGUgcHJvZ3Jlc3MgYXMgdGhlIHByb21pc2VzIHJlc29sdmUuXG4gICAqXG4gICAqIEBwYXJhbSAkcHJvbWlzZSBqUVVlcnkgUHJvbWlzZVxuICAgKi9cbiAgKGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbml0aWFsID0gMCwgY3VycmVudCA9IDA7XG5cbiAgICBOUHJvZ3Jlc3MucHJvbWlzZSA9IGZ1bmN0aW9uKCRwcm9taXNlKSB7XG4gICAgICBpZiAoISRwcm9taXNlIHx8ICRwcm9taXNlLnN0YXRlKCkgPT09IFwicmVzb2x2ZWRcIikge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgTlByb2dyZXNzLnN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIGluaXRpYWwrKztcbiAgICAgIGN1cnJlbnQrKztcblxuICAgICAgJHByb21pc2UuYWx3YXlzKGZ1bmN0aW9uKCkge1xuICAgICAgICBjdXJyZW50LS07XG4gICAgICAgIGlmIChjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgICBpbml0aWFsID0gMDtcbiAgICAgICAgICAgIE5Qcm9ncmVzcy5kb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBOUHJvZ3Jlc3Muc2V0KChpbml0aWFsIC0gY3VycmVudCkgLyBpbml0aWFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSByZW5kZXJzIHRoZSBwcm9ncmVzcyBiYXIgbWFya3VwIGJhc2VkIG9uIHRoZSBgdGVtcGxhdGVgXG4gICAqIHNldHRpbmcuXG4gICAqL1xuXG4gIE5Qcm9ncmVzcy5yZW5kZXIgPSBmdW5jdGlvbihmcm9tU3RhcnQpIHtcbiAgICBpZiAoTlByb2dyZXNzLmlzUmVuZGVyZWQoKSkgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcblxuICAgIGFkZENsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ25wcm9ncmVzcy1idXN5Jyk7XG4gICAgXG4gICAgdmFyIHByb2dyZXNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJvZ3Jlc3MuaWQgPSAnbnByb2dyZXNzJztcbiAgICBwcm9ncmVzcy5pbm5lckhUTUwgPSBTZXR0aW5ncy50ZW1wbGF0ZTtcblxuICAgIHZhciBiYXIgICAgICA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3MuYmFyU2VsZWN0b3IpLFxuICAgICAgICBwZXJjICAgICA9IGZyb21TdGFydCA/ICctMTAwJyA6IHRvQmFyUGVyYyhOUHJvZ3Jlc3Muc3RhdHVzIHx8IDApLFxuICAgICAgICBwYXJlbnQgICA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoU2V0dGluZ3MucGFyZW50KSxcbiAgICAgICAgc3Bpbm5lcjtcbiAgICBcbiAgICBjc3MoYmFyLCB7XG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDAgbGluZWFyJyxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBwZXJjICsgJyUsMCwwKSdcbiAgICB9KTtcblxuICAgIGlmICghU2V0dGluZ3Muc2hvd1NwaW5uZXIpIHtcbiAgICAgIHNwaW5uZXIgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFNldHRpbmdzLnNwaW5uZXJTZWxlY3Rvcik7XG4gICAgICBzcGlubmVyICYmIHJlbW92ZUVsZW1lbnQoc3Bpbm5lcik7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudCAhPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICBhZGRDbGFzcyhwYXJlbnQsICducHJvZ3Jlc3MtY3VzdG9tLXBhcmVudCcpO1xuICAgIH1cblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChwcm9ncmVzcyk7XG4gICAgcmV0dXJuIHByb2dyZXNzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50LiBPcHBvc2l0ZSBvZiByZW5kZXIoKS5cbiAgICovXG5cbiAgTlByb2dyZXNzLnJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJlbW92ZUNsYXNzKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ25wcm9ncmVzcy1idXN5Jyk7XG4gICAgcmVtb3ZlQ2xhc3MoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihTZXR0aW5ncy5wYXJlbnQpLCAnbnByb2dyZXNzLWN1c3RvbS1wYXJlbnQnKTtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbnByb2dyZXNzJyk7XG4gICAgcHJvZ3Jlc3MgJiYgcmVtb3ZlRWxlbWVudChwcm9ncmVzcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHJlbmRlcmVkLlxuICAgKi9cblxuICBOUHJvZ3Jlc3MuaXNSZW5kZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCducHJvZ3Jlc3MnKTtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoaWNoIHBvc2l0aW9uaW5nIENTUyBydWxlIHRvIHVzZS5cbiAgICovXG5cbiAgTlByb2dyZXNzLmdldFBvc2l0aW9uaW5nQ1NTID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gU25pZmYgb24gZG9jdW1lbnQuYm9keS5zdHlsZVxuICAgIHZhciBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuXG4gICAgLy8gU25pZmYgcHJlZml4ZXNcbiAgICB2YXIgdmVuZG9yUHJlZml4ID0gKCdXZWJraXRUcmFuc2Zvcm0nIGluIGJvZHlTdHlsZSkgPyAnV2Via2l0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnTW96VHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ01veicgOlxuICAgICAgICAgICAgICAgICAgICAgICAoJ21zVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpID8gJ21zJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICgnT1RyYW5zZm9ybScgaW4gYm9keVN0eWxlKSA/ICdPJyA6ICcnO1xuXG4gICAgaWYgKHZlbmRvclByZWZpeCArICdQZXJzcGVjdGl2ZScgaW4gYm9keVN0eWxlKSB7XG4gICAgICAvLyBNb2Rlcm4gYnJvd3NlcnMgd2l0aCAzRCBzdXBwb3J0LCBlLmcuIFdlYmtpdCwgSUUxMFxuICAgICAgcmV0dXJuICd0cmFuc2xhdGUzZCc7XG4gICAgfSBlbHNlIGlmICh2ZW5kb3JQcmVmaXggKyAnVHJhbnNmb3JtJyBpbiBib2R5U3R5bGUpIHtcbiAgICAgIC8vIEJyb3dzZXJzIHdpdGhvdXQgM0Qgc3VwcG9ydCwgZS5nLiBJRTlcbiAgICAgIHJldHVybiAndHJhbnNsYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQnJvd3NlcnMgd2l0aG91dCB0cmFuc2xhdGUoKSBzdXBwb3J0LCBlLmcuIElFNy04XG4gICAgICByZXR1cm4gJ21hcmdpbic7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsYW1wKG4sIG1pbiwgbWF4KSB7XG4gICAgaWYgKG4gPCBtaW4pIHJldHVybiBtaW47XG4gICAgaWYgKG4gPiBtYXgpIHJldHVybiBtYXg7XG4gICAgcmV0dXJuIG47XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBjb252ZXJ0cyBhIHBlcmNlbnRhZ2UgKGAwLi4xYCkgdG8gYSBiYXIgdHJhbnNsYXRlWFxuICAgKiBwZXJjZW50YWdlIChgLTEwMCUuLjAlYCkuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRvQmFyUGVyYyhuKSB7XG4gICAgcmV0dXJuICgtMSArIG4pICogMTAwO1xuICB9XG5cblxuICAvKipcbiAgICogKEludGVybmFsKSByZXR1cm5zIHRoZSBjb3JyZWN0IENTUyBmb3IgY2hhbmdpbmcgdGhlIGJhcidzXG4gICAqIHBvc2l0aW9uIGdpdmVuIGFuIG4gcGVyY2VudGFnZSwgYW5kIHNwZWVkIGFuZCBlYXNlIGZyb20gU2V0dGluZ3NcbiAgICovXG5cbiAgZnVuY3Rpb24gYmFyUG9zaXRpb25DU1Mobiwgc3BlZWQsIGVhc2UpIHtcbiAgICB2YXIgYmFyQ1NTO1xuXG4gICAgaWYgKFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPT09ICd0cmFuc2xhdGUzZCcpIHtcbiAgICAgIGJhckNTUyA9IHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoJyt0b0JhclBlcmMobikrJyUsMCwwKScgfTtcbiAgICB9IGVsc2UgaWYgKFNldHRpbmdzLnBvc2l0aW9uVXNpbmcgPT09ICd0cmFuc2xhdGUnKSB7XG4gICAgICBiYXJDU1MgPSB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnK3RvQmFyUGVyYyhuKSsnJSwwKScgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFyQ1NTID0geyAnbWFyZ2luLWxlZnQnOiB0b0JhclBlcmMobikrJyUnIH07XG4gICAgfVxuXG4gICAgYmFyQ1NTLnRyYW5zaXRpb24gPSAnYWxsICcrc3BlZWQrJ21zICcrZWFzZTtcblxuICAgIHJldHVybiBiYXJDU1M7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBRdWV1ZXMgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZC5cbiAgICovXG5cbiAgdmFyIHF1ZXVlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBwZW5kaW5nID0gW107XG4gICAgXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHZhciBmbiA9IHBlbmRpbmcuc2hpZnQoKTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbihuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgIHBlbmRpbmcucHVzaChmbik7XG4gICAgICBpZiAocGVuZGluZy5sZW5ndGggPT0gMSkgbmV4dCgpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgQXBwbGllcyBjc3MgcHJvcGVydGllcyB0byBhbiBlbGVtZW50LCBzaW1pbGFyIHRvIHRoZSBqUXVlcnkgXG4gICAqIGNzcyBtZXRob2QuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgaGVscGVyIGRvZXMgYXNzaXN0IHdpdGggdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5IG5hbWVzLCBpdCBcbiAgICogZG9lcyBub3QgcGVyZm9ybSBhbnkgbWFuaXB1bGF0aW9uIG9mIHZhbHVlcyBwcmlvciB0byBzZXR0aW5nIHN0eWxlcy5cbiAgICovXG5cbiAgdmFyIGNzcyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgY3NzUHJlZml4ZXMgPSBbICdXZWJraXQnLCAnTycsICdNb3onLCAnbXMnIF0sXG4gICAgICAgIGNzc1Byb3BzICAgID0ge307XG5cbiAgICBmdW5jdGlvbiBjYW1lbENhc2Uoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL14tbXMtLywgJ21zLScpLnJlcGxhY2UoLy0oW1xcZGEtel0pL2dpLCBmdW5jdGlvbihtYXRjaCwgbGV0dGVyKSB7XG4gICAgICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZlbmRvclByb3AobmFtZSkge1xuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgIGlmIChuYW1lIGluIHN0eWxlKSByZXR1cm4gbmFtZTtcblxuICAgICAgdmFyIGkgPSBjc3NQcmVmaXhlcy5sZW5ndGgsXG4gICAgICAgICAgY2FwTmFtZSA9IG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLFxuICAgICAgICAgIHZlbmRvck5hbWU7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZlbmRvck5hbWUgPSBjc3NQcmVmaXhlc1tpXSArIGNhcE5hbWU7XG4gICAgICAgIGlmICh2ZW5kb3JOYW1lIGluIHN0eWxlKSByZXR1cm4gdmVuZG9yTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3R5bGVQcm9wKG5hbWUpIHtcbiAgICAgIG5hbWUgPSBjYW1lbENhc2UobmFtZSk7XG4gICAgICByZXR1cm4gY3NzUHJvcHNbbmFtZV0gfHwgKGNzc1Byb3BzW25hbWVdID0gZ2V0VmVuZG9yUHJvcChuYW1lKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlDc3MoZWxlbWVudCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIHByb3AgPSBnZXRTdHlsZVByb3AocHJvcCk7XG4gICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHByb3AsIFxuICAgICAgICAgIHZhbHVlO1xuXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT0gMikge1xuICAgICAgICBmb3IgKHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIHZhbHVlID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3ApKSBhcHBseUNzcyhlbGVtZW50LCBwcm9wLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGx5Q3NzKGVsZW1lbnQsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgfVxuICAgIH1cbiAgfSkoKTtcblxuICAvKipcbiAgICogKEludGVybmFsKSBEZXRlcm1pbmVzIGlmIGFuIGVsZW1lbnQgb3Igc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgY2xhc3MgbmFtZXMgY29udGFpbnMgYSBjbGFzcyBuYW1lLlxuICAgKi9cblxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbGVtZW50LCBuYW1lKSB7XG4gICAgdmFyIGxpc3QgPSB0eXBlb2YgZWxlbWVudCA9PSAnc3RyaW5nJyA/IGVsZW1lbnQgOiBjbGFzc0xpc3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIGxpc3QuaW5kZXhPZignICcgKyBuYW1lICsgJyAnKSA+PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgQWRkcyBhIGNsYXNzIHRvIGFuIGVsZW1lbnQuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIG5hbWUpIHtcbiAgICB2YXIgb2xkTGlzdCA9IGNsYXNzTGlzdChlbGVtZW50KSxcbiAgICAgICAgbmV3TGlzdCA9IG9sZExpc3QgKyBuYW1lO1xuXG4gICAgaWYgKGhhc0NsYXNzKG9sZExpc3QsIG5hbWUpKSByZXR1cm47IFxuXG4gICAgLy8gVHJpbSB0aGUgb3BlbmluZyBzcGFjZS5cbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IG5ld0xpc3Quc3Vic3RyaW5nKDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgUmVtb3ZlcyBhIGNsYXNzIGZyb20gYW4gZWxlbWVudC5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgbmFtZSkge1xuICAgIHZhciBvbGRMaXN0ID0gY2xhc3NMaXN0KGVsZW1lbnQpLFxuICAgICAgICBuZXdMaXN0O1xuXG4gICAgaWYgKCFoYXNDbGFzcyhlbGVtZW50LCBuYW1lKSkgcmV0dXJuO1xuXG4gICAgLy8gUmVwbGFjZSB0aGUgY2xhc3MgbmFtZS5cbiAgICBuZXdMaXN0ID0gb2xkTGlzdC5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJyk7XG5cbiAgICAvLyBUcmltIHRoZSBvcGVuaW5nIGFuZCBjbG9zaW5nIHNwYWNlcy5cbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IG5ld0xpc3Quc3Vic3RyaW5nKDEsIG5ld0xpc3QubGVuZ3RoIC0gMSk7XG4gIH1cblxuICAvKipcbiAgICogKEludGVybmFsKSBHZXRzIGEgc3BhY2Ugc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGNsYXNzIG5hbWVzIG9uIHRoZSBlbGVtZW50LiBcbiAgICogVGhlIGxpc3QgaXMgd3JhcHBlZCB3aXRoIGEgc2luZ2xlIHNwYWNlIG9uIGVhY2ggZW5kIHRvIGZhY2lsaXRhdGUgZmluZGluZyBcbiAgICogbWF0Y2hlcyB3aXRoaW4gdGhlIGxpc3QuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGNsYXNzTGlzdChlbGVtZW50KSB7XG4gICAgcmV0dXJuICgnICcgKyAoZWxlbWVudC5jbGFzc05hbWUgfHwgJycpICsgJyAnKS5yZXBsYWNlKC9cXHMrL2dpLCAnICcpO1xuICB9XG5cbiAgLyoqXG4gICAqIChJbnRlcm5hbCkgUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICovXG5cbiAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XG4gICAgZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUgJiYgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIE5Qcm9ncmVzcztcbn0pO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/nprogress/nprogress.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v17.0.2\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE = 0xeac7;\nvar REACT_PORTAL_TYPE = 0xeaca;\nexports.Fragment = 0xeacb;\nvar REACT_STRICT_MODE_TYPE = 0xeacc;\nvar REACT_PROFILER_TYPE = 0xead2;\nvar REACT_PROVIDER_TYPE = 0xeacd;\nvar REACT_CONTEXT_TYPE = 0xeace;\nvar REACT_FORWARD_REF_TYPE = 0xead0;\nvar REACT_SUSPENSE_TYPE = 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = 0xead8;\nvar REACT_MEMO_TYPE = 0xead3;\nvar REACT_LAZY_TYPE = 0xead4;\nvar REACT_BLOCK_TYPE = 0xead9;\nvar REACT_SERVER_BLOCK_TYPE = 0xeada;\nvar REACT_FUNDAMENTAL_TYPE = 0xead5;\nvar REACT_SCOPE_TYPE = 0xead7;\nvar REACT_OPAQUE_ID_TYPE = 0xeae0;\nvar REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\nvar REACT_OFFSCREEN_TYPE = 0xeae2;\nvar REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  var symbolFor = Symbol.for;\n  REACT_ELEMENT_TYPE = symbolFor('react.element');\n  REACT_PORTAL_TYPE = symbolFor('react.portal');\n  exports.Fragment = symbolFor('react.fragment');\n  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n  REACT_PROFILER_TYPE = symbolFor('react.profiler');\n  REACT_PROVIDER_TYPE = symbolFor('react.provider');\n  REACT_CONTEXT_TYPE = symbolFor('react.context');\n  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n  REACT_MEMO_TYPE = symbolFor('react.memo');\n  REACT_LAZY_TYPE = symbolFor('react.lazy');\n  REACT_BLOCK_TYPE = symbolFor('react.block');\n  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n  REACT_SCOPE_TYPE = symbolFor('react.scope');\n  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n}\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    printWarning('error', format, args);\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    }\n\n    var argsWithFormat = args.map(function (item) {\n      return '' + item;\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n}\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case exports.Fragment:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        return getComponentName(type.type);\n\n      case REACT_BLOCK_TYPE:\n        return getComponentName(type._render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentName(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: _assign({}, props, {\n          value: prevLog\n        }),\n        info: _assign({}, props, {\n          value: prevInfo\n        }),\n        warn: _assign({}, props, {\n          value: prevWarn\n        }),\n        error: _assign({}, props, {\n          value: prevError\n        }),\n        group: _assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: _assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: _assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_BLOCK_TYPE:\n        return describeFunctionComponentFrame(type._render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (Array.isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentName(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentName(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (Array.isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (Array.isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === exports.Fragment) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsNENBQU87QUFDM0IsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0ZBQStGLGVBQWU7QUFDOUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9FQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzE3ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLmpzeERFViA9IGpzeERFViQxO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v17.0.2\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE = 0xeac7;\nvar REACT_PORTAL_TYPE = 0xeaca;\nexports.Fragment = 0xeacb;\nvar REACT_STRICT_MODE_TYPE = 0xeacc;\nvar REACT_PROFILER_TYPE = 0xead2;\nvar REACT_PROVIDER_TYPE = 0xeacd;\nvar REACT_CONTEXT_TYPE = 0xeace;\nvar REACT_FORWARD_REF_TYPE = 0xead0;\nvar REACT_SUSPENSE_TYPE = 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = 0xead8;\nvar REACT_MEMO_TYPE = 0xead3;\nvar REACT_LAZY_TYPE = 0xead4;\nvar REACT_BLOCK_TYPE = 0xead9;\nvar REACT_SERVER_BLOCK_TYPE = 0xeada;\nvar REACT_FUNDAMENTAL_TYPE = 0xead5;\nvar REACT_SCOPE_TYPE = 0xead7;\nvar REACT_OPAQUE_ID_TYPE = 0xeae0;\nvar REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\nvar REACT_OFFSCREEN_TYPE = 0xeae2;\nvar REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  var symbolFor = Symbol.for;\n  REACT_ELEMENT_TYPE = symbolFor('react.element');\n  REACT_PORTAL_TYPE = symbolFor('react.portal');\n  exports.Fragment = symbolFor('react.fragment');\n  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n  REACT_PROFILER_TYPE = symbolFor('react.profiler');\n  REACT_PROVIDER_TYPE = symbolFor('react.provider');\n  REACT_CONTEXT_TYPE = symbolFor('react.context');\n  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n  REACT_MEMO_TYPE = symbolFor('react.memo');\n  REACT_LAZY_TYPE = symbolFor('react.lazy');\n  REACT_BLOCK_TYPE = symbolFor('react.block');\n  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n  REACT_SCOPE_TYPE = symbolFor('react.scope');\n  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n}\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    printWarning('error', format, args);\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    }\n\n    var argsWithFormat = args.map(function (item) {\n      return '' + item;\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n}\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case exports.Fragment:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        return getComponentName(type.type);\n\n      case REACT_BLOCK_TYPE:\n        return getComponentName(type._render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentName(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: _assign({}, props, {\n          value: prevLog\n        }),\n        info: _assign({}, props, {\n          value: prevInfo\n        }),\n        warn: _assign({}, props, {\n          value: prevWarn\n        }),\n        error: _assign({}, props, {\n          value: prevError\n        }),\n        group: _assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: _assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: _assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_BLOCK_TYPE:\n        return describeFunctionComponentFrame(type._render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (Array.isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentName(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentName(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (Array.isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (Array.isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === exports.Fragment) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx =  jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs =  jsxWithValidationStatic ;\n\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTztBQUMzQixjQUFjLG1CQUFPLENBQUMsZ0ZBQWU7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrRkFBK0YsZUFBZTtBQUM5RztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkhBQTJIO0FBQzNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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Q0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0Qzs7QUFFQTs7QUFFQSxXQUFXO0FBQ1gsWUFBWTtBQUNaLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzPzJmYzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG4vLyBldmVuIHdpdGggdGhlIHByb2QgdHJhbnNmb3JtLiBUaGlzIG1lYW5zIHRoYXQganN4REVWIGlzIHB1cmVseVxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxuLy8gZ2l2aW5nIHlvdSB3YXJuaW5ncyBpZiB5b3UgdXNlIHByb2R1Y3Rpb24gYXBpcy5cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGZhbHNlKTtcbiAgfVxufVxuXG52YXIganN4ID0gIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyA7IC8vIHdlIG1heSB3YW50IHRvIHNwZWNpYWwgY2FzZSBqc3hzIGludGVybmFsbHkgdG8gdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RhdGljIGNoaWxkcmVuLlxuLy8gZm9yIG5vdyB3ZSBjYW4gc2hpcCBpZGVudGljYWwgcHJvZCBmdW5jdGlvbnNcblxudmFyIGpzeHMgPSAganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5leHBvcnRzLmpzeCA9IGpzeDtcbmV4cG9ydHMuanN4cyA9IGpzeHM7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-runtime.development.js\n");

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n");

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLCtJQUFrRTtBQUNwRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LXJ1bnRpbWUuanM/MzRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-runtime.js\n");

/***/ }),

/***/ "./node_modules/recoil/es/index.js":
/*!*****************************************!*\
  !*** ./node_modules/recoil/es/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DefaultValue\": function() { return /* binding */ Recoil_index_1; },\n/* harmony export */   \"RecoilEnv\": function() { return /* binding */ Recoil_index_4; },\n/* harmony export */   \"RecoilLoadable\": function() { return /* binding */ Recoil_index_3; },\n/* harmony export */   \"RecoilRoot\": function() { return /* binding */ Recoil_index_5; },\n/* harmony export */   \"atom\": function() { return /* binding */ Recoil_index_8; },\n/* harmony export */   \"atomFamily\": function() { return /* binding */ Recoil_index_10; },\n/* harmony export */   \"constSelector\": function() { return /* binding */ Recoil_index_12; },\n/* harmony export */   \"errorSelector\": function() { return /* binding */ Recoil_index_13; },\n/* harmony export */   \"isRecoilValue\": function() { return /* binding */ Recoil_index_2; },\n/* harmony export */   \"noWait\": function() { return /* binding */ Recoil_index_15; },\n/* harmony export */   \"readOnlySelector\": function() { return /* binding */ Recoil_index_14; },\n/* harmony export */   \"retentionZone\": function() { return /* binding */ Recoil_index_38; },\n/* harmony export */   \"selector\": function() { return /* binding */ Recoil_index_9; },\n/* harmony export */   \"selectorFamily\": function() { return /* binding */ Recoil_index_11; },\n/* harmony export */   \"snapshot_UNSTABLE\": function() { return /* binding */ Recoil_index_36; },\n/* harmony export */   \"useGetRecoilValueInfo_UNSTABLE\": function() { return /* binding */ Recoil_index_26; },\n/* harmony export */   \"useGotoRecoilSnapshot\": function() { return /* binding */ Recoil_index_33; },\n/* harmony export */   \"useRecoilBridgeAcrossReactRoots_UNSTABLE\": function() { return /* binding */ Recoil_index_7; },\n/* harmony export */   \"useRecoilCallback\": function() { return /* binding */ Recoil_index_31; },\n/* harmony export */   \"useRecoilRefresher_UNSTABLE\": function() { return /* binding */ Recoil_index_27; },\n/* harmony export */   \"useRecoilSnapshot\": function() { return /* binding */ Recoil_index_34; },\n/* harmony export */   \"useRecoilState\": function() { return /* binding */ Recoil_index_22; },\n/* harmony export */   \"useRecoilStateLoadable\": function() { return /* binding */ Recoil_index_23; },\n/* harmony export */   \"useRecoilState_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_30; },\n/* harmony export */   \"useRecoilStoreID\": function() { return /* binding */ Recoil_index_6; },\n/* harmony export */   \"useRecoilTransactionObserver_UNSTABLE\": function() { return /* binding */ Recoil_index_35; },\n/* harmony export */   \"useRecoilTransaction_UNSTABLE\": function() { return /* binding */ Recoil_index_32; },\n/* harmony export */   \"useRecoilValue\": function() { return /* binding */ Recoil_index_20; },\n/* harmony export */   \"useRecoilValueLoadable\": function() { return /* binding */ Recoil_index_21; },\n/* harmony export */   \"useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_28; },\n/* harmony export */   \"useRecoilValue_TRANSITION_SUPPORT_UNSTABLE\": function() { return /* binding */ Recoil_index_29; },\n/* harmony export */   \"useResetRecoilState\": function() { return /* binding */ Recoil_index_25; },\n/* harmony export */   \"useRetain\": function() { return /* binding */ Recoil_index_37; },\n/* harmony export */   \"useSetRecoilState\": function() { return /* binding */ Recoil_index_24; },\n/* harmony export */   \"waitForAll\": function() { return /* binding */ Recoil_index_18; },\n/* harmony export */   \"waitForAllSettled\": function() { return /* binding */ Recoil_index_19; },\n/* harmony export */   \"waitForAny\": function() { return /* binding */ Recoil_index_17; },\n/* harmony export */   \"waitForNone\": function() { return /* binding */ Recoil_index_16; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../node_modules/process/browser.js\");\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction err(message) {\n  const error = new Error(message); // In V8, Error objects keep the closure scope chain alive until the\n  // err.stack property is accessed.\n\n  if (error.stack === undefined) {\n    // IE sets the stack only if error is thrown\n    try {\n      throw error;\n    } catch (_) {} // eslint-disable-line fb-www/no-unused-catch-bindings, no-empty\n\n  }\n\n  return error;\n}\n\nvar err_1 = err;\n\n// @oss-only\n\n\nvar Recoil_err = err_1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n// Split declaration and implementation to allow this function to pretend to\n// check for actual instance of Promise instead of something with a `then`\n// method.\n// eslint-disable-next-line no-redeclare\nfunction isPromise(p) {\n  return !!p && typeof p.then === 'function';\n}\n\nvar Recoil_isPromise = isPromise;\n\nfunction nullthrows(x, message) {\n  if (x != null) {\n    return x;\n  }\n\n  throw Recoil_err(message !== null && message !== void 0 ? message : 'Got unexpected null or undefined');\n}\n\nvar Recoil_nullthrows = nullthrows;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nclass BaseLoadable {\n  getValue() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  toPromise() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  valueOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected value, but in \"${this.state}\" state`);\n  }\n\n  promiseMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  promiseOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected promise, but in \"${this.state}\" state`);\n  }\n\n  errorMaybe() {\n    throw Recoil_err('BaseLoadable');\n  }\n\n  errorOrThrow() {\n    // $FlowFixMe[prop-missing]\n    throw Recoil_err(`Loadable expected error, but in \"${this.state}\" state`);\n  }\n\n  is(other) {\n    // $FlowFixMe[prop-missing]\n    return other.state === this.state && other.contents === this.contents;\n  }\n\n  map(_map) {\n    throw Recoil_err('BaseLoadable');\n  }\n\n}\n\nclass ValueLoadable extends BaseLoadable {\n  constructor(value) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasValue');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = value;\n  }\n\n  getValue() {\n    return this.contents;\n  }\n\n  toPromise() {\n    return Promise.resolve(this.contents);\n  }\n\n  valueMaybe() {\n    return this.contents;\n  }\n\n  valueOrThrow() {\n    return this.contents;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    try {\n      const next = map(this.contents);\n      return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);\n    } catch (e) {\n      return Recoil_isPromise(e) ? // If we \"suspended\", then try again.\n      // errors and subsequent retries will be handled in 'loading' case\n      // $FlowFixMe[prop-missing]\n      loadableWithPromise(e.next(() => this.map(map))) : loadableWithError(e);\n    }\n  }\n\n}\n\nclass ErrorLoadable extends BaseLoadable {\n  constructor(error) {\n    super();\n\n    _defineProperty(this, \"state\", 'hasError');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = error;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return Promise.reject(this.contents);\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return undefined;\n  }\n\n  errorMaybe() {\n    return this.contents;\n  }\n\n  errorOrThrow() {\n    return this.contents;\n  }\n\n  map(_map) {\n    // $FlowIssue[incompatible-return]\n    return this;\n  }\n\n}\n\nclass LoadingLoadable extends BaseLoadable {\n  constructor(promise) {\n    super();\n\n    _defineProperty(this, \"state\", 'loading');\n\n    _defineProperty(this, \"contents\", void 0);\n\n    this.contents = promise;\n  }\n\n  getValue() {\n    throw this.contents;\n  }\n\n  toPromise() {\n    return this.contents;\n  }\n\n  valueMaybe() {\n    return undefined;\n  }\n\n  promiseMaybe() {\n    return this.contents;\n  }\n\n  promiseOrThrow() {\n    return this.contents;\n  }\n\n  errorMaybe() {\n    return undefined;\n  }\n\n  map(map) {\n    return loadableWithPromise(this.contents.then(value => {\n      const next = map(value);\n\n      if (isLoadable(next)) {\n        const nextLoadable = next;\n\n        switch (nextLoadable.state) {\n          case 'hasValue':\n            return nextLoadable.contents;\n\n          case 'hasError':\n            throw nextLoadable.contents;\n\n          case 'loading':\n            return nextLoadable.contents;\n        }\n      } // $FlowIssue[incompatible-return]\n\n\n      return next;\n    }) // $FlowFixMe[incompatible-call]\n    .catch(e => {\n      if (Recoil_isPromise(e)) {\n        // we were \"suspended,\" try again\n        return e.then(() => this.map(map).contents);\n      }\n\n      throw e;\n    }));\n  }\n\n}\n\nfunction loadableWithValue(value) {\n  return Object.freeze(new ValueLoadable(value));\n}\n\nfunction loadableWithError(error) {\n  return Object.freeze(new ErrorLoadable(error));\n}\n\nfunction loadableWithPromise(promise) {\n  return Object.freeze(new LoadingLoadable(promise));\n}\n\nfunction loadableLoading() {\n  return Object.freeze(new LoadingLoadable(new Promise(() => {})));\n}\n\nfunction loadableAllArray(inputs) {\n  return inputs.every(i => i.state === 'hasValue') ? loadableWithValue(inputs.map(i => i.contents)) : inputs.some(i => i.state === 'hasError') ? loadableWithError(Recoil_nullthrows(inputs.find(i => i.state === 'hasError'), 'Invalid loadable passed to loadableAll').contents) : loadableWithPromise(Promise.all(inputs.map(i => i.contents)));\n}\n\nfunction loadableAll(inputs) {\n  const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map(key => inputs[key]);\n  const normalizedInputs = unwrapedInputs.map(x => isLoadable(x) ? x : Recoil_isPromise(x) ? loadableWithPromise(x) : loadableWithValue(x));\n  const output = loadableAllArray(normalizedInputs);\n  return Array.isArray(inputs) ? // $FlowIssue[incompatible-return]\n  output : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  // $FlowIssue[incompatible-call]\n  output.map(outputs => Object.getOwnPropertyNames(inputs).reduce( // $FlowFixMe[invalid-computed-prop]\n  (out, key, idx) => ({ ...out,\n    [key]: outputs[idx]\n  }), {}));\n}\n\nfunction isLoadable(x) {\n  return x instanceof BaseLoadable;\n}\n\nconst LoadableStaticInterface = {\n  of: value => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),\n  error: error => loadableWithError(error),\n  // $FlowIssue[incompatible-return]\n  loading: () => loadableLoading(),\n  // $FlowIssue[unclear-type]\n  all: loadableAll,\n  isLoadable\n};\nvar Recoil_Loadable = {\n  loadableWithValue,\n  loadableWithError,\n  loadableWithPromise,\n  loadableLoading,\n  loadableAll,\n  isLoadable,\n  RecoilLoadable: LoadableStaticInterface\n};\n\nvar Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;\nvar Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;\nvar Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;\nvar Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;\nvar Recoil_Loadable_5 = Recoil_Loadable.loadableAll;\nvar Recoil_Loadable_6 = Recoil_Loadable.isLoadable;\nvar Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;\n\nvar Recoil_Loadable$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  loadableWithValue: Recoil_Loadable_1,\n  loadableWithError: Recoil_Loadable_2,\n  loadableWithPromise: Recoil_Loadable_3,\n  loadableLoading: Recoil_Loadable_4,\n  loadableAll: Recoil_Loadable_5,\n  isLoadable: Recoil_Loadable_6,\n  RecoilLoadable: Recoil_Loadable_7\n});\n\nconst env = {\n  RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: true,\n  // Note: RECOIL_GKS_ENABLED settings will only be honored in OSS builds of Recoil\n  RECOIL_GKS_ENABLED: new Set(['recoil_hamt_2020', 'recoil_sync_external_store', 'recoil_suppress_rerender_in_callback', 'recoil_memory_managament_2020'])\n};\n\nfunction readProcessEnvBooleanFlag(name, set) {\n  var _process$env$name, _process$env$name$toL;\n\n  const sanitizedValue = (_process$env$name = process.env[name]) === null || _process$env$name === void 0 ? void 0 : (_process$env$name$toL = _process$env$name.toLowerCase()) === null || _process$env$name$toL === void 0 ? void 0 : _process$env$name$toL.trim();\n\n  if (sanitizedValue == null || sanitizedValue === '') {\n    return;\n  }\n\n  const allowedValues = ['true', 'false'];\n\n  if (!allowedValues.includes(sanitizedValue)) {\n    throw Recoil_err(`process.env.${name} value must be 'true', 'false', or empty: ${sanitizedValue}`);\n  }\n\n  set(sanitizedValue === 'true');\n}\n\nfunction readProcessEnvStringArrayFlag(name, set) {\n  var _process$env$name2;\n\n  const sanitizedValue = (_process$env$name2 = process.env[name]) === null || _process$env$name2 === void 0 ? void 0 : _process$env$name2.trim();\n\n  if (sanitizedValue == null || sanitizedValue === '') {\n    return;\n  }\n\n  set(sanitizedValue.split(/\\s*,\\s*|\\s+/));\n}\n/**\n * Allow NodeJS/NextJS/etc to set the initial state through process.env variable\n * Note:  we don't assume 'process' is available in all runtime environments\n *\n * @see https://github.com/facebookexperimental/Recoil/issues/733\n */\n\n\nfunction applyProcessEnvFlagOverrides() {\n  var _process;\n\n  // note: this check is needed in addition to the check below, runtime error will occur without it!\n  // eslint-disable-next-line fb-www/typeof-undefined\n  if (typeof process === 'undefined') {\n    return;\n  }\n\n  if (((_process = process) === null || process === void 0 ? void 0 : process.env) == null) {\n    return;\n  }\n\n  readProcessEnvBooleanFlag('RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED', value => {\n    env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = value;\n  });\n  readProcessEnvStringArrayFlag('RECOIL_GKS_ENABLED', value => {\n    value.forEach(gk => {\n      env.RECOIL_GKS_ENABLED.add(gk);\n    });\n  });\n}\n\napplyProcessEnvFlagOverrides();\nvar Recoil_RecoilEnv = env;\n\nfunction Recoil_gkx_OSS(gk) {\n  return Recoil_RecoilEnv.RECOIL_GKS_ENABLED.has(gk);\n}\n\nRecoil_gkx_OSS.setPass = gk => {\n  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.add(gk);\n};\n\nRecoil_gkx_OSS.setFail = gk => {\n  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.delete(gk);\n};\n\nRecoil_gkx_OSS.clear = () => {\n  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.clear();\n};\n\nvar Recoil_gkx = Recoil_gkx_OSS; // @oss-only\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction recoverableViolation(message, _projectName, {\n  error\n} = {}) {\n  if (true) {\n    console.error(message, error);\n  }\n\n  return null;\n}\n\nvar recoverableViolation_1 = recoverableViolation;\n\n// @oss-only\n\n\nvar Recoil_recoverableViolation = recoverableViolation_1;\n\nvar _createMutableSource, _useMutableSource, _useSyncExternalStore;\n\n\n\n\n\n\n\nconst createMutableSource = // flowlint-next-line unclear-type:off\n(_createMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().createMutableSource)) !== null && _createMutableSource !== void 0 ? _createMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_createMutableSource);\nconst useMutableSource = // flowlint-next-line unclear-type:off\n(_useMutableSource = (react__WEBPACK_IMPORTED_MODULE_0___default().useMutableSource)) !== null && _useMutableSource !== void 0 ? _useMutableSource : (react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useMutableSource); // https://github.com/reactwg/react-18/discussions/86\n\nconst useSyncExternalStore = // flowlint-next-line unclear-type:off\n(_useSyncExternalStore = (react__WEBPACK_IMPORTED_MODULE_0___default().useSyncExternalStore)) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : // flowlint-next-line unclear-type:off\n(react__WEBPACK_IMPORTED_MODULE_0___default().unstable_useSyncExternalStore);\nlet ReactRendererVersionMismatchWarnOnce = false; // Check if the current renderer supports `useSyncExternalStore()`.\n// Since React goes through a proxy dispatcher and the current renderer can\n// change we can't simply check if `React.useSyncExternalStore()` is defined.\n\nfunction currentRendererSupportsUseSyncExternalStore() {\n  var _ReactCurrentDispatch;\n\n  // $FlowFixMe[incompatible-use]\n  const {\n    ReactCurrentDispatcher,\n    ReactCurrentOwner\n  } =\n  /* $FlowFixMe[prop-missing] This workaround was approved as a safer mechanism\n   * to detect if the current renderer supports useSyncExternalStore()\n   * https://fb.workplace.com/groups/reactjs/posts/9558682330846963/ */\n  (react__WEBPACK_IMPORTED_MODULE_0___default().__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED);\n  const dispatcher = (_ReactCurrentDispatch = ReactCurrentDispatcher === null || ReactCurrentDispatcher === void 0 ? void 0 : ReactCurrentDispatcher.current) !== null && _ReactCurrentDispatch !== void 0 ? _ReactCurrentDispatch : ReactCurrentOwner.currentDispatcher;\n  const isUseSyncExternalStoreSupported = dispatcher.useSyncExternalStore != null;\n\n  if (useSyncExternalStore && !isUseSyncExternalStoreSupported && !ReactRendererVersionMismatchWarnOnce) {\n    ReactRendererVersionMismatchWarnOnce = true;\n    Recoil_recoverableViolation('A React renderer without React 18+ API support is being used with React 18+.');\n  }\n\n  return isUseSyncExternalStoreSupported;\n}\n\n/**\n * mode: The React API and approach to use for syncing state with React\n * early: Re-renders from Recoil updates occur:\n *    1) earlier\n *    2) in sync with React updates in the same batch\n *    3) before transaction observers instead of after.\n * concurrent: Is the current mode compatible with Concurrent Mode and useTransition()\n */\nfunction reactMode() {\n  // NOTE: This mode is currently broken with some Suspense cases\n  // see Recoil_selector-test.js\n  if (Recoil_gkx('recoil_transition_support')) {\n    return {\n      mode: 'TRANSITION_SUPPORT',\n      early: true,\n      concurrent: true\n    };\n  }\n\n  if (Recoil_gkx('recoil_sync_external_store') && useSyncExternalStore != null) {\n    return {\n      mode: 'SYNC_EXTERNAL_STORE',\n      early: true,\n      concurrent: false\n    };\n  }\n\n  if (Recoil_gkx('recoil_mutable_source') && useMutableSource != null && typeof window !== 'undefined' && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {\n    return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n      mode: 'MUTABLE_SOURCE',\n      early: true,\n      concurrent: true\n    } : {\n      mode: 'MUTABLE_SOURCE',\n      early: false,\n      concurrent: false\n    };\n  }\n\n  return Recoil_gkx('recoil_suppress_rerender_in_callback') ? {\n    mode: 'LEGACY',\n    early: true,\n    concurrent: false\n  } : {\n    mode: 'LEGACY',\n    early: false,\n    concurrent: false\n  };\n} // TODO Need to figure out if there is a standard/open-source equivalent to see if hot module replacement is happening:\n\n\nfunction isFastRefreshEnabled() {\n  // @fb-only: const {isAcceptingUpdate} = require('__debug');\n  // @fb-only: return typeof isAcceptingUpdate === 'function' && isAcceptingUpdate();\n  return false; // @oss-only\n}\n\nvar Recoil_ReactMode = {\n  createMutableSource,\n  useMutableSource,\n  useSyncExternalStore,\n  currentRendererSupportsUseSyncExternalStore,\n  reactMode,\n  isFastRefreshEnabled\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\n// eslint-disable-next-line no-unused-vars\nclass AbstractRecoilValue {\n  constructor(newKey) {\n    _defineProperty(this, \"key\", void 0);\n\n    this.key = newKey;\n  }\n\n  toJSON() {\n    return {\n      key: this.key\n    };\n  }\n\n}\n\nclass RecoilState extends AbstractRecoilValue {}\n\nclass RecoilValueReadOnly extends AbstractRecoilValue {}\n\nfunction isRecoilValue(x) {\n  return x instanceof RecoilState || x instanceof RecoilValueReadOnly;\n}\n\nvar Recoil_RecoilValue = {\n  AbstractRecoilValue,\n  RecoilState,\n  RecoilValueReadOnly,\n  isRecoilValue\n};\n\nvar Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;\nvar Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;\nvar Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;\nvar Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;\n\nvar Recoil_RecoilValue$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  AbstractRecoilValue: Recoil_RecoilValue_1,\n  RecoilState: Recoil_RecoilValue_2,\n  RecoilValueReadOnly: Recoil_RecoilValue_3,\n  isRecoilValue: Recoil_RecoilValue_4\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction sprintf(format, ...args) {\n  let index = 0;\n  return format.replace(/%s/g, () => String(args[index++]));\n}\n\nvar sprintf_1 = sprintf;\n\nfunction expectationViolation(format, ...args) {\n  if (true) {\n    const message = sprintf_1.call(null, format, ...args);\n    const error = new Error(message);\n    error.name = 'Expectation Violation';\n    console.error(error);\n  }\n}\n\nvar expectationViolation_1 = expectationViolation;\n\n// @oss-only\n\n\nvar Recoil_expectationViolation = expectationViolation_1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the mapper function.\n */\n\nfunction mapIterable(iterable, callback) {\n  // Use generator to create iterable/iterator\n  return function* () {\n    let index = 0;\n\n    for (const value of iterable) {\n      yield callback(value, index++);\n    }\n  }();\n}\n\nvar Recoil_mapIterable = mapIterable;\n\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$1\n} = Recoil_ReactMode;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass DefaultValue {}\n\nconst DEFAULT_VALUE = new DefaultValue();\n// flowlint-next-line unclear-type:off\nconst nodes = new Map(); // flowlint-next-line unclear-type:off\n\nconst recoilValues = new Map();\n/* eslint-disable no-redeclare */\n\nfunction recoilValuesForKeys(keys) {\n  return Recoil_mapIterable(keys, key => Recoil_nullthrows(recoilValues.get(key)));\n}\n\nfunction checkForDuplicateAtomKey(key) {\n  if (nodes.has(key)) {\n    const message = `Duplicate atom key \"${key}\". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;\n\n    if (true) {\n      // TODO Figure this out for open-source\n      if (!isFastRefreshEnabled$1()) {\n        Recoil_expectationViolation(message, 'recoil');\n      }\n    } else {}\n  }\n}\n\nfunction registerNode(node) {\n  if (Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) {\n    checkForDuplicateAtomKey(node.key);\n  }\n\n  nodes.set(node.key, node);\n  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);\n  recoilValues.set(node.key, recoilValue);\n  return recoilValue;\n}\n/* eslint-enable no-redeclare */\n\n\nclass NodeMissingError extends Error {} // flowlint-next-line unclear-type:off\n\n\nfunction getNode(key) {\n  const node = nodes.get(key);\n\n  if (node == null) {\n    throw new NodeMissingError(`Missing definition for RecoilValue: \"${key}\"\"`);\n  }\n\n  return node;\n} // flowlint-next-line unclear-type:off\n\n\nfunction getNodeMaybe(key) {\n  return nodes.get(key);\n}\n\nconst configDeletionHandlers = new Map();\n\nfunction deleteNodeConfigIfPossible(key) {\n  var _node$shouldDeleteCon;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const node = nodes.get(key);\n\n  if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {\n    var _getConfigDeletionHan;\n\n    nodes.delete(key);\n    (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();\n    configDeletionHandlers.delete(key);\n  }\n}\n\nfunction setConfigDeletionHandler(key, fn) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  if (fn === undefined) {\n    configDeletionHandlers.delete(key);\n  } else {\n    configDeletionHandlers.set(key, fn);\n  }\n}\n\nfunction getConfigDeletionHandler(key) {\n  return configDeletionHandlers.get(key);\n}\n\nvar Recoil_Node = {\n  nodes,\n  recoilValues,\n  registerNode,\n  getNode,\n  getNodeMaybe,\n  deleteNodeConfigIfPossible,\n  setConfigDeletionHandler,\n  getConfigDeletionHandler,\n  recoilValuesForKeys,\n  NodeMissingError,\n  DefaultValue,\n  DEFAULT_VALUE\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction enqueueExecution(s, f) {\n  f();\n}\n\nvar Recoil_Queue = {\n  enqueueExecution\n};\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\nvar hamt_1 = createCommonjsModule(function (module) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/**\n    @fileOverview Hash Array Mapped Trie.\n\n    Code based on: https://github.com/exclipy/pdata\n*/\n\n\nvar hamt = {}; // export\n\n/* Configuration\n ******************************************************************************/\n\nvar SIZE = 5;\nvar BUCKET_SIZE = Math.pow(2, SIZE);\nvar MASK = BUCKET_SIZE - 1;\nvar MAX_INDEX_NODE = BUCKET_SIZE / 2;\nvar MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n/*\n ******************************************************************************/\n\nvar nothing = {};\n\nvar constant = function constant(x) {\n  return function () {\n    return x;\n  };\n};\n/**\n    Get 32 bit hash of string.\n\n    Based on:\n    http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery\n*/\n\n\nvar hash = hamt.hash = function (str) {\n  var type = typeof str === 'undefined' ? 'undefined' : _typeof(str);\n  if (type === 'number') return str;\n  if (type !== 'string') str += '';\n  var hash = 0;\n\n  for (var i = 0, len = str.length; i < len; ++i) {\n    var c = str.charCodeAt(i);\n    hash = (hash << 5) - hash + c | 0;\n  }\n\n  return hash;\n};\n/* Bit Ops\n ******************************************************************************/\n\n/**\n    Hamming weight.\n\n    Taken from: http://jsperf.com/hamming-weight\n*/\n\n\nvar popcount = function popcount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n};\n\nvar hashFragment = function hashFragment(shift, h) {\n  return h >>> shift & MASK;\n};\n\nvar toBitmap = function toBitmap(x) {\n  return 1 << x;\n};\n\nvar fromBitmap = function fromBitmap(bitmap, bit) {\n  return popcount(bitmap & bit - 1);\n};\n/* Array Ops\n ******************************************************************************/\n\n/**\n    Set a value in an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to change.\n    @param v New value\n    @param arr Array.\n*/\n\n\nvar arrayUpdate = function arrayUpdate(mutate, at, v, arr) {\n  var out = arr;\n\n  if (!mutate) {\n    var len = arr.length;\n    out = new Array(len);\n\n    for (var i = 0; i < len; ++i) {\n      out[i] = arr[i];\n    }\n  }\n\n  out[at] = v;\n  return out;\n};\n/**\n    Remove a value from an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to remove.\n    @param arr Array.\n*/\n\n\nvar arraySpliceOut = function arraySpliceOut(mutate, at, arr) {\n  var newLen = arr.length - 1;\n  var i = 0;\n  var g = 0;\n  var out = arr;\n\n  if (mutate) {\n    i = g = at;\n  } else {\n    out = new Array(newLen);\n\n    while (i < at) {\n      out[g++] = arr[i++];\n    }\n  }\n\n  ++i;\n\n  while (i <= newLen) {\n    out[g++] = arr[i++];\n  }\n\n  if (mutate) {\n    out.length = newLen;\n  }\n\n  return out;\n};\n/**\n    Insert a value into an array.\n\n    @param mutate Should the input array be mutated?\n    @param at Index to insert at.\n    @param v Value to insert,\n    @param arr Array.\n*/\n\n\nvar arraySpliceIn = function arraySpliceIn(mutate, at, v, arr) {\n  var len = arr.length;\n\n  if (mutate) {\n    var _i = len;\n\n    while (_i >= at) {\n      arr[_i--] = arr[_i];\n    }\n\n    arr[at] = v;\n    return arr;\n  }\n\n  var i = 0,\n      g = 0;\n  var out = new Array(len + 1);\n\n  while (i < at) {\n    out[g++] = arr[i++];\n  }\n\n  out[at] = v;\n\n  while (i < len) {\n    out[++g] = arr[i++];\n  }\n\n  return out;\n};\n/* Node Structures\n ******************************************************************************/\n\n\nvar LEAF = 1;\nvar COLLISION = 2;\nvar INDEX = 3;\nvar ARRAY = 4;\n/**\n    Empty node.\n*/\n\nvar empty = {\n  __hamt_isEmpty: true\n};\n\nvar isEmptyNode = function isEmptyNode(x) {\n  return x === empty || x && x.__hamt_isEmpty;\n};\n/**\n    Leaf holding a value.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member key Key.\n    @member value Value stored.\n*/\n\n\nvar Leaf = function Leaf(edit, hash, key, value) {\n  return {\n    type: LEAF,\n    edit: edit,\n    hash: hash,\n    key: key,\n    value: value,\n    _modify: Leaf__modify\n  };\n};\n/**\n    Leaf holding multiple values with the same hash but different keys.\n\n    @member edit Edit of the node.\n    @member hash Hash of key.\n    @member children Array of collision children node.\n*/\n\n\nvar Collision = function Collision(edit, hash, children) {\n  return {\n    type: COLLISION,\n    edit: edit,\n    hash: hash,\n    children: children,\n    _modify: Collision__modify\n  };\n};\n/**\n    Internal node with a sparse set of children.\n\n    Uses a bitmap and array to pack children.\n\n  @member edit Edit of the node.\n    @member mask Bitmap that encode the positions of children in the array.\n    @member children Array of child nodes.\n*/\n\n\nvar IndexedNode = function IndexedNode(edit, mask, children) {\n  return {\n    type: INDEX,\n    edit: edit,\n    mask: mask,\n    children: children,\n    _modify: IndexedNode__modify\n  };\n};\n/**\n    Internal node with many children.\n\n    @member edit Edit of the node.\n    @member size Number of children.\n    @member children Array of child nodes.\n*/\n\n\nvar ArrayNode = function ArrayNode(edit, size, children) {\n  return {\n    type: ARRAY,\n    edit: edit,\n    size: size,\n    children: children,\n    _modify: ArrayNode__modify\n  };\n};\n/**\n    Is `node` a leaf node?\n*/\n\n\nvar isLeaf = function isLeaf(node) {\n  return node === empty || node.type === LEAF || node.type === COLLISION;\n};\n/* Internal node operations.\n ******************************************************************************/\n\n/**\n    Expand an indexed node into an array node.\n\n  @param edit Current edit.\n    @param frag Index of added child.\n    @param child Added child.\n    @param mask Index node mask before child added.\n    @param subNodes Index node children before child added.\n*/\n\n\nvar expand = function expand(edit, frag, child, bitmap, subNodes) {\n  var arr = [];\n  var bit = bitmap;\n  var count = 0;\n\n  for (var i = 0; bit; ++i) {\n    if (bit & 1) arr[i] = subNodes[count++];\n    bit >>>= 1;\n  }\n\n  arr[frag] = child;\n  return ArrayNode(edit, count + 1, arr);\n};\n/**\n    Collapse an array node into a indexed node.\n\n  @param edit Current edit.\n    @param count Number of elements in new array.\n    @param removed Index of removed element.\n    @param elements Array node children before remove.\n*/\n\n\nvar pack = function pack(edit, count, removed, elements) {\n  var children = new Array(count - 1);\n  var g = 0;\n  var bitmap = 0;\n\n  for (var i = 0, len = elements.length; i < len; ++i) {\n    if (i !== removed) {\n      var elem = elements[i];\n\n      if (elem && !isEmptyNode(elem)) {\n        children[g++] = elem;\n        bitmap |= 1 << i;\n      }\n    }\n  }\n\n  return IndexedNode(edit, bitmap, children);\n};\n/**\n    Merge two leaf nodes.\n\n    @param shift Current shift.\n    @param h1 Node 1 hash.\n    @param n1 Node 1.\n    @param h2 Node 2 hash.\n    @param n2 Node 2.\n*/\n\n\nvar mergeLeaves = function mergeLeaves(edit, shift, h1, n1, h2, n2) {\n  if (h1 === h2) return Collision(edit, h1, [n2, n1]);\n  var subH1 = hashFragment(shift, h1);\n  var subH2 = hashFragment(shift, h2);\n  return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);\n};\n/**\n    Update an entry in a collision list.\n\n    @param mutate Should mutation be used?\n    @param edit Current edit.\n    @param keyEq Key compare function.\n    @param hash Hash of collision.\n    @param list Collision list.\n    @param f Update function.\n    @param k Key to update.\n    @param size Size ref.\n*/\n\n\nvar updateCollisionList = function updateCollisionList(mutate, edit, keyEq, h, list, f, k, size) {\n  var len = list.length;\n\n  for (var i = 0; i < len; ++i) {\n    var child = list[i];\n\n    if (keyEq(k, child.key)) {\n      var value = child.value;\n\n      var _newValue = f(value);\n\n      if (_newValue === value) return list;\n\n      if (_newValue === nothing) {\n        --size.value;\n        return arraySpliceOut(mutate, i, list);\n      }\n\n      return arrayUpdate(mutate, i, Leaf(edit, h, k, _newValue), list);\n    }\n  }\n\n  var newValue = f();\n  if (newValue === nothing) return list;\n  ++size.value;\n  return arrayUpdate(mutate, len, Leaf(edit, h, k, newValue), list);\n};\n\nvar canEditNode = function canEditNode(edit, node) {\n  return edit === node.edit;\n};\n/* Editing\n ******************************************************************************/\n\n\nvar Leaf__modify = function Leaf__modify(edit, keyEq, shift, f, h, k, size) {\n  if (keyEq(k, this.key)) {\n    var _v = f(this.value);\n\n    if (_v === this.value) return this;else if (_v === nothing) {\n      --size.value;\n      return empty;\n    }\n\n    if (canEditNode(edit, this)) {\n      this.value = _v;\n      return this;\n    }\n\n    return Leaf(edit, h, k, _v);\n  }\n\n  var v = f();\n  if (v === nothing) return this;\n  ++size.value;\n  return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\n\nvar Collision__modify = function Collision__modify(edit, keyEq, shift, f, h, k, size) {\n  if (h === this.hash) {\n    var canEdit = canEditNode(edit, this);\n    var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f, k, size);\n    if (list === this.children) return this;\n    return list.length > 1 ? Collision(edit, this.hash, list) : list[0]; // collapse single element collision list\n  }\n\n  var v = f();\n  if (v === nothing) return this;\n  ++size.value;\n  return mergeLeaves(edit, shift, this.hash, this, h, Leaf(edit, h, k, v));\n};\n\nvar IndexedNode__modify = function IndexedNode__modify(edit, keyEq, shift, f, h, k, size) {\n  var mask = this.mask;\n  var children = this.children;\n  var frag = hashFragment(shift, h);\n  var bit = toBitmap(frag);\n  var indx = fromBitmap(mask, bit);\n  var exists = mask & bit;\n  var current = exists ? children[indx] : empty;\n\n  var child = current._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n  if (current === child) return this;\n  var canEdit = canEditNode(edit, this);\n  var bitmap = mask;\n  var newChildren = void 0;\n\n  if (exists && isEmptyNode(child)) {\n    // remove\n    bitmap &= ~bit;\n    if (!bitmap) return empty;\n    if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1]; // collapse\n\n    newChildren = arraySpliceOut(canEdit, indx, children);\n  } else if (!exists && !isEmptyNode(child)) {\n    // add\n    if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);\n    bitmap |= bit;\n    newChildren = arraySpliceIn(canEdit, indx, child, children);\n  } else {\n    // modify\n    newChildren = arrayUpdate(canEdit, indx, child, children);\n  }\n\n  if (canEdit) {\n    this.mask = bitmap;\n    this.children = newChildren;\n    return this;\n  }\n\n  return IndexedNode(edit, bitmap, newChildren);\n};\n\nvar ArrayNode__modify = function ArrayNode__modify(edit, keyEq, shift, f, h, k, size) {\n  var count = this.size;\n  var children = this.children;\n  var frag = hashFragment(shift, h);\n  var child = children[frag];\n\n  var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f, h, k, size);\n\n  if (child === newChild) return this;\n  var canEdit = canEditNode(edit, this);\n  var newChildren = void 0;\n\n  if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n    // add\n    ++count;\n    newChildren = arrayUpdate(canEdit, frag, newChild, children);\n  } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n    // remove\n    --count;\n    if (count <= MIN_ARRAY_NODE) return pack(edit, count, frag, children);\n    newChildren = arrayUpdate(canEdit, frag, empty, children);\n  } else {\n    // modify\n    newChildren = arrayUpdate(canEdit, frag, newChild, children);\n  }\n\n  if (canEdit) {\n    this.size = count;\n    this.children = newChildren;\n    return this;\n  }\n\n  return ArrayNode(edit, count, newChildren);\n};\n\nempty._modify = function (edit, keyEq, shift, f, h, k, size) {\n  var v = f();\n  if (v === nothing) return empty;\n  ++size.value;\n  return Leaf(edit, h, k, v);\n};\n/*\n ******************************************************************************/\n\n\nfunction Map(editable, edit, config, root, size) {\n  this._editable = editable;\n  this._edit = edit;\n  this._config = config;\n  this._root = root;\n  this._size = size;\n}\n\nMap.prototype.setTree = function (newRoot, newSize) {\n  if (this._editable) {\n    this._root = newRoot;\n    this._size = newSize;\n    return this;\n  }\n\n  return newRoot === this._root ? this : new Map(this._editable, this._edit, this._config, newRoot, newSize);\n};\n/* Queries\n ******************************************************************************/\n\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `alt` if none.\n*/\n\n\nvar tryGetHash = hamt.tryGetHash = function (alt, hash, key, map) {\n  var node = map._root;\n  var shift = 0;\n  var keyEq = map._config.keyEq;\n\n  while (true) {\n    switch (node.type) {\n      case LEAF:\n        {\n          return keyEq(key, node.key) ? node.value : alt;\n        }\n\n      case COLLISION:\n        {\n          if (hash === node.hash) {\n            var children = node.children;\n\n            for (var i = 0, len = children.length; i < len; ++i) {\n              var child = children[i];\n              if (keyEq(key, child.key)) return child.value;\n            }\n          }\n\n          return alt;\n        }\n\n      case INDEX:\n        {\n          var frag = hashFragment(shift, hash);\n          var bit = toBitmap(frag);\n\n          if (node.mask & bit) {\n            node = node.children[fromBitmap(node.mask, bit)];\n            shift += SIZE;\n            break;\n          }\n\n          return alt;\n        }\n\n      case ARRAY:\n        {\n          node = node.children[hashFragment(shift, hash)];\n\n          if (node) {\n            shift += SIZE;\n            break;\n          }\n\n          return alt;\n        }\n\n      default:\n        return alt;\n    }\n  }\n};\n\nMap.prototype.tryGetHash = function (alt, hash, key) {\n  return tryGetHash(alt, hash, key, this);\n};\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `tryGetHash`\n*/\n\n\nvar tryGet = hamt.tryGet = function (alt, key, map) {\n  return tryGetHash(alt, map._config.hash(key), key, map);\n};\n\nMap.prototype.tryGet = function (alt, key) {\n  return tryGet(alt, key, this);\n};\n/**\n    Lookup the value for `key` in `map` using a custom `hash`.\n\n    Returns the value or `undefined` if none.\n*/\n\n\nvar getHash = hamt.getHash = function (hash, key, map) {\n  return tryGetHash(undefined, hash, key, map);\n};\n\nMap.prototype.getHash = function (hash, key) {\n  return getHash(hash, key, this);\n};\n/**\n    Lookup the value for `key` in `map` using internal hash function.\n\n    @see `get`\n*/\n\n\nvar get = hamt.get = function (key, map) {\n  return tryGetHash(undefined, map._config.hash(key), key, map);\n};\n\nMap.prototype.get = function (key, alt) {\n  return tryGet(alt, key, this);\n};\n/**\n    Does an entry exist for `key` in `map`? Uses custom `hash`.\n*/\n\n\nvar hasHash = hamt.has = function (hash, key, map) {\n  return tryGetHash(nothing, hash, key, map) !== nothing;\n};\n\nMap.prototype.hasHash = function (hash, key) {\n  return hasHash(hash, key, this);\n};\n/**\n    Does an entry exist for `key` in `map`? Uses internal hash function.\n*/\n\n\nvar has = hamt.has = function (key, map) {\n  return hasHash(map._config.hash(key), key, map);\n};\n\nMap.prototype.has = function (key) {\n  return has(key, this);\n};\n\nvar defKeyCompare = function defKeyCompare(x, y) {\n  return x === y;\n};\n/**\n    Create an empty map.\n\n    @param config Configuration.\n*/\n\n\nhamt.make = function (config) {\n  return new Map(0, 0, {\n    keyEq: config && config.keyEq || defKeyCompare,\n    hash: config && config.hash || hash\n  }, empty, 0);\n};\n/**\n    Empty map.\n*/\n\n\nhamt.empty = hamt.make();\n/**\n    Does `map` contain any elements?\n*/\n\nvar isEmpty = hamt.isEmpty = function (map) {\n  return map && !!isEmptyNode(map._root);\n};\n\nMap.prototype.isEmpty = function () {\n  return isEmpty(this);\n};\n/* Updates\n ******************************************************************************/\n\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    custom hash.\n\n    `f` is invoked with the current value for `k` if it exists,\n    or no arguments if no such value exists. `modify` will always either\n    update or insert a value into the map.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\n\n\nvar modifyHash = hamt.modifyHash = function (f, hash, key, map) {\n  var size = {\n    value: map._size\n  };\n\n  var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f, hash, key, size);\n\n  return map.setTree(newRoot, size.value);\n};\n\nMap.prototype.modifyHash = function (hash, key, f) {\n  return modifyHash(f, hash, key, this);\n};\n/**\n    Alter the value stored for `key` in `map` using function `f` using\n    internal hash function.\n\n    @see `modifyHash`\n*/\n\n\nvar modify = hamt.modify = function (f, key, map) {\n  return modifyHash(f, map._config.hash(key), key, map);\n};\n\nMap.prototype.modify = function (key, f) {\n  return modify(f, key, this);\n};\n/**\n    Store `value` for `key` in `map` using custom `hash`.\n\n    Returns a map with the modified value. Does not alter `map`.\n*/\n\n\nvar setHash = hamt.setHash = function (hash, key, value, map) {\n  return modifyHash(constant(value), hash, key, map);\n};\n\nMap.prototype.setHash = function (hash, key, value) {\n  return setHash(hash, key, value, this);\n};\n/**\n    Store `value` for `key` in `map` using internal hash function.\n\n    @see `setHash`\n*/\n\n\nvar set = hamt.set = function (key, value, map) {\n  return setHash(map._config.hash(key), key, value, map);\n};\n\nMap.prototype.set = function (key, value) {\n  return set(key, value, this);\n};\n/**\n    Remove the entry for `key` in `map`.\n\n    Returns a map with the value removed. Does not alter `map`.\n*/\n\n\nvar del = constant(nothing);\n\nvar removeHash = hamt.removeHash = function (hash, key, map) {\n  return modifyHash(del, hash, key, map);\n};\n\nMap.prototype.removeHash = Map.prototype.deleteHash = function (hash, key) {\n  return removeHash(hash, key, this);\n};\n/**\n    Remove the entry for `key` in `map` using internal hash function.\n\n    @see `removeHash`\n*/\n\n\nvar remove = hamt.remove = function (key, map) {\n  return removeHash(map._config.hash(key), key, map);\n};\n\nMap.prototype.remove = Map.prototype.delete = function (key) {\n  return remove(key, this);\n};\n/* Mutation\n ******************************************************************************/\n\n/**\n    Mark `map` as mutable.\n */\n\n\nvar beginMutation = hamt.beginMutation = function (map) {\n  return new Map(map._editable + 1, map._edit + 1, map._config, map._root, map._size);\n};\n\nMap.prototype.beginMutation = function () {\n  return beginMutation(this);\n};\n/**\n    Mark `map` as immutable.\n */\n\n\nvar endMutation = hamt.endMutation = function (map) {\n  map._editable = map._editable && map._editable - 1;\n  return map;\n};\n\nMap.prototype.endMutation = function () {\n  return endMutation(this);\n};\n/**\n    Mutate `map` within the context of `f`.\n    @param f\n    @param map HAMT\n*/\n\n\nvar mutate = hamt.mutate = function (f, map) {\n  var transient = beginMutation(map);\n  f(transient);\n  return endMutation(transient);\n};\n\nMap.prototype.mutate = function (f) {\n  return mutate(f, this);\n};\n/* Traversal\n ******************************************************************************/\n\n/**\n    Apply a continuation.\n*/\n\n\nvar appk = function appk(k) {\n  return k && lazyVisitChildren(k[0], k[1], k[2], k[3], k[4]);\n};\n/**\n    Recursively visit all values stored in an array of nodes lazily.\n*/\n\n\nvar lazyVisitChildren = function lazyVisitChildren(len, children, i, f, k) {\n  while (i < len) {\n    var child = children[i++];\n    if (child && !isEmptyNode(child)) return lazyVisit(child, f, [len, children, i, f, k]);\n  }\n\n  return appk(k);\n};\n/**\n    Recursively visit all values stored in `node` lazily.\n*/\n\n\nvar lazyVisit = function lazyVisit(node, f, k) {\n  switch (node.type) {\n    case LEAF:\n      return {\n        value: f(node),\n        rest: k\n      };\n\n    case COLLISION:\n    case ARRAY:\n    case INDEX:\n      var children = node.children;\n      return lazyVisitChildren(children.length, children, 0, f, k);\n\n    default:\n      return appk(k);\n  }\n};\n\nvar DONE = {\n  done: true\n};\n/**\n    Javascript iterator over a map.\n*/\n\nfunction MapIterator(v) {\n  this.v = v;\n}\n\nMapIterator.prototype.next = function () {\n  if (!this.v) return DONE;\n  var v0 = this.v;\n  this.v = appk(v0.rest);\n  return v0;\n};\n\nMapIterator.prototype[Symbol.iterator] = function () {\n  return this;\n};\n/**\n    Lazily visit each value in map with function `f`.\n*/\n\n\nvar visit = function visit(map, f) {\n  return new MapIterator(lazyVisit(map._root, f));\n};\n/**\n    Get a Javascsript iterator of `map`.\n\n    Iterates over `[key, value]` arrays.\n*/\n\n\nvar buildPairs = function buildPairs(x) {\n  return [x.key, x.value];\n};\n\nvar entries = hamt.entries = function (map) {\n  return visit(map, buildPairs);\n};\n\nMap.prototype.entries = Map.prototype[Symbol.iterator] = function () {\n  return entries(this);\n};\n/**\n    Get array of all keys in `map`.\n\n    Order is not guaranteed.\n*/\n\n\nvar buildKeys = function buildKeys(x) {\n  return x.key;\n};\n\nvar keys = hamt.keys = function (map) {\n  return visit(map, buildKeys);\n};\n\nMap.prototype.keys = function () {\n  return keys(this);\n};\n/**\n    Get array of all values in `map`.\n\n    Order is not guaranteed, duplicates are preserved.\n*/\n\n\nvar buildValues = function buildValues(x) {\n  return x.value;\n};\n\nvar values = hamt.values = Map.prototype.values = function (map) {\n  return visit(map, buildValues);\n};\n\nMap.prototype.values = function () {\n  return values(this);\n};\n/* Fold\n ******************************************************************************/\n\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function mapping accumulated value, value, and key to new value.\n    @param z Starting value.\n    @param m HAMT\n*/\n\n\nvar fold = hamt.fold = function (f, z, m) {\n  var root = m._root;\n  if (root.type === LEAF) return f(z, root.value, root.key);\n  var toVisit = [root.children];\n  var children = void 0;\n\n  while (children = toVisit.pop()) {\n    for (var i = 0, len = children.length; i < len;) {\n      var child = children[i++];\n\n      if (child && child.type) {\n        if (child.type === LEAF) z = f(z, child.value, child.key);else toVisit.push(child.children);\n      }\n    }\n  }\n\n  return z;\n};\n\nMap.prototype.fold = function (f, z) {\n  return fold(f, z, this);\n};\n/**\n    Visit every entry in the map, aggregating data.\n\n    Order of nodes is not guaranteed.\n\n    @param f Function invoked with value and key\n    @param map HAMT\n*/\n\n\nvar forEach = hamt.forEach = function (f, map) {\n  return fold(function (_, value, key) {\n    return f(value, key, map);\n  }, null, map);\n};\n\nMap.prototype.forEach = function (f) {\n  return forEach(f, this);\n};\n/* Aggregate\n ******************************************************************************/\n\n/**\n    Get the number of entries in `map`.\n*/\n\n\nvar count = hamt.count = function (map) {\n  return map._size;\n};\n\nMap.prototype.count = function () {\n  return count(this);\n};\n\nObject.defineProperty(Map.prototype, 'size', {\n  get: Map.prototype.count\n});\n/* Export\n ******************************************************************************/\n\nif ( module.exports) {\n  module.exports = hamt;\n} else {\n  undefined.hamt = hamt;\n}\n});\n\nclass BuiltInMap {\n  constructor(existing) {\n    _defineProperty(this, \"_map\", void 0);\n\n    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  get(k) {\n    return this._map.get(k);\n  }\n\n  has(k) {\n    return this._map.has(k);\n  }\n\n  set(k, v) {\n    this._map.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._map.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._map);\n  }\n\n}\n\nclass HashArrayMappedTrieMap {\n  // Because hamt.empty is not a function there is no way to introduce type\n  // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.\n  // $FlowIssue\n  constructor(existing) {\n    _defineProperty(this, \"_hamt\", hamt_1.empty.beginMutation());\n\n    if (existing instanceof HashArrayMappedTrieMap) {\n      const h = existing._hamt.endMutation();\n\n      existing._hamt = h.beginMutation();\n      this._hamt = h.beginMutation();\n    } else if (existing) {\n      for (const [k, v] of existing.entries()) {\n        this._hamt.set(k, v);\n      }\n    }\n  }\n\n  keys() {\n    return this._hamt.keys();\n  }\n\n  entries() {\n    return this._hamt.entries();\n  }\n\n  get(k) {\n    return this._hamt.get(k);\n  }\n\n  has(k) {\n    return this._hamt.has(k);\n  }\n\n  set(k, v) {\n    this._hamt.set(k, v);\n\n    return this;\n  }\n\n  delete(k) {\n    this._hamt.delete(k);\n\n    return this;\n  }\n\n  clone() {\n    return persistentMap(this);\n  }\n\n  toMap() {\n    return new Map(this._hamt);\n  }\n\n}\n\nfunction persistentMap(existing) {\n  if (Recoil_gkx('recoil_hamt_2020')) {\n    return new HashArrayMappedTrieMap(existing);\n  } else {\n    return new BuiltInMap(existing);\n  }\n}\n\nvar Recoil_PersistentMap = {\n  persistentMap\n};\n\nvar Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;\n\nvar Recoil_PersistentMap$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  persistentMap: Recoil_PersistentMap_1\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Returns a set containing all of the values from the first set that are not\n * present in any of the subsequent sets.\n *\n * Note: this is written procedurally (i.e., without filterSet) for performant\n * use in tight loops.\n */\n\nfunction differenceSets(set, ...setsWithValuesToRemove) {\n  const ret = new Set();\n\n  FIRST: for (const value of set) {\n    for (const otherSet of setsWithValuesToRemove) {\n      if (otherSet.has(value)) {\n        continue FIRST;\n      }\n    }\n\n    ret.add(value);\n  }\n\n  return ret;\n}\n\nvar Recoil_differenceSets = differenceSets;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Returns a new Map object with the same keys as the original, but with the\n * values replaced with the output of the given callback function.\n */\n\nfunction mapMap(map, callback) {\n  const result = new Map();\n  map.forEach((value, key) => {\n    result.set(key, callback(value, key));\n  });\n  return result;\n}\n\nvar Recoil_mapMap = mapMap;\n\nfunction makeGraph() {\n  return {\n    nodeDeps: new Map(),\n    nodeToNodeSubscriptions: new Map()\n  };\n}\n\nfunction cloneGraph(graph) {\n  return {\n    nodeDeps: Recoil_mapMap(graph.nodeDeps, s => new Set(s)),\n    nodeToNodeSubscriptions: Recoil_mapMap(graph.nodeToNodeSubscriptions, s => new Set(s))\n  };\n} // Note that this overwrites the deps of existing nodes, rather than unioning\n// the new deps with the old deps.\n\n\nfunction mergeDepsIntoGraph(key, newDeps, graph, // If olderGraph is given then we will not overwrite changes made to the given\n// graph compared with olderGraph:\nolderGraph) {\n  const {\n    nodeDeps,\n    nodeToNodeSubscriptions\n  } = graph;\n  const oldDeps = nodeDeps.get(key);\n\n  if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {\n    return;\n  } // Update nodeDeps:\n\n\n  nodeDeps.set(key, newDeps); // Add new deps to nodeToNodeSubscriptions:\n\n  const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);\n\n  for (const dep of addedDeps) {\n    if (!nodeToNodeSubscriptions.has(dep)) {\n      nodeToNodeSubscriptions.set(dep, new Set());\n    }\n\n    const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n    existing.add(key);\n  } // Remove removed deps from nodeToNodeSubscriptions:\n\n\n  if (oldDeps) {\n    const removedDeps = Recoil_differenceSets(oldDeps, newDeps);\n\n    for (const dep of removedDeps) {\n      if (!nodeToNodeSubscriptions.has(dep)) {\n        return;\n      }\n\n      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));\n      existing.delete(key);\n\n      if (existing.size === 0) {\n        nodeToNodeSubscriptions.delete(dep);\n      }\n    }\n  }\n}\n\nfunction saveDepsToStore(key, deps, store, version) {\n  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;\n\n  const storeState = store.getState();\n\n  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to save dependencies to a discarded tree');\n  } // Merge the dependencies discovered into the store's dependency map\n  // for the version that was read:\n\n\n  const graph = store.getGraph(version);\n  mergeDepsIntoGraph(key, deps, graph); // If this version is not the latest version, also write these dependencies\n  // into later versions if they don't already have their own:\n\n  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {\n    const currentGraph = store.getGraph(storeState.currentTree.version);\n    mergeDepsIntoGraph(key, deps, currentGraph, graph);\n  }\n\n  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {\n    var _storeState$nextTree2;\n\n    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;\n\n    if (nextVersion !== undefined) {\n      const nextGraph = store.getGraph(nextVersion);\n      mergeDepsIntoGraph(key, deps, nextGraph, graph);\n    }\n  }\n}\n\nvar Recoil_Graph = {\n  cloneGraph,\n  graph: makeGraph,\n  saveDepsToStore\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nlet nextTreeStateVersion = 0;\n\nconst getNextTreeStateVersion = () => nextTreeStateVersion++;\n\nlet nextStoreID = 0;\n\nconst getNextStoreID = () => nextStoreID++;\n\nlet nextComponentID = 0;\n\nconst getNextComponentID = () => nextComponentID++;\n\nvar Recoil_Keys = {\n  getNextTreeStateVersion,\n  getNextStoreID,\n  getNextComponentID\n};\n\nconst {\n  persistentMap: persistentMap$1\n} = Recoil_PersistentMap$1;\n\nconst {\n  graph\n} = Recoil_Graph;\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n} = Recoil_Keys;\n\nfunction makeEmptyTreeState() {\n  const version = getNextTreeStateVersion$1();\n  return {\n    version,\n    stateID: version,\n    transactionMetadata: {},\n    dirtyAtoms: new Set(),\n    atomValues: persistentMap$1(),\n    nonvalidatedAtoms: persistentMap$1()\n  };\n}\n\nfunction makeEmptyStoreState() {\n  const currentTree = makeEmptyTreeState();\n  return {\n    currentTree,\n    nextTree: null,\n    previousTree: null,\n    commitDepth: 0,\n    knownAtoms: new Set(),\n    knownSelectors: new Set(),\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(currentTree.version, graph()),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    nodeCleanupFunctions: new Map()\n  };\n}\n\nvar Recoil_State = {\n  makeEmptyTreeState,\n  makeEmptyStoreState,\n  getNextTreeStateVersion: getNextTreeStateVersion$1\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass RetentionZone {}\n\nfunction retentionZone() {\n  return new RetentionZone();\n}\n\nvar Recoil_RetentionZone = {\n  RetentionZone,\n  retentionZone\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Utilities for working with built-in Maps and Sets without mutating them.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction setByAddingToSet(set, v) {\n  const next = new Set(set);\n  next.add(v);\n  return next;\n}\n\nfunction setByDeletingFromSet(set, v) {\n  const next = new Set(set);\n  next.delete(v);\n  return next;\n}\n\nfunction mapBySettingInMap(map, k, v) {\n  const next = new Map(map);\n  next.set(k, v);\n  return next;\n}\n\nfunction mapByUpdatingInMap(map, k, updater) {\n  const next = new Map(map);\n  next.set(k, updater(next.get(k)));\n  return next;\n}\n\nfunction mapByDeletingFromMap(map, k) {\n  const next = new Map(map);\n  next.delete(k);\n  return next;\n}\n\nfunction mapByDeletingMultipleFromMap(map, ks) {\n  const next = new Map(map);\n  ks.forEach(k => next.delete(k));\n  return next;\n}\n\nvar Recoil_CopyOnWrite = {\n  setByAddingToSet,\n  setByDeletingFromSet,\n  mapBySettingInMap,\n  mapByUpdatingInMap,\n  mapByDeletingFromMap,\n  mapByDeletingMultipleFromMap\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Creates a new iterable whose output is generated by passing the input\n * iterable's values through the filter function.\n */\n\nfunction* filterIterable(iterable, predicate) {\n  // Use generator to create iterable/iterator\n  let index = 0;\n\n  for (const value of iterable) {\n    if (predicate(value, index++)) {\n      yield value;\n    }\n  }\n}\n\nvar Recoil_filterIterable = filterIterable;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Return a proxy object based on the provided base and factories objects.\n * The proxy will include all properties of the base object as-is.\n * The factories object contains callbacks to obtain the values of the properies\n * for its keys.\n *\n * This is useful for providing users an object where some properties may be\n * lazily computed only on first access.\n */\n// $FlowIssue[unclear-type]\n\nfunction lazyProxy(base, factories) {\n  const proxy = new Proxy(base, {\n    // Compute and cache lazy property if not already done.\n    get: (target, prop) => {\n      if (!(prop in target) && prop in factories) {\n        target[prop] = factories[prop]();\n      }\n\n      return target[prop];\n    },\n    // This method allows user to iterate keys as normal\n    ownKeys: target => {\n\n      return Object.keys(target);\n    }\n  }); // $FlowIssue[incompatible-return]\n\n  return proxy;\n}\n\nvar Recoil_lazyProxy = lazyProxy;\n\nconst {\n  getNode: getNode$1,\n  getNodeMaybe: getNodeMaybe$1,\n  recoilValuesForKeys: recoilValuesForKeys$1\n} = Recoil_Node;\n\nconst {\n  RetentionZone: RetentionZone$1\n} = Recoil_RetentionZone;\n\nconst {\n  setByAddingToSet: setByAddingToSet$1\n} = Recoil_CopyOnWrite;\n\n\n\n\n\n\n\n // flowlint-next-line unclear-type:off\n\n\nconst emptySet = Object.freeze(new Set());\n\nclass ReadOnlyRecoilValueError extends Error {}\n\nfunction initializeRetentionForNode(store, nodeKey, retainedBy) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return () => undefined;\n  }\n\n  const {\n    nodesRetainedByZone\n  } = store.getState().retention;\n\n  function addToZone(zone) {\n    let set = nodesRetainedByZone.get(zone);\n\n    if (!set) {\n      nodesRetainedByZone.set(zone, set = new Set());\n    }\n\n    set.add(nodeKey);\n  }\n\n  if (retainedBy instanceof RetentionZone$1) {\n    addToZone(retainedBy);\n  } else if (Array.isArray(retainedBy)) {\n    for (const zone of retainedBy) {\n      addToZone(zone);\n    }\n  }\n\n  return () => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const {\n      retention\n    } = store.getState();\n\n    function deleteFromZone(zone) {\n      const set = retention.nodesRetainedByZone.get(zone);\n      set === null || set === void 0 ? void 0 : set.delete(nodeKey);\n\n      if (set && set.size === 0) {\n        retention.nodesRetainedByZone.delete(zone);\n      }\n    }\n\n    if (retainedBy instanceof RetentionZone$1) {\n      deleteFromZone(retainedBy);\n    } else if (Array.isArray(retainedBy)) {\n      for (const zone of retainedBy) {\n        deleteFromZone(zone);\n      }\n    }\n  };\n}\n\nfunction initializeNodeIfNewToStore(store, treeState, key, trigger) {\n  const storeState = store.getState();\n\n  if (storeState.nodeCleanupFunctions.has(key)) {\n    return;\n  }\n\n  const node = getNode$1(key);\n  const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);\n  const nodeCleanup = node.init(store, treeState, trigger);\n  storeState.nodeCleanupFunctions.set(key, () => {\n    nodeCleanup();\n    retentionCleanup();\n  });\n}\n\nfunction initializeNode(store, key, trigger) {\n  initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);\n}\n\nfunction cleanUpNode(store, key) {\n  var _state$nodeCleanupFun;\n\n  const state = store.getState();\n  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();\n  state.nodeCleanupFunctions.delete(key);\n} // Get the current value loadable of a node and update the state.\n// Update dependencies and subscriptions for selectors.\n// Update saved value validation for atoms.\n\n\nfunction getNodeLoadable(store, state, key) {\n  initializeNodeIfNewToStore(store, state, key, 'get');\n  return getNode$1(key).get(store, state);\n} // Peek at the current value loadable for a node without any evaluation or state change\n\n\nfunction peekNodeLoadable(store, state, key) {\n  return getNode$1(key).peek(store, state);\n} // Write value directly to state bypassing the Node interface as the node\n// definitions may not have been loaded yet when processing the initial snapshot.\n\n\nfunction setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {\n  var _node$invalidate;\n\n  const node = getNodeMaybe$1(key);\n  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n  return { ...state,\n    atomValues: state.atomValues.clone().delete(key),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),\n    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)\n  };\n} // Return the discovered dependencies and values to be written by setting\n// a node value. (Multiple values may be written due to selectors getting to\n// set upstreams; deps may be discovered because of reads in updater functions.)\n\n\nfunction setNodeValue(store, state, key, newValue) {\n  const node = getNode$1(key);\n\n  if (node.set == null) {\n    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);\n  }\n\n  const set = node.set; // so flow doesn't lose the above refinement.\n\n  initializeNodeIfNewToStore(store, state, key, 'set');\n  return set(store, state, newValue);\n}\n\nfunction peekNodeInfo(store, state, key) {\n  const storeState = store.getState();\n  const graph = store.getGraph(state.version);\n  const type = getNode$1(key).nodeType;\n  return Recoil_lazyProxy({\n    type\n  }, {\n    // $FlowFixMe[underconstrained-implicit-instantiation]\n    loadable: () => peekNodeLoadable(store, state, key),\n    isActive: () => storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),\n    isSet: () => type === 'selector' ? false : state.atomValues.has(key),\n    isModified: () => state.dirtyAtoms.has(key),\n    // Report current dependencies.  If the node hasn't been evaluated, then\n    // dependencies may be missing based on the current state.\n    deps: () => {\n      var _graph$nodeDeps$get;\n\n      return recoilValuesForKeys$1((_graph$nodeDeps$get = graph.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);\n    },\n    // Reports all \"current\" subscribers.  Evaluating other nodes or\n    // previous in-progress async evaluations may introduce new subscribers.\n    subscribers: () => {\n      var _storeState$nodeToCom, _storeState$nodeToCom2;\n\n      return {\n        nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, new Set([key])), nodeKey => nodeKey !== key)),\n        components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({\n          name\n        }))\n      };\n    }\n  });\n} // Find all of the recursively dependent nodes\n\n\nfunction getDownstreamNodes(store, state, keys) {\n  const visitedNodes = new Set();\n  const visitingNodes = Array.from(keys);\n  const graph = store.getGraph(state.version);\n\n  for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {\n    var _graph$nodeToNodeSubs;\n\n    visitedNodes.add(key);\n    const subscribedNodes = (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;\n\n    for (const downstreamNode of subscribedNodes) {\n      if (!visitedNodes.has(downstreamNode)) {\n        visitingNodes.push(downstreamNode);\n      }\n    }\n  }\n\n  return visitedNodes;\n}\n\nvar Recoil_FunctionalCore = {\n  getNodeLoadable,\n  peekNodeLoadable,\n  setNodeValue,\n  initializeNode,\n  cleanUpNode,\n  setUnvalidatedAtomValue_DEPRECATED,\n  peekNodeInfo,\n  getDownstreamNodes\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nlet _invalidateMemoizedSnapshot = null;\n\nfunction setInvalidateMemoizedSnapshot(invalidate) {\n  _invalidateMemoizedSnapshot = invalidate;\n}\n\nfunction invalidateMemoizedSnapshot() {\n  var _invalidateMemoizedSn;\n\n  (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();\n}\n\nvar Recoil_SnapshotCache = {\n  setInvalidateMemoizedSnapshot,\n  invalidateMemoizedSnapshot\n};\n\nconst {\n  getDownstreamNodes: getDownstreamNodes$1,\n  getNodeLoadable: getNodeLoadable$1,\n  setNodeValue: setNodeValue$1\n} = Recoil_FunctionalCore;\n\nconst {\n  getNextComponentID: getNextComponentID$1\n} = Recoil_Keys;\n\nconst {\n  getNode: getNode$2,\n  getNodeMaybe: getNodeMaybe$2\n} = Recoil_Node;\n\nconst {\n  DefaultValue: DefaultValue$1\n} = Recoil_Node;\n\nconst {\n  reactMode: reactMode$1\n} = Recoil_ReactMode;\n\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  isRecoilValue: isRecoilValue$1\n} = Recoil_RecoilValue$1;\n\nconst {\n  invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\n\n\n\n\n\n\n\nfunction getRecoilValueAsLoadable(store, {\n  key\n}, treeState = store.getState().currentTree) {\n  var _storeState$nextTree, _storeState$previousT;\n\n  // Reading from an older tree can cause bugs because the dependencies that we\n  // discover during the read are lost.\n  const storeState = store.getState();\n\n  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {\n    Recoil_recoverableViolation('Tried to read from a discarded tree');\n  }\n\n  const loadable = getNodeLoadable$1(store, treeState, key);\n\n  if (loadable.state === 'loading') {\n    loadable.contents.catch(() => {\n      /**\n       * HACK: intercept thrown error here to prevent an uncaught promise exception. Ideally this would happen closer to selector\n       * execution (perhaps introducing a new ERROR class to be resolved by async selectors that are in an error state)\n       */\n      return;\n    });\n  }\n\n  return loadable;\n}\n\nfunction applyAtomValueWrites(atomValues, writes) {\n  const result = atomValues.clone();\n  writes.forEach((v, k) => {\n    if (v.state === 'hasValue' && v.contents instanceof DefaultValue$1) {\n      result.delete(k);\n    } else {\n      result.set(k, v);\n    }\n  });\n  return result;\n}\n\nfunction valueFromValueOrUpdater(store, state, {\n  key\n}, valueOrUpdater) {\n  if (typeof valueOrUpdater === 'function') {\n    // Updater form: pass in the current value. Throw if the current value\n    // is unavailable (namely when updating an async selector that's\n    // pending or errored):\n    const current = getNodeLoadable$1(store, state, key);\n\n    if (current.state === 'loading') {\n      const msg = `Tried to set atom or selector \"${key}\" using an updater function while the current state is pending, this is not currently supported.`;\n      Recoil_recoverableViolation(msg);\n      throw Recoil_err(msg);\n    } else if (current.state === 'hasError') {\n      throw current.contents;\n    } // T itself may be a function, so our refinement is not sufficient:\n\n\n    return valueOrUpdater(current.contents); // flowlint-line unclear-type:off\n  } else {\n    return valueOrUpdater;\n  }\n}\n\nfunction applyAction(store, state, action) {\n  if (action.type === 'set') {\n    const {\n      recoilValue,\n      valueOrUpdater\n    } = action;\n    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);\n    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);\n\n    for (const [key, loadable] of writes.entries()) {\n      writeLoadableToTreeState(state, key, loadable);\n    }\n  } else if (action.type === 'setLoadable') {\n    const {\n      recoilValue: {\n        key\n      },\n      loadable\n    } = action;\n    writeLoadableToTreeState(state, key, loadable);\n  } else if (action.type === 'markModified') {\n    const {\n      recoilValue: {\n        key\n      }\n    } = action;\n    state.dirtyAtoms.add(key);\n  } else if (action.type === 'setUnvalidated') {\n    var _node$invalidate;\n\n    // Write value directly to state bypassing the Node interface as the node\n    // definitions may not have been loaded yet when processing the initial snapshot.\n    const {\n      recoilValue: {\n        key\n      },\n      unvalidatedValue\n    } = action;\n    const node = getNodeMaybe$2(key);\n    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);\n    state.atomValues.delete(key);\n    state.nonvalidatedAtoms.set(key, unvalidatedValue);\n    state.dirtyAtoms.add(key);\n  } else {\n    Recoil_recoverableViolation(`Unknown action ${action.type}`);\n  }\n}\n\nfunction writeLoadableToTreeState(state, key, loadable) {\n  if (loadable.state === 'hasValue' && loadable.contents instanceof DefaultValue$1) {\n    state.atomValues.delete(key);\n  } else {\n    state.atomValues.set(key, loadable);\n  }\n\n  state.dirtyAtoms.add(key);\n  state.nonvalidatedAtoms.delete(key);\n}\n\nfunction applyActionsToStore(store, actions) {\n  store.replaceState(state => {\n    const newState = copyTreeState(state);\n\n    for (const action of actions) {\n      applyAction(store, newState, action);\n    }\n\n    invalidateDownstreams(store, newState);\n    invalidateMemoizedSnapshot$1();\n    return newState;\n  });\n}\n\nfunction queueOrPerformStateUpdate(store, action) {\n  if (batchStack.length) {\n    const actionsByStore = batchStack[batchStack.length - 1];\n    let actions = actionsByStore.get(store);\n\n    if (!actions) {\n      actionsByStore.set(store, actions = []);\n    }\n\n    actions.push(action);\n  } else {\n    applyActionsToStore(store, [action]);\n  }\n}\n\nconst batchStack = [];\n\nfunction batchStart() {\n  const actionsByStore = new Map();\n  batchStack.push(actionsByStore);\n  return () => {\n    for (const [store, actions] of actionsByStore) {\n      applyActionsToStore(store, actions);\n    }\n\n    const popped = batchStack.pop();\n\n    if (popped !== actionsByStore) {\n      Recoil_recoverableViolation('Incorrect order of batch popping');\n    }\n  };\n}\n\nfunction copyTreeState(state) {\n  return { ...state,\n    atomValues: state.atomValues.clone(),\n    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),\n    dirtyAtoms: new Set(state.dirtyAtoms)\n  };\n}\n\nfunction invalidateDownstreams(store, state) {\n  // Inform any nodes that were changed or downstream of changes so that they\n  // can clear out any caches as needed due to the update:\n  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);\n\n  for (const key of downstreams) {\n    var _getNodeMaybe, _getNodeMaybe$invalid;\n\n    (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);\n  }\n}\n\nfunction setRecoilValue(store, recoilValue, valueOrUpdater) {\n  queueOrPerformStateUpdate(store, {\n    type: 'set',\n    recoilValue,\n    valueOrUpdater\n  });\n}\n\nfunction setRecoilValueLoadable(store, recoilValue, loadable) {\n  if (loadable instanceof DefaultValue$1) {\n    return setRecoilValue(store, recoilValue, loadable);\n  }\n\n  queueOrPerformStateUpdate(store, {\n    type: 'setLoadable',\n    recoilValue,\n    loadable: loadable\n  });\n}\n\nfunction markRecoilValueModified(store, recoilValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'markModified',\n    recoilValue\n  });\n}\n\nfunction setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {\n  queueOrPerformStateUpdate(store, {\n    type: 'setUnvalidated',\n    recoilValue,\n    unvalidatedValue\n  });\n}\n\nfunction subscribeToRecoilValue(store, {\n  key\n}, callback, componentDebugName = null) {\n  const subID = getNextComponentID$1();\n  const storeState = store.getState();\n\n  if (!storeState.nodeToComponentSubscriptions.has(key)) {\n    storeState.nodeToComponentSubscriptions.set(key, new Map());\n  }\n\n  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : '<not captured>', callback]); // Handle the case that, during the same tick that we are subscribing, an atom\n  // has been updated by some effect handler. Otherwise we will miss the update.\n\n  const mode = reactMode$1();\n\n  if (mode.early && (mode.mode === 'LEGACY' || mode.mode === 'MUTABLE_SOURCE')) {\n    const nextTree = store.getState().nextTree;\n\n    if (nextTree && nextTree.dirtyAtoms.has(key)) {\n      callback(nextTree);\n    }\n  }\n\n  return {\n    release: () => {\n      const releaseStoreState = store.getState();\n      const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);\n\n      if (subs === undefined || !subs.has(subID)) {\n        Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);\n        return;\n      }\n\n      subs.delete(subID);\n\n      if (subs.size === 0) {\n        releaseStoreState.nodeToComponentSubscriptions.delete(key);\n      }\n    }\n  };\n}\n\nfunction refreshRecoilValue(store, recoilValue) {\n  var _node$clearCache;\n\n  const {\n    currentTree\n  } = store.getState();\n  const node = getNode$2(recoilValue.key);\n  (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);\n}\n\nvar Recoil_RecoilValueInterface = {\n  RecoilValueReadOnly: RecoilValueReadOnly$1,\n  AbstractRecoilValue: AbstractRecoilValue$1,\n  RecoilState: RecoilState$1,\n  getRecoilValueAsLoadable,\n  setRecoilValue,\n  setRecoilValueLoadable,\n  markRecoilValueModified,\n  setUnvalidatedRecoilValue,\n  subscribeToRecoilValue,\n  isRecoilValue: isRecoilValue$1,\n  applyAtomValueWrites,\n  // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot\n  batchStart,\n  writeLoadableToTreeState,\n  invalidateDownstreams,\n  copyTreeState,\n  refreshRecoilValue\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * The someSet() method tests whether some elements in the given Set pass the\n * test implemented by the provided function.\n */\n\nfunction someSet(set, callback, context) {\n  const iterator = set.entries();\n  let current = iterator.next();\n\n  while (!current.done) {\n    const entry = current.value;\n\n    if (callback.call(context, entry[1], entry[0], set)) {\n      return true;\n    }\n\n    current = iterator.next();\n  }\n\n  return false;\n}\n\nvar Recoil_someSet = someSet;\n\nconst {\n  cleanUpNode: cleanUpNode$1\n} = Recoil_FunctionalCore;\n\nconst {\n  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,\n  getNode: getNode$3\n} = Recoil_Node;\n\nconst {\n  RetentionZone: RetentionZone$2\n} = Recoil_RetentionZone;\n\n\n\n\n\n\n\n // Components that aren't mounted after suspending for this long will be assumed\n// to be discarded and their resources released.\n\n\nconst SUSPENSE_TIMEOUT_MS = 120000;\nconst emptySet$1 = new Set();\n\nfunction releaseRetainablesNowOnCurrentTree(store, retainables) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n\n  if (storeState.nextTree) {\n    Recoil_recoverableViolation('releaseNodesNowOnCurrentTree should only be called at the end of a batch');\n    return; // leak memory rather than erase something that's about to be used.\n  }\n\n  const nodes = new Set();\n\n  for (const r of retainables) {\n    if (r instanceof RetentionZone$2) {\n      for (const n of nodesRetainedByZone(storeState, r)) {\n        nodes.add(n);\n      }\n    } else {\n      nodes.add(r);\n    }\n  }\n\n  const releasableNodes = findReleasableNodes(store, nodes);\n\n  for (const node of releasableNodes) {\n    releaseNode(store, treeState, node);\n  }\n}\n\nfunction findReleasableNodes(store, searchFromNodes) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree;\n  const graph = store.getGraph(treeState.version);\n  const releasableNodes = new Set(); // mutated to collect answer\n\n  const nonReleasableNodes = new Set();\n  findReleasableNodesInner(searchFromNodes);\n  return releasableNodes;\n\n  function findReleasableNodesInner(searchFromNodes) {\n    const releasableNodesFoundThisIteration = new Set();\n    const downstreams = getDownstreamNodesInTopologicalOrder(store, treeState, searchFromNodes, releasableNodes, // don't descend into these\n    nonReleasableNodes // don't descend into these\n    ); // Find which of the downstream nodes are releasable and which are not:\n\n    for (const node of downstreams) {\n      var _storeState$retention;\n\n      // Not releasable if configured to be retained forever:\n      if (getNode$3(node).retainedBy === 'recoilRoot') {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained directly by a component:\n\n\n      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if retained by a zone:\n\n\n      if (zonesThatCouldRetainNode(node).some(z => storeState.retention.referenceCounts.get(z))) {\n        nonReleasableNodes.add(node);\n        continue;\n      } // Not releasable if it has a non-releasable child (which will already be in\n      // nonReleasableNodes because we are going in topological order):\n\n\n      const nodeChildren = graph.nodeToNodeSubscriptions.get(node);\n\n      if (nodeChildren && Recoil_someSet(nodeChildren, child => nonReleasableNodes.has(child))) {\n        nonReleasableNodes.add(node);\n        continue;\n      }\n\n      releasableNodes.add(node);\n      releasableNodesFoundThisIteration.add(node);\n    } // If we found any releasable nodes, we need to walk UP from those nodes to\n    // find whether their parents can now be released as well:\n\n\n    const parents = new Set();\n\n    for (const node of releasableNodesFoundThisIteration) {\n      for (const parent of (_graph$nodeDeps$get = graph.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {\n        var _graph$nodeDeps$get;\n\n        if (!releasableNodes.has(parent)) {\n          parents.add(parent);\n        }\n      }\n    }\n\n    if (parents.size) {\n      findReleasableNodesInner(parents);\n    }\n  }\n} // Children before parents\n\n\nfunction getDownstreamNodesInTopologicalOrder(store, treeState, nodes, // Mutable set is destroyed in place\ndoNotDescendInto1, doNotDescendInto2) {\n  const graph = store.getGraph(treeState.version);\n  const answer = [];\n  const visited = new Set();\n\n  while (nodes.size > 0) {\n    visit(Recoil_nullthrows(nodes.values().next().value));\n  }\n\n  return answer;\n\n  function visit(node) {\n    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {\n      nodes.delete(node);\n      return;\n    }\n\n    if (visited.has(node)) {\n      return;\n    }\n\n    const children = graph.nodeToNodeSubscriptions.get(node);\n\n    if (children) {\n      for (const child of children) {\n        visit(child);\n      }\n    }\n\n    visited.add(node);\n    nodes.delete(node);\n    answer.push(node);\n  }\n}\n\nfunction releaseNode(store, treeState, node) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // Atom effects, in-closure caches, etc.:\n\n\n  cleanUpNode$1(store, node); // Delete from store state:\n\n  const storeState = store.getState();\n  storeState.knownAtoms.delete(node);\n  storeState.knownSelectors.delete(node);\n  storeState.nodeTransactionSubscriptions.delete(node);\n  storeState.retention.referenceCounts.delete(node);\n  const zones = zonesThatCouldRetainNode(node);\n\n  for (const zone of zones) {\n    var _storeState$retention2;\n\n    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);\n  } // Note that we DO NOT delete from nodeToComponentSubscriptions because this\n  // already happens when the last component that was retaining the node unmounts,\n  // and this could happen either before or after that.\n  // Delete from TreeState and dep graph:\n\n\n  treeState.atomValues.delete(node);\n  treeState.dirtyAtoms.delete(node);\n  treeState.nonvalidatedAtoms.delete(node);\n  const graph = storeState.graphsByVersion.get(treeState.version);\n\n  if (graph) {\n    const deps = graph.nodeDeps.get(node);\n\n    if (deps !== undefined) {\n      graph.nodeDeps.delete(node);\n\n      for (const dep of deps) {\n        var _graph$nodeToNodeSubs;\n\n        (_graph$nodeToNodeSubs = graph.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);\n      }\n    } // No need to delete sub's deps as there should be no subs at this point.\n    // But an invariant would require deleting nodes in topological order.\n\n\n    graph.nodeToNodeSubscriptions.delete(node);\n  } // Node config (for family members only as their configs can be recreated, and\n  // only if they are not retained within any other Stores):\n\n\n  deleteNodeConfigIfPossible$1(node);\n}\n\nfunction nodesRetainedByZone(storeState, zone) {\n  var _storeState$retention3;\n\n  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;\n}\n\nfunction zonesThatCouldRetainNode(node) {\n  const retainedBy = getNode$3(node).retainedBy;\n\n  if (retainedBy === undefined || retainedBy === 'components' || retainedBy === 'recoilRoot') {\n    return [];\n  } else if (retainedBy instanceof RetentionZone$2) {\n    return [retainedBy];\n  } else {\n    return retainedBy; // it's an array of zones\n  }\n}\n\nfunction scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {\n  const state = store.getState();\n\n  if (state.nextTree) {\n    state.retention.retainablesToCheckForRelease.add(retainable);\n  } else {\n    releaseRetainablesNowOnCurrentTree(store, new Set([retainable]));\n  }\n}\n\nfunction updateRetainCount(store, retainable, delta) {\n  var _map$get;\n\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;\n\n  if (newCount === 0) {\n    updateRetainCountToZero(store, retainable);\n  } else {\n    map.set(retainable, newCount);\n  }\n}\n\nfunction updateRetainCountToZero(store, retainable) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const map = store.getState().retention.referenceCounts;\n  map.delete(retainable);\n  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);\n}\n\nfunction releaseScheduledRetainablesNow(store) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  }\n\n  const state = store.getState();\n  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);\n  state.retention.retainablesToCheckForRelease.clear();\n}\n\nfunction retainedByOptionWithDefault(r) {\n  // The default will change from 'recoilRoot' to 'components' in the future.\n  return r === undefined ? 'recoilRoot' : r;\n}\n\nvar Recoil_Retention = {\n  SUSPENSE_TIMEOUT_MS,\n  updateRetainCount,\n  updateRetainCountToZero,\n  releaseScheduledRetainablesNow,\n  retainedByOptionWithDefault\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */\nconst {\n  unstable_batchedUpdates\n} = (react_dom__WEBPACK_IMPORTED_MODULE_1___default());\n\nvar ReactBatchedUpdates = {\n  unstable_batchedUpdates\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is to export esstiential functions from react-dom\n * for our web build\n *\n * \n * @format\n * @oncall recoil\n */\n// @fb-only: const {unstable_batchedUpdates} = require('ReactDOMComet');\n// prettier-ignore\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n} = ReactBatchedUpdates; // @oss-only\n\n\nvar Recoil_ReactBatchedUpdates = {\n  unstable_batchedUpdates: unstable_batchedUpdates$1\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\nconst {\n  batchStart: batchStart$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  unstable_batchedUpdates: unstable_batchedUpdates$2\n} = Recoil_ReactBatchedUpdates; // flowlint-next-line unclear-type:off\n\n\n/*\n * During SSR, unstable_batchedUpdates may be undefined so this\n * falls back to a basic function that executes the batch\n */\nlet batcher = unstable_batchedUpdates$2 || (batchFn => batchFn());\n/**\n * Sets the provided batcher function as the batcher function used by Recoil.\n *\n * Set the batcher to a custom batcher for your renderer,\n * if you use a renderer other than React DOM or React Native.\n */\n\n\nconst setBatcher = newBatcher => {\n  batcher = newBatcher;\n};\n/**\n * Returns the current batcher function.\n */\n\n\nconst getBatcher = () => batcher;\n/**\n * Calls the current batcher function and passes the\n * provided callback function.\n */\n\n\nconst batchUpdates = callback => {\n  batcher(() => {\n    let batchEnd = () => undefined;\n\n    try {\n      batchEnd = batchStart$1();\n      callback();\n    } finally {\n      batchEnd();\n    }\n  });\n};\n\nvar Recoil_Batching = {\n  getBatcher,\n  setBatcher,\n  batchUpdates\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Combines multiple Iterables into a single Iterable.\n * Traverses the input Iterables in the order provided and maintains the order\n * of their elements.\n *\n * Example:\n * ```\n * const r = Array.from(concatIterables(['a', 'b'], ['c'], ['d', 'e', 'f']));\n * r == ['a', 'b', 'c', 'd', 'e', 'f'];\n * ```\n */\n\nfunction* concatIterables(iters) {\n  for (const iter of iters) {\n    for (const val of iter) {\n      yield val;\n    }\n  }\n}\n\nvar Recoil_concatIterables = concatIterables;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/* eslint-disable fb-www/typeof-undefined */\n\nconst isSSR = // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\ntypeof Window === 'undefined' || typeof window === 'undefined';\n/* eslint-enable fb-www/typeof-undefined */\n\nconst isWindow = value => !isSSR && ( // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709\nvalue === window || value instanceof Window);\n\nconst isReactNative = typeof navigator !== 'undefined' && navigator.product === 'ReactNative'; // eslint-disable-line fb-www/typeof-undefined\n\nvar Recoil_Environment = {\n  isSSR,\n  isReactNative,\n  isWindow\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Caches a function's results based on the key returned by the passed\n * hashFunction.\n */\n\nfunction memoizeWithArgsHash(fn, hashFunction) {\n  let cache;\n  return (...args) => {\n    if (!cache) {\n      cache = {};\n    }\n\n    const key = hashFunction(...args);\n\n    if (!Object.hasOwnProperty.call(cache, key)) {\n      cache[key] = fn(...args);\n    }\n\n    return cache[key];\n  };\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */\n\n\nfunction memoizeOneWithArgsHash(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  return (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n}\n/**\n * Caches a function's results based on a comparison of the arguments.\n * Only caches the last return of the function.\n * Defaults to reference equality\n */\n\n\nfunction memoizeOneWithArgsHashAndInvalidation(fn, hashFunction) {\n  let lastKey;\n  let lastResult; // breaking cache when arguments change\n\n  const memoizedFn = (...args) => {\n    const key = hashFunction(...args);\n\n    if (lastKey === key) {\n      return lastResult;\n    }\n\n    lastKey = key;\n    lastResult = fn(...args);\n    return lastResult;\n  };\n\n  const invalidate = () => {\n    lastKey = null;\n  };\n\n  return [memoizedFn, invalidate];\n}\n\nvar Recoil_Memoize = {\n  memoizeWithArgsHash,\n  memoizeOneWithArgsHash,\n  memoizeOneWithArgsHashAndInvalidation\n};\n\nconst {\n  batchUpdates: batchUpdates$1\n} = Recoil_Batching;\n\nconst {\n  initializeNode: initializeNode$1,\n  peekNodeInfo: peekNodeInfo$1\n} = Recoil_FunctionalCore;\n\nconst {\n  graph: graph$1\n} = Recoil_Graph;\n\nconst {\n  getNextStoreID: getNextStoreID$1\n} = Recoil_Keys;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$1,\n  recoilValues: recoilValues$1,\n  recoilValuesForKeys: recoilValuesForKeys$2\n} = Recoil_Node;\n\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$2,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,\n  setRecoilValue: setRecoilValue$1,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  updateRetainCount: updateRetainCount$1\n} = Recoil_Retention;\n\nconst {\n  setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1\n} = Recoil_SnapshotCache;\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$2,\n  makeEmptyStoreState: makeEmptyStoreState$1\n} = Recoil_State;\n\n\n\nconst {\n  isSSR: isSSR$1\n} = Recoil_Environment;\n\n\n\n\n\n\n\n\n\nconst {\n  memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1\n} = Recoil_Memoize;\n\n\n\n // Opaque at this surface because it's part of the public API from here.\n\n\nconst retainWarning = `\nRecoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:\n\n  const release = snapshot.retain();\n  try {\n    await doSomethingWithSnapshot(snapshot);\n  } finally {\n    release();\n  }\n\nThis is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.\n`; // A \"Snapshot\" is \"read-only\" and captures a specific set of values of atoms.\n// However, the data-flow-graph and selector values may evolve as selector\n// evaluation functions are executed and async selectors resolve.\n\nclass Snapshot {\n  // eslint-disable-next-line fb-www/no-uninitialized-properties\n  constructor(storeState, parentStoreID) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_refCount\", 1);\n\n    _defineProperty(this, \"getLoadable\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return getRecoilValueAsLoadable$1(this._store, recoilValue);\n    });\n\n    _defineProperty(this, \"getPromise\", recoilValue => {\n      this.checkRefCount_INTERNAL();\n      return this.getLoadable(recoilValue).toPromise();\n    });\n\n    _defineProperty(this, \"getNodes_UNSTABLE\", opt => {\n      this.checkRefCount_INTERNAL(); // TODO Deal with modified selectors\n\n      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {\n        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {\n          return [];\n        }\n\n        const state = this._store.getState().currentTree;\n\n        return recoilValuesForKeys$2(state.dirtyAtoms);\n      }\n\n      const knownAtoms = this._store.getState().knownAtoms;\n\n      const knownSelectors = this._store.getState().knownSelectors;\n\n      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({\n        key\n      }) => !knownAtoms.has(key) && !knownSelectors.has(key));\n    });\n\n    _defineProperty(this, \"getInfo_UNSTABLE\", ({\n      key\n    }) => {\n      this.checkRefCount_INTERNAL();\n      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);\n    });\n\n    _defineProperty(this, \"map\", mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mapper(mutableSnapshot); // if removing batchUpdates from `set` add it here\n\n      return mutableSnapshot;\n    });\n\n    _defineProperty(this, \"asyncMap\", async mapper => {\n      this.checkRefCount_INTERNAL();\n      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);\n      mutableSnapshot.retain(); // Retain new snapshot during async mapper\n\n      await mapper(mutableSnapshot); // Continue to retain the new snapshot for the user, but auto-release it\n      // after the next tick, the same as a new synchronous snapshot.\n\n      mutableSnapshot.autoRelease_INTERNAL();\n      return mutableSnapshot;\n    });\n\n    this._store = {\n      storeID: getNextStoreID$1(),\n      parentStoreID,\n      getState: () => storeState,\n      replaceState: replacer => {\n        // no batching, so nextTree is never active\n        storeState.currentTree = replacer(storeState.currentTree);\n      },\n      getGraph: version => {\n        const graphs = storeState.graphsByVersion;\n\n        if (graphs.has(version)) {\n          return Recoil_nullthrows(graphs.get(version));\n        }\n\n        const newGraph = graph$1();\n        graphs.set(version, newGraph);\n        return newGraph;\n      },\n      subscribeToTransactions: () => ({\n        release: () => {}\n      }),\n      addTransactionMetadata: () => {\n        throw Recoil_err('Cannot subscribe to Snapshots');\n      }\n    }; // Initialize any nodes that are live in the parent store (primarily so that\n    // this snapshot gets counted towards the node's live stores count).\n    // TODO Optimize this when cloning snapshots for callbacks\n\n    for (const nodeKey of this._store.getState().knownAtoms) {\n      initializeNode$1(this._store, nodeKey, 'get');\n      updateRetainCount$1(this._store, nodeKey, 1);\n    }\n\n    this.autoRelease_INTERNAL();\n  }\n\n  retain() {\n    if (this._refCount <= 0) {\n      if (true) {\n        throw Recoil_err('Snapshot has already been released.');\n      } else {}\n    }\n\n    this._refCount++;\n    let released = false;\n    return () => {\n      if (!released) {\n        released = true;\n\n        this._release();\n      }\n    };\n  }\n  /**\n   * Release the snapshot on the next tick.  This means the snapshot is retained\n   * during the execution of the current function using it.\n   */\n\n\n  autoRelease_INTERNAL() {\n    if (!isSSR$1) {\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(() => this._release(), 10);\n    }\n  }\n\n  _release() {\n    this._refCount--;\n\n    if (this._refCount === 0) {\n      this._store.getState().nodeCleanupFunctions.forEach(cleanup => cleanup());\n\n      this._store.getState().nodeCleanupFunctions.clear();\n\n      if (!Recoil_gkx('recoil_memory_managament_2020')) {\n        return;\n      } // Temporarily nerfing this to allow us to find broken call sites without\n      // actually breaking anybody yet.\n      // for (const k of this._store.getState().knownAtoms) {\n      //   updateRetainCountToZero(this._store, k);\n      // }\n\n    } else if (this._refCount < 0) {\n      if (true) {\n        Recoil_recoverableViolation('Snapshot released an extra time.');\n      }\n    }\n  }\n\n  isRetained() {\n    return this._refCount > 0;\n  }\n\n  checkRefCount_INTERNAL() {\n    if (Recoil_gkx('recoil_memory_managament_2020') && this._refCount <= 0) {\n      if (true) {\n        Recoil_recoverableViolation(retainWarning);\n      } // What we will ship later:\n      // throw err(retainWarning);\n\n    }\n  }\n\n  getStore_INTERNAL() {\n    this.checkRefCount_INTERNAL();\n    return this._store;\n  }\n\n  getID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.getState().currentTree.stateID;\n  }\n\n  getStoreID() {\n    this.checkRefCount_INTERNAL();\n    return this._store.storeID;\n  } // We want to allow the methods to be destructured and used as accessors\n\n  /* eslint-disable fb-www/extra-arrow-initializer */\n\n  /* eslint-enable fb-www/extra-arrow-initializer */\n\n\n}\n\nfunction cloneStoreState(store, treeState, bumpVersion = false) {\n  const storeState = store.getState();\n  const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;\n  return {\n    // Always clone the TreeState to isolate stores from accidental mutations.\n    // For example, reading a selector from a cloned snapshot shouldn't cache\n    // in the original treestate which may cause the original to skip\n    // initialization of upstream atoms.\n    currentTree: {\n      // TODO snapshots shouldn't really have versions because a new version number\n      // is always assigned when the snapshot is gone to.\n      version: bumpVersion ? version : treeState.version,\n      stateID: bumpVersion ? version : treeState.stateID,\n      transactionMetadata: { ...treeState.transactionMetadata\n      },\n      dirtyAtoms: new Set(treeState.dirtyAtoms),\n      atomValues: treeState.atomValues.clone(),\n      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()\n    },\n    commitDepth: 0,\n    nextTree: null,\n    previousTree: null,\n    knownAtoms: new Set(storeState.knownAtoms),\n    // FIXME here's a copy\n    knownSelectors: new Set(storeState.knownSelectors),\n    // FIXME here's a copy\n    transactionSubscriptions: new Map(),\n    nodeTransactionSubscriptions: new Map(),\n    nodeToComponentSubscriptions: new Map(),\n    queuedComponentCallbacks_DEPRECATED: [],\n    suspendedComponentResolvers: new Set(),\n    graphsByVersion: new Map().set(version, store.getGraph(treeState.version)),\n    retention: {\n      referenceCounts: new Map(),\n      nodesRetainedByZone: new Map(),\n      retainablesToCheckForRelease: new Set()\n    },\n    // FIXME here's a copy\n    // Create blank cleanup handlers for atoms so snapshots don't re-run\n    // atom effects.\n    nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key]) => [key, () => {}]))\n  };\n} // Factory to build a fresh snapshot\n\n\nfunction freshSnapshot(initializeState) {\n  const snapshot = new Snapshot(makeEmptyStoreState$1());\n  return initializeState != null ? snapshot.map(initializeState) : snapshot;\n} // Factory to clone a snapshot state\n\n\nconst [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1( // $FlowFixMe[missing-local-annot]\n(store, version) => {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const treeState = version === 'latest' ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);\n  return new Snapshot(cloneStoreState(store, treeState), store.storeID);\n}, (store, version) => {\n  var _store$getState$nextT, _store$getState$previ;\n\n  return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);\n}); // Avoid circular dependencies\n\nsetInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);\n\nfunction cloneSnapshot(store, version = 'latest') {\n  const snapshot = memoizedCloneSnapshot(store, version);\n\n  if (!snapshot.isRetained()) {\n    invalidateMemoizedSnapshot$2();\n    return memoizedCloneSnapshot(store, version);\n  }\n\n  return snapshot;\n}\n\nclass MutableSnapshot extends Snapshot {\n  constructor(snapshot, batch) {\n    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());\n\n    _defineProperty(this, \"_batch\", void 0);\n\n    _defineProperty(this, \"set\", (recoilState, newValueOrUpdater) => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // This batchUpdates ensures this `set` is applied immediately and you can\n      // read the written value after calling `set`. I would like to remove this\n      // behavior and only batch in `Snapshot.map`, but this would be a breaking\n      // change potentially.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);\n      });\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      this._batch(() => {\n        updateRetainCount$1(store, recoilState.key, 1);\n        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);\n      });\n    });\n\n    _defineProperty(this, \"setUnvalidatedAtomValues_DEPRECATED\", values => {\n      this.checkRefCount_INTERNAL();\n      const store = this.getStore_INTERNAL(); // See note at `set` about batched updates.\n\n      batchUpdates$1(() => {\n        for (const [k, v] of values.entries()) {\n          updateRetainCount$1(store, k, 1);\n          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k), v);\n        }\n      });\n    });\n\n    this._batch = batch;\n  }\n\n}\n\nvar Recoil_Snapshot = {\n  Snapshot,\n  MutableSnapshot,\n  freshSnapshot,\n  cloneSnapshot\n};\n\nvar Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;\nvar Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;\nvar Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;\nvar Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;\n\nvar Recoil_Snapshot$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  Snapshot: Recoil_Snapshot_1,\n  MutableSnapshot: Recoil_Snapshot_2,\n  freshSnapshot: Recoil_Snapshot_3,\n  cloneSnapshot: Recoil_Snapshot_4\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction unionSets(...sets) {\n  const result = new Set();\n\n  for (const set of sets) {\n    for (const value of set) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_unionSets = unionSets;\n\nconst {\n  useRef\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n/**\n * The same as `useRef()` except that if a function is specified then it will\n * call that function to get the value to initialize the reference with.\n * This is similar to how `useState()` behaves when given a function.  It allows\n * the user to avoid generating the initial value for subsequent renders.\n * The tradeoff is that to set the reference to a function itself you need to\n * nest it: useRefInitOnce(() => () => {...});\n */\n\n\nfunction useRefInitOnce(initialValue) {\n  // $FlowExpectedError[incompatible-call]\n  const ref = useRef(initialValue);\n\n  if (ref.current === initialValue && typeof initialValue === 'function') {\n    // $FlowExpectedError[incompatible-use]\n    ref.current = initialValue();\n  }\n\n  return ref;\n}\n\nvar Recoil_useRefInitOnce = useRefInitOnce;\n\n// @fb-only: const RecoilusagelogEvent = require('RecoilusagelogEvent');\n// @fb-only: const RecoilUsageLogFalcoEvent = require('RecoilUsageLogFalcoEvent');\n// @fb-only: const URI = require('URI');\n\n\nconst {\n  getNextTreeStateVersion: getNextTreeStateVersion$3,\n  makeEmptyStoreState: makeEmptyStoreState$2\n} = Recoil_State;\n\nconst {\n  cleanUpNode: cleanUpNode$2,\n  getDownstreamNodes: getDownstreamNodes$2,\n  initializeNode: initializeNode$2,\n  setNodeValue: setNodeValue$2,\n  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1\n} = Recoil_FunctionalCore;\n\nconst {\n  graph: graph$2\n} = Recoil_Graph;\n\nconst {\n  cloneGraph: cloneGraph$1\n} = Recoil_Graph;\n\nconst {\n  getNextStoreID: getNextStoreID$2\n} = Recoil_Keys;\n\nconst {\n  createMutableSource: createMutableSource$1,\n  reactMode: reactMode$2\n} = Recoil_ReactMode;\n\nconst {\n  applyAtomValueWrites: applyAtomValueWrites$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1\n} = Recoil_Retention;\n\nconst {\n  freshSnapshot: freshSnapshot$1\n} = Recoil_Snapshot$1;\n\n\n\nconst {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef: useRef$1,\n  useState\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction notInAContext() {\n  throw Recoil_err('This component must be used inside a <RecoilRoot> component.');\n}\n\nconst defaultStore = Object.freeze({\n  storeID: getNextStoreID$2(),\n  getState: notInAContext,\n  replaceState: notInAContext,\n  getGraph: notInAContext,\n  subscribeToTransactions: notInAContext,\n  addTransactionMetadata: notInAContext\n});\nlet stateReplacerIsBeingExecuted = false;\n\nfunction startNextTreeIfNeeded(store) {\n  if (stateReplacerIsBeingExecuted) {\n    throw Recoil_err('An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.');\n  }\n\n  const storeState = store.getState();\n\n  if (storeState.nextTree === null) {\n    if (Recoil_gkx('recoil_memory_managament_2020') && Recoil_gkx('recoil_release_on_cascading_update_killswitch_2021')) {\n      // If this is a cascading update (that is, rendering due to one state change\n      // invokes a second state change), we won't have cleaned up retainables yet\n      // because this normally happens after notifying components. Do it before\n      // proceeding with the cascading update so that it remains predictable:\n      if (storeState.commitDepth > 0) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n\n    const version = storeState.currentTree.version;\n    const nextVersion = getNextTreeStateVersion$3();\n    storeState.nextTree = { ...storeState.currentTree,\n      version: nextVersion,\n      stateID: nextVersion,\n      dirtyAtoms: new Set(),\n      transactionMetadata: {}\n    };\n    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));\n  }\n}\n\nconst AppContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n  current: defaultStore\n});\n\nconst useStoreRef = () => useContext(AppContext); // $FlowExpectedError[incompatible-call]\n\n\nconst MutableSourceContext = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\n\nfunction useRecoilMutableSource() {\n  const mutableSource = useContext(MutableSourceContext);\n\n  if (mutableSource == null) {\n    Recoil_expectationViolation('Attempted to use a Recoil hook outside of a <RecoilRoot>. ' + '<RecoilRoot> must be an ancestor of any component that uses ' + 'Recoil hooks.');\n  }\n\n  return mutableSource;\n}\n\nfunction notifyComponents(store, storeState, treeState) {\n  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);\n\n  for (const key of dependentNodes) {\n    const comps = storeState.nodeToComponentSubscriptions.get(key);\n\n    if (comps) {\n      for (const [_subID, [_debugName, callback]] of comps) {\n        callback(treeState);\n      }\n    }\n  }\n}\n\nfunction sendEndOfBatchNotifications(store) {\n  const storeState = store.getState();\n  const treeState = storeState.currentTree; // Inform transaction subscribers of the transaction:\n\n  const dirtyAtoms = treeState.dirtyAtoms;\n\n  if (dirtyAtoms.size) {\n    // Execute Node-specific subscribers before global subscribers\n    for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions) {\n      if (dirtyAtoms.has(key)) {\n        for (const [_, subscription] of subscriptions) {\n          subscription(store);\n        }\n      }\n    }\n\n    for (const [_, subscription] of storeState.transactionSubscriptions) {\n      subscription(store);\n    }\n\n    if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {\n      // Notifying components is needed to wake from suspense, even when using\n      // early rendering.\n      notifyComponents(store, storeState, treeState); // Wake all suspended components so the right one(s) can try to re-render.\n      // We need to wake up components not just when some asynchronous selector\n      // resolved, but also when changing synchronous values because this may cause\n      // a selector to change from asynchronous to synchronous, in which case there\n      // would be no follow-up asynchronous resolution to wake us up.\n      // TODO OPTIMIZATION Only wake up related downstream components\n\n      storeState.suspendedComponentResolvers.forEach(cb => cb());\n      storeState.suspendedComponentResolvers.clear();\n    }\n  } // Special behavior ONLY invoked by useInterface.\n  // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n\n  storeState.queuedComponentCallbacks_DEPRECATED.forEach(cb => cb(treeState));\n  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);\n}\n\nfunction endBatch(store) {\n  const storeState = store.getState();\n  storeState.commitDepth++;\n\n  try {\n    const {\n      nextTree\n    } = storeState; // Ignore commits that are not because of Recoil transactions -- namely,\n    // because something above RecoilRoot re-rendered:\n\n    if (nextTree == null) {\n      return;\n    } // nextTree is now committed -- note that copying and reset occurs when\n    // a transaction begins, in startNextTreeIfNeeded:\n\n\n    storeState.previousTree = storeState.currentTree;\n    storeState.currentTree = nextTree;\n    storeState.nextTree = null;\n    sendEndOfBatchNotifications(store);\n\n    if (storeState.previousTree != null) {\n      storeState.graphsByVersion.delete(storeState.previousTree.version);\n    } else {\n      Recoil_recoverableViolation('Ended batch with no previous state, which is unexpected', 'recoil');\n    }\n\n    storeState.previousTree = null;\n\n    if (Recoil_gkx('recoil_memory_managament_2020')) {\n      // Only release retainables if there were no writes during the end of the\n      // batch.  This avoids releasing something we might be about to use.\n      if (nextTree == null) {\n        releaseScheduledRetainablesNow$1(store);\n      }\n    }\n  } finally {\n    storeState.commitDepth--;\n  }\n}\n/*\n * The purpose of the Batcher is to observe when React batches end so that\n * Recoil state changes can be batched. Whenever Recoil state changes, we call\n * setState on the batcher. Then we wait for that change to be committed, which\n * signifies the end of the batch. That's when we respond to the Recoil change.\n */\n\n\nfunction Batcher({\n  setNotifyBatcherOfChange\n}) {\n  const storeRef = useStoreRef();\n  const [, setState] = useState([]); // $FlowFixMe[incompatible-call]\n\n  setNotifyBatcherOfChange(() => setState({}));\n  useEffect(() => {\n    // $FlowFixMe[incompatible-call]\n    setNotifyBatcherOfChange(() => setState({})); // If an asynchronous selector resolves after the Batcher is unmounted,\n    // notifyBatcherOfChange will still be called. An error gets thrown whenever\n    // setState is called after a component is already unmounted, so this sets\n    // notifyBatcherOfChange to be a no-op.\n\n    return () => {\n      setNotifyBatcherOfChange(() => {});\n    };\n  }, [setNotifyBatcherOfChange]);\n  useEffect(() => {\n    // enqueueExecution runs this function immediately; it is only used to\n    // manipulate the order of useEffects during tests, since React seems to\n    // call useEffect in an unpredictable order sometimes.\n    Recoil_Queue.enqueueExecution('Batcher', () => {\n      endBatch(storeRef.current);\n    });\n  });\n  return null;\n}\n\nif (true) {\n  if (typeof window !== 'undefined' && !window.$recoilDebugStates) {\n    window.$recoilDebugStates = [];\n  }\n} // When removing this deprecated function, remove stateBySettingRecoilValue\n// which will no longer be needed.\n\n\nfunction initialStoreState_DEPRECATED(store, initializeState) {\n  const initial = makeEmptyStoreState$2();\n  initializeState({\n    set: (atom, value) => {\n      const state = initial.currentTree;\n      const writes = setNodeValue$2(store, state, atom.key, value);\n      const writtenNodes = new Set(writes.keys());\n      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();\n\n      for (const n of writtenNodes) {\n        nonvalidatedAtoms.delete(n);\n      }\n\n      initial.currentTree = { ...state,\n        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),\n        atomValues: applyAtomValueWrites$1(state.atomValues, writes),\n        // NB: PLEASE un-export applyAtomValueWrites when deleting this code\n        nonvalidatedAtoms\n      };\n    },\n    setUnvalidatedAtomValues: atomValues => {\n      // FIXME replace this with a mutative loop\n      atomValues.forEach((v, k) => {\n        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k, v);\n      });\n    }\n  });\n  return initial;\n} // Initialize state snapshot for <RecoilRoot> for the initializeState prop.\n// Atom effect initialization takes precedence over this prop.\n// Any atom effects will be run before initialization, but then cleaned up,\n// they are then re-run when used as part of rendering.  These semantics are\n// compatible with React StrictMode where effects may be re-run multiple times\n// but state initialization only happens once the first time.\n\n\nfunction initialStoreState(initializeState) {\n  // Initialize a snapshot and get its store\n  const snapshot = freshSnapshot$1(initializeState);\n  const storeState = snapshot.getStore_INTERNAL().getState(); // Counteract the snapshot auto-release\n\n  snapshot.retain(); // Cleanup any effects run during initialization and clear the handlers so\n  // they will re-initialize if used during rendering.  This allows atom effect\n  // initialization to take precedence over initializeState and be compatible\n  // with StrictMode semantics.\n\n  storeState.nodeCleanupFunctions.forEach(cleanup => cleanup());\n  storeState.nodeCleanupFunctions.clear();\n  return storeState;\n}\n\nlet nextID = 0;\n\nfunction RecoilRoot_INTERNAL({\n  initializeState_DEPRECATED,\n  initializeState,\n  store_INTERNAL: storeProp,\n  // For use with React \"context bridging\"\n  children\n}) {\n  // prettier-ignore\n  // @fb-only: useEffect(() => {\n  // @fb-only: if (gkx('recoil_usage_logging')) {\n  // @fb-only: try {\n  // @fb-only: RecoilUsageLogFalcoEvent.log(() => ({\n  // @fb-only: type: RecoilusagelogEvent.RECOIL_ROOT_MOUNTED,\n  // @fb-only: path: URI.getRequestURI().getPath(),\n  // @fb-only: }));\n  // @fb-only: } catch {\n  // @fb-only: recoverableViolation(\n  // @fb-only: 'Error when logging Recoil Usage event',\n  // @fb-only: 'recoil',\n  // @fb-only: );\n  // @fb-only: }\n  // @fb-only: }\n  // @fb-only: }, []);\n  let storeStateRef; // eslint-disable-line prefer-const\n\n  const getGraph = version => {\n    const graphs = storeStateRef.current.graphsByVersion;\n\n    if (graphs.has(version)) {\n      return Recoil_nullthrows(graphs.get(version));\n    }\n\n    const newGraph = graph$2();\n    graphs.set(version, newGraph);\n    return newGraph;\n  };\n\n  const subscribeToTransactions = (callback, key) => {\n    if (key == null) {\n      // Global transaction subscriptions\n      const {\n        transactionSubscriptions\n      } = storeRef.current.getState();\n      const id = nextID++;\n      transactionSubscriptions.set(id, callback);\n      return {\n        release: () => {\n          transactionSubscriptions.delete(id);\n        }\n      };\n    } else {\n      // Node-specific transaction subscriptions:\n      const {\n        nodeTransactionSubscriptions\n      } = storeRef.current.getState();\n\n      if (!nodeTransactionSubscriptions.has(key)) {\n        nodeTransactionSubscriptions.set(key, new Map());\n      }\n\n      const id = nextID++;\n      Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);\n      return {\n        release: () => {\n          const subs = nodeTransactionSubscriptions.get(key);\n\n          if (subs) {\n            subs.delete(id);\n\n            if (subs.size === 0) {\n              nodeTransactionSubscriptions.delete(key);\n            }\n          }\n        }\n      };\n    }\n  };\n\n  const addTransactionMetadata = metadata => {\n    startNextTreeIfNeeded(storeRef.current);\n\n    for (const k of Object.keys(metadata)) {\n      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k] = metadata[k];\n    }\n  };\n\n  const replaceState = replacer => {\n    startNextTreeIfNeeded(storeRef.current); // Use replacer to get the next state:\n\n    const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);\n    let replaced;\n\n    try {\n      stateReplacerIsBeingExecuted = true;\n      replaced = replacer(nextTree);\n    } finally {\n      stateReplacerIsBeingExecuted = false;\n    }\n\n    if (replaced === nextTree) {\n      return;\n    }\n\n    if (true) {\n      if (typeof window !== 'undefined') {\n        window.$recoilDebugStates.push(replaced); // TODO this shouldn't happen here because it's not batched\n      }\n    } // Save changes to nextTree and schedule a React update:\n\n\n    storeStateRef.current.nextTree = replaced;\n\n    if (reactMode$2().early) {\n      notifyComponents(storeRef.current, storeStateRef.current, replaced);\n    }\n\n    Recoil_nullthrows(notifyBatcherOfChange.current)();\n  };\n\n  const notifyBatcherOfChange = useRef$1(null);\n  const setNotifyBatcherOfChange = useCallback(x => {\n    notifyBatcherOfChange.current = x;\n  }, [notifyBatcherOfChange]);\n  const storeRef = Recoil_useRefInitOnce(() => storeProp !== null && storeProp !== void 0 ? storeProp : {\n    storeID: getNextStoreID$2(),\n    getState: () => storeStateRef.current,\n    replaceState,\n    getGraph,\n    subscribeToTransactions,\n    addTransactionMetadata\n  });\n\n  if (storeProp != null) {\n    storeRef.current = storeProp;\n  }\n\n  storeStateRef = Recoil_useRefInitOnce(() => initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());\n  const mutableSource = useMemo(() => createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, () => storeStateRef.current.currentTree.version), [storeStateRef]); // Cleanup when the <RecoilRoot> is unmounted\n\n  useEffect(() => {\n    // React is free to call effect cleanup handlers and effects at will, the\n    // deps array is only an optimization.  For example, React strict mode\n    // will execute each effect twice for testing.  Therefore, we need symmetry\n    // to re-initialize all known atoms after they were cleaned up.\n    const store = storeRef.current;\n\n    for (const atomKey of new Set(store.getState().knownAtoms)) {\n      initializeNode$2(store, atomKey, 'get');\n    }\n\n    return () => {\n      for (const atomKey of store.getState().knownAtoms) {\n        cleanUpNode$2(store, atomKey);\n      }\n    };\n  }, [storeRef]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(AppContext.Provider, {\n    value: storeRef\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MutableSourceContext.Provider, {\n    value: mutableSource\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Batcher, {\n    setNotifyBatcherOfChange: setNotifyBatcherOfChange\n  }), children));\n}\n\nfunction RecoilRoot(props) {\n  const {\n    override,\n    ...propsExceptOverride\n  } = props;\n  const ancestorStoreRef = useStoreRef();\n\n  if (override === false && ancestorStoreRef.current !== defaultStore) {\n    // If ancestorStoreRef.current !== defaultStore, it means that this\n    // RecoilRoot is not nested within another.\n    return props.children;\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot_INTERNAL, propsExceptOverride);\n}\n\nfunction useRecoilStoreID() {\n  return useStoreRef().current.storeID;\n}\n\nvar Recoil_RecoilRoot = {\n  RecoilRoot,\n  useStoreRef,\n  useRecoilMutableSource,\n  useRecoilStoreID,\n  notifyComponents_FOR_TESTING: notifyComponents,\n  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction shallowArrayEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar Recoil_shallowArrayEqual = shallowArrayEqual;\n\nconst {\n  useEffect: useEffect$1,\n  useRef: useRef$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction usePrevious(value) {\n  const ref = useRef$2();\n  useEffect$1(() => {\n    // $FlowFixMe[incompatible-type]\n    ref.current = value;\n  });\n  return ref.current;\n}\n\nvar Recoil_usePrevious = usePrevious;\n\nconst {\n  useStoreRef: useStoreRef$1\n} = Recoil_RecoilRoot;\n\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1\n} = Recoil_Retention;\n\nconst {\n  updateRetainCount: updateRetainCount$2\n} = Recoil_Retention;\n\nconst {\n  RetentionZone: RetentionZone$3\n} = Recoil_RetentionZone;\n\nconst {\n  useEffect: useEffect$2,\n  useRef: useRef$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nconst {\n  isSSR: isSSR$2\n} = Recoil_Environment;\n\n\n\n\n\n // I don't see a way to avoid the any type here because we want to accept readable\n// and writable values with any type parameter, but normally with writable ones\n// RecoilState<SomeT> is not a subtype of RecoilState<mixed>.\n\n\n// flowlint-line unclear-type:off\nfunction useRetain(toRetain) {\n  if (!Recoil_gkx('recoil_memory_managament_2020')) {\n    return;\n  } // eslint-disable-next-line fb-www/react-hooks\n\n\n  return useRetain_ACTUAL(toRetain);\n}\n\nfunction useRetain_ACTUAL(toRetain) {\n  const array = Array.isArray(toRetain) ? toRetain : [toRetain];\n  const retainables = array.map(a => a instanceof RetentionZone$3 ? a : a.key);\n  const storeRef = useStoreRef$1();\n  useEffect$2(() => {\n    if (!Recoil_gkx('recoil_memory_managament_2020')) {\n      return;\n    }\n\n    const store = storeRef.current;\n\n    if (timeoutID.current && !isSSR$2) {\n      // Already performed a temporary retain on render, simply cancel the release\n      // of that temporary retain.\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n    } else {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, 1);\n      }\n    }\n\n    return () => {\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }; // eslint-disable-next-line fb-www/react-hooks-deps\n  }, [storeRef, ...retainables]); // We want to retain if the component suspends. This is terrible but the Suspense\n  // API affords us no better option. If we suspend and never commit after some\n  // seconds, then release. The 'actual' retain/release in the effect above\n  // cancels this.\n\n  const timeoutID = useRef$3();\n  const previousRetainables = Recoil_usePrevious(retainables);\n\n  if (!isSSR$2 && (previousRetainables === undefined || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {\n    const store = storeRef.current;\n\n    for (const r of retainables) {\n      updateRetainCount$2(store, r, 1);\n    }\n\n    if (previousRetainables) {\n      for (const r of previousRetainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }\n\n    if (timeoutID.current) {\n      window.clearTimeout(timeoutID.current);\n    }\n\n    timeoutID.current = window.setTimeout(() => {\n      timeoutID.current = null;\n\n      for (const r of retainables) {\n        updateRetainCount$2(store, r, -1);\n      }\n    }, SUSPENSE_TIMEOUT_MS$1);\n  }\n}\n\nvar Recoil_useRetain = useRetain;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * THIS CODE HAS BEEN COMMENTED OUT INTENTIONALLY\n *\n * This technique of getting the component name is imperfect, since it both only\n * works in a non-minified code base, and more importantly introduces performance\n * problems since it relies in throwing errors which is an expensive operation.\n *\n * At some point we may want to reevaluate this technique hence why we have commented\n * this code out, rather than delete it all together.\n */\n// const {useRef} = require('react');\n// const gkx = require('recoil-shared/util/Recoil_gkx');\n// const stackTraceParser = require('recoil-shared/util/Recoil_stackTraceParser');\n\nfunction useComponentName() {\n  // const nameRef = useRef();\n  // if (__DEV__) {\n  //   if (gkx('recoil_infer_component_names')) {\n  //     if (nameRef.current === undefined) {\n  //       // There is no blessed way to determine the calling React component from\n  //       // within a hook. This hack uses the fact that hooks must start with 'use'\n  //       // and that hooks are either called by React Components or other hooks. It\n  //       // follows therefore, that to find the calling component, you simply need\n  //       // to look down the stack and find the first function which doesn't start\n  //       // with 'use'. We are only enabling this in dev for now, since once the\n  //       // codebase is minified, the naming assumptions no longer hold true.\n  //       // eslint-disable-next-line fb-www/no-new-error\n  //       const frames = stackTraceParser(new Error().stack);\n  //       for (const {methodName} of frames) {\n  //         // I observed cases where the frame was of the form 'Object.useXXX'\n  //         // hence why I'm searching for hooks following a word boundary\n  //         if (!methodName.match(/\\buse[^\\b]+$/)) {\n  //           return (nameRef.current = methodName);\n  //         }\n  //       }\n  //       nameRef.current = null;\n  //     }\n  //     return nameRef.current ?? '<unable to determine component name>';\n  //   }\n  // }\n  // @fb-only: return \"<component name only available when both in dev mode and when passing GK 'recoil_infer_component_names'>\";\n  return '<component name not available>'; // @oss-only\n}\n\nvar Recoil_useComponentName = useComponentName;\n\nconst {\n  batchUpdates: batchUpdates$2\n} = Recoil_Batching;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$2\n} = Recoil_Node;\n\nconst {\n  currentRendererSupportsUseSyncExternalStore: currentRendererSupportsUseSyncExternalStore$1,\n  reactMode: reactMode$3,\n  useMutableSource: useMutableSource$1,\n  useSyncExternalStore: useSyncExternalStore$1\n} = Recoil_ReactMode;\n\nconst {\n  useRecoilMutableSource: useRecoilMutableSource$1,\n  useStoreRef: useStoreRef$2\n} = Recoil_RecoilRoot;\n\nconst {\n  isRecoilValue: isRecoilValue$2\n} = Recoil_RecoilValue$1;\n\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$3,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,\n  setRecoilValue: setRecoilValue$2,\n  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,\n  subscribeToRecoilValue: subscribeToRecoilValue$1\n} = Recoil_RecoilValueInterface;\n\n\n\nconst {\n  useCallback: useCallback$1,\n  useEffect: useEffect$3,\n  useMemo: useMemo$1,\n  useRef: useRef$4,\n  useState: useState$1\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nconst {\n  setByAddingToSet: setByAddingToSet$2\n} = Recoil_CopyOnWrite;\n\n\n\nconst {\n  isSSR: isSSR$3\n} = Recoil_Environment;\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction handleLoadable(loadable, recoilValue, storeRef) {\n  // We can't just throw the promise we are waiting on to Suspense.  If the\n  // upstream dependencies change it may produce a state in which the component\n  // can render, but it would still be suspended on a Promise that may never resolve.\n  if (loadable.state === 'hasValue') {\n    return loadable.contents;\n  } else if (loadable.state === 'loading') {\n    const promise = new Promise(resolve => {\n      const suspendedComponentResolvers = storeRef.current.getState().suspendedComponentResolvers;\n      suspendedComponentResolvers.add(resolve); // SSR should clear out the wake-up resolver if the Promise is resolved\n      // to avoid infinite loops.  (See https://github.com/facebookexperimental/Recoil/pull/2073)\n\n      if (isSSR$3 && Recoil_isPromise(loadable.contents)) {\n        loadable.contents.finally(() => {\n          suspendedComponentResolvers.delete(resolve);\n        });\n      }\n    }); // $FlowExpectedError Flow(prop-missing) for integrating with tools that inspect thrown promises @fb-only\n    // @fb-only: promise.displayName = `Recoil State: ${recoilValue.key}`;\n\n    throw promise;\n  } else if (loadable.state === 'hasError') {\n    throw loadable.contents;\n  } else {\n    throw Recoil_err(`Invalid value of loadable atom \"${recoilValue.key}\"`);\n  }\n}\n\nfunction validateRecoilValue(recoilValue, hookName // $FlowFixMe[missing-local-annot]\n) {\n  if (!isRecoilValue$2(recoilValue)) {\n    throw Recoil_err(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);\n  }\n}\n\n/**\n * Various things are broken with useRecoilInterface, particularly concurrent\n * mode, React strict mode, and memory management. They will not be fixed.\n * */\nfunction useRecoilInterface_DEPRECATED() {\n  const componentName = Recoil_useComponentName();\n  const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook\n\n  const [, forceUpdate] = useState$1([]);\n  const recoilValuesUsed = useRef$4(new Set());\n  recoilValuesUsed.current = new Set(); // Track the RecoilValues used just during this render\n\n  const previousSubscriptions = useRef$4(new Set());\n  const subscriptions = useRef$4(new Map());\n  const unsubscribeFrom = useCallback$1(key => {\n    const sub = subscriptions.current.get(key);\n\n    if (sub) {\n      sub.release();\n      subscriptions.current.delete(key);\n    }\n  }, [subscriptions]);\n  const updateState = useCallback$1((_state, key) => {\n    if (subscriptions.current.has(key)) {\n      forceUpdate([]);\n    }\n  }, []); // Effect to add/remove subscriptions as nodes are used\n\n  useEffect$3(() => {\n    const store = storeRef.current;\n    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach(key => {\n      if (subscriptions.current.has(key)) {\n        Recoil_expectationViolation(`Double subscription to RecoilValue \"${key}\"`);\n        return;\n      }\n\n      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      subscriptions.current.set(key, sub);\n      /**\n       * Since we're subscribing in an effect we need to update to the latest\n       * value of the atom since it may have changed since we rendered. We can\n       * go ahead and do that now, unless we're in the middle of a batch --\n       * in which case we should do it at the end of the batch, due to the\n       * following edge case: Suppose an atom is updated in another useEffect\n       * of this same component. Then the following sequence of events occur:\n       * 1. Atom is updated and subs fired (but we may not be subscribed\n       *    yet depending on order of effects, so we miss this) Updated value\n       *    is now in nextTree, but not currentTree.\n       * 2. This effect happens. We subscribe and update.\n       * 3. From the update we re-render and read currentTree, with old value.\n       * 4. Batcher's effect sets currentTree to nextTree.\n       * In this sequence we miss the update. To avoid that, add the update\n       * to queuedComponentCallback if a batch is in progress.\n       */\n      // FIXME delete queuedComponentCallbacks_DEPRECATED when deleting useInterface.\n\n      const state = store.getState();\n\n      if (state.nextTree) {\n        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n          updateState(store.getState(), key);\n        });\n      } else {\n        updateState(store.getState(), key);\n      }\n    });\n    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach(key => {\n      unsubscribeFrom(key);\n    });\n    previousSubscriptions.current = recoilValuesUsed.current;\n  }); // Effect to unsubscribe from all when unmounting\n\n  useEffect$3(() => {\n    const currentSubscriptions = subscriptions.current; // Restore subscriptions that were cleared due to StrictMode running this effect twice\n\n    Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach(key => {\n      const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), state => updateState(state, key), componentName);\n      currentSubscriptions.set(key, sub);\n    });\n    return () => currentSubscriptions.forEach((_, key) => unsubscribeFrom(key));\n  }, [componentName, storeRef, unsubscribeFrom, updateState]);\n  return useMemo$1(() => {\n    // eslint-disable-next-line no-shadow\n    function useSetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useSetRecoilState');\n      }\n\n      return newValueOrUpdater => {\n        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n      };\n    } // eslint-disable-next-line no-shadow\n\n\n    function useResetRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useResetRecoilState');\n      }\n\n      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValueLoadable(recoilValue) {\n      var _storeState$nextTree;\n\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n      }\n\n      if (!recoilValuesUsed.current.has(recoilValue.key)) {\n        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);\n      } // TODO Restore optimization to memoize lookup\n\n\n      const storeState = storeRef.current.getState();\n      return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilValue(recoilValue) {\n      if (true) {\n        validateRecoilValue(recoilValue, 'useRecoilValue');\n      }\n\n      const loadable = useRecoilValueLoadable(recoilValue);\n      return handleLoadable(loadable, recoilValue, storeRef);\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilState(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilState');\n      }\n\n      return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n    } // eslint-disable-next-line no-shadow\n\n\n    function useRecoilStateLoadable(recoilState) {\n      if (true) {\n        validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n      }\n\n      return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n    }\n\n    return {\n      getRecoilValue: useRecoilValue,\n      getRecoilValueLoadable: useRecoilValueLoadable,\n      getRecoilState: useRecoilState,\n      getRecoilStateLoadable: useRecoilStateLoadable,\n      getSetRecoilState: useSetRecoilState,\n      getResetRecoilState: useResetRecoilState\n    };\n  }, [recoilValuesUsed, storeRef]);\n}\n\nconst recoilComponentGetRecoilValueCount_FOR_TESTING = {\n  current: 0\n};\n\nfunction useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName();\n  const getSnapshot = useCallback$1(() => {\n    var _storeState$nextTree2;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;\n    const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n    return {\n      loadable,\n      key: recoilValue.key\n    };\n  }, [storeRef, recoilValue]); // Memoize the state to avoid unnecessary rerenders\n\n  const memoizePreviousSnapshot = useCallback$1(getState => {\n    let prevState;\n    return () => {\n      var _prevState, _prevState2;\n\n      const nextState = getState();\n\n      if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {\n        return prevState;\n      }\n\n      prevState = nextState;\n      return nextState;\n    };\n  }, []);\n  const getMemoizedSnapshot = useMemo$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);\n  const subscribe = useCallback$1(notify => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName]);\n  return useSyncExternalStore$1(subscribe, getMemoizedSnapshot, // getSnapshot()\n  getMemoizedSnapshot // getServerSnapshot() for SSR support\n  ).loadable;\n}\n\nfunction useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree3;\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getLoadableWithTesting = useCallback$1(() => {\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    return getLoadable();\n  }, [getLoadable]);\n  const componentName = Recoil_useComponentName();\n  const subscribe = useCallback$1((_storeState, notify) => {\n    const store = storeRef.current;\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return notify();\n      } // Only re-render if the value has changed.\n      // This will evaluate the atom/selector now as well as when the\n      // component renders, but that may help with prefetching.\n\n\n      const newLoadable = getLoadable();\n\n      if (!prevLoadableRef.current.is(newLoadable)) {\n        notify();\n      } // If the component is suspended then the effect setting prevLoadableRef\n      // will not run.  So, set the previous value here when its subscription\n      // is fired to wake it up.  We can't just rely on this, though, because\n      // this only executes when an atom/selector is dirty and the atom/selector\n      // passed to the hook can dynamically change.\n\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    return subscription.release;\n  }, [storeRef, recoilValue, componentName, getLoadable]);\n  const source = useRecoilMutableSource$1();\n\n  if (source == null) {\n    throw Recoil_err('Recoil hooks must be used in components contained within a <RecoilRoot> component.');\n  }\n\n  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  return loadable;\n}\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {\n  const storeRef = useStoreRef$2();\n  const componentName = Recoil_useComponentName(); // Accessors to get the current state\n\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree4;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const getState = useCallback$1(() => ({\n    loadable: getLoadable(),\n    key: recoilValue.key\n  }), [getLoadable, recoilValue.key]); // Memoize state snapshots\n\n  const updateState = useCallback$1(prevState => {\n    const nextState = getState();\n    return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;\n  }, [getState]); // Subscribe to Recoil state changes\n\n  useEffect$3(() => {\n    const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, _state => {\n      setState(updateState);\n    }, componentName); // Update state in case we are using a different key\n\n    setState(updateState);\n    return subscription.release;\n  }, [componentName, recoilValue, storeRef, updateState]); // Get the current state\n\n  const [state, setState] = useState$1(getState); // If we changed keys, then return the state for the new key.\n  // This is important in case the old key would cause the component to suspend.\n  // We don't have to set the new state here since the subscribing effect above\n  // will do that.\n\n  return state.key !== recoilValue.key ? getState().loadable : state.loadable;\n}\n\nfunction useRecoilValueLoadable_LEGACY(recoilValue) {\n  const storeRef = useStoreRef$2(); // eslint-disable-next-line fb-www/react-no-unused-state-hook\n\n  const [, forceUpdate] = useState$1([]);\n  const componentName = Recoil_useComponentName();\n  const getLoadable = useCallback$1(() => {\n    var _storeState$nextTree5;\n\n    if (true) {\n      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;\n    }\n\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;\n    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);\n  }, [storeRef, recoilValue]);\n  const loadable = getLoadable();\n  const prevLoadableRef = useRef$4(loadable);\n  useEffect$3(() => {\n    prevLoadableRef.current = loadable;\n  });\n  useEffect$3(() => {\n    const store = storeRef.current;\n    const storeState = store.getState();\n    const subscription = subscribeToRecoilValue$1(store, recoilValue, _state => {\n      var _prevLoadableRef$curr;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {\n        // $FlowFixMe[incompatible-call]\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }, componentName);\n    /**\n     * Since we're subscribing in an effect we need to update to the latest\n     * value of the atom since it may have changed since we rendered. We can\n     * go ahead and do that now, unless we're in the middle of a batch --\n     * in which case we should do it at the end of the batch, due to the\n     * following edge case: Suppose an atom is updated in another useEffect\n     * of this same component. Then the following sequence of events occur:\n     * 1. Atom is updated and subs fired (but we may not be subscribed\n     *    yet depending on order of effects, so we miss this) Updated value\n     *    is now in nextTree, but not currentTree.\n     * 2. This effect happens. We subscribe and update.\n     * 3. From the update we re-render and read currentTree, with old value.\n     * 4. Batcher's effect sets currentTree to nextTree.\n     * In this sequence we miss the update. To avoid that, add the update\n     * to queuedComponentCallback if a batch is in progress.\n     */\n\n    if (storeState.nextTree) {\n      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {\n        // $FlowFixMe[incompatible-type]\n        prevLoadableRef.current = null;\n        forceUpdate([]);\n      });\n    } else {\n      var _prevLoadableRef$curr2;\n\n      if (!Recoil_gkx('recoil_suppress_rerender_in_callback')) {\n        return forceUpdate([]);\n      }\n\n      const newLoadable = getLoadable();\n\n      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {\n        // $FlowFixMe[incompatible-call]\n        forceUpdate(newLoadable);\n      }\n\n      prevLoadableRef.current = newLoadable;\n    }\n\n    return subscription.release;\n  }, [componentName, getLoadable, recoilValue, storeRef]);\n  return loadable;\n}\n/**\n  Like useRecoilValue(), but either returns the value if available or\n  just undefined if not available for any reason, such as pending or error.\n*/\n\n\nfunction useRecoilValueLoadable(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable');\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return {\n    TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,\n    // Recoil will attemp to detect if `useSyncExternalStore()` is supported with\n    // `reactMode()` before calling it.  However, sometimes the host React\n    // environment supports it but uses additional React renderers (such as with\n    // `react-three-fiber`) which do not.  While this is technically a user issue\n    // by using a renderer with React 18+ that doesn't fully support React 18 we\n    // don't want to break users if it can be avoided. As the current renderer can\n    // change at runtime, we need to dynamically check and fallback if necessary.\n    SYNC_EXTERNAL_STORE: currentRendererSupportsUseSyncExternalStore$1() ? useRecoilValueLoadable_SYNC_EXTERNAL_STORE : useRecoilValueLoadable_TRANSITION_SUPPORT,\n    MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,\n    LEGACY: useRecoilValueLoadable_LEGACY\n  }[reactMode$3().mode](recoilValue);\n}\n/**\n  Returns the value represented by the RecoilValue.\n  If the value is pending, it will throw a Promise to suspend the component,\n  if the value is an error it will throw it for the nearest React error boundary.\n  This will also subscribe the component for any updates in the value.\n  */\n\n\nfunction useRecoilValue(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n/**\n  Returns a function that allows the value of a RecoilState to be updated, but does\n  not subscribe the component to changes to that RecoilState.\n*/\n\n\nfunction useSetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useSetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(newValueOrUpdater => {\n    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);\n  }, [storeRef, recoilState]);\n}\n/**\n  Returns a function that will reset the value of a RecoilState to its default\n*/\n\n\nfunction useResetRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useResetRecoilState');\n  }\n\n  const storeRef = useStoreRef$2();\n  return useCallback$1(() => {\n    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);\n  }, [storeRef, recoilState]);\n}\n/**\n  Equivalent to useState(). Allows the value of the RecoilState to be read and written.\n  Subsequent updates to the RecoilState will cause the component to re-render. If the\n  RecoilState is pending, this will suspend the component and initiate the\n  retrieval of the value. If evaluating the RecoilState resulted in an error, this will\n  throw the error so that the nearest React error boundary can catch it.\n*/\n\n\nfunction useRecoilState(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState');\n  }\n\n  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];\n}\n/**\n  Like useRecoilState(), but does not cause Suspense or React error handling. Returns\n  an object that indicates whether the RecoilState is available, pending, or\n  unavailable due to an error.\n*/\n\n\nfunction useRecoilStateLoadable(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilStateLoadable');\n  }\n\n  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];\n}\n\nfunction useSetUnvalidatedAtomValues() {\n  const storeRef = useStoreRef$2();\n  return (values, transactionMetadata = {}) => {\n    batchUpdates$2(() => {\n      storeRef.current.addTransactionMetadata(transactionMetadata);\n      values.forEach((value, key) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));\n    });\n  };\n}\n/**\n * Experimental variants of hooks with support for useTransition()\n */\n\n\nfunction useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE');\n\n    if (!reactMode$3().early) {\n      Recoil_recoverableViolation('Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.');\n    }\n  }\n\n  if (Recoil_gkx('recoil_memory_managament_2020')) {\n    // eslint-disable-next-line fb-www/react-hooks\n    Recoil_useRetain(recoilValue);\n  }\n\n  return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);\n}\n\nfunction useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {\n  if (true) {\n    validateRecoilValue(recoilValue, 'useRecoilValue_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  const storeRef = useStoreRef$2();\n  const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);\n  return handleLoadable(loadable, recoilValue, storeRef);\n}\n\nfunction useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {\n  if (true) {\n    validateRecoilValue(recoilState, 'useRecoilState_TRANSITION_SUPPORT_UNSTABLE');\n  }\n\n  return [useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState), useSetRecoilState(recoilState)];\n}\n\nvar Recoil_Hooks = {\n  recoilComponentGetRecoilValueCount_FOR_TESTING,\n  useRecoilInterface: useRecoilInterface_DEPRECATED,\n  useRecoilState,\n  useRecoilStateLoadable,\n  useRecoilValue,\n  useRecoilValueLoadable,\n  useResetRecoilState,\n  useSetRecoilState,\n  useSetUnvalidatedAtomValues,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Returns a map containing all of the keys + values from the original map where\n * the given callback returned true.\n */\n\nfunction filterMap(map, callback) {\n  const result = new Map();\n\n  for (const [key, value] of map) {\n    if (callback(value, key)) {\n      result.set(key, value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterMap = filterMap;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n/**\n * Returns a set containing all of the values from the original set where\n * the given callback returned true.\n */\n\nfunction filterSet(set, callback) {\n  const result = new Set();\n\n  for (const value of set) {\n    if (callback(value)) {\n      result.add(value);\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_filterSet = filterSet;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction mergeMaps(...maps) {\n  const result = new Map();\n\n  for (let i = 0; i < maps.length; i++) {\n    const iterator = maps[i].keys();\n    let nextKey;\n\n    while (!(nextKey = iterator.next()).done) {\n      // $FlowIssue[incompatible-call] - map/iterator knows nothing about flow types\n      result.set(nextKey.value, maps[i].get(nextKey.value));\n    }\n  }\n\n  return result;\n}\n\nvar Recoil_mergeMaps = mergeMaps;\n\nconst {\n  batchUpdates: batchUpdates$3\n} = Recoil_Batching;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$3,\n  getNode: getNode$4,\n  nodes: nodes$1\n} = Recoil_Node;\n\nconst {\n  useStoreRef: useStoreRef$3\n} = Recoil_RecoilRoot;\n\nconst {\n  AbstractRecoilValue: AbstractRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2\n} = Recoil_Retention;\n\nconst {\n  cloneSnapshot: cloneSnapshot$1\n} = Recoil_Snapshot$1;\n\nconst {\n  useCallback: useCallback$2,\n  useEffect: useEffect$4,\n  useRef: useRef$5,\n  useState: useState$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nconst {\n  isSSR: isSSR$4\n} = Recoil_Environment;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction useTransactionSubscription(callback) {\n  const storeRef = useStoreRef$3();\n  useEffect$4(() => {\n    const sub = storeRef.current.subscribeToTransactions(callback);\n    return sub.release;\n  }, [callback, storeRef]);\n}\n\nfunction externallyVisibleAtomValuesInState(state) {\n  const atomValues = state.atomValues.toMap();\n  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v, k) => {\n    const node = getNode$4(k);\n    const persistence = node.persistence_UNSTABLE;\n    return persistence != null && persistence.type !== 'none' && v.state === 'hasValue';\n  }), v => v.contents); // Merge in nonvalidated atoms; we may not have defs for them but they will\n  // all have persistence on or they wouldn't be there in the first place.\n\n  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);\n}\n\n/**\n  Calls the given callback after any atoms have been modified and the consequent\n  component re-renders have been committed. This is intended for persisting\n  the values of the atoms to storage. The stored values can then be restored\n  using the useSetUnvalidatedAtomValues hook.\n\n  The callback receives the following info:\n\n  atomValues: The current value of every atom that is both persistable (persistence\n              type not set to 'none') and whose value is available (not in an\n              error or loading state).\n\n  previousAtomValues: The value of every persistable and available atom before\n               the transaction began.\n\n  atomInfo: A map containing the persistence settings for each atom. Every key\n            that exists in atomValues will also exist in atomInfo.\n\n  modifiedAtoms: The set of atoms that were written to during the transaction.\n\n  transactionMetadata: Arbitrary information that was added via the\n          useSetUnvalidatedAtomValues hook. Useful for ignoring the useSetUnvalidatedAtomValues\n          transaction, to avoid loops.\n*/\nfunction useTransactionObservation_DEPRECATED(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    let previousTree = store.getState().previousTree;\n    const currentTree = store.getState().currentTree;\n\n    if (!previousTree) {\n      Recoil_recoverableViolation('Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil');\n      previousTree = store.getState().currentTree; // attempt to trundle on\n    }\n\n    const atomValues = externallyVisibleAtomValuesInState(currentTree);\n    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);\n    const atomInfo = Recoil_mapMap(nodes$1, node => {\n      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;\n\n      return {\n        persistence_UNSTABLE: {\n          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : 'none',\n          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false\n        }\n      };\n    }); // Filter on existance in atomValues so that externally-visible rules\n    // are also applied to modified atoms (specifically exclude selectors):\n\n    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, k => atomValues.has(k) || previousAtomValues.has(k));\n    callback({\n      atomValues,\n      previousAtomValues,\n      atomInfo,\n      modifiedAtoms,\n      transactionMetadata: { ...currentTree.transactionMetadata\n      }\n    });\n  }, [callback]));\n}\n\nfunction useRecoilTransactionObserver(callback) {\n  useTransactionSubscription(useCallback$2(store => {\n    const snapshot = cloneSnapshot$1(store, 'latest');\n    const previousSnapshot = cloneSnapshot$1(store, 'previous');\n    callback({\n      snapshot,\n      previousSnapshot\n    });\n  }, [callback]));\n} // Return a snapshot of the current state and subscribe to all state changes\n\n\nfunction useRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  const [snapshot, setSnapshot] = useState$2(() => cloneSnapshot$1(storeRef.current));\n  const previousSnapshot = Recoil_usePrevious(snapshot);\n  const timeoutID = useRef$5();\n  const releaseRef = useRef$5();\n  useTransactionSubscription(useCallback$2(store => setSnapshot(cloneSnapshot$1(store)), [])); // Retain snapshot for duration component is mounted\n\n  useEffect$4(() => {\n    const release = snapshot.retain(); // Release the retain from the rendering call\n\n    if (timeoutID.current && !isSSR$4) {\n      var _releaseRef$current;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    return () => {\n      // Defer the release.  If \"Fast Refresh\"\" is used then the component may\n      // re-render with the same state.  The previous cleanup will then run and\n      // then the new effect will run. We don't want the snapshot to be released\n      // by that cleanup before the new effect has a chance to retain it again.\n      // Use timeout of 10 to workaround Firefox issue: https://github.com/facebookexperimental/Recoil/issues/1936\n      window.setTimeout(release, 10);\n    };\n  }, [snapshot]); // Retain snapshot until above effect is run.\n  // Release after a threshold in case component is suspended.\n\n  if (previousSnapshot !== snapshot && !isSSR$4) {\n    // Release the previous snapshot\n    if (timeoutID.current) {\n      var _releaseRef$current2;\n\n      window.clearTimeout(timeoutID.current);\n      timeoutID.current = null;\n      (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);\n      releaseRef.current = null;\n    }\n\n    releaseRef.current = snapshot.retain();\n    timeoutID.current = window.setTimeout(() => {\n      var _releaseRef$current3;\n\n      timeoutID.current = null;\n      (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);\n      releaseRef.current = null;\n    }, SUSPENSE_TIMEOUT_MS$2);\n  }\n\n  return snapshot;\n}\n\nfunction gotoSnapshot(store, snapshot) {\n  var _storeState$nextTree;\n\n  const storeState = store.getState();\n  const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;\n  const next = snapshot.getStore_INTERNAL().getState().currentTree;\n  batchUpdates$3(() => {\n    const keysToUpdate = new Set();\n\n    for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {\n      for (const key of keys) {\n        var _prev$atomValues$get, _next$atomValues$get;\n\n        if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {\n          keysToUpdate.add(key);\n        }\n      }\n    }\n\n    keysToUpdate.forEach(key => {\n      setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);\n    });\n    store.replaceState(state => ({ ...state,\n      stateID: snapshot.getID()\n    }));\n  });\n}\n\nfunction useGotoRecoilSnapshot() {\n  const storeRef = useStoreRef$3();\n  return useCallback$2(snapshot => gotoSnapshot(storeRef.current, snapshot), [storeRef]);\n}\n\nvar Recoil_SnapshotHooks = {\n  useRecoilSnapshot,\n  gotoSnapshot,\n  useGotoRecoilSnapshot,\n  useRecoilTransactionObserver,\n  useTransactionObservation_DEPRECATED,\n  useTransactionSubscription_DEPRECATED: useTransactionSubscription\n};\n\nconst {\n  peekNodeInfo: peekNodeInfo$2\n} = Recoil_FunctionalCore;\n\nconst {\n  useStoreRef: useStoreRef$4\n} = Recoil_RecoilRoot;\n\nfunction useGetRecoilValueInfo() {\n  const storeRef = useStoreRef$4(); // $FlowFixMe[incompatible-return]\n\n  return ({\n    key\n  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);\n}\n\nvar Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;\n\nconst {\n  reactMode: reactMode$4\n} = Recoil_ReactMode;\n\nconst {\n  RecoilRoot: RecoilRoot$1,\n  useStoreRef: useStoreRef$5\n} = Recoil_RecoilRoot;\n\n\n\nconst {\n  useMemo: useMemo$2\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilBridgeAcrossReactRoots() {\n  // The test fails when using useMutableSource(), but only if act() is used\n  // for the nested root.  So, this may only be a testing environment issue.\n  if (reactMode$4().mode === 'MUTABLE_SOURCE') {\n    // eslint-disable-next-line fb-www/no-console\n    console.warn('Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.');\n  }\n\n  const store = useStoreRef$5().current;\n  return useMemo$2(() => {\n    // eslint-disable-next-line no-shadow\n    function RecoilBridge({\n      children\n    }) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(RecoilRoot$1, {\n        store_INTERNAL: store\n      }, children);\n    }\n\n    return RecoilBridge;\n  }, [store]);\n}\n\nvar Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;\n\nconst {\n  loadableWithValue: loadableWithValue$1\n} = Recoil_Loadable$1;\n\nconst {\n  initializeNode: initializeNode$3\n} = Recoil_FunctionalCore;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$4,\n  getNode: getNode$5\n} = Recoil_Node;\n\nconst {\n  copyTreeState: copyTreeState$1,\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,\n  invalidateDownstreams: invalidateDownstreams$1,\n  writeLoadableToTreeState: writeLoadableToTreeState$1\n} = Recoil_RecoilValueInterface;\n\n\n\nfunction isAtom(recoilValue) {\n  return getNode$5(recoilValue.key).nodeType === 'atom';\n}\n\nclass TransactionInterfaceImpl {\n  constructor(store, treeState) {\n    _defineProperty(this, \"_store\", void 0);\n\n    _defineProperty(this, \"_treeState\", void 0);\n\n    _defineProperty(this, \"_changes\", void 0);\n\n    _defineProperty(this, \"get\", recoilValue => {\n      if (this._changes.has(recoilValue.key)) {\n        // $FlowIssue[incompatible-return]\n        return this._changes.get(recoilValue.key);\n      }\n\n      if (!isAtom(recoilValue)) {\n        throw Recoil_err('Reading selectors within atomicUpdate is not supported');\n      }\n\n      const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);\n\n      if (loadable.state === 'hasValue') {\n        return loadable.contents;\n      } else if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      } else {\n        throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);\n      }\n    });\n\n    _defineProperty(this, \"set\", (recoilState, valueOrUpdater) => {\n      if (!isAtom(recoilState)) {\n        throw Recoil_err('Setting selectors within atomicUpdate is not supported');\n      }\n\n      if (typeof valueOrUpdater === 'function') {\n        const current = this.get(recoilState);\n\n        this._changes.set(recoilState.key, valueOrUpdater(current)); // flowlint-line unclear-type:off\n\n      } else {\n        // Initialize atom and run effects if not initialized yet\n        initializeNode$3(this._store, recoilState.key, 'set');\n\n        this._changes.set(recoilState.key, valueOrUpdater);\n      }\n    });\n\n    _defineProperty(this, \"reset\", recoilState => {\n      this.set(recoilState, DEFAULT_VALUE$4);\n    });\n\n    this._store = store;\n    this._treeState = treeState;\n    this._changes = new Map();\n  } // Allow destructing\n  // eslint-disable-next-line fb-www/extra-arrow-initializer\n\n\n  newTreeState_INTERNAL() {\n    if (this._changes.size === 0) {\n      return this._treeState;\n    }\n\n    const newState = copyTreeState$1(this._treeState);\n\n    for (const [k, v] of this._changes) {\n      writeLoadableToTreeState$1(newState, k, loadableWithValue$1(v));\n    }\n\n    invalidateDownstreams$1(this._store, newState);\n    return newState;\n  }\n\n}\n\nfunction atomicUpdater(store) {\n  return fn => {\n    store.replaceState(treeState => {\n      const changeset = new TransactionInterfaceImpl(store, treeState);\n      fn(changeset);\n      return changeset.newTreeState_INTERNAL();\n    });\n  };\n}\n\nvar Recoil_AtomicUpdates = {\n  atomicUpdater\n};\n\nvar Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;\n\nvar Recoil_AtomicUpdates$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  atomicUpdater: Recoil_AtomicUpdates_1\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n\nvar invariant_1 = invariant;\n\n// @oss-only\n\n\nvar Recoil_invariant = invariant_1;\n\nconst {\n  atomicUpdater: atomicUpdater$1\n} = Recoil_AtomicUpdates$1;\n\nconst {\n  batchUpdates: batchUpdates$4\n} = Recoil_Batching;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$5\n} = Recoil_Node;\n\nconst {\n  useStoreRef: useStoreRef$6\n} = Recoil_RecoilRoot;\n\nconst {\n  refreshRecoilValue: refreshRecoilValue$1,\n  setRecoilValue: setRecoilValue$3\n} = Recoil_RecoilValueInterface;\n\nconst {\n  cloneSnapshot: cloneSnapshot$2\n} = Recoil_Snapshot$1;\n\nconst {\n  gotoSnapshot: gotoSnapshot$1\n} = Recoil_SnapshotHooks;\n\nconst {\n  useCallback: useCallback$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\n\n\n\n\n\n\n\n\nclass Sentinel {}\n\nconst SENTINEL = new Sentinel();\n\nfunction recoilCallback(store, fn, args, extraInterface) {\n  let ret = SENTINEL;\n  let releaseSnapshot;\n  batchUpdates$4(() => {\n    const errMsg = 'useRecoilCallback() expects a function that returns a function: ' + 'it accepts a function of the type (RecoilInterface) => (Args) => ReturnType ' + 'and returns a callback function (Args) => ReturnType, where RecoilInterface is ' + 'an object {snapshot, set, ...} and Args and ReturnType are the argument and return ' + 'types of the callback you want to create.  Please see the docs ' + 'at recoiljs.org for details.';\n\n    if (typeof fn !== 'function') {\n      throw Recoil_err(errMsg);\n    } // Clone the snapshot lazily to avoid overhead if the callback does not use it.\n    // Note that this means the snapshot may represent later state from when\n    // the callback was called if it first accesses the snapshot asynchronously.\n\n\n    const callbackInterface = Recoil_lazyProxy({ ...(extraInterface !== null && extraInterface !== void 0 ? extraInterface : {}),\n      // flowlint-line unclear-type:off\n      // $FlowFixMe[missing-local-annot]\n      set: (node, newValue) => setRecoilValue$3(store, node, newValue),\n      // $FlowFixMe[missing-local-annot]\n      reset: node => setRecoilValue$3(store, node, DEFAULT_VALUE$5),\n      // $FlowFixMe[missing-local-annot]\n      refresh: node => refreshRecoilValue$1(store, node),\n      gotoSnapshot: snapshot => gotoSnapshot$1(store, snapshot),\n      transact_UNSTABLE: transaction => atomicUpdater$1(store)(transaction)\n    }, {\n      snapshot: () => {\n        const snapshot = cloneSnapshot$2(store);\n        releaseSnapshot = snapshot.retain();\n        return snapshot;\n      }\n    });\n    const callback = fn(callbackInterface);\n\n    if (typeof callback !== 'function') {\n      throw Recoil_err(errMsg);\n    }\n\n    ret = callback(...args);\n  });\n  !!(ret instanceof Sentinel) ?  true ? Recoil_invariant(false, 'batchUpdates should return immediately') : 0 : void 0;\n\n  if (Recoil_isPromise(ret)) {\n    ret = ret.finally(() => {\n      var _releaseSnapshot;\n\n      (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();\n    });\n  } else {\n    var _releaseSnapshot2;\n\n    (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();\n  }\n\n  return ret;\n}\n\nfunction useRecoilCallback(fn, deps) {\n  const storeRef = useStoreRef$6();\n  return useCallback$3( // $FlowIssue[incompatible-call]\n  (...args) => {\n    return recoilCallback(storeRef.current, fn, args);\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilCallback = {\n  recoilCallback,\n  useRecoilCallback\n};\n\nconst {\n  useStoreRef: useStoreRef$7\n} = Recoil_RecoilRoot;\n\nconst {\n  refreshRecoilValue: refreshRecoilValue$2\n} = Recoil_RecoilValueInterface;\n\nconst {\n  useCallback: useCallback$4\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilRefresher(recoilValue) {\n  const storeRef = useStoreRef$7();\n  return useCallback$4(() => {\n    const store = storeRef.current;\n    refreshRecoilValue$2(store, recoilValue);\n  }, [recoilValue, storeRef]);\n}\n\nvar Recoil_useRecoilRefresher = useRecoilRefresher;\n\nconst {\n  atomicUpdater: atomicUpdater$2\n} = Recoil_AtomicUpdates$1;\n\nconst {\n  useStoreRef: useStoreRef$8\n} = Recoil_RecoilRoot;\n\nconst {\n  useMemo: useMemo$3\n} = (react__WEBPACK_IMPORTED_MODULE_0___default());\n\nfunction useRecoilTransaction(fn, deps) {\n  const storeRef = useStoreRef$8();\n  return useMemo$3(() => (...args) => {\n    const atomicUpdate = atomicUpdater$2(storeRef.current);\n    atomicUpdate(transactionInterface => {\n      fn(transactionInterface)(...args);\n    });\n  }, deps != null ? [...deps, storeRef] : undefined // eslint-disable-line fb-www/react-hooks-deps\n  );\n}\n\nvar Recoil_useRecoilTransaction = useRecoilTransaction;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass WrappedValue {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n\n    this.value = value;\n  }\n\n}\n\nvar Recoil_Wrapper = {\n  WrappedValue\n};\n\nvar Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;\n\nvar Recoil_Wrapper$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  WrappedValue: Recoil_Wrapper_1\n});\n\nconst {\n  isFastRefreshEnabled: isFastRefreshEnabled$2\n} = Recoil_ReactMode;\n\n\n\nclass ChangedPathError extends Error {}\n\nclass TreeCache {\n  // $FlowIssue[unclear-type]\n  constructor(options) {\n    var _options$onHit, _options$onSet, _options$mapNodeValue;\n\n    _defineProperty(this, \"_name\", void 0);\n\n    _defineProperty(this, \"_numLeafs\", void 0);\n\n    _defineProperty(this, \"_root\", void 0);\n\n    _defineProperty(this, \"_onHit\", void 0);\n\n    _defineProperty(this, \"_onSet\", void 0);\n\n    _defineProperty(this, \"_mapNodeValue\", void 0);\n\n    this._name = options === null || options === void 0 ? void 0 : options.name;\n    this._numLeafs = 0;\n    this._root = null;\n    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {};\n    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {};\n    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : val => val;\n  }\n\n  size() {\n    return this._numLeafs;\n  } // $FlowIssue[unclear-type]\n\n\n  root() {\n    return this._root;\n  }\n\n  get(getNodeValue, handlers) {\n    var _this$getLeafNode;\n\n    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;\n  }\n\n  getLeafNode(getNodeValue, handlers) {\n    if (this._root == null) {\n      return undefined;\n    } // Iterate down the tree based on the current node values until we hit a leaf\n    // $FlowIssue[unclear-type]\n\n\n    let node = this._root;\n\n    while (node) {\n      handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);\n\n      if (node.type === 'leaf') {\n        this._onHit(node);\n\n        return node;\n      }\n\n      const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));\n\n      node = node.branches.get(nodeValue);\n    }\n\n    return undefined;\n  }\n\n  set(route, value, handlers) {\n    const addLeaf = () => {\n      var _node2, _node3, _this$_root2, _handlers$onNodeVisit2;\n\n      // First, setup the branch nodes for the route:\n      // Iterate down the tree to find or add branch nodes following the route\n      let node;\n      let branchKey;\n\n      for (const [nodeKey, nodeValue] of route) {\n        var _node, _handlers$onNodeVisit, _this$_root;\n\n        // If the previous root was a leaf, while we not have a get(), it means\n        // the selector has inconsistent values or implementation changed.\n        const root = this._root;\n\n        if ((root === null || root === void 0 ? void 0 : root.type) === 'leaf') {\n          throw this.invalidCacheError();\n        } // node now refers to the next node down in the tree\n\n\n        const parent = node; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = parent ? parent.branches.get(branchKey) : root; // $FlowFixMe[prop-missing]\n        // $FlowFixMe[incompatible-type]\n\n        node = (_node = node) !== null && _node !== void 0 ? _node : {\n          type: 'branch',\n          nodeKey,\n          parent,\n          branches: new Map(),\n          branchKey\n        }; // If we found an existing node, confirm it has a consistent value\n\n        if (node.type !== 'branch' || node.nodeKey !== nodeKey) {\n          throw this.invalidCacheError();\n        } // Add the branch node to the tree\n\n\n        parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);\n        handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node); // Prepare for next iteration and install root if it is new.\n\n        branchKey = this._mapNodeValue(nodeValue);\n        this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;\n      } // Second, setup the leaf node:\n      // If there is an existing leaf for this route confirm it is consistent\n\n\n      const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;\n\n      if (oldLeaf != null && (oldLeaf.type !== 'leaf' || oldLeaf.branchKey !== branchKey)) {\n        throw this.invalidCacheError();\n      } // Create a new or replacement leaf.\n\n\n      const leafNode = {\n        type: 'leaf',\n        value,\n        parent: node,\n        branchKey\n      }; // Install the leaf and call handlers\n\n      (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);\n      this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;\n      this._numLeafs++;\n\n      this._onSet(leafNode);\n\n      handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);\n    };\n\n    try {\n      addLeaf();\n    } catch (error) {\n      // If the cache was stale or observed inconsistent values, such as with\n      // Fast Refresh, then clear it and rebuild with the new values.\n      if (error instanceof ChangedPathError) {\n        this.clear();\n        addLeaf();\n      } else {\n        throw error;\n      }\n    }\n  } // Returns true if leaf was actually deleted from the tree\n\n\n  delete(leaf) {\n    const root = this.root();\n\n    if (!root) {\n      return false;\n    }\n\n    if (leaf === root) {\n      this._root = null;\n      this._numLeafs = 0;\n      return true;\n    } // Iterate up from the leaf deleteing it from it's parent's branches.\n\n\n    let node = leaf.parent;\n    let branchKey = leaf.branchKey;\n\n    while (node) {\n      var _node4;\n\n      node.branches.delete(branchKey); // Stop iterating if we hit the root.\n\n      if (node === root) {\n        if (node.branches.size === 0) {\n          this._root = null;\n          this._numLeafs = 0;\n        } else {\n          this._numLeafs--;\n        }\n\n        return true;\n      } // Stop iterating if there are other branches since we don't need to\n      // remove any more nodes.\n\n\n      if (node.branches.size > 0) {\n        break;\n      } // Iterate up to our parent\n\n\n      branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;\n      node = node.parent;\n    } // Confirm that the leaf we are deleting is actually attached to our tree\n\n\n    for (; node !== root; node = node.parent) {\n      if (node == null) {\n        return false;\n      }\n    }\n\n    this._numLeafs--;\n    return true;\n  }\n\n  clear() {\n    this._numLeafs = 0;\n    this._root = null;\n  }\n\n  invalidCacheError() {\n    const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? 'Possible Fast Refresh module reload detected.  ' + 'This may also be caused by an selector returning inconsistent values. ' + 'Resetting cache.' : 'Invalid cache values.  This happens when selectors do not return ' + 'consistent values for the same input dependency values.  That may also ' + 'be caused when using Fast Refresh to change a selector implementation.  ' + 'Resetting cache.';\n    Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ''));\n    throw new ChangedPathError();\n  }\n\n}\n\nvar Recoil_TreeCache = {\n  TreeCache\n};\n\nvar Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;\n\nvar Recoil_TreeCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TreeCache: Recoil_TreeCache_1\n});\n\nclass LRUCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_maxSize\", void 0);\n\n    _defineProperty(this, \"_size\", void 0);\n\n    _defineProperty(this, \"_head\", void 0);\n\n    _defineProperty(this, \"_tail\", void 0);\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._maxSize = options.maxSize;\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  head() {\n    return this._head;\n  }\n\n  tail() {\n    return this._tail;\n  }\n\n  size() {\n    return this._size;\n  }\n\n  maxSize() {\n    return this._maxSize;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    const mappedKey = this._keyMapper(key);\n\n    const node = this._map.get(mappedKey);\n\n    if (!node) {\n      return undefined;\n    }\n\n    this.set(key, node.value);\n    return node.value;\n  }\n\n  set(key, val) {\n    const mappedKey = this._keyMapper(key);\n\n    const existingNode = this._map.get(mappedKey);\n\n    if (existingNode) {\n      this.delete(key);\n    }\n\n    const head = this.head();\n    const node = {\n      key,\n      right: head,\n      left: null,\n      value: val\n    };\n\n    if (head) {\n      head.left = node;\n    } else {\n      this._tail = node;\n    }\n\n    this._map.set(mappedKey, node);\n\n    this._head = node;\n    this._size++;\n\n    this._maybeDeleteLRU();\n  }\n\n  _maybeDeleteLRU() {\n    if (this.size() > this.maxSize()) {\n      this.deleteLru();\n    }\n  }\n\n  deleteLru() {\n    const tail = this.tail();\n\n    if (tail) {\n      this.delete(tail.key);\n    }\n  }\n\n  delete(key) {\n    const mappedKey = this._keyMapper(key);\n\n    if (!this._size || !this._map.has(mappedKey)) {\n      return;\n    }\n\n    const node = Recoil_nullthrows(this._map.get(mappedKey));\n    const right = node.right;\n    const left = node.left;\n\n    if (right) {\n      right.left = node.left;\n    }\n\n    if (left) {\n      left.right = node.right;\n    }\n\n    if (node === this.head()) {\n      this._head = right;\n    }\n\n    if (node === this.tail()) {\n      this._tail = left;\n    }\n\n    this._map.delete(mappedKey);\n\n    this._size--;\n  }\n\n  clear() {\n    this._size = 0;\n    this._head = null;\n    this._tail = null;\n    this._map = new Map();\n  }\n\n}\n\nvar Recoil_LRUCache = {\n  LRUCache\n};\n\nvar Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;\n\nvar Recoil_LRUCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  LRUCache: Recoil_LRUCache_1\n});\n\nconst {\n  LRUCache: LRUCache$1\n} = Recoil_LRUCache$1;\n\nconst {\n  TreeCache: TreeCache$1\n} = Recoil_TreeCache$1;\n\nfunction treeCacheLRU({\n  name,\n  maxSize,\n  mapNodeValue = v => v\n}) {\n  const lruCache = new LRUCache$1({\n    maxSize\n  });\n  const cache = new TreeCache$1({\n    name,\n    mapNodeValue,\n    onHit: node => {\n      lruCache.set(node, true);\n    },\n    onSet: node => {\n      const lruNode = lruCache.tail();\n      lruCache.set(node, true);\n\n      if (lruNode && cache.size() > maxSize) {\n        // $FlowFixMe[incompatible-call]\n        cache.delete(lruNode.key);\n      }\n    }\n  });\n  return cache;\n}\n\nvar Recoil_treeCacheLRU = treeCacheLRU;\n\nconst TIME_WARNING_THRESHOLD_MS = 15;\n\nfunction stringify(x, opt, key) {\n  // A optimization to avoid the more expensive JSON.stringify() for simple strings\n  // This may lose protection for u2028 and u2029, though.\n  if (typeof x === 'string' && !x.includes('\"') && !x.includes('\\\\')) {\n    return `\"${x}\"`;\n  } // Handle primitive types\n\n\n  switch (typeof x) {\n    case 'undefined':\n      return '';\n    // JSON.stringify(undefined) returns undefined, but we always want to return a string\n\n    case 'boolean':\n      return x ? 'true' : 'false';\n\n    case 'number':\n    case 'symbol':\n      // case 'bigint': // BigInt is not supported in www\n      return String(x);\n\n    case 'string':\n      // Add surrounding quotes and escape internal quotes\n      return JSON.stringify(x);\n\n    case 'function':\n      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {\n        throw Recoil_err('Attempt to serialize function in a Recoil cache key');\n      }\n\n      return `__FUNCTION(${x.name})__`;\n  }\n\n  if (x === null) {\n    return 'null';\n  } // Fallback case for unknown types\n\n\n  if (typeof x !== 'object') {\n    var _JSON$stringify;\n\n    return (_JSON$stringify = JSON.stringify(x)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : '';\n  } // Deal with all promises as equivalent for now.\n\n\n  if (Recoil_isPromise(x)) {\n    return '__PROMISE__';\n  } // Arrays handle recursive stringification\n\n\n  if (Array.isArray(x)) {\n    // $FlowFixMe[missing-local-annot]\n    return `[${x.map((v, i) => stringify(v, opt, i.toString()))}]`;\n  } // If an object defines a toJSON() method, then use that to override the\n  // serialization.  This matches the behavior of JSON.stringify().\n  // Pass the key for compatibility.\n  // Immutable.js collections define this method to allow us to serialize them.\n\n\n  if (typeof x.toJSON === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(x.toJSON(key), opt, key);\n  } // For built-in Maps, sort the keys in a stable order instead of the\n  // default insertion order.  Support non-string keys.\n\n\n  if (x instanceof Map) {\n    const obj = {};\n\n    for (const [k, v] of x) {\n      // Stringify will escape any nested quotes\n      obj[typeof k === 'string' ? k : stringify(k, opt)] = v;\n    }\n\n    return stringify(obj, opt, key);\n  } // For built-in Sets, sort the keys in a stable order instead of the\n  // default insertion order.\n\n\n  if (x instanceof Set) {\n    return stringify( // $FlowFixMe[missing-local-annot]\n    Array.from(x).sort((a, b) => stringify(a, opt).localeCompare(stringify(b, opt))), opt, key);\n  } // Anything else that is iterable serialize as an Array.\n\n\n  if (Symbol !== undefined && x[Symbol.iterator] != null && typeof x[Symbol.iterator] === 'function') {\n    // flowlint-next-line unclear-type: off\n    return stringify(Array.from(x), opt, key);\n  } // For all other Objects, sort the keys in a stable order.\n\n\n  return `{${Object.keys(x).filter(k => x[k] !== undefined).sort() // stringify the key to add quotes and escape any nested slashes or quotes.\n  .map(k => `${stringify(k, opt)}:${stringify(x[k], opt, k)}`).join(',')}}`;\n} // Utility similar to JSON.stringify() except:\n// * Serialize built-in Sets as an Array\n// * Serialize built-in Maps as an Object.  Supports non-string keys.\n// * Serialize other iterables as arrays\n// * Sort the keys of Objects and Maps to have a stable order based on string conversion.\n//    This overrides their default insertion order.\n// * Still uses toJSON() of any object to override serialization\n// * Support Symbols (though don't guarantee uniqueness)\n// * We could support BigInt, but Flow doesn't seem to like it.\n// See Recoil_stableStringify-test.js for examples\n\n\nfunction stableStringify(x, opt = {\n  allowFunctions: false\n}) {\n  if (true) {\n    if (typeof window !== 'undefined') {\n      const startTime = window.performance ? window.performance.now() : 0;\n      const str = stringify(x, opt);\n      const endTime = window.performance ? window.performance.now() : 0;\n\n      if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {\n        /* eslint-disable fb-www/no-console */\n        console.groupCollapsed(`Recoil: Spent ${endTime - startTime}ms computing a cache key`);\n        console.warn(x, str);\n        console.groupEnd();\n        /* eslint-enable fb-www/no-console */\n      }\n\n      return str;\n    }\n  }\n\n  return stringify(x, opt);\n}\n\nvar Recoil_stableStringify = stableStringify;\n\nconst {\n  TreeCache: TreeCache$2\n} = Recoil_TreeCache$1;\n\n\n\n\n\n\n\n\n\nconst defaultPolicy = {\n  equality: 'reference',\n  eviction: 'keep-all',\n  maxSize: Infinity\n};\n\nfunction treeCacheFromPolicy({\n  equality = defaultPolicy.equality,\n  eviction = defaultPolicy.eviction,\n  maxSize = defaultPolicy.maxSize\n} = defaultPolicy, name) {\n  const valueMapper = getValueMapper(equality);\n  return getTreeCache(eviction, maxSize, valueMapper, name);\n}\n\nfunction getValueMapper(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getTreeCache(eviction, maxSize, mapNodeValue, name) {\n  switch (eviction) {\n    case 'keep-all':\n      return new TreeCache$2({\n        name,\n        mapNodeValue\n      });\n\n    case 'lru':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: Recoil_nullthrows(maxSize),\n        mapNodeValue\n      });\n\n    case 'most-recent':\n      return Recoil_treeCacheLRU({\n        name,\n        maxSize: 1,\n        mapNodeValue\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_treeCacheFromPolicy = treeCacheFromPolicy;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction isNode(object) {\n  var _ownerDocument, _doc$defaultView;\n\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;\n  const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;\n  return !!(object != null && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));\n}\n\nvar Recoil_isNode = isNode;\n\nconst {\n  isReactNative: isReactNative$1,\n  isWindow: isWindow$1\n} = Recoil_Environment;\n\n\n\n\n\nfunction shouldNotBeFrozen(value) {\n  // Primitives and functions:\n  if (value === null || typeof value !== 'object') {\n    return true;\n  } // React elements:\n\n\n  switch (typeof value.$$typeof) {\n    case 'symbol':\n      return true;\n\n    case 'number':\n      return true;\n  } // Immutable structures:\n\n\n  if (value['@@__IMMUTABLE_ITERABLE__@@'] != null || value['@@__IMMUTABLE_KEYED__@@'] != null || value['@@__IMMUTABLE_INDEXED__@@'] != null || value['@@__IMMUTABLE_ORDERED__@@'] != null || value['@@__IMMUTABLE_RECORD__@@'] != null) {\n    return true;\n  } // DOM nodes:\n\n\n  if (Recoil_isNode(value)) {\n    return true;\n  }\n\n  if (Recoil_isPromise(value)) {\n    return true;\n  }\n\n  if (value instanceof Error) {\n    return true;\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return true;\n  } // Some environments, just as Jest, don't work with the instanceof check\n\n\n  if (!isReactNative$1 && isWindow$1(value)) {\n    return true;\n  }\n\n  return false;\n} // Recursively freeze a value to enforce it is read-only.\n// This may also have minimal performance improvements for enumerating\n// objects (based on browser implementations, of course)\n\n\nfunction deepFreezeValue(value) {\n  if (typeof value !== 'object' || shouldNotBeFrozen(value)) {\n    return;\n  }\n\n  Object.freeze(value); // Make all properties read-only\n\n  for (const key in value) {\n    // $FlowIssue[method-unbinding] added when improving typing for this parameters\n    if (Object.prototype.hasOwnProperty.call(value, key)) {\n      const prop = value[key]; // Prevent infinite recurssion for circular references.\n\n      if (typeof prop === 'object' && prop != null && !Object.isFrozen(prop)) {\n        deepFreezeValue(prop);\n      }\n    }\n  }\n\n  Object.seal(value); // This also makes existing properties non-configurable.\n}\n\nvar Recoil_deepFreezeValue = deepFreezeValue;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * This is a stub for some integration into FB internal stuff\n *\n * \n * @format\n * @oncall recoil\n */\nfunction startPerfBlock(_id) {\n  return () => null;\n}\n\nvar Recoil_PerformanceTimings = {\n  startPerfBlock\n};\n\nconst {\n  isLoadable: isLoadable$1,\n  loadableWithError: loadableWithError$1,\n  loadableWithPromise: loadableWithPromise$1,\n  loadableWithValue: loadableWithValue$2\n} = Recoil_Loadable$1;\n\nconst {\n  WrappedValue: WrappedValue$1\n} = Recoil_Wrapper$1;\n\n\n\nconst {\n  getNodeLoadable: getNodeLoadable$2,\n  peekNodeLoadable: peekNodeLoadable$1,\n  setNodeValue: setNodeValue$3\n} = Recoil_FunctionalCore;\n\nconst {\n  saveDepsToStore: saveDepsToStore$1\n} = Recoil_Graph;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$6,\n  getConfigDeletionHandler: getConfigDeletionHandler$1,\n  getNode: getNode$6,\n  registerNode: registerNode$1\n} = Recoil_Node;\n\nconst {\n  isRecoilValue: isRecoilValue$3\n} = Recoil_RecoilValue$1;\n\nconst {\n  markRecoilValueModified: markRecoilValueModified$1\n} = Recoil_RecoilValueInterface;\n\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$1\n} = Recoil_Retention;\n\nconst {\n  recoilCallback: recoilCallback$1\n} = Recoil_useRecoilCallback;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst {\n  startPerfBlock: startPerfBlock$1\n} = Recoil_PerformanceTimings;\n\n\n\nclass Canceled {}\n\nconst CANCELED = new Canceled();\n/**\n * An ExecutionID is an arbitrary ID that lets us distinguish executions from\n * each other. This is necessary as we need a way of solving this problem:\n * \"given 3 async executions, only update state for the 'latest' execution when\n * it finishes running regardless of when the other 2 finish\". ExecutionIDs\n * provide a convenient way of identifying executions so that we can track and\n * manage them over time.\n */\n\nconst dependencyStack = []; // for detecting circular dependencies.\n\nconst waitingStores = new Map();\n\nconst getNewExecutionID = (() => {\n  let executionID = 0;\n  return () => executionID++;\n})();\n/* eslint-disable no-redeclare */\n\n\nfunction selector(options) {\n  let recoilValue = null;\n  const {\n    key,\n    get,\n    cachePolicy_UNSTABLE: cachePolicy\n  } = options;\n  const set = options.set != null ? options.set : undefined; // flow\n\n  if (true) {\n    if (typeof key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating a selector.');\n    }\n\n    if (typeof get !== 'function') {\n      throw Recoil_err('Selectors must specify a get callback option to get the selector value.');\n    }\n  } // This is every discovered dependency across all executions\n\n\n  const discoveredDependencyNodeKeys = new Set();\n  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {\n    equality: 'reference',\n    eviction: 'keep-all'\n  }, key);\n  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);\n  const executionInfoMap = new Map();\n  let liveStoresCount = 0;\n\n  function selectorIsLive() {\n    return !Recoil_gkx('recoil_memory_managament_2020') || liveStoresCount > 0;\n  }\n\n  function selectorInit(store) {\n    store.getState().knownSelectors.add(key);\n    liveStoresCount++;\n    return () => {\n      liveStoresCount--;\n    };\n  }\n\n  function selectorShouldDeleteConfigOnRelease() {\n    return getConfigDeletionHandler$1(key) !== undefined && !selectorIsLive();\n  }\n\n  function resolveAsync(store, state, executionID, loadable, depValues) {\n    setCache(state, loadable, depValues);\n    notifyStoresOfResolvedAsync(store, executionID);\n  }\n\n  function notifyStoresOfResolvedAsync(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      clearExecutionInfo(store);\n    }\n\n    notifyWaitingStores(executionID, true);\n  }\n  /**\n   * Notify stores to pull the selector again if a new async dep was discovered.\n   * 1) Async selector adds a new dep but doesn't resolve yet.\n   *    Note that deps for an async selector are based on the state when the\n   *    evaluation started, in order to provide a consistent picture of state.\n   * 2) But, new value of dep based on the current state might cause the selector\n   *    to resolve or resolve differently.\n   * 3) Therefore, this notification will pull the selector based on the current\n   *    state for the components\n   */\n\n\n  function notifyStoresOfNewAsyncDep(store, executionID) {\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = Recoil_nullthrows(getExecutionInfo(store));\n      executionInfo.stateVersions.clear();\n      notifyWaitingStores(executionID, false);\n    }\n  }\n\n  function notifyWaitingStores(executionID, clearWaitlist) {\n    const stores = waitingStores.get(executionID);\n\n    if (stores != null) {\n      for (const waitingStore of stores) {\n        markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));\n      }\n\n      if (clearWaitlist) {\n        waitingStores.delete(executionID);\n      }\n    }\n  }\n\n  function markStoreWaitingForResolvedAsync(store, executionID) {\n    let stores = waitingStores.get(executionID);\n\n    if (stores == null) {\n      waitingStores.set(executionID, stores = new Set());\n    }\n\n    stores.add(store);\n  }\n  /**\n   * This function attaches a then() and a catch() to a promise that was\n   * returned from a selector's get() (either explicitly or implicitly by\n   * running a function that uses the \"async\" keyword). If a selector's get()\n   * returns a promise, we have two possibilities:\n   *\n   * 1. The promise will resolve, in which case it will have completely finished\n   *    executing without any remaining pending dependencies. No more retries\n   *    are needed and we can proceed with updating the cache and notifying\n   *    subscribers (if it is the latest execution, otherwise only the cache\n   *    will be updated and subscriptions will not be fired). This is the case\n   *    handled by the attached then() handler.\n   *\n   * 2. The promise will throw because it either has an error or it came across\n   *    an async dependency that has not yet resolved, in which case we will\n   *    call wrapDepdencyPromise(), whose responsibility is to handle dependency\n   *    promises. This case is handled by the attached catch() handler.\n   *\n   * Both branches will eventually resolve to the final result of the selector\n   * (or an error if a real error occurred).\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was thrown--AKA a\n   * dependency promise. Dependency promises should be passed to\n   * wrapPendingDependencyPromise()).\n   */\n\n\n  function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {\n    return promise.then(value => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithValue$2(value);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      return value;\n    }).catch(errorOrPromise => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      if (Recoil_isPromise(errorOrPromise)) {\n        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);\n      }\n\n      const loadable = loadableWithError$1(errorOrPromise);\n      resolveAsync(store, state, executionID, loadable, depValues);\n      throw errorOrPromise;\n    });\n  }\n  /**\n   * This function attaches a then() and a catch() to a promise that was\n   * thrown from a selector's get(). If a selector's get() throws a promise,\n   * we have two possibilities:\n   *\n   * 1. The promise will resolve, meaning one of our selector's dependencies is\n   *    now available and we should \"retry\" our get() by running it again. This\n   *    is the case handled by the attached then() handler.\n   *\n   * 2. The promise will throw because something went wrong with the dependency\n   *    promise (in other words a real error occurred). This case is handled by\n   *    the attached catch() handler. If the dependency promise throws, it is\n   *    _always_ a real error and not another dependency promise (any dependency\n   *    promises would have been handled upstream).\n   *\n   * The then() branch will eventually resolve to the final result of the\n   * selector (or an error if a real error occurs), and the catch() will always\n   * resolve to an error because the dependency promise is a promise that was\n   * wrapped upstream, meaning it will only resolve to its real value or to a\n   * real error.\n   *\n   * The execution will run to completion even if it is stale, and its value\n   * will be cached. But stale executions will not update global state or update\n   * executionInfo as that is the responsibility of the 'latest' execution.\n   *\n   * Note this function should not be passed a promise that was returned from\n   * get(). The intention is that this function is only passed promises that\n   * were thrown due to a pending dependency. Promises returned by get() should\n   * be passed to wrapResultPromise() instead.\n   */\n\n\n  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {\n    return promise.then(resolvedDep => {\n      if (!selectorIsLive()) {\n        // The selector was released since the request began; ignore the response.\n        clearExecutionInfo(store);\n        throw CANCELED;\n      } // Check if we are handling a pending Recoil dependency or if the user\n      // threw their own Promise to \"suspend\" a selector evaluation.  We need\n      // to check that the loadingDepPromise actually matches the promise that\n      // we caught in case the selector happened to catch the promise we threw\n      // for a pending Recoil dependency from `getRecoilValue()` and threw\n      // their own promise instead.\n\n\n      if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {\n        /**\n         * Note for async atoms, this means we are changing the atom's value\n         * in the store for the given version. This should be alright because\n         * the version of state is now stale and a new version will have\n         * already been triggered by the atom being resolved (see this logic\n         * in Recoil_atom.js)\n         */\n        state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));\n      } else {\n        /**\n         * If resolvedDepKey is not defined, the promise was a user-thrown\n         * promise. User-thrown promises are an advanced feature and they\n         * should be avoided in almost all cases. Using `loadable.map()` inside\n         * of selectors for loading loadables and then throwing that mapped\n         * loadable's promise is an example of a user-thrown promise.\n         *\n         * When we hit a user-thrown promise, we have to bail out of an optimization\n         * where we bypass calculating selector cache keys for selectors that\n         * have been previously seen for a given state (these selectors are saved in\n         * state.atomValues) to avoid stale state as we have no way of knowing\n         * what state changes happened (if any) in result to the promise resolving.\n         *\n         * Ideally we would only bail out selectors that are in the chain of\n         * dependencies for this selector, but there's currently no way to get\n         * a full list of a selector's downstream nodes because the state that\n         * is executing may be a discarded tree (so store.getGraph(state.version)\n         * will be empty), and the full dep tree may not be in the selector\n         * caches in the case where the selector's cache was cleared. To solve\n         * for this we would have to keep track of all running selector\n         * executions and their downstream deps. Because this only covers edge\n         * cases, that complexity might not be justifyable.\n         */\n        store.getState().knownSelectors.forEach(nodeKey => {\n          state.atomValues.delete(nodeKey);\n        });\n      }\n      /**\n       * Optimization: Now that the dependency has resolved, let's try hitting\n       * the cache in case the dep resolved to a value we have previously seen.\n       *\n       * TODO:\n       * Note this optimization is not perfect because it only prevents re-executions\n       * _after_ the point where an async dependency is found. Any code leading\n       * up to the async dependency may have run unnecessarily. The ideal case\n       * would be to wait for the async dependency to resolve first, check the\n       * cache, and prevent _any_ execution of the selector if the resulting\n       * value of the dependency leads to a path that is found in the cache.\n       * The ideal case is more difficult to implement as it would require that\n       * we capture and wait for the the async dependency right after checking\n       * the cache. The current approach takes advantage of the fact that running\n       * the selector already has a code path that lets us exit early when\n       * an async dep resolves.\n       */\n\n\n      const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);\n\n      if (cachedLoadable && cachedLoadable.state !== 'loading') {\n        /**\n         * This has to notify stores of a resolved async, even if there is no\n         * current pending execution for the following case:\n         * 1) A component renders with this pending loadable.\n         * 2) The upstream dependency resolves.\n         * 3) While processing some other selector it reads this one, such as\n         *    while traversing its dependencies.  At this point it gets the\n         *    new resolved value synchronously and clears the current\n         *    execution ID.  The component wasn't getting the value itself,\n         *    though, so it still has the pending loadable.\n         * 4) When this code executes the current execution id was cleared\n         *    and it wouldn't notify the component of the new value.\n         *\n         * I think this is only an issue with \"early\" rendering since the\n         * components got their value using the in-progress execution.\n         * We don't have a unit test for this case yet.  I'm not sure it is\n         * necessary with recoil_transition_support mode.\n         */\n        if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {\n          notifyStoresOfResolvedAsync(store, executionID);\n        }\n\n        if (cachedLoadable.state === 'hasValue') {\n          return cachedLoadable.contents;\n        } else {\n          throw cachedLoadable.contents;\n        }\n      }\n      /**\n       * If this execution is stale, let's check to see if there is some in\n       * progress execution with a matching state. If we find a match, then\n       * we can take the value from that in-progress execution. Note this may\n       * sound like an edge case, but may be very common in cases where a\n       * loading dependency resolves from loading to having a value (thus\n       * possibly triggering a re-render), and React re-renders before the\n       * chained .then() functions run, thus starting a new execution as the\n       * dep has changed value. Without this check we will run the selector\n       * twice (once in the new execution and once again in this .then(), so\n       * this check is necessary to keep unnecessary re-executions to a\n       * minimum).\n       *\n       * Also note this code does not check across all executions that may be\n       * running. It only optimizes for the _latest_ execution per store as\n       * we currently do not maintain a list of all currently running executions.\n       * This means in some cases we may run selectors more than strictly\n       * necessary when there are multiple executions running for the same\n       * selector. This may be a valid tradeoff as checking for dep changes\n       * across all in-progress executions may take longer than just\n       * re-running the selector. This will be app-dependent, and maybe in the\n       * future we can make the behavior configurable. An ideal fix may be\n       * to extend the tree cache to support caching loading states.\n       */\n\n\n      if (!isLatestExecution(store, executionID)) {\n        const executionInfo = getInProgressExecutionInfo(store, state);\n\n        if (executionInfo != null) {\n          /**\n           * Returning promise here without wrapping as the wrapper logic was\n           * already done upstream when this promise was generated.\n           */\n          return executionInfo.loadingLoadable.contents;\n        }\n      } // Retry the selector evaluation now that the dependency has resolved\n\n\n      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);\n\n      if (loadable.state !== 'loading') {\n        resolveAsync(store, state, executionID, loadable, depValues);\n      }\n\n      if (loadable.state === 'hasError') {\n        throw loadable.contents;\n      }\n\n      return loadable.contents;\n    }).catch(error => {\n      // The selector was released since the request began; ignore the response.\n      if (error instanceof Canceled) {\n        throw CANCELED;\n      }\n\n      if (!selectorIsLive()) {\n        clearExecutionInfo(store);\n        throw CANCELED;\n      }\n\n      const loadable = loadableWithError$1(error);\n      resolveAsync(store, state, executionID, loadable, existingDeps);\n      throw error;\n    });\n  }\n\n  function updateDeps(store, state, deps, executionID) {\n    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;\n\n    if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {\n      var _store$getState$nextT, _store$getState3, _store$getState3$next;\n\n      saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);\n    }\n\n    for (const nodeKey of deps) {\n      discoveredDependencyNodeKeys.add(nodeKey);\n    }\n  }\n\n  function evaluateSelectorGetter(store, state, executionID) {\n    const endPerfBlock = startPerfBlock$1(key); // TODO T63965866: use execution ID here\n\n    let duringSynchronousExecution = true;\n    let duringAsynchronousExecution = true;\n\n    const finishEvaluation = () => {\n      endPerfBlock();\n      duringAsynchronousExecution = false;\n    };\n\n    let result;\n    let resultIsError = false;\n    let loadable;\n    const loadingDepsState = {\n      loadingDepKey: null,\n      loadingDepPromise: null\n    };\n    /**\n     * Starting a fresh set of deps that we'll be using to update state. We're\n     * starting a new set versus adding it in existing state deps because\n     * the version of state that we update deps for may be a more recent version\n     * than the version the selector was called with. This is because the latest\n     * execution will update the deps of the current/latest version of state\n     * (This is safe to do because the fact that the selector is the latest\n     * execution means the deps we discover below are our best guess at the\n     * deps for the current/latest state in the store)\n     */\n\n    const depValues = new Map();\n\n    function getRecoilValue({\n      key: depKey\n    }) {\n      const depLoadable = getNodeLoadable$2(store, state, depKey);\n      depValues.set(depKey, depLoadable); // We need to update asynchronous dependencies as we go so the selector\n      // knows if it has to restart evaluation if one of them is updated before\n      // the asynchronous selector completely resolves.\n\n      if (!duringSynchronousExecution) {\n        updateDeps(store, state, new Set(depValues.keys()), executionID);\n        notifyStoresOfNewAsyncDep(store, executionID);\n      }\n\n      switch (depLoadable.state) {\n        case 'hasValue':\n          return depLoadable.contents;\n\n        case 'hasError':\n          throw depLoadable.contents;\n\n        case 'loading':\n          loadingDepsState.loadingDepKey = depKey;\n          loadingDepsState.loadingDepPromise = depLoadable.contents;\n          throw depLoadable.contents;\n      }\n\n      throw Recoil_err('Invalid Loadable state');\n    }\n\n    const getCallback = fn => {\n      return (...args) => {\n        if (duringAsynchronousExecution) {\n          throw Recoil_err('Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.');\n        }\n\n        !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n        return recoilCallback$1(store, fn, args, {\n          node: recoilValue\n        } // flowlint-line unclear-type:off\n        );\n      };\n    };\n\n    try {\n      result = get({\n        get: getRecoilValue,\n        getCallback\n      });\n      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;\n\n      if (isLoadable$1(result)) {\n        if (result.state === 'hasError') {\n          resultIsError = true;\n        }\n\n        result = result.contents;\n      }\n\n      if (Recoil_isPromise(result)) {\n        result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        finishEvaluation();\n      }\n\n      result = result instanceof WrappedValue$1 ? result.value : result;\n    } catch (errorOrDepPromise) {\n      result = errorOrDepPromise;\n\n      if (Recoil_isPromise(result)) {\n        result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);\n      } else {\n        resultIsError = true;\n        finishEvaluation();\n      }\n    }\n\n    if (resultIsError) {\n      loadable = loadableWithError$1(result);\n    } else if (Recoil_isPromise(result)) {\n      loadable = loadableWithPromise$1(result);\n    } else {\n      loadable = loadableWithValue$2(result);\n    }\n\n    duringSynchronousExecution = false;\n    updateExecutionInfoDepValues(store, executionID, depValues);\n    updateDeps(store, state, new Set(depValues.keys()), executionID);\n    return [loadable, depValues];\n  }\n\n  function getLoadableFromCacheAndUpdateDeps(store, state) {\n    // First, look up in the state cache\n    // If it's here, then the deps in the store should already be valid.\n    let cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    } // Second, look up in the selector cache and update the deps in the store\n\n\n    const depsAfterCacheLookup = new Set();\n\n    try {\n      cachedLoadable = cache.get(nodeKey => {\n        !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n        return getNodeLoadable$2(store, state, nodeKey).contents;\n      }, {\n        onNodeVisit: node => {\n          if (node.type === 'branch' && node.nodeKey !== key) {\n            depsAfterCacheLookup.add(node.nodeKey);\n          }\n        }\n      });\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector \"${key}\": ${error.message}`);\n    }\n\n    if (cachedLoadable) {\n      var _getExecutionInfo;\n\n      // Cache the results in the state to allow for cheaper lookup than\n      // iterating the tree cache of dependencies.\n      state.atomValues.set(key, cachedLoadable);\n      /**\n       * Ensure store contains correct dependencies if we hit the cache so that\n       * the store deps and cache are in sync for a given state. This is important\n       * because store deps are normally updated when new executions are created,\n       * but cache hits don't trigger new executions but they still _may_ signify\n       * a change in deps in the store if the store deps for this state are empty\n       * or stale.\n       */\n\n      updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);\n    }\n\n    return cachedLoadable;\n  }\n  /**\n   * Given a tree state, this function returns a Loadable of the current state.\n   *\n   * The selector's get() function will only be re-evaluated if _both_ of the\n   * following statements are true:\n   *\n   * 1. The current dep values from the given state produced a cache key that\n   *    was not found in the cache.\n   * 2. There is no currently running async execution OR there is an\n   *    async execution that is running, but after comparing the dep values in\n   *    the given state with the dep values that the execution has discovered so\n   *    far we find that at least one dep value has changed, in which case we\n   *    start a new execution (the previously running execution will continue to\n   *    run to completion, but only the new execution will be deemed the\n   *    'latest' execution, meaning it will be the only execution that will\n   *    update global state when it is finished. Any non-latest executions will\n   *    run to completion and update the selector cache but not global state).\n   */\n\n\n  function getSelectorLoadableAndUpdateDeps(store, state) {\n    // First, see if our current state is cached\n    const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);\n\n    if (cachedVal != null) {\n      clearExecutionInfo(store);\n      return cachedVal;\n    } // Second, check if there is already an ongoing execution based on the current state\n\n\n    const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);\n\n    if (inProgressExecutionInfo != null) {\n      var _inProgressExecutionI;\n\n      if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === 'loading') {\n        markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);\n      } // FIXME: check after the fact to see if we made the right choice by waiting\n\n\n      return inProgressExecutionInfo.loadingLoadable;\n    } // Third, start a new evaluation of the selector\n\n\n    const newExecutionID = getNewExecutionID();\n    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);\n    /**\n     * Conditionally updates the cache with a given loadable.\n     *\n     * We only cache loadables that are not loading because our cache keys are\n     * based on dep values, which are in an unfinished state for loadables that\n     * have a 'loading' state (new deps may be discovered while the selector\n     * runs its async code). We never want to cache partial dependencies b/c it\n     * could lead to errors, such as prematurely returning the result based on a\n     * partial list of deps-- we need the full list of deps to ensure that we\n     * are returning the correct result from cache.\n     */\n\n    if (loadable.state === 'loading') {\n      setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);\n      markStoreWaitingForResolvedAsync(store, newExecutionID);\n    } else {\n      clearExecutionInfo(store);\n      setCache(state, loadable, newDepValues);\n    }\n\n    return loadable;\n  }\n  /**\n   * Searches execution info across all stores to see if there is an in-progress\n   * execution whose dependency values match the values of the requesting store.\n   */\n\n\n  function getInProgressExecutionInfo(store, state) {\n    // Sort the pending executions so that our current store is checked first.\n    const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s]) => s !== store), ([, execInfo]) => execInfo)]);\n\n    function anyDepChanged(execDepValues) {\n      for (const [depKey, execLoadable] of execDepValues) {\n        if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    for (const execInfo of pendingExecutions) {\n      if ( // If this execution was already checked to be valid with this version\n      // of state, then let's use it!\n      execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid\n      !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)) {\n        execInfo.stateVersions.set(state.version, true);\n        return execInfo;\n      } else {\n        execInfo.stateVersions.set(state.version, false);\n      }\n    }\n\n    return undefined;\n  }\n\n  function getExecutionInfo(store) {\n    return executionInfoMap.get(store);\n  }\n  /**\n   * This function will update the selector's execution info when the selector\n   * has either finished running an execution or has started a new execution. If\n   * the given loadable is in a 'loading' state, the intention is that a new\n   * execution has started. Otherwise, the intention is that an execution has\n   * just finished.\n   */\n\n\n  function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {\n    executionInfoMap.set(store, {\n      depValuesDiscoveredSoFarDuringAsyncWork: depValues,\n      executionID: newExecutionID,\n      loadingLoadable: loadable,\n      stateVersions: new Map([[state.version, true]])\n    });\n  }\n\n  function updateExecutionInfoDepValues(store, executionID, depValues) {\n    // We only need to bother updating the deps for the latest execution because\n    // that's all getInProgressExecutionInfo() will be looking for.\n    if (isLatestExecution(store, executionID)) {\n      const executionInfo = getExecutionInfo(store);\n\n      if (executionInfo != null) {\n        executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;\n      }\n    }\n  }\n\n  function clearExecutionInfo(store) {\n    executionInfoMap.delete(store);\n  }\n\n  function isLatestExecution(store, executionID) {\n    var _getExecutionInfo2;\n\n    return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);\n  }\n  /**\n   * FIXME: dep keys should take into account the state of the loadable to\n   * prevent the edge case where a loadable with an error and a loadable with\n   * an error as a value are treated as the same thing incorrectly. For example\n   * these two should be treated differently:\n   *\n   * selector({key: '', get: () => new Error('hi')});\n   * selector({key: '', get () => {throw new Error('hi')}});\n   *\n   * With current implementation they are treated the same\n   */\n\n\n  function depValuesToDepRoute(depValues) {\n    return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);\n  }\n\n  function setCache(state, loadable, depValues) {\n    if (true) {\n      if (loadable.state !== 'loading' && Boolean(options.dangerouslyAllowMutability) === false) {\n        Recoil_deepFreezeValue(loadable.contents);\n      }\n    }\n\n    state.atomValues.set(key, loadable);\n\n    try {\n      cache.set(depValuesToDepRoute(depValues), loadable);\n    } catch (error) {\n      throw Recoil_err(`Problem with setting cache for selector \"${key}\": ${error.message}`);\n    }\n  }\n\n  function detectCircularDependencies(fn) {\n    if (dependencyStack.includes(key)) {\n      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(' \\u2192 ')}`;\n      return loadableWithError$1(Recoil_err(message));\n    }\n\n    dependencyStack.push(key);\n\n    try {\n      return fn();\n    } finally {\n      dependencyStack.pop();\n    }\n  }\n\n  function selectorPeek(store, state) {\n    const cachedLoadable = state.atomValues.get(key);\n\n    if (cachedLoadable != null) {\n      return cachedLoadable;\n    }\n\n    return cache.get(nodeKey => {\n      var _peekNodeLoadable;\n\n      !(typeof nodeKey === 'string') ?  true ? Recoil_invariant(false, 'Cache nodeKey is type string') : 0 : void 0;\n      return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;\n    });\n  }\n\n  function selectorGet(store, state) {\n    return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));\n  }\n\n  function invalidateSelector(state) {\n    state.atomValues.delete(key);\n  }\n\n  function clearSelectorCache(store, treeState) {\n    !(recoilValue != null) ?  true ? Recoil_invariant(false, 'Recoil Value can never be null') : 0 : void 0;\n\n    for (const nodeKey of discoveredDependencyNodeKeys) {\n      var _node$clearCache;\n\n      const node = getNode$6(nodeKey);\n      (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);\n    }\n\n    discoveredDependencyNodeKeys.clear();\n    invalidateSelector(treeState);\n    cache.clear();\n    markRecoilValueModified$1(store, recoilValue);\n  }\n\n  if (set != null) {\n    /**\n     * ES5 strict mode prohibits defining non-top-level function declarations,\n     * so don't use function declaration syntax here\n     */\n    const selectorSet = (store, state, newValue) => {\n      let syncSelectorSetFinished = false;\n      const writes = new Map();\n\n      function getRecoilValue({\n        key: depKey\n      }) {\n        if (syncSelectorSetFinished) {\n          throw Recoil_err('Recoil: Async selector sets are not currently supported.');\n        }\n\n        const loadable = getNodeLoadable$2(store, state, depKey);\n\n        if (loadable.state === 'hasValue') {\n          return loadable.contents;\n        } else if (loadable.state === 'loading') {\n          const msg = `Getting value of asynchronous atom or selector \"${depKey}\" in a pending state while setting selector \"${key}\" is not yet supported.`;\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        } else {\n          throw loadable.contents;\n        }\n      }\n\n      function setRecoilState(recoilState, valueOrUpdater // $FlowFixMe[missing-local-annot]\n      ) {\n        if (syncSelectorSetFinished) {\n          const msg = 'Recoil: Async selector sets are not currently supported.';\n          Recoil_recoverableViolation(msg);\n          throw Recoil_err(msg);\n        }\n\n        const setValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict type S from being a function itself without losing support for opaque types\n        // flowlint-next-line unclear-type:off\n        valueOrUpdater(getRecoilValue(recoilState)) : valueOrUpdater;\n        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);\n        upstreamWrites.forEach((v, k) => writes.set(k, v));\n      }\n\n      function resetRecoilState(recoilState) {\n        setRecoilState(recoilState, DEFAULT_VALUE$6);\n      }\n\n      const ret = set({\n        set: setRecoilState,\n        get: getRecoilValue,\n        reset: resetRecoilState\n      }, newValue); // set should be a void method, but if the user makes it `async`, then it\n      // will return a Promise, which we don't currently support.\n\n      if (ret !== undefined) {\n        throw Recoil_isPromise(ret) ? Recoil_err('Recoil: Async selector sets are not currently supported.') : Recoil_err('Recoil: selector set should be a void function.');\n      }\n\n      syncSelectorSetFinished = true;\n      return writes;\n    };\n\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      set: selectorSet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  } else {\n    return recoilValue = registerNode$1({\n      key,\n      nodeType: 'selector',\n      peek: selectorPeek,\n      get: selectorGet,\n      init: selectorInit,\n      invalidate: invalidateSelector,\n      clearCache: clearSelectorCache,\n      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,\n      dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n      shouldRestoreFromSnapshots: false,\n      retainedBy\n    });\n  }\n}\n/* eslint-enable no-redeclare */\n// $FlowIssue[incompatible-use]\n// $FlowFixMe[missing-local-annot]\n\n\nselector.value = value => new WrappedValue$1(value);\n\nvar Recoil_selector = selector;\n\n// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n// @fb-only: const {scopedAtom} = require('Recoil_ScopedAtom');\nconst {\n  isLoadable: isLoadable$2,\n  loadableWithError: loadableWithError$2,\n  loadableWithPromise: loadableWithPromise$2,\n  loadableWithValue: loadableWithValue$3\n} = Recoil_Loadable$1;\n\nconst {\n  WrappedValue: WrappedValue$2\n} = Recoil_Wrapper$1;\n\nconst {\n  peekNodeInfo: peekNodeInfo$3\n} = Recoil_FunctionalCore;\n\nconst {\n  DEFAULT_VALUE: DEFAULT_VALUE$7,\n  DefaultValue: DefaultValue$2,\n  getConfigDeletionHandler: getConfigDeletionHandler$2,\n  registerNode: registerNode$2,\n  setConfigDeletionHandler: setConfigDeletionHandler$1\n} = Recoil_Node;\n\nconst {\n  isRecoilValue: isRecoilValue$4\n} = Recoil_RecoilValue$1;\n\nconst {\n  getRecoilValueAsLoadable: getRecoilValueAsLoadable$4,\n  markRecoilValueModified: markRecoilValueModified$2,\n  setRecoilValue: setRecoilValue$4,\n  setRecoilValueLoadable: setRecoilValueLoadable$2\n} = Recoil_RecoilValueInterface;\n\nconst {\n  retainedByOptionWithDefault: retainedByOptionWithDefault$2\n} = Recoil_Retention;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst unwrap = x => x instanceof WrappedValue$2 ? x.value : x;\n\nfunction baseAtom(options) {\n  const {\n    key,\n    persistence_UNSTABLE: persistence\n  } = options;\n  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);\n  let liveStoresCount = 0;\n\n  function unwrapPromise(promise) {\n    return loadableWithPromise$2(promise.then(value => {\n      defaultLoadable = loadableWithValue$3(value);\n      return value;\n    }).catch(error => {\n      defaultLoadable = loadableWithError$2(error);\n      throw error;\n    }));\n  }\n\n  let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === 'loading' ? unwrapPromise(options.default.contents) : options.default : // $FlowFixMe[incompatible-call]\n  loadableWithValue$3(unwrap(options.default));\n  maybeFreezeValueOrPromise(defaultLoadable.contents);\n  let cachedAnswerForUnvalidatedValue = undefined; // Cleanup handlers for this atom\n  // Rely on stable reference equality of the store to use it as a key per <RecoilRoot>\n\n  const cleanupEffectsByStore = new Map();\n\n  function maybeFreezeValueOrPromise(valueOrPromise) {\n    if (true) {\n      if (options.dangerouslyAllowMutability !== true) {\n        if (Recoil_isPromise(valueOrPromise)) {\n          return valueOrPromise.then(value => {\n            Recoil_deepFreezeValue(value);\n            return value;\n          });\n        } else {\n          Recoil_deepFreezeValue(valueOrPromise);\n          return valueOrPromise;\n        }\n      }\n    }\n\n    return valueOrPromise;\n  }\n\n  function wrapPendingPromise(store, promise) {\n    const wrappedPromise = promise.then(value => {\n      var _store$getState$nextT, _state$atomValues$get;\n\n      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;\n\n      if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {\n        setRecoilValue$4(store, node, value);\n      }\n\n      return value;\n    }).catch(error => {\n      var _store$getState$nextT2, _state$atomValues$get2;\n\n      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;\n\n      if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {\n        setRecoilValueLoadable$2(store, node, loadableWithError$2(error));\n      }\n\n      throw error;\n    });\n    return wrappedPromise;\n  }\n\n  function initAtom(store, initState, trigger) {\n    var _options$effects;\n\n    liveStoresCount++;\n\n    const cleanupAtom = () => {\n      var _cleanupEffectsByStor;\n\n      liveStoresCount--;\n      (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach(cleanup => cleanup());\n      cleanupEffectsByStore.delete(store);\n    };\n\n    store.getState().knownAtoms.add(key); // Setup async defaults to notify subscribers when they resolve\n\n    if (defaultLoadable.state === 'loading') {\n      const notifyDefaultSubscribers = () => {\n        var _store$getState$nextT3;\n\n        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;\n\n        if (!state.atomValues.has(key)) {\n          markRecoilValueModified$2(store, node);\n        }\n      };\n\n      defaultLoadable.contents.finally(notifyDefaultSubscribers);\n    } ///////////////////\n    // Run Atom Effects\n    ///////////////////\n\n\n    const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;\n\n    if (effects != null) {\n      // This state is scoped by Store, since this is in the initAtom() closure\n      let initValue = DEFAULT_VALUE$7;\n      let isDuringInit = true;\n      let isInitError = false;\n      let pendingSetSelf = null;\n\n      function getLoadable(recoilValue) {\n        // Normally we can just get the current value of another atom.\n        // But for our own value we need to check if there is a pending\n        // initialized value or get the fallback default value.\n        if (isDuringInit && recoilValue.key === key) {\n          // Cast T to S\n          const retValue = initValue; // flowlint-line unclear-type:off\n\n          return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) // flowlint-line unclear-type:off\n          : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then(v => v instanceof DefaultValue$2 ? // Cast T to S\n          defaultLoadable.toPromise() // flowlint-line unclear-type:off\n          : v)) : // $FlowFixMe[incompatible-call]\n          loadableWithValue$3(retValue);\n        }\n\n        return getRecoilValueAsLoadable$4(store, recoilValue);\n      }\n\n      function getPromise(recoilValue) {\n        return getLoadable(recoilValue).toPromise();\n      }\n\n      function getInfo_UNSTABLE(recoilValue) {\n        var _store$getState$nextT4;\n\n        const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);\n        return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? { ...info,\n          isSet: true,\n          loadable: getLoadable(recoilValue)\n        } : info;\n      }\n\n      const setSelf = effect => valueOrUpdater => {\n        if (isDuringInit) {\n          const currentLoadable = getLoadable(node);\n          const currentValue = currentLoadable.state === 'hasValue' ? currentLoadable.contents : DEFAULT_VALUE$7;\n          initValue = typeof valueOrUpdater === 'function' ? // cast to any because we can't restrict T from being a function without losing support for opaque types\n          valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n          : valueOrUpdater;\n\n          if (Recoil_isPromise(initValue)) {\n            initValue = initValue.then(value => {\n              // Avoid calling onSet() when setSelf() initializes with a Promise\n              pendingSetSelf = {\n                effect,\n                value\n              };\n              return value;\n            });\n          }\n        } else {\n          if (Recoil_isPromise(valueOrUpdater)) {\n            throw Recoil_err('Setting atoms to async values is not implemented.');\n          }\n\n          if (typeof valueOrUpdater !== 'function') {\n            pendingSetSelf = {\n              effect,\n              value: unwrap(valueOrUpdater)\n            };\n          }\n\n          setRecoilValue$4(store, node, typeof valueOrUpdater === 'function' ? currentValue => {\n            const newValue = unwrap( // cast to any because we can't restrict T from being a function without losing support for opaque types\n            valueOrUpdater(currentValue) // flowlint-line unclear-type:off\n            ); // $FlowFixMe[incompatible-type]\n\n            pendingSetSelf = {\n              effect,\n              value: newValue\n            };\n            return newValue;\n          } : unwrap(valueOrUpdater));\n        }\n      };\n\n      const resetSelf = effect => () => setSelf(effect)(DEFAULT_VALUE$7);\n\n      const onSet = effect => handler => {\n        var _cleanupEffectsByStor2;\n\n        const {\n          release\n        } = store.subscribeToTransactions(currentStore => {\n          var _currentTree$atomValu;\n\n          // eslint-disable-next-line prefer-const\n          let {\n            currentTree,\n            previousTree\n          } = currentStore.getState();\n\n          if (!previousTree) {\n            Recoil_recoverableViolation('Transaction subscribers notified without a next tree being present -- this is a bug in Recoil');\n            previousTree = currentTree; // attempt to trundle on\n          }\n\n          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;\n\n          if (newLoadable.state === 'hasValue') {\n            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;\n\n            const newValue = newLoadable.contents;\n            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;\n            const oldValue = oldLoadable.state === 'hasValue' ? oldLoadable.contents : DEFAULT_VALUE$7; // TODO This isn't actually valid, use as a placeholder for now.\n            // Ignore atom value changes that were set via setSelf() in the same effect.\n            // We will still properly call the handler if there was a subsequent\n            // set from something other than an atom effect which was batched\n            // with the `setSelf()` call.  However, we may incorrectly ignore\n            // the handler if the subsequent batched call happens to set the\n            // atom to the exact same value as the `setSelf()`.   But, in that\n            // case, it was kind of a noop, so the semantics are debatable..\n\n            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {\n              handler(newValue, oldValue, !currentTree.atomValues.has(key));\n            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {\n              pendingSetSelf = null;\n            }\n          }\n        }, key);\n        cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : []), release]);\n      };\n\n      for (const effect of effects) {\n        try {\n          const cleanup = effect({\n            node,\n            storeID: store.storeID,\n            parentStoreID_UNSTABLE: store.parentStoreID,\n            trigger,\n            setSelf: setSelf(effect),\n            resetSelf: resetSelf(effect),\n            onSet: onSet(effect),\n            getPromise,\n            getLoadable,\n            getInfo_UNSTABLE\n          });\n\n          if (cleanup != null) {\n            var _cleanupEffectsByStor3;\n\n            cleanupEffectsByStore.set(store, [...((_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : []), cleanup]);\n          }\n        } catch (error) {\n          initValue = error;\n          isInitError = true;\n        }\n      }\n\n      isDuringInit = false; // Mutate initial state in place since we know there are no other subscribers\n      // since we are the ones initializing on first use.\n\n      if (!(initValue instanceof DefaultValue$2)) {\n        var _store$getState$nextT5;\n\n        const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));\n        maybeFreezeValueOrPromise(initLoadable.contents);\n        initState.atomValues.set(key, initLoadable); // If there is a pending transaction, then also mutate the next state tree.\n        // This could happen if the atom was first initialized in an action that\n        // also updated some other atom's state.\n\n        (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);\n      }\n    }\n\n    return cleanupAtom;\n  }\n\n  function peekAtom(_store, state) {\n    var _ref, _state$atomValues$get3;\n\n    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;\n  }\n\n  function getAtom(_store, state) {\n    if (state.atomValues.has(key)) {\n      // Atom value is stored in state:\n      return Recoil_nullthrows(state.atomValues.get(key));\n    } else if (state.nonvalidatedAtoms.has(key)) {\n      // Atom value is stored but needs validation before use.\n      // We might have already validated it and have a cached validated value:\n      if (cachedAnswerForUnvalidatedValue != null) {\n        return cachedAnswerForUnvalidatedValue;\n      }\n\n      if (persistence == null) {\n        Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`);\n        return defaultLoadable;\n      }\n\n      const nonvalidatedValue = state.nonvalidatedAtoms.get(key);\n      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);\n      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);\n      cachedAnswerForUnvalidatedValue = validatedValueLoadable;\n      return cachedAnswerForUnvalidatedValue;\n    } else {\n      return defaultLoadable;\n    }\n  }\n\n  function invalidateAtom() {\n    cachedAnswerForUnvalidatedValue = undefined;\n  }\n\n  function setAtom(_store, state, newValue) {\n    // Bail out if we're being set to the existing value, or if we're being\n    // reset but have no stored value (validated or unvalidated) to reset from:\n    if (state.atomValues.has(key)) {\n      const existing = Recoil_nullthrows(state.atomValues.get(key));\n\n      if (existing.state === 'hasValue' && newValue === existing.contents) {\n        return new Map();\n      }\n    } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {\n      return new Map();\n    }\n\n    maybeFreezeValueOrPromise(newValue);\n    cachedAnswerForUnvalidatedValue = undefined; // can be released now if it was previously in use\n\n    return new Map().set(key, loadableWithValue$3(newValue));\n  }\n\n  function shouldDeleteConfigOnReleaseAtom() {\n    return getConfigDeletionHandler$2(key) !== undefined && liveStoresCount <= 0;\n  }\n\n  const node = registerNode$2({\n    key,\n    nodeType: 'atom',\n    peek: peekAtom,\n    get: getAtom,\n    set: setAtom,\n    init: initAtom,\n    invalidate: invalidateAtom,\n    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n    persistence_UNSTABLE: options.persistence_UNSTABLE ? {\n      type: options.persistence_UNSTABLE.type,\n      backButton: options.persistence_UNSTABLE.backButton\n    } : undefined,\n    shouldRestoreFromSnapshots: true,\n    retainedBy\n  });\n  return node;\n} // prettier-ignore\n\n\nfunction atom(options) {\n  if (true) {\n    if (typeof options.key !== 'string') {\n      throw Recoil_err('A key option with a unique string value must be provided when creating an atom.');\n    }\n  }\n\n  const { // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    ...restOptions\n  } = options;\n  const optionsDefault = 'default' in options ? // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n  options.default : new Promise(() => {});\n\n  if (isRecoilValue$4(optionsDefault) // Continue to use atomWithFallback for promise defaults for scoped atoms\n  // for now, since scoped atoms don't support async defaults\n  // @fb-only: || (isPromise(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  // @fb-only: || (isLoadable(optionsDefault) && scopeRules_APPEND_ONLY_READ_THE_DOCS)\n  ) {\n    return atomWithFallback({ ...restOptions,\n      default: optionsDefault // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n\n    }); // @fb-only: } else if (scopeRules_APPEND_ONLY_READ_THE_DOCS\n    // @fb-only: && !isPromise(optionsDefault)\n    // @fb-only: && !isLoadable(optionsDefault)\n    // @fb-only: ) {\n    // @fb-only: return scopedAtom<T>({\n    // @fb-only: ...restOptions,\n    // @fb-only: default: unwrap<T>(optionsDefault),\n    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,\n    // @fb-only: });\n  } else {\n    return baseAtom({ ...restOptions,\n      default: optionsDefault\n    });\n  }\n}\n\nfunction atomWithFallback(options) {\n  const base = atom({ ...options,\n    default: DEFAULT_VALUE$7,\n    persistence_UNSTABLE: options.persistence_UNSTABLE === undefined ? undefined : { ...options.persistence_UNSTABLE,\n      validator: storedValue => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)\n    },\n    // TODO Hack for now.\n    effects: options.effects,\n    // flowlint-line unclear-type: off\n    effects_UNSTABLE: options.effects_UNSTABLE // flowlint-line unclear-type: off\n\n  }); // $FlowFixMe[incompatible-call]\n\n  const sel = Recoil_selector({\n    key: `${options.key}__withFallback`,\n    get: ({\n      get\n    }) => {\n      const baseValue = get(base);\n      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;\n    },\n    // $FlowFixMe[incompatible-call]\n    set: ({\n      set\n    }, newValue) => set(base, newValue),\n    // This selector does not need to cache as it is a wrapper selector\n    // and the selector within the wrapper selector will have a cache\n    // option by default\n    cachePolicy_UNSTABLE: {\n      eviction: 'most-recent'\n    },\n    dangerouslyAllowMutability: options.dangerouslyAllowMutability\n  });\n  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));\n  return sel;\n} // $FlowFixMe[missing-local-annot]\n\n\natom.value = value => new WrappedValue$2(value);\n\nvar Recoil_atom = atom;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @oncall recoil\n */\n\nclass MapCache {\n  constructor(options) {\n    var _options$mapKey;\n\n    _defineProperty(this, \"_map\", void 0);\n\n    _defineProperty(this, \"_keyMapper\", void 0);\n\n    this._map = new Map();\n    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : v => v;\n  }\n\n  size() {\n    return this._map.size;\n  }\n\n  has(key) {\n    return this._map.has(this._keyMapper(key));\n  }\n\n  get(key) {\n    return this._map.get(this._keyMapper(key));\n  }\n\n  set(key, val) {\n    this._map.set(this._keyMapper(key), val);\n  }\n\n  delete(key) {\n    this._map.delete(this._keyMapper(key));\n  }\n\n  clear() {\n    this._map.clear();\n  }\n\n}\n\nvar Recoil_MapCache = {\n  MapCache\n};\n\nvar Recoil_MapCache_1 = Recoil_MapCache.MapCache;\n\nvar Recoil_MapCache$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MapCache: Recoil_MapCache_1\n});\n\nconst {\n  LRUCache: LRUCache$2\n} = Recoil_LRUCache$1;\n\nconst {\n  MapCache: MapCache$1\n} = Recoil_MapCache$1;\n\n\n\n\n\n\n\nconst defaultPolicy$1 = {\n  equality: 'reference',\n  eviction: 'none',\n  maxSize: Infinity\n};\n\nfunction cacheFromPolicy({\n  equality = defaultPolicy$1.equality,\n  eviction = defaultPolicy$1.eviction,\n  maxSize = defaultPolicy$1.maxSize\n} = defaultPolicy$1) {\n  const valueMapper = getValueMapper$1(equality);\n  const cache = getCache(eviction, maxSize, valueMapper);\n  return cache;\n}\n\nfunction getValueMapper$1(equality) {\n  switch (equality) {\n    case 'reference':\n      return val => val;\n\n    case 'value':\n      return val => Recoil_stableStringify(val);\n  }\n\n  throw Recoil_err(`Unrecognized equality policy ${equality}`);\n}\n\nfunction getCache(eviction, maxSize, mapKey) {\n  switch (eviction) {\n    case 'keep-all':\n      return new MapCache$1({\n        mapKey\n      });\n\n    case 'lru':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: Recoil_nullthrows(maxSize)\n      });\n\n    case 'most-recent':\n      return new LRUCache$2({\n        mapKey,\n        maxSize: 1\n      });\n  }\n\n  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);\n}\n\nvar Recoil_cacheFromPolicy = cacheFromPolicy;\n\n// @fb-only: import type {ScopeRules} from 'Recoil_ScopedAtom';\n\n\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$2\n} = Recoil_Node;\n\n\n\n\n\n// Process scopeRules to handle any entries which are functions taking parameters\n// prettier-ignore\n// @fb-only: function mapScopeRules<P>(\n// @fb-only: scopeRules?: ParameterizedScopeRules<P>,\n// @fb-only: param: P,\n// @fb-only: ): ScopeRules | void {\n// @fb-only: return scopeRules?.map(rule =>\n// @fb-only: Array.isArray(rule)\n// @fb-only: ? rule.map(entry => (typeof entry === 'function' ? entry(param) : entry))\n// @fb-only: : rule,\n// @fb-only: );\n// @fb-only: }\n\n/*\nA function which returns an atom based on the input parameter.\n\nEach unique parameter returns a unique atom. E.g.,\n\n  const f = atomFamily(...);\n  f({a: 1}) => an atom\n  f({a: 2}) => a different atom\n\nThis allows components to persist local, private state using atoms.  Each\ninstance of the component may have a different key, which it uses as the\nparameter for a family of atoms; in this way, each component will have\nits own atom not shared by other instances.  These state keys may be composed\ninto children's state keys as well.\n*/\nfunction atomFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const atomCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  }); // Simple atomFamily implementation to cache individual atoms based\n  // on the parameter value equality.\n\n  return params => {\n    var _stableStringify, _options$effects;\n\n    const cachedAtom = atomCache.get(params);\n\n    if (cachedAtom != null) {\n      return cachedAtom;\n    }\n\n    const {\n      cachePolicyForParams_UNSTABLE,\n      ...atomOptions\n    } = options;\n    const optionsDefault = 'default' in options ? // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined\n    options.default : new Promise(() => {});\n    const newAtom = Recoil_atom({ ...atomOptions,\n      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}`,\n      default: typeof optionsDefault === 'function' ? // The default was parameterized\n      // Flow doesn't know that T isn't a function, so we need to case to any\n      // $FlowIssue[incompatible-use]\n      optionsDefault(params) : // Default may be a static value, promise, or RecoilValue\n      optionsDefault,\n      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,\n      effects: typeof options.effects === 'function' ? options.effects(params) : typeof options.effects_UNSTABLE === 'function' ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE // prettier-ignore\n      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS: mapScopeRules(\n      // @fb-only: options.scopeRules_APPEND_ONLY_READ_THE_DOCS,\n      // @fb-only: params,\n      // @fb-only: ),\n\n    });\n    atomCache.set(params, newAtom);\n    setConfigDeletionHandler$2(newAtom.key, () => {\n      atomCache.delete(params);\n    });\n    return newAtom;\n  };\n}\n\nvar Recoil_atomFamily = atomFamily;\n\nconst {\n  setConfigDeletionHandler: setConfigDeletionHandler$3\n} = Recoil_Node;\n\n\n\n\n\n // Keep in mind the parameter needs to be serializable as a cahche key\n// using Recoil_stableStringify\n\n\n// Add a unique index to each selector in case the cache implementation allows\n// duplicate keys based on equivalent stringified parameters\nlet nextIndex = 0;\n/* eslint-disable no-redeclare */\n\n// Return a function that returns members of a family of selectors of the same type\n// E.g.,\n//\n// const s = selectorFamily(...);\n// s({a: 1}) => a selector\n// s({a: 2}) => a different selector\n//\n// By default, the selectors are distinguished by distinct values of the\n// parameter based on value equality, not reference equality.  This allows using\n// object literals or other equivalent objects at callsites to not create\n// duplicate cache entries.  This behavior may be overridden with the\n// cacheImplementationForParams option.\nfunction selectorFamily(options) {\n  var _options$cachePolicyF, _options$cachePolicyF2;\n\n  const selectorCache = Recoil_cacheFromPolicy({\n    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : 'value',\n    eviction: 'keep-all'\n  });\n  return params => {\n    var _stableStringify;\n\n    // Throw an error with selector key so that it is clear which\n    // selector is causing an error\n    let cachedSelector;\n\n    try {\n      cachedSelector = selectorCache.get(params);\n    } catch (error) {\n      throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);\n    }\n\n    if (cachedSelector != null) {\n      return cachedSelector;\n    }\n\n    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {\n      // It is possible to use functions in parameters if the user uses\n      // a cache with reference equality thanks to the incrementing index.\n      allowFunctions: true\n    })) !== null && _stableStringify !== void 0 ? _stableStringify : 'void'}/${nextIndex++}`; // Append index in case values serialize to the same key string\n\n    const myGet = callbacks => options.get(params)(callbacks);\n\n    const myCachePolicy = options.cachePolicy_UNSTABLE;\n    const retainedBy = typeof options.retainedBy_UNSTABLE === 'function' ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;\n    let newSelector;\n\n    if (options.set != null) {\n      const set = options.set;\n\n      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);\n\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        set: mySet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    } else {\n      newSelector = Recoil_selector({\n        key: myKey,\n        get: myGet,\n        cachePolicy_UNSTABLE: myCachePolicy,\n        dangerouslyAllowMutability: options.dangerouslyAllowMutability,\n        retainedBy_UNSTABLE: retainedBy\n      });\n    }\n\n    selectorCache.set(params, newSelector);\n    setConfigDeletionHandler$3(newSelector.key, () => {\n      selectorCache.delete(params);\n    });\n    return newSelector;\n  };\n}\n/* eslint-enable no-redeclare */\n\n\nvar Recoil_selectorFamily = selectorFamily;\n\n// flowlint-next-line unclear-type:off\n\n\nconst constantSelector = Recoil_selectorFamily({\n  key: '__constant',\n  get: constant => () => constant,\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always produces the\n// same constant value.  It may be called multiple times with the\n// same value, based on reference equality, and will provide the\n// same selector.\n\nfunction constSelector(constant) {\n  return constantSelector(constant);\n}\n\nvar Recoil_constSelector = constSelector;\n\n// flowlint-next-line unclear-type:off\n\n\nconst throwingSelector = Recoil_selectorFamily({\n  key: '__error',\n  get: message => () => {\n    throw Recoil_err(message);\n  },\n  // TODO Why?\n  cachePolicyForParams_UNSTABLE: {\n    equality: 'reference'\n  }\n}); // Function that returns a selector which always throws an error\n// with the provided message.\n\nfunction errorSelector(message) {\n  return throwingSelector(message);\n}\n\nvar Recoil_errorSelector = errorSelector;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * Wraps another recoil value and prevents writing to it.\n *\n * \n * @format\n * @oncall recoil\n */\n\nfunction readOnlySelector(atom) {\n  // flowlint-next-line unclear-type: off\n  return atom;\n}\n\nvar Recoil_readOnlySelector = readOnlySelector;\n\nconst {\n  loadableWithError: loadableWithError$3,\n  loadableWithPromise: loadableWithPromise$3,\n  loadableWithValue: loadableWithValue$4\n} = Recoil_Loadable$1;\n\n\n\n\n\n /////////////////\n//  TRUTH TABLE\n/////////////////\n// Dependencies        waitForNone         waitForAny        waitForAll       waitForAllSettled\n//  [loading, loading]  [Promise, Promise]  Promise           Promise         Promise\n//  [value, loading]    [value, Promise]    [value, Promise]  Promise         Promise\n//  [value, value]      [value, value]      [value, value]    [value, value]  [value, value]\n//\n//  [error, loading]    [Error, Promise]    [Error, Promise]  Error           Promise\n//  [error, error]      [Error, Error]      [Error, Error]    Error           [error, error]\n//  [value, error]      [value, Error]      [value, Error]    Error           [value, error]\n// Issue parallel requests for all dependencies and return the current\n// status if they have results, have some error, or are still pending.\n\n\nfunction concurrentRequests(getRecoilValue, deps) {\n  const results = Array(deps.length).fill(undefined);\n  const exceptions = Array(deps.length).fill(undefined);\n\n  for (const [i, dep] of deps.entries()) {\n    try {\n      results[i] = getRecoilValue(dep);\n    } catch (e) {\n      // exceptions can either be Promises of pending results or real errors\n      exceptions[i] = e;\n    }\n  }\n\n  return [results, exceptions];\n}\n\nfunction isError(exp) {\n  return exp != null && !Recoil_isPromise(exp);\n}\n\nfunction unwrapDependencies(dependencies) {\n  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map(key => dependencies[key]);\n}\n\nfunction wrapResults(dependencies,\n/* $FlowFixMe[missing-local-annot] The type annotation(s) required by Flow's\n * LTI update could not be added via codemod */\nresults) {\n  return Array.isArray(dependencies) ? results : // Object.getOwnPropertyNames() has consistent key ordering with ES6\n  Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({ ...out,\n    [key]: results[idx]\n  }), {});\n}\n\nfunction wrapLoadables(dependencies, results, exceptions) {\n  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n  return wrapResults(dependencies, output);\n}\n\nfunction combineAsyncResultsWithSyncResults(syncResults, asyncResults) {\n  return asyncResults.map((result, idx) =>\n  /**\n   * it's important we use === undefined as opposed to == null, because the\n   * resolved value of the async promise could be `null`, in which case we\n   * don't want to use syncResults[idx], which would be undefined. If async\n   * promise resolves to `undefined`, that's ok because `syncResults[idx]`\n   * will also be `undefined`. That's a little hacky, but it works.\n   */\n  result === undefined ? syncResults[idx] : result);\n} // Selector that requests all dependencies in parallel and immediately returns\n// current results without waiting.\n\n\nconst waitForNone = Recoil_selectorFamily({\n  key: '__waitForNone',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // Always return the current status of the results; never block.\n\n    return wrapLoadables(dependencies, results, exceptions);\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for at least\n// one to be available before returning results.  It will only error if all\n// dependencies have errors.\n\nconst waitForAny = Recoil_selectorFamily({\n  key: '__waitForAny',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If any results are available, value or error, return the current status\n\n    if (exceptions.some(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Otherwise, return a promise that will resolve when the next result is\n    // available, whichever one happens to be next.  But, if all pending\n    // dependencies end up with errors, then reject the promise.\n\n\n    return new Promise(resolve => {\n      for (const [i, exp] of exceptions.entries()) {\n        if (Recoil_isPromise(exp)) {\n          exp.then(result => {\n            results[i] = result;\n            exceptions[i] = undefined;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          }).catch(error => {\n            exceptions[i] = error;\n            resolve(wrapLoadables(dependencies, results, exceptions));\n          });\n        }\n      }\n    });\n  },\n  dangerouslyAllowMutability: true\n}); // Selector that requests all dependencies in parallel and waits for all to be\n// available before returning a value.  It will error if any dependencies error.\n\nconst waitForAll = Recoil_selectorFamily({\n  key: '__waitForAll',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => exp == null)) {\n      return wrapResults(dependencies, results);\n    } // If we have any errors, throw the first error\n\n\n    const error = exceptions.find(isError);\n\n    if (error != null) {\n      throw error;\n    } // Otherwise, return a promise that will resolve when all results are available\n\n\n    return Promise.all(exceptions).then(exceptionResults => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));\n  },\n  dangerouslyAllowMutability: true\n});\nconst waitForAllSettled = Recoil_selectorFamily({\n  key: '__waitForAllSettled',\n  get: dependencies => ({\n    get\n  }) => {\n    // Issue requests for all dependencies in parallel.\n    // Exceptions can either be Promises of pending results or real errors\n    const deps = unwrapDependencies(dependencies);\n    const [results, exceptions] = concurrentRequests(get, deps); // If all results are available, return the results\n\n    if (exceptions.every(exp => !Recoil_isPromise(exp))) {\n      return wrapLoadables(dependencies, results, exceptions);\n    } // Wait for all results to settle\n\n\n    return Promise.all(exceptions.map((exp, i) => Recoil_isPromise(exp) ? exp.then(result => {\n      results[i] = result;\n      exceptions[i] = undefined;\n    }).catch(error => {\n      results[i] = undefined;\n      exceptions[i] = error;\n    }) : null)) // Then wrap them as loadables\n    .then(() => wrapLoadables(dependencies, results, exceptions));\n  },\n  dangerouslyAllowMutability: true\n});\nconst noWait = Recoil_selectorFamily({\n  key: '__noWait',\n  get: dependency => ({\n    get\n  }) => {\n    try {\n      return Recoil_selector.value(loadableWithValue$4(get(dependency)));\n    } catch (exception) {\n      return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));\n    }\n  },\n  dangerouslyAllowMutability: true\n});\nvar Recoil_WaitFor = {\n  waitForNone,\n  waitForAny,\n  waitForAll,\n  waitForAllSettled,\n  noWait\n};\n\nconst {\n  RecoilLoadable\n} = Recoil_Loadable$1;\n\nconst {\n  DefaultValue: DefaultValue$3\n} = Recoil_Node;\n\nconst {\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1\n} = Recoil_RecoilRoot;\n\nconst {\n  isRecoilValue: isRecoilValue$5\n} = Recoil_RecoilValue$1;\n\nconst {\n  retentionZone: retentionZone$1\n} = Recoil_RetentionZone;\n\nconst {\n  freshSnapshot: freshSnapshot$2\n} = Recoil_Snapshot$1;\n\nconst {\n  useRecoilState: useRecoilState$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useSetRecoilState: useSetRecoilState$1\n} = Recoil_Hooks;\n\nconst {\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver: useRecoilTransactionObserver$1\n} = Recoil_SnapshotHooks;\n\n\n\n\n\nconst {\n  useRecoilCallback: useRecoilCallback$1\n} = Recoil_useRecoilCallback;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst {\n  noWait: noWait$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  waitForAny: waitForAny$1,\n  waitForNone: waitForNone$1\n} = Recoil_WaitFor;\n\n\n\nvar Recoil_index = {\n  // Types\n  DefaultValue: DefaultValue$3,\n  isRecoilValue: isRecoilValue$5,\n  RecoilLoadable,\n  // Global Recoil environment settiongs\n  RecoilEnv: Recoil_RecoilEnv,\n  // Recoil Root\n  RecoilRoot: RecoilRoot$2,\n  useRecoilStoreID: useRecoilStoreID$1,\n  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,\n  // Atoms/Selectors\n  atom: Recoil_atom,\n  selector: Recoil_selector,\n  // Convenience Atoms/Selectors\n  atomFamily: Recoil_atomFamily,\n  selectorFamily: Recoil_selectorFamily,\n  constSelector: Recoil_constSelector,\n  errorSelector: Recoil_errorSelector,\n  readOnlySelector: Recoil_readOnlySelector,\n  // Concurrency Helpers for Atoms/Selectors\n  noWait: noWait$1,\n  waitForNone: waitForNone$1,\n  waitForAny: waitForAny$1,\n  waitForAll: waitForAll$1,\n  waitForAllSettled: waitForAllSettled$1,\n  // Hooks for Atoms/Selectors\n  useRecoilValue: useRecoilValue$1,\n  useRecoilValueLoadable: useRecoilValueLoadable$1,\n  useRecoilState: useRecoilState$1,\n  useRecoilStateLoadable: useRecoilStateLoadable$1,\n  useSetRecoilState: useSetRecoilState$1,\n  useResetRecoilState: useResetRecoilState$1,\n  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,\n  useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,\n  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,\n  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,\n  // Hooks for complex operations\n  useRecoilCallback: useRecoilCallback$1,\n  useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,\n  // Snapshots\n  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,\n  useRecoilSnapshot: useRecoilSnapshot$1,\n  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,\n  snapshot_UNSTABLE: freshSnapshot$2,\n  // Memory Management\n  useRetain: Recoil_useRetain,\n  retentionZone: retentionZone$1\n};\nvar Recoil_index_1 = Recoil_index.DefaultValue;\nvar Recoil_index_2 = Recoil_index.isRecoilValue;\nvar Recoil_index_3 = Recoil_index.RecoilLoadable;\nvar Recoil_index_4 = Recoil_index.RecoilEnv;\nvar Recoil_index_5 = Recoil_index.RecoilRoot;\nvar Recoil_index_6 = Recoil_index.useRecoilStoreID;\nvar Recoil_index_7 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;\nvar Recoil_index_8 = Recoil_index.atom;\nvar Recoil_index_9 = Recoil_index.selector;\nvar Recoil_index_10 = Recoil_index.atomFamily;\nvar Recoil_index_11 = Recoil_index.selectorFamily;\nvar Recoil_index_12 = Recoil_index.constSelector;\nvar Recoil_index_13 = Recoil_index.errorSelector;\nvar Recoil_index_14 = Recoil_index.readOnlySelector;\nvar Recoil_index_15 = Recoil_index.noWait;\nvar Recoil_index_16 = Recoil_index.waitForNone;\nvar Recoil_index_17 = Recoil_index.waitForAny;\nvar Recoil_index_18 = Recoil_index.waitForAll;\nvar Recoil_index_19 = Recoil_index.waitForAllSettled;\nvar Recoil_index_20 = Recoil_index.useRecoilValue;\nvar Recoil_index_21 = Recoil_index.useRecoilValueLoadable;\nvar Recoil_index_22 = Recoil_index.useRecoilState;\nvar Recoil_index_23 = Recoil_index.useRecoilStateLoadable;\nvar Recoil_index_24 = Recoil_index.useSetRecoilState;\nvar Recoil_index_25 = Recoil_index.useResetRecoilState;\nvar Recoil_index_26 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;\nvar Recoil_index_27 = Recoil_index.useRecoilRefresher_UNSTABLE;\nvar Recoil_index_28 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_29 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_30 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;\nvar Recoil_index_31 = Recoil_index.useRecoilCallback;\nvar Recoil_index_32 = Recoil_index.useRecoilTransaction_UNSTABLE;\nvar Recoil_index_33 = Recoil_index.useGotoRecoilSnapshot;\nvar Recoil_index_34 = Recoil_index.useRecoilSnapshot;\nvar Recoil_index_35 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;\nvar Recoil_index_36 = Recoil_index.snapshot_UNSTABLE;\nvar Recoil_index_37 = Recoil_index.useRetain;\nvar Recoil_index_38 = Recoil_index.retentionZone;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Recoil_index);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVjb2lsL2VzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEI7QUFDTzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGFBQWE7O0FBRW5COztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsV0FBVztBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRCxXQUFXO0FBQ3RFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlELFdBQVc7QUFDcEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsR0FBRyxLQUFLO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsT0FBTzs7QUFFckQ7QUFDQTtBQUNB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QUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBSyxFQUdOO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHdDQUF3Qzs7O0FBR3hDO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUUsSUFBSTtBQUMzRTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsZUFBZTs7QUFFZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUY7O0FBRXZGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7O0FBRUE7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKLDhCQUE4Qjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7Ozs7Ozs7O0FBUUY7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxrQkFBa0I7OztBQUdsQjtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGLElBQUk7QUFDcEY7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxLQUFLO0FBQzNDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7Ozs7Ozs7QUFRRjtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBb0QsSUFBSTtBQUN4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QUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsa0RBQVE7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxFQUFFLHVCQUF1Qjs7O0FBR3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFLDhCQUE4Qjs7O0FBR2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0ZBQStGOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBLEVBQUU7Ozs7Ozs7Ozs7QUFVRjtBQUNBO0FBQ0EsRUFBRTs7OztBQUlGOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEMscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQSxRQUFRLEtBQUssRUFFTjtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU07QUFDTixVQUFVLElBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx5SEFBeUg7QUFDekg7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0EsQ0FBQyxHQUFHOztBQUVKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUUsRUFBRSw4Q0FBSztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxJQUFJO0FBQzVDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7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QUs7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSw4Q0FBSzs7QUFFVDtBQUNBO0FBQ0EsRUFBRTs7Ozs7O0FBTUY7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEdBQUcsK0JBQStCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLDhDQUFLOztBQUVUO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7QUFDQTtBQUNBLEVBQUU7Ozs7Ozs7Ozs7Ozs7O0FBY0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSyxHQUFHO0FBQ1Isd0RBQXdELGdCQUFnQjs7QUFFeEU7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTLHlDQUF5QyxvQkFBb0I7QUFDbEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxPQUFPOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLElBQUk7QUFDL0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsR0FBRzs7QUFFTjtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTs7QUFFQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUEsVUFBVSxJQUFxQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBOztBQUVBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxVQUFVLElBQXFDO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0QkFBNEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQ0FBb0M7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZUFBZTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSyxrQkFBa0I7O0FBRXZCO0FBQ0E7QUFDQSxHQUFHLHdEQUF3RDs7QUFFM0Qsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FB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O0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSCxnQ0FBZ0MsS0FBcUMsdUVBQXVFLENBQXVCOztBQUVuSztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUUsRUFBRSw4Q0FBSzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFLEVBQUUsOENBQUs7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHViw2QkFBNkI7QUFDN0I7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0EsK01BQStNOztBQUUvTTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RkFBeUYsV0FBVztBQUNwRztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixPQUFPO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxlQUFlLGlEQUFpRDtBQUNoRSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKLFdBQVcsRUFBRTtBQUNiLGVBQWUsa0JBQWtCLEdBQUcsd0JBQXdCLGNBQWM7QUFDMUUsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRCxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Qsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7Ozs7Ozs7O0FBVUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxTQUFTO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxtREFBbUQsU0FBUztBQUM1RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7Ozs7QUFNRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7Ozs7QUFJRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JGO0FBQ0E7QUFDQSxFQUFFOzs7O0FBSUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNkRBQTZEOztBQUU3RCxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFF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RUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1GQUFtRixLQUFLO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOzs7QUFHRjtBQUNBLE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBLEtBQUssR0FBRyxlQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLElBQUk7QUFDSixzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHLEdBQUc7O0FBRU47QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOzs7Ozs7OztBQVFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxTQUFTO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxtREFBbUQsU0FBUztBQUM1RDs7QUFFQTs7QUFFQSwwQkFBMEIsWUFBWTs7O0FBR3RDO0FBQ0E7QUFDQSxFQUFFOzs7Ozs7QUFNRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUssS0FBSztBQUNWLEtBQUssS0FBSzs7QUFFVjtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMENBQTBDO0FBQzFDLGtDQUFrQztBQUNsQyxjQUFjLFlBQVksSUFBSSx3SEFBd0g7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7O0FBTUY7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQUs7QUFDWCxNQUFNLEtBQUs7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGlFQUFpRSxZQUFZLElBQUksY0FBYztBQUMvRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVksbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUVBQXVFLEdBQUcsWUFBWSxHQUFHOztBQUU5Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7Ozs7OztBQU1GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0EsR0FBRyxLQUFLO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxpRUFBaUUsb0RBQW9EOztBQUVySDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7Ozs7O0FBTUY7QUFDQTtBQUNBLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7OztBQUlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUFlLFlBQVksRUFBQztBQUNvOEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlY29pbC9lcy9pbmRleC5qcz8zYTY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCByZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgcmVhY3REb20gZnJvbSAncmVhY3QtZG9tJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBlcnIobWVzc2FnZSkge1xuICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTsgLy8gSW4gVjgsIEVycm9yIG9iamVjdHMga2VlcCB0aGUgY2xvc3VyZSBzY29wZSBjaGFpbiBhbGl2ZSB1bnRpbCB0aGVcbiAgLy8gZXJyLnN0YWNrIHByb3BlcnR5IGlzIGFjY2Vzc2VkLlxuXG4gIGlmIChlcnJvci5zdGFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSUUgc2V0cyB0aGUgc3RhY2sgb25seSBpZiBlcnJvciBpcyB0aHJvd25cbiAgICB0cnkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBjYXRjaCAoXykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBmYi13d3cvbm8tdW51c2VkLWNhdGNoLWJpbmRpbmdzLCBuby1lbXB0eVxuXG4gIH1cblxuICByZXR1cm4gZXJyb3I7XG59XG5cbnZhciBlcnJfMSA9IGVycjtcblxuLy8gQG9zcy1vbmx5XG5cblxudmFyIFJlY29pbF9lcnIgPSBlcnJfMTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG4vLyBTcGxpdCBkZWNsYXJhdGlvbiBhbmQgaW1wbGVtZW50YXRpb24gdG8gYWxsb3cgdGhpcyBmdW5jdGlvbiB0byBwcmV0ZW5kIHRvXG4vLyBjaGVjayBmb3IgYWN0dWFsIGluc3RhbmNlIG9mIFByb21pc2UgaW5zdGVhZCBvZiBzb21ldGhpbmcgd2l0aCBhIGB0aGVuYFxuLy8gbWV0aG9kLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZnVuY3Rpb24gaXNQcm9taXNlKHApIHtcbiAgcmV0dXJuICEhcCAmJiB0eXBlb2YgcC50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG52YXIgUmVjb2lsX2lzUHJvbWlzZSA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gbnVsbHRocm93cyh4LCBtZXNzYWdlKSB7XG4gIGlmICh4ICE9IG51bGwpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIHRocm93IFJlY29pbF9lcnIobWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ0dvdCB1bmV4cGVjdGVkIG51bGwgb3IgdW5kZWZpbmVkJyk7XG59XG5cbnZhciBSZWNvaWxfbnVsbHRocm93cyA9IG51bGx0aHJvd3M7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5jbGFzcyBCYXNlTG9hZGFibGUge1xuICBnZXRWYWx1ZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIHRvUHJvbWlzZSgpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG4gIHZhbHVlTWF5YmUoKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQmFzZUxvYWRhYmxlJyk7XG4gIH1cblxuICB2YWx1ZU9yVGhyb3coKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgdGhyb3cgUmVjb2lsX2VycihgTG9hZGFibGUgZXhwZWN0ZWQgdmFsdWUsIGJ1dCBpbiBcIiR7dGhpcy5zdGF0ZX1cIiBzdGF0ZWApO1xuICB9XG5cbiAgcHJvbWlzZU1heWJlKCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbiAgcHJvbWlzZU9yVGhyb3coKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgdGhyb3cgUmVjb2lsX2VycihgTG9hZGFibGUgZXhwZWN0ZWQgcHJvbWlzZSwgYnV0IGluIFwiJHt0aGlzLnN0YXRlfVwiIHN0YXRlYCk7XG4gIH1cblxuICBlcnJvck1heWJlKCkge1xuICAgIHRocm93IFJlY29pbF9lcnIoJ0Jhc2VMb2FkYWJsZScpO1xuICB9XG5cbiAgZXJyb3JPclRocm93KCkge1xuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIHRocm93IFJlY29pbF9lcnIoYExvYWRhYmxlIGV4cGVjdGVkIGVycm9yLCBidXQgaW4gXCIke3RoaXMuc3RhdGV9XCIgc3RhdGVgKTtcbiAgfVxuXG4gIGlzKG90aGVyKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgcmV0dXJuIG90aGVyLnN0YXRlID09PSB0aGlzLnN0YXRlICYmIG90aGVyLmNvbnRlbnRzID09PSB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgbWFwKF9tYXApIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdCYXNlTG9hZGFibGUnKTtcbiAgfVxuXG59XG5cbmNsYXNzIFZhbHVlTG9hZGFibGUgZXh0ZW5kcyBCYXNlTG9hZGFibGUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCAnaGFzVmFsdWUnKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNvbnRlbnRzID0gdmFsdWU7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHRvUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29udGVudHMpO1xuICB9XG5cbiAgdmFsdWVNYXliZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHZhbHVlT3JUaHJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHByb21pc2VNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZXJyb3JNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbWFwKG1hcCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXh0ID0gbWFwKHRoaXMuY29udGVudHMpO1xuICAgICAgcmV0dXJuIFJlY29pbF9pc1Byb21pc2UobmV4dCkgPyBsb2FkYWJsZVdpdGhQcm9taXNlKG5leHQpIDogaXNMb2FkYWJsZShuZXh0KSA/IG5leHQgOiBsb2FkYWJsZVdpdGhWYWx1ZShuZXh0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gUmVjb2lsX2lzUHJvbWlzZShlKSA/IC8vIElmIHdlIFwic3VzcGVuZGVkXCIsIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgLy8gZXJyb3JzIGFuZCBzdWJzZXF1ZW50IHJldHJpZXMgd2lsbCBiZSBoYW5kbGVkIGluICdsb2FkaW5nJyBjYXNlXG4gICAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIGxvYWRhYmxlV2l0aFByb21pc2UoZS5uZXh0KCgpID0+IHRoaXMubWFwKG1hcCkpKSA6IGxvYWRhYmxlV2l0aEVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG59XG5cbmNsYXNzIEVycm9yTG9hZGFibGUgZXh0ZW5kcyBCYXNlTG9hZGFibGUge1xuICBjb25zdHJ1Y3RvcihlcnJvcikge1xuICAgIHN1cGVyKCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCAnaGFzRXJyb3InKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRlbnRzXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmNvbnRlbnRzID0gZXJyb3I7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICB0aHJvdyB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgdG9Qcm9taXNlKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNvbnRlbnRzKTtcbiAgfVxuXG4gIHZhbHVlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByb21pc2VNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZXJyb3JNYXliZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIGVycm9yT3JUaHJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIG1hcChfbWFwKSB7XG4gICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbn1cblxuY2xhc3MgTG9hZGluZ0xvYWRhYmxlIGV4dGVuZHMgQmFzZUxvYWRhYmxlIHtcbiAgY29uc3RydWN0b3IocHJvbWlzZSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGF0ZVwiLCAnbG9hZGluZycpO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29udGVudHNcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuY29udGVudHMgPSBwcm9taXNlO1xuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgdGhyb3cgdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHRvUHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHZhbHVlTWF5YmUoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByb21pc2VNYXliZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50cztcbiAgfVxuXG4gIHByb21pc2VPclRocm93KCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnRzO1xuICB9XG5cbiAgZXJyb3JNYXliZSgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgbWFwKG1hcCkge1xuICAgIHJldHVybiBsb2FkYWJsZVdpdGhQcm9taXNlKHRoaXMuY29udGVudHMudGhlbih2YWx1ZSA9PiB7XG4gICAgICBjb25zdCBuZXh0ID0gbWFwKHZhbHVlKTtcblxuICAgICAgaWYgKGlzTG9hZGFibGUobmV4dCkpIHtcbiAgICAgICAgY29uc3QgbmV4dExvYWRhYmxlID0gbmV4dDtcblxuICAgICAgICBzd2l0Y2ggKG5leHRMb2FkYWJsZS5zdGF0ZSkge1xuICAgICAgICAgIGNhc2UgJ2hhc1ZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXh0TG9hZGFibGUuY29udGVudHM7XG5cbiAgICAgICAgICBjYXNlICdoYXNFcnJvcic6XG4gICAgICAgICAgICB0aHJvdyBuZXh0TG9hZGFibGUuY29udGVudHM7XG5cbiAgICAgICAgICBjYXNlICdsb2FkaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBuZXh0TG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG5cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0pIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICAgLmNhdGNoKGUgPT4ge1xuICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoZSkpIHtcbiAgICAgICAgLy8gd2Ugd2VyZSBcInN1c3BlbmRlZCxcIiB0cnkgYWdhaW5cbiAgICAgICAgcmV0dXJuIGUudGhlbigoKSA9PiB0aGlzLm1hcChtYXApLmNvbnRlbnRzKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9KSk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBsb2FkYWJsZVdpdGhWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgVmFsdWVMb2FkYWJsZSh2YWx1ZSkpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZVdpdGhFcnJvcihlcnJvcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShuZXcgRXJyb3JMb2FkYWJsZShlcnJvcikpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZVdpdGhQcm9taXNlKHByb21pc2UpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IExvYWRpbmdMb2FkYWJsZShwcm9taXNlKSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRhYmxlTG9hZGluZygpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobmV3IExvYWRpbmdMb2FkYWJsZShuZXcgUHJvbWlzZSgoKSA9PiB7fSkpKTtcbn1cblxuZnVuY3Rpb24gbG9hZGFibGVBbGxBcnJheShpbnB1dHMpIHtcbiAgcmV0dXJuIGlucHV0cy5ldmVyeShpID0+IGkuc3RhdGUgPT09ICdoYXNWYWx1ZScpID8gbG9hZGFibGVXaXRoVmFsdWUoaW5wdXRzLm1hcChpID0+IGkuY29udGVudHMpKSA6IGlucHV0cy5zb21lKGkgPT4gaS5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykgPyBsb2FkYWJsZVdpdGhFcnJvcihSZWNvaWxfbnVsbHRocm93cyhpbnB1dHMuZmluZChpID0+IGkuc3RhdGUgPT09ICdoYXNFcnJvcicpLCAnSW52YWxpZCBsb2FkYWJsZSBwYXNzZWQgdG8gbG9hZGFibGVBbGwnKS5jb250ZW50cykgOiBsb2FkYWJsZVdpdGhQcm9taXNlKFByb21pc2UuYWxsKGlucHV0cy5tYXAoaSA9PiBpLmNvbnRlbnRzKSkpO1xufVxuXG5mdW5jdGlvbiBsb2FkYWJsZUFsbChpbnB1dHMpIHtcbiAgY29uc3QgdW53cmFwZWRJbnB1dHMgPSBBcnJheS5pc0FycmF5KGlucHV0cykgPyBpbnB1dHMgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dHMpLm1hcChrZXkgPT4gaW5wdXRzW2tleV0pO1xuICBjb25zdCBub3JtYWxpemVkSW5wdXRzID0gdW53cmFwZWRJbnB1dHMubWFwKHggPT4gaXNMb2FkYWJsZSh4KSA/IHggOiBSZWNvaWxfaXNQcm9taXNlKHgpID8gbG9hZGFibGVXaXRoUHJvbWlzZSh4KSA6IGxvYWRhYmxlV2l0aFZhbHVlKHgpKTtcbiAgY29uc3Qgb3V0cHV0ID0gbG9hZGFibGVBbGxBcnJheShub3JtYWxpemVkSW5wdXRzKTtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXRzKSA/IC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgb3V0cHV0IDogLy8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoKSBoYXMgY29uc2lzdGVudCBrZXkgb3JkZXJpbmcgd2l0aCBFUzZcbiAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtY2FsbF1cbiAgb3V0cHV0Lm1hcChvdXRwdXRzID0+IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGlucHV0cykucmVkdWNlKCAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29tcHV0ZWQtcHJvcF1cbiAgKG91dCwga2V5LCBpZHgpID0+ICh7IC4uLm91dCxcbiAgICBba2V5XTogb3V0cHV0c1tpZHhdXG4gIH0pLCB7fSkpO1xufVxuXG5mdW5jdGlvbiBpc0xvYWRhYmxlKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBCYXNlTG9hZGFibGU7XG59XG5cbmNvbnN0IExvYWRhYmxlU3RhdGljSW50ZXJmYWNlID0ge1xuICBvZjogdmFsdWUgPT4gUmVjb2lsX2lzUHJvbWlzZSh2YWx1ZSkgPyBsb2FkYWJsZVdpdGhQcm9taXNlKHZhbHVlKSA6IGlzTG9hZGFibGUodmFsdWUpID8gdmFsdWUgOiBsb2FkYWJsZVdpdGhWYWx1ZSh2YWx1ZSksXG4gIGVycm9yOiBlcnJvciA9PiBsb2FkYWJsZVdpdGhFcnJvcihlcnJvciksXG4gIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgbG9hZGluZzogKCkgPT4gbG9hZGFibGVMb2FkaW5nKCksXG4gIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxuICBhbGw6IGxvYWRhYmxlQWxsLFxuICBpc0xvYWRhYmxlXG59O1xudmFyIFJlY29pbF9Mb2FkYWJsZSA9IHtcbiAgbG9hZGFibGVXaXRoVmFsdWUsXG4gIGxvYWRhYmxlV2l0aEVycm9yLFxuICBsb2FkYWJsZVdpdGhQcm9taXNlLFxuICBsb2FkYWJsZUxvYWRpbmcsXG4gIGxvYWRhYmxlQWxsLFxuICBpc0xvYWRhYmxlLFxuICBSZWNvaWxMb2FkYWJsZTogTG9hZGFibGVTdGF0aWNJbnRlcmZhY2Vcbn07XG5cbnZhciBSZWNvaWxfTG9hZGFibGVfMSA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZVdpdGhWYWx1ZTtcbnZhciBSZWNvaWxfTG9hZGFibGVfMiA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZVdpdGhFcnJvcjtcbnZhciBSZWNvaWxfTG9hZGFibGVfMyA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZVdpdGhQcm9taXNlO1xudmFyIFJlY29pbF9Mb2FkYWJsZV80ID0gUmVjb2lsX0xvYWRhYmxlLmxvYWRhYmxlTG9hZGluZztcbnZhciBSZWNvaWxfTG9hZGFibGVfNSA9IFJlY29pbF9Mb2FkYWJsZS5sb2FkYWJsZUFsbDtcbnZhciBSZWNvaWxfTG9hZGFibGVfNiA9IFJlY29pbF9Mb2FkYWJsZS5pc0xvYWRhYmxlO1xudmFyIFJlY29pbF9Mb2FkYWJsZV83ID0gUmVjb2lsX0xvYWRhYmxlLlJlY29pbExvYWRhYmxlO1xuXG52YXIgUmVjb2lsX0xvYWRhYmxlJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgbG9hZGFibGVXaXRoVmFsdWU6IFJlY29pbF9Mb2FkYWJsZV8xLFxuICBsb2FkYWJsZVdpdGhFcnJvcjogUmVjb2lsX0xvYWRhYmxlXzIsXG4gIGxvYWRhYmxlV2l0aFByb21pc2U6IFJlY29pbF9Mb2FkYWJsZV8zLFxuICBsb2FkYWJsZUxvYWRpbmc6IFJlY29pbF9Mb2FkYWJsZV80LFxuICBsb2FkYWJsZUFsbDogUmVjb2lsX0xvYWRhYmxlXzUsXG4gIGlzTG9hZGFibGU6IFJlY29pbF9Mb2FkYWJsZV82LFxuICBSZWNvaWxMb2FkYWJsZTogUmVjb2lsX0xvYWRhYmxlXzdcbn0pO1xuXG5jb25zdCBlbnYgPSB7XG4gIFJFQ09JTF9EVVBMSUNBVEVfQVRPTV9LRVlfQ0hFQ0tJTkdfRU5BQkxFRDogdHJ1ZSxcbiAgLy8gTm90ZTogUkVDT0lMX0dLU19FTkFCTEVEIHNldHRpbmdzIHdpbGwgb25seSBiZSBob25vcmVkIGluIE9TUyBidWlsZHMgb2YgUmVjb2lsXG4gIFJFQ09JTF9HS1NfRU5BQkxFRDogbmV3IFNldChbJ3JlY29pbF9oYW10XzIwMjAnLCAncmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUnLCAncmVjb2lsX3N1cHByZXNzX3JlcmVuZGVyX2luX2NhbGxiYWNrJywgJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJ10pXG59O1xuXG5mdW5jdGlvbiByZWFkUHJvY2Vzc0VudkJvb2xlYW5GbGFnKG5hbWUsIHNldCkge1xuICB2YXIgX3Byb2Nlc3MkZW52JG5hbWUsIF9wcm9jZXNzJGVudiRuYW1lJHRvTDtcblxuICBjb25zdCBzYW5pdGl6ZWRWYWx1ZSA9IChfcHJvY2VzcyRlbnYkbmFtZSA9IHByb2Nlc3MuZW52W25hbWVdKSA9PT0gbnVsbCB8fCBfcHJvY2VzcyRlbnYkbmFtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9wcm9jZXNzJGVudiRuYW1lJHRvTCA9IF9wcm9jZXNzJGVudiRuYW1lLnRvTG93ZXJDYXNlKCkpID09PSBudWxsIHx8IF9wcm9jZXNzJGVudiRuYW1lJHRvTCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb2Nlc3MkZW52JG5hbWUkdG9MLnRyaW0oKTtcblxuICBpZiAoc2FuaXRpemVkVmFsdWUgPT0gbnVsbCB8fCBzYW5pdGl6ZWRWYWx1ZSA9PT0gJycpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBhbGxvd2VkVmFsdWVzID0gWyd0cnVlJywgJ2ZhbHNlJ107XG5cbiAgaWYgKCFhbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHNhbml0aXplZFZhbHVlKSkge1xuICAgIHRocm93IFJlY29pbF9lcnIoYHByb2Nlc3MuZW52LiR7bmFtZX0gdmFsdWUgbXVzdCBiZSAndHJ1ZScsICdmYWxzZScsIG9yIGVtcHR5OiAke3Nhbml0aXplZFZhbHVlfWApO1xuICB9XG5cbiAgc2V0KHNhbml0aXplZFZhbHVlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiByZWFkUHJvY2Vzc0VudlN0cmluZ0FycmF5RmxhZyhuYW1lLCBzZXQpIHtcbiAgdmFyIF9wcm9jZXNzJGVudiRuYW1lMjtcblxuICBjb25zdCBzYW5pdGl6ZWRWYWx1ZSA9IChfcHJvY2VzcyRlbnYkbmFtZTIgPSBwcm9jZXNzLmVudltuYW1lXSkgPT09IG51bGwgfHwgX3Byb2Nlc3MkZW52JG5hbWUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJvY2VzcyRlbnYkbmFtZTIudHJpbSgpO1xuXG4gIGlmIChzYW5pdGl6ZWRWYWx1ZSA9PSBudWxsIHx8IHNhbml0aXplZFZhbHVlID09PSAnJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHNldChzYW5pdGl6ZWRWYWx1ZS5zcGxpdCgvXFxzKixcXHMqfFxccysvKSk7XG59XG4vKipcbiAqIEFsbG93IE5vZGVKUy9OZXh0SlMvZXRjIHRvIHNldCB0aGUgaW5pdGlhbCBzdGF0ZSB0aHJvdWdoIHByb2Nlc3MuZW52IHZhcmlhYmxlXG4gKiBOb3RlOiAgd2UgZG9uJ3QgYXNzdW1lICdwcm9jZXNzJyBpcyBhdmFpbGFibGUgaW4gYWxsIHJ1bnRpbWUgZW52aXJvbm1lbnRzXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tleHBlcmltZW50YWwvUmVjb2lsL2lzc3Vlcy83MzNcbiAqL1xuXG5cbmZ1bmN0aW9uIGFwcGx5UHJvY2Vzc0VudkZsYWdPdmVycmlkZXMoKSB7XG4gIHZhciBfcHJvY2VzcztcblxuICAvLyBub3RlOiB0aGlzIGNoZWNrIGlzIG5lZWRlZCBpbiBhZGRpdGlvbiB0byB0aGUgY2hlY2sgYmVsb3csIHJ1bnRpbWUgZXJyb3Igd2lsbCBvY2N1ciB3aXRob3V0IGl0IVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3R5cGVvZi11bmRlZmluZWRcbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgoKF9wcm9jZXNzID0gcHJvY2VzcykgPT09IG51bGwgfHwgX3Byb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wcm9jZXNzLmVudikgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJlYWRQcm9jZXNzRW52Qm9vbGVhbkZsYWcoJ1JFQ09JTF9EVVBMSUNBVEVfQVRPTV9LRVlfQ0hFQ0tJTkdfRU5BQkxFRCcsIHZhbHVlID0+IHtcbiAgICBlbnYuUkVDT0lMX0RVUExJQ0FURV9BVE9NX0tFWV9DSEVDS0lOR19FTkFCTEVEID0gdmFsdWU7XG4gIH0pO1xuICByZWFkUHJvY2Vzc0VudlN0cmluZ0FycmF5RmxhZygnUkVDT0lMX0dLU19FTkFCTEVEJywgdmFsdWUgPT4ge1xuICAgIHZhbHVlLmZvckVhY2goZ2sgPT4ge1xuICAgICAgZW52LlJFQ09JTF9HS1NfRU5BQkxFRC5hZGQoZ2spO1xuICAgIH0pO1xuICB9KTtcbn1cblxuYXBwbHlQcm9jZXNzRW52RmxhZ092ZXJyaWRlcygpO1xudmFyIFJlY29pbF9SZWNvaWxFbnYgPSBlbnY7XG5cbmZ1bmN0aW9uIFJlY29pbF9na3hfT1NTKGdrKSB7XG4gIHJldHVybiBSZWNvaWxfUmVjb2lsRW52LlJFQ09JTF9HS1NfRU5BQkxFRC5oYXMoZ2spO1xufVxuXG5SZWNvaWxfZ2t4X09TUy5zZXRQYXNzID0gZ2sgPT4ge1xuICBSZWNvaWxfUmVjb2lsRW52LlJFQ09JTF9HS1NfRU5BQkxFRC5hZGQoZ2spO1xufTtcblxuUmVjb2lsX2dreF9PU1Muc2V0RmFpbCA9IGdrID0+IHtcbiAgUmVjb2lsX1JlY29pbEVudi5SRUNPSUxfR0tTX0VOQUJMRUQuZGVsZXRlKGdrKTtcbn07XG5cblJlY29pbF9na3hfT1NTLmNsZWFyID0gKCkgPT4ge1xuICBSZWNvaWxfUmVjb2lsRW52LlJFQ09JTF9HS1NfRU5BQkxFRC5jbGVhcigpO1xufTtcblxudmFyIFJlY29pbF9na3ggPSBSZWNvaWxfZ2t4X09TUzsgLy8gQG9zcy1vbmx5XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gcmVjb3ZlcmFibGVWaW9sYXRpb24obWVzc2FnZSwgX3Byb2plY3ROYW1lLCB7XG4gIGVycm9yXG59ID0ge30pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSwgZXJyb3IpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciByZWNvdmVyYWJsZVZpb2xhdGlvbl8xID0gcmVjb3ZlcmFibGVWaW9sYXRpb247XG5cbi8vIEBvc3Mtb25seVxuXG5cbnZhciBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24gPSByZWNvdmVyYWJsZVZpb2xhdGlvbl8xO1xuXG52YXIgX2NyZWF0ZU11dGFibGVTb3VyY2UsIF91c2VNdXRhYmxlU291cmNlLCBfdXNlU3luY0V4dGVybmFsU3RvcmU7XG5cblxuXG5cblxuXG5cbmNvbnN0IGNyZWF0ZU11dGFibGVTb3VyY2UgPSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuKF9jcmVhdGVNdXRhYmxlU291cmNlID0gcmVhY3QuY3JlYXRlTXV0YWJsZVNvdXJjZSkgIT09IG51bGwgJiYgX2NyZWF0ZU11dGFibGVTb3VyY2UgIT09IHZvaWQgMCA/IF9jcmVhdGVNdXRhYmxlU291cmNlIDogcmVhY3QudW5zdGFibGVfY3JlYXRlTXV0YWJsZVNvdXJjZTtcbmNvbnN0IHVzZU11dGFibGVTb3VyY2UgPSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuKF91c2VNdXRhYmxlU291cmNlID0gcmVhY3QudXNlTXV0YWJsZVNvdXJjZSkgIT09IG51bGwgJiYgX3VzZU11dGFibGVTb3VyY2UgIT09IHZvaWQgMCA/IF91c2VNdXRhYmxlU291cmNlIDogcmVhY3QudW5zdGFibGVfdXNlTXV0YWJsZVNvdXJjZTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvODZcblxuY29uc3QgdXNlU3luY0V4dGVybmFsU3RvcmUgPSAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuKF91c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHJlYWN0LnVzZVN5bmNFeHRlcm5hbFN0b3JlKSAhPT0gbnVsbCAmJiBfdXNlU3luY0V4dGVybmFsU3RvcmUgIT09IHZvaWQgMCA/IF91c2VTeW5jRXh0ZXJuYWxTdG9yZSA6IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5yZWFjdC51bnN0YWJsZV91c2VTeW5jRXh0ZXJuYWxTdG9yZTtcbmxldCBSZWFjdFJlbmRlcmVyVmVyc2lvbk1pc21hdGNoV2Fybk9uY2UgPSBmYWxzZTsgLy8gQ2hlY2sgaWYgdGhlIGN1cnJlbnQgcmVuZGVyZXIgc3VwcG9ydHMgYHVzZVN5bmNFeHRlcm5hbFN0b3JlKClgLlxuLy8gU2luY2UgUmVhY3QgZ29lcyB0aHJvdWdoIGEgcHJveHkgZGlzcGF0Y2hlciBhbmQgdGhlIGN1cnJlbnQgcmVuZGVyZXIgY2FuXG4vLyBjaGFuZ2Ugd2UgY2FuJ3Qgc2ltcGx5IGNoZWNrIGlmIGBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSgpYCBpcyBkZWZpbmVkLlxuXG5mdW5jdGlvbiBjdXJyZW50UmVuZGVyZXJTdXBwb3J0c1VzZVN5bmNFeHRlcm5hbFN0b3JlKCkge1xuICB2YXIgX1JlYWN0Q3VycmVudERpc3BhdGNoO1xuXG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV1cbiAgY29uc3Qge1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgUmVhY3RDdXJyZW50T3duZXJcbiAgfSA9XG4gIC8qICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBUaGlzIHdvcmthcm91bmQgd2FzIGFwcHJvdmVkIGFzIGEgc2FmZXIgbWVjaGFuaXNtXG4gICAqIHRvIGRldGVjdCBpZiB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0cyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSgpXG4gICAqIGh0dHBzOi8vZmIud29ya3BsYWNlLmNvbS9ncm91cHMvcmVhY3Rqcy9wb3N0cy85NTU4NjgyMzMwODQ2OTYzLyAqL1xuICByZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgY29uc3QgZGlzcGF0Y2hlciA9IChfUmVhY3RDdXJyZW50RGlzcGF0Y2ggPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID09PSBudWxsIHx8IFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCkgIT09IG51bGwgJiYgX1JlYWN0Q3VycmVudERpc3BhdGNoICE9PSB2b2lkIDAgPyBfUmVhY3RDdXJyZW50RGlzcGF0Y2ggOiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50RGlzcGF0Y2hlcjtcbiAgY29uc3QgaXNVc2VTeW5jRXh0ZXJuYWxTdG9yZVN1cHBvcnRlZCA9IGRpc3BhdGNoZXIudXNlU3luY0V4dGVybmFsU3RvcmUgIT0gbnVsbDtcblxuICBpZiAodXNlU3luY0V4dGVybmFsU3RvcmUgJiYgIWlzVXNlU3luY0V4dGVybmFsU3RvcmVTdXBwb3J0ZWQgJiYgIVJlYWN0UmVuZGVyZXJWZXJzaW9uTWlzbWF0Y2hXYXJuT25jZSkge1xuICAgIFJlYWN0UmVuZGVyZXJWZXJzaW9uTWlzbWF0Y2hXYXJuT25jZSA9IHRydWU7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBIFJlYWN0IHJlbmRlcmVyIHdpdGhvdXQgUmVhY3QgMTgrIEFQSSBzdXBwb3J0IGlzIGJlaW5nIHVzZWQgd2l0aCBSZWFjdCAxOCsuJyk7XG4gIH1cblxuICByZXR1cm4gaXNVc2VTeW5jRXh0ZXJuYWxTdG9yZVN1cHBvcnRlZDtcbn1cblxuLyoqXG4gKiBtb2RlOiBUaGUgUmVhY3QgQVBJIGFuZCBhcHByb2FjaCB0byB1c2UgZm9yIHN5bmNpbmcgc3RhdGUgd2l0aCBSZWFjdFxuICogZWFybHk6IFJlLXJlbmRlcnMgZnJvbSBSZWNvaWwgdXBkYXRlcyBvY2N1cjpcbiAqICAgIDEpIGVhcmxpZXJcbiAqICAgIDIpIGluIHN5bmMgd2l0aCBSZWFjdCB1cGRhdGVzIGluIHRoZSBzYW1lIGJhdGNoXG4gKiAgICAzKSBiZWZvcmUgdHJhbnNhY3Rpb24gb2JzZXJ2ZXJzIGluc3RlYWQgb2YgYWZ0ZXIuXG4gKiBjb25jdXJyZW50OiBJcyB0aGUgY3VycmVudCBtb2RlIGNvbXBhdGlibGUgd2l0aCBDb25jdXJyZW50IE1vZGUgYW5kIHVzZVRyYW5zaXRpb24oKVxuICovXG5mdW5jdGlvbiByZWFjdE1vZGUoKSB7XG4gIC8vIE5PVEU6IFRoaXMgbW9kZSBpcyBjdXJyZW50bHkgYnJva2VuIHdpdGggc29tZSBTdXNwZW5zZSBjYXNlc1xuICAvLyBzZWUgUmVjb2lsX3NlbGVjdG9yLXRlc3QuanNcbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF90cmFuc2l0aW9uX3N1cHBvcnQnKSkge1xuICAgIHJldHVybiB7XG4gICAgICBtb2RlOiAnVFJBTlNJVElPTl9TVVBQT1JUJyxcbiAgICAgIGVhcmx5OiB0cnVlLFxuICAgICAgY29uY3VycmVudDogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUnKSAmJiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vZGU6ICdTWU5DX0VYVEVSTkFMX1NUT1JFJyxcbiAgICAgIGVhcmx5OiB0cnVlLFxuICAgICAgY29uY3VycmVudDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tdXRhYmxlX3NvdXJjZScpICYmIHVzZU11dGFibGVTb3VyY2UgIT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LiRkaXNhYmxlUmVjb2lsVmFsdWVNdXRhYmxlU291cmNlX1RFTVBfSEFDS19ET19OT1RfVVNFKSB7XG4gICAgcmV0dXJuIFJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpID8ge1xuICAgICAgbW9kZTogJ01VVEFCTEVfU09VUkNFJyxcbiAgICAgIGVhcmx5OiB0cnVlLFxuICAgICAgY29uY3VycmVudDogdHJ1ZVxuICAgIH0gOiB7XG4gICAgICBtb2RlOiAnTVVUQUJMRV9TT1VSQ0UnLFxuICAgICAgZWFybHk6IGZhbHNlLFxuICAgICAgY29uY3VycmVudDogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIFJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpID8ge1xuICAgIG1vZGU6ICdMRUdBQ1knLFxuICAgIGVhcmx5OiB0cnVlLFxuICAgIGNvbmN1cnJlbnQ6IGZhbHNlXG4gIH0gOiB7XG4gICAgbW9kZTogJ0xFR0FDWScsXG4gICAgZWFybHk6IGZhbHNlLFxuICAgIGNvbmN1cnJlbnQ6IGZhbHNlXG4gIH07XG59IC8vIFRPRE8gTmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoZXJlIGlzIGEgc3RhbmRhcmQvb3Blbi1zb3VyY2UgZXF1aXZhbGVudCB0byBzZWUgaWYgaG90IG1vZHVsZSByZXBsYWNlbWVudCBpcyBoYXBwZW5pbmc6XG5cblxuZnVuY3Rpb24gaXNGYXN0UmVmcmVzaEVuYWJsZWQoKSB7XG4gIC8vIEBmYi1vbmx5OiBjb25zdCB7aXNBY2NlcHRpbmdVcGRhdGV9ID0gcmVxdWlyZSgnX19kZWJ1ZycpO1xuICAvLyBAZmItb25seTogcmV0dXJuIHR5cGVvZiBpc0FjY2VwdGluZ1VwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0FjY2VwdGluZ1VwZGF0ZSgpO1xuICByZXR1cm4gZmFsc2U7IC8vIEBvc3Mtb25seVxufVxuXG52YXIgUmVjb2lsX1JlYWN0TW9kZSA9IHtcbiAgY3JlYXRlTXV0YWJsZVNvdXJjZSxcbiAgdXNlTXV0YWJsZVNvdXJjZSxcbiAgdXNlU3luY0V4dGVybmFsU3RvcmUsXG4gIGN1cnJlbnRSZW5kZXJlclN1cHBvcnRzVXNlU3luY0V4dGVybmFsU3RvcmUsXG4gIHJlYWN0TW9kZSxcbiAgaXNGYXN0UmVmcmVzaEVuYWJsZWRcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5jbGFzcyBBYnN0cmFjdFJlY29pbFZhbHVlIHtcbiAgY29uc3RydWN0b3IobmV3S2V5KSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwia2V5XCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLmtleSA9IG5ld0tleTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5OiB0aGlzLmtleVxuICAgIH07XG4gIH1cblxufVxuXG5jbGFzcyBSZWNvaWxTdGF0ZSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cblxuY2xhc3MgUmVjb2lsVmFsdWVSZWFkT25seSBleHRlbmRzIEFic3RyYWN0UmVjb2lsVmFsdWUge31cblxuZnVuY3Rpb24gaXNSZWNvaWxWYWx1ZSh4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmVjb2lsU3RhdGUgfHwgeCBpbnN0YW5jZW9mIFJlY29pbFZhbHVlUmVhZE9ubHk7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUgPSB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWUsXG4gIFJlY29pbFN0YXRlLFxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5LFxuICBpc1JlY29pbFZhbHVlXG59O1xuXG52YXIgUmVjb2lsX1JlY29pbFZhbHVlXzEgPSBSZWNvaWxfUmVjb2lsVmFsdWUuQWJzdHJhY3RSZWNvaWxWYWx1ZTtcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMiA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxTdGF0ZTtcbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVfMyA9IFJlY29pbF9SZWNvaWxWYWx1ZS5SZWNvaWxWYWx1ZVJlYWRPbmx5O1xudmFyIFJlY29pbF9SZWNvaWxWYWx1ZV80ID0gUmVjb2lsX1JlY29pbFZhbHVlLmlzUmVjb2lsVmFsdWU7XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBSZWNvaWxfUmVjb2lsVmFsdWVfMSxcbiAgUmVjb2lsU3RhdGU6IFJlY29pbF9SZWNvaWxWYWx1ZV8yLFxuICBSZWNvaWxWYWx1ZVJlYWRPbmx5OiBSZWNvaWxfUmVjb2lsVmFsdWVfMyxcbiAgaXNSZWNvaWxWYWx1ZTogUmVjb2lsX1JlY29pbFZhbHVlXzRcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIHNwcmludGYoZm9ybWF0LCAuLi5hcmdzKSB7XG4gIGxldCBpbmRleCA9IDA7XG4gIHJldHVybiBmb3JtYXQucmVwbGFjZSgvJXMvZywgKCkgPT4gU3RyaW5nKGFyZ3NbaW5kZXgrK10pKTtcbn1cblxudmFyIHNwcmludGZfMSA9IHNwcmludGY7XG5cbmZ1bmN0aW9uIGV4cGVjdGF0aW9uVmlvbGF0aW9uKGZvcm1hdCwgLi4uYXJncykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHNwcmludGZfMS5jYWxsKG51bGwsIGZvcm1hdCwgLi4uYXJncyk7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IubmFtZSA9ICdFeHBlY3RhdGlvbiBWaW9sYXRpb24nO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG59XG5cbnZhciBleHBlY3RhdGlvblZpb2xhdGlvbl8xID0gZXhwZWN0YXRpb25WaW9sYXRpb247XG5cbi8vIEBvc3Mtb25seVxuXG5cbnZhciBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24gPSBleHBlY3RhdGlvblZpb2xhdGlvbl8xO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaXRlcmFibGUgd2hvc2Ugb3V0cHV0IGlzIGdlbmVyYXRlZCBieSBwYXNzaW5nIHRoZSBpbnB1dFxuICogaXRlcmFibGUncyB2YWx1ZXMgdGhyb3VnaCB0aGUgbWFwcGVyIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIG1hcEl0ZXJhYmxlKGl0ZXJhYmxlLCBjYWxsYmFjaykge1xuICAvLyBVc2UgZ2VuZXJhdG9yIHRvIGNyZWF0ZSBpdGVyYWJsZS9pdGVyYXRvclxuICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgICAgeWllbGQgY2FsbGJhY2sodmFsdWUsIGluZGV4KyspO1xuICAgIH1cbiAgfSgpO1xufVxuXG52YXIgUmVjb2lsX21hcEl0ZXJhYmxlID0gbWFwSXRlcmFibGU7XG5cbmNvbnN0IHtcbiAgaXNGYXN0UmVmcmVzaEVuYWJsZWQ6IGlzRmFzdFJlZnJlc2hFbmFibGVkJDFcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY2xhc3MgRGVmYXVsdFZhbHVlIHt9XG5cbmNvbnN0IERFRkFVTFRfVkFMVUUgPSBuZXcgRGVmYXVsdFZhbHVlKCk7XG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuY29uc3Qgbm9kZXMgPSBuZXcgTWFwKCk7IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbmNvbnN0IHJlY29pbFZhbHVlcyA9IG5ldyBNYXAoKTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG5mdW5jdGlvbiByZWNvaWxWYWx1ZXNGb3JLZXlzKGtleXMpIHtcbiAgcmV0dXJuIFJlY29pbF9tYXBJdGVyYWJsZShrZXlzLCBrZXkgPT4gUmVjb2lsX251bGx0aHJvd3MocmVjb2lsVmFsdWVzLmdldChrZXkpKSk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yRHVwbGljYXRlQXRvbUtleShrZXkpIHtcbiAgaWYgKG5vZGVzLmhhcyhrZXkpKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGBEdXBsaWNhdGUgYXRvbSBrZXkgXCIke2tleX1cIi4gVGhpcyBpcyBhIEZBVEFMIEVSUk9SIGluXG4gICAgICBwcm9kdWN0aW9uLiBCdXQgaXQgaXMgc2FmZSB0byBpZ25vcmUgdGhpcyB3YXJuaW5nIGlmIGl0IG9jY3VycmVkIGJlY2F1c2Ugb2ZcbiAgICAgIGhvdCBtb2R1bGUgcmVwbGFjZW1lbnQuYDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIC8vIFRPRE8gRmlndXJlIHRoaXMgb3V0IGZvciBvcGVuLXNvdXJjZVxuICAgICAgaWYgKCFpc0Zhc3RSZWZyZXNoRW5hYmxlZCQxKCkpIHtcbiAgICAgICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKG1lc3NhZ2UsICdyZWNvaWwnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQGZiLW9ubHk6IHJlY292ZXJhYmxlVmlvbGF0aW9uKG1lc3NhZ2UsICdyZWNvaWwnKTtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTsgLy8gQG9zcy1vbmx5XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyTm9kZShub2RlKSB7XG4gIGlmIChSZWNvaWxfUmVjb2lsRW52LlJFQ09JTF9EVVBMSUNBVEVfQVRPTV9LRVlfQ0hFQ0tJTkdfRU5BQkxFRCkge1xuICAgIGNoZWNrRm9yRHVwbGljYXRlQXRvbUtleShub2RlLmtleSk7XG4gIH1cblxuICBub2Rlcy5zZXQobm9kZS5rZXksIG5vZGUpO1xuICBjb25zdCByZWNvaWxWYWx1ZSA9IG5vZGUuc2V0ID09IG51bGwgPyBuZXcgUmVjb2lsX1JlY29pbFZhbHVlJDEuUmVjb2lsVmFsdWVSZWFkT25seShub2RlLmtleSkgOiBuZXcgUmVjb2lsX1JlY29pbFZhbHVlJDEuUmVjb2lsU3RhdGUobm9kZS5rZXkpO1xuICByZWNvaWxWYWx1ZXMuc2V0KG5vZGUua2V5LCByZWNvaWxWYWx1ZSk7XG4gIHJldHVybiByZWNvaWxWYWx1ZTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG5cblxuY2xhc3MgTm9kZU1pc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHt9IC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cblxuZnVuY3Rpb24gZ2V0Tm9kZShrZXkpIHtcbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xuXG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9kZU1pc3NpbmdFcnJvcihgTWlzc2luZyBkZWZpbml0aW9uIGZvciBSZWNvaWxWYWx1ZTogXCIke2tleX1cIlwiYCk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5mdW5jdGlvbiBnZXROb2RlTWF5YmUoa2V5KSB7XG4gIHJldHVybiBub2Rlcy5nZXQoa2V5KTtcbn1cblxuY29uc3QgY29uZmlnRGVsZXRpb25IYW5kbGVycyA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUoa2V5KSB7XG4gIHZhciBfbm9kZSRzaG91bGREZWxldGVDb247XG5cbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IG5vZGVzLmdldChrZXkpO1xuXG4gIGlmIChub2RlICE9PSBudWxsICYmIG5vZGUgIT09IHZvaWQgMCAmJiAoX25vZGUkc2hvdWxkRGVsZXRlQ29uID0gbm9kZS5zaG91bGREZWxldGVDb25maWdPblJlbGVhc2UpICE9PSBudWxsICYmIF9ub2RlJHNob3VsZERlbGV0ZUNvbiAhPT0gdm9pZCAwICYmIF9ub2RlJHNob3VsZERlbGV0ZUNvbi5jYWxsKG5vZGUpKSB7XG4gICAgdmFyIF9nZXRDb25maWdEZWxldGlvbkhhbjtcblxuICAgIG5vZGVzLmRlbGV0ZShrZXkpO1xuICAgIChfZ2V0Q29uZmlnRGVsZXRpb25IYW4gPSBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIoa2V5KSkgPT09IG51bGwgfHwgX2dldENvbmZpZ0RlbGV0aW9uSGFuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0Q29uZmlnRGVsZXRpb25IYW4oKTtcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLmRlbGV0ZShrZXkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcihrZXksIGZuKSB7XG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uZmlnRGVsZXRpb25IYW5kbGVycy5kZWxldGUoa2V5KTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWdEZWxldGlvbkhhbmRsZXJzLnNldChrZXksIGZuKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIoa2V5KSB7XG4gIHJldHVybiBjb25maWdEZWxldGlvbkhhbmRsZXJzLmdldChrZXkpO1xufVxuXG52YXIgUmVjb2lsX05vZGUgPSB7XG4gIG5vZGVzLFxuICByZWNvaWxWYWx1ZXMsXG4gIHJlZ2lzdGVyTm9kZSxcbiAgZ2V0Tm9kZSxcbiAgZ2V0Tm9kZU1heWJlLFxuICBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZSxcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyLFxuICBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIsXG4gIHJlY29pbFZhbHVlc0ZvcktleXMsXG4gIE5vZGVNaXNzaW5nRXJyb3IsXG4gIERlZmF1bHRWYWx1ZSxcbiAgREVGQVVMVF9WQUxVRVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBlbnF1ZXVlRXhlY3V0aW9uKHMsIGYpIHtcbiAgZigpO1xufVxuXG52YXIgUmVjb2lsX1F1ZXVlID0ge1xuICBlbnF1ZXVlRXhlY3V0aW9uXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVDb21tb25qc01vZHVsZShmbiwgbW9kdWxlKSB7XG5cdHJldHVybiBtb2R1bGUgPSB7IGV4cG9ydHM6IHt9IH0sIGZuKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMpLCBtb2R1bGUuZXhwb3J0cztcbn1cblxudmFyIGhhbXRfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG4vKipcbiAgICBAZmlsZU92ZXJ2aWV3IEhhc2ggQXJyYXkgTWFwcGVkIFRyaWUuXG5cbiAgICBDb2RlIGJhc2VkIG9uOiBodHRwczovL2dpdGh1Yi5jb20vZXhjbGlweS9wZGF0YVxuKi9cblxuXG52YXIgaGFtdCA9IHt9OyAvLyBleHBvcnRcblxuLyogQ29uZmlndXJhdGlvblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIFNJWkUgPSA1O1xudmFyIEJVQ0tFVF9TSVpFID0gTWF0aC5wb3coMiwgU0laRSk7XG52YXIgTUFTSyA9IEJVQ0tFVF9TSVpFIC0gMTtcbnZhciBNQVhfSU5ERVhfTk9ERSA9IEJVQ0tFVF9TSVpFIC8gMjtcbnZhciBNSU5fQVJSQVlfTk9ERSA9IEJVQ0tFVF9TSVpFIC8gNDtcbi8qXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgbm90aGluZyA9IHt9O1xuXG52YXIgY29uc3RhbnQgPSBmdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuLyoqXG4gICAgR2V0IDMyIGJpdCBoYXNoIG9mIHN0cmluZy5cblxuICAgIEJhc2VkIG9uOlxuICAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYxNjQ2MS9nZW5lcmF0ZS1hLWhhc2gtZnJvbS1zdHJpbmctaW4tamF2YXNjcmlwdC1qcXVlcnlcbiovXG5cblxudmFyIGhhc2ggPSBoYW10Lmhhc2ggPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3RyKTtcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKSByZXR1cm4gc3RyO1xuICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHN0ciArPSAnJztcbiAgdmFyIGhhc2ggPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjIHwgMDtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufTtcbi8qIEJpdCBPcHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIEhhbW1pbmcgd2VpZ2h0LlxuXG4gICAgVGFrZW4gZnJvbTogaHR0cDovL2pzcGVyZi5jb20vaGFtbWluZy13ZWlnaHRcbiovXG5cblxudmFyIHBvcGNvdW50ID0gZnVuY3Rpb24gcG9wY291bnQoeCkge1xuICB4IC09IHggPj4gMSAmIDB4NTU1NTU1NTU7XG4gIHggPSAoeCAmIDB4MzMzMzMzMzMpICsgKHggPj4gMiAmIDB4MzMzMzMzMzMpO1xuICB4ID0geCArICh4ID4+IDQpICYgMHgwZjBmMGYwZjtcbiAgeCArPSB4ID4+IDg7XG4gIHggKz0geCA+PiAxNjtcbiAgcmV0dXJuIHggJiAweDdmO1xufTtcblxudmFyIGhhc2hGcmFnbWVudCA9IGZ1bmN0aW9uIGhhc2hGcmFnbWVudChzaGlmdCwgaCkge1xuICByZXR1cm4gaCA+Pj4gc2hpZnQgJiBNQVNLO1xufTtcblxudmFyIHRvQml0bWFwID0gZnVuY3Rpb24gdG9CaXRtYXAoeCkge1xuICByZXR1cm4gMSA8PCB4O1xufTtcblxudmFyIGZyb21CaXRtYXAgPSBmdW5jdGlvbiBmcm9tQml0bWFwKGJpdG1hcCwgYml0KSB7XG4gIHJldHVybiBwb3Bjb3VudChiaXRtYXAgJiBiaXQgLSAxKTtcbn07XG4vKiBBcnJheSBPcHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIFNldCBhIHZhbHVlIGluIGFuIGFycmF5LlxuXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgdGhlIGlucHV0IGFycmF5IGJlIG11dGF0ZWQ/XG4gICAgQHBhcmFtIGF0IEluZGV4IHRvIGNoYW5nZS5cbiAgICBAcGFyYW0gdiBOZXcgdmFsdWVcbiAgICBAcGFyYW0gYXJyIEFycmF5LlxuKi9cblxuXG52YXIgYXJyYXlVcGRhdGUgPSBmdW5jdGlvbiBhcnJheVVwZGF0ZShtdXRhdGUsIGF0LCB2LCBhcnIpIHtcbiAgdmFyIG91dCA9IGFycjtcblxuICBpZiAoIW11dGF0ZSkge1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIG91dCA9IG5ldyBBcnJheShsZW4pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgb3V0W2ldID0gYXJyW2ldO1xuICAgIH1cbiAgfVxuXG4gIG91dFthdF0gPSB2O1xuICByZXR1cm4gb3V0O1xufTtcbi8qKlxuICAgIFJlbW92ZSBhIHZhbHVlIGZyb20gYW4gYXJyYXkuXG5cbiAgICBAcGFyYW0gbXV0YXRlIFNob3VsZCB0aGUgaW5wdXQgYXJyYXkgYmUgbXV0YXRlZD9cbiAgICBAcGFyYW0gYXQgSW5kZXggdG8gcmVtb3ZlLlxuICAgIEBwYXJhbSBhcnIgQXJyYXkuXG4qL1xuXG5cbnZhciBhcnJheVNwbGljZU91dCA9IGZ1bmN0aW9uIGFycmF5U3BsaWNlT3V0KG11dGF0ZSwgYXQsIGFycikge1xuICB2YXIgbmV3TGVuID0gYXJyLmxlbmd0aCAtIDE7XG4gIHZhciBpID0gMDtcbiAgdmFyIGcgPSAwO1xuICB2YXIgb3V0ID0gYXJyO1xuXG4gIGlmIChtdXRhdGUpIHtcbiAgICBpID0gZyA9IGF0O1xuICB9IGVsc2Uge1xuICAgIG91dCA9IG5ldyBBcnJheShuZXdMZW4pO1xuXG4gICAgd2hpbGUgKGkgPCBhdCkge1xuICAgICAgb3V0W2crK10gPSBhcnJbaSsrXTtcbiAgICB9XG4gIH1cblxuICArK2k7XG5cbiAgd2hpbGUgKGkgPD0gbmV3TGVuKSB7XG4gICAgb3V0W2crK10gPSBhcnJbaSsrXTtcbiAgfVxuXG4gIGlmIChtdXRhdGUpIHtcbiAgICBvdXQubGVuZ3RoID0gbmV3TGVuO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAgICBJbnNlcnQgYSB2YWx1ZSBpbnRvIGFuIGFycmF5LlxuXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgdGhlIGlucHV0IGFycmF5IGJlIG11dGF0ZWQ/XG4gICAgQHBhcmFtIGF0IEluZGV4IHRvIGluc2VydCBhdC5cbiAgICBAcGFyYW0gdiBWYWx1ZSB0byBpbnNlcnQsXG4gICAgQHBhcmFtIGFyciBBcnJheS5cbiovXG5cblxudmFyIGFycmF5U3BsaWNlSW4gPSBmdW5jdGlvbiBhcnJheVNwbGljZUluKG11dGF0ZSwgYXQsIHYsIGFycikge1xuICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICBpZiAobXV0YXRlKSB7XG4gICAgdmFyIF9pID0gbGVuO1xuXG4gICAgd2hpbGUgKF9pID49IGF0KSB7XG4gICAgICBhcnJbX2ktLV0gPSBhcnJbX2ldO1xuICAgIH1cblxuICAgIGFyclthdF0gPSB2O1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICB2YXIgaSA9IDAsXG4gICAgICBnID0gMDtcbiAgdmFyIG91dCA9IG5ldyBBcnJheShsZW4gKyAxKTtcblxuICB3aGlsZSAoaSA8IGF0KSB7XG4gICAgb3V0W2crK10gPSBhcnJbaSsrXTtcbiAgfVxuXG4gIG91dFthdF0gPSB2O1xuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgb3V0WysrZ10gPSBhcnJbaSsrXTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuLyogTm9kZSBTdHJ1Y3R1cmVzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbnZhciBMRUFGID0gMTtcbnZhciBDT0xMSVNJT04gPSAyO1xudmFyIElOREVYID0gMztcbnZhciBBUlJBWSA9IDQ7XG4vKipcbiAgICBFbXB0eSBub2RlLlxuKi9cblxudmFyIGVtcHR5ID0ge1xuICBfX2hhbXRfaXNFbXB0eTogdHJ1ZVxufTtcblxudmFyIGlzRW1wdHlOb2RlID0gZnVuY3Rpb24gaXNFbXB0eU5vZGUoeCkge1xuICByZXR1cm4geCA9PT0gZW1wdHkgfHwgeCAmJiB4Ll9faGFtdF9pc0VtcHR5O1xufTtcbi8qKlxuICAgIExlYWYgaG9sZGluZyBhIHZhbHVlLlxuXG4gICAgQG1lbWJlciBlZGl0IEVkaXQgb2YgdGhlIG5vZGUuXG4gICAgQG1lbWJlciBoYXNoIEhhc2ggb2Yga2V5LlxuICAgIEBtZW1iZXIga2V5IEtleS5cbiAgICBAbWVtYmVyIHZhbHVlIFZhbHVlIHN0b3JlZC5cbiovXG5cblxudmFyIExlYWYgPSBmdW5jdGlvbiBMZWFmKGVkaXQsIGhhc2gsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBMRUFGLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgaGFzaDogaGFzaCxcbiAgICBrZXk6IGtleSxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgX21vZGlmeTogTGVhZl9fbW9kaWZ5XG4gIH07XG59O1xuLyoqXG4gICAgTGVhZiBob2xkaW5nIG11bHRpcGxlIHZhbHVlcyB3aXRoIHRoZSBzYW1lIGhhc2ggYnV0IGRpZmZlcmVudCBrZXlzLlxuXG4gICAgQG1lbWJlciBlZGl0IEVkaXQgb2YgdGhlIG5vZGUuXG4gICAgQG1lbWJlciBoYXNoIEhhc2ggb2Yga2V5LlxuICAgIEBtZW1iZXIgY2hpbGRyZW4gQXJyYXkgb2YgY29sbGlzaW9uIGNoaWxkcmVuIG5vZGUuXG4qL1xuXG5cbnZhciBDb2xsaXNpb24gPSBmdW5jdGlvbiBDb2xsaXNpb24oZWRpdCwgaGFzaCwgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDT0xMSVNJT04sXG4gICAgZWRpdDogZWRpdCxcbiAgICBoYXNoOiBoYXNoLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBfbW9kaWZ5OiBDb2xsaXNpb25fX21vZGlmeVxuICB9O1xufTtcbi8qKlxuICAgIEludGVybmFsIG5vZGUgd2l0aCBhIHNwYXJzZSBzZXQgb2YgY2hpbGRyZW4uXG5cbiAgICBVc2VzIGEgYml0bWFwIGFuZCBhcnJheSB0byBwYWNrIGNoaWxkcmVuLlxuXG4gIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxuICAgIEBtZW1iZXIgbWFzayBCaXRtYXAgdGhhdCBlbmNvZGUgdGhlIHBvc2l0aW9ucyBvZiBjaGlsZHJlbiBpbiB0aGUgYXJyYXkuXG4gICAgQG1lbWJlciBjaGlsZHJlbiBBcnJheSBvZiBjaGlsZCBub2Rlcy5cbiovXG5cblxudmFyIEluZGV4ZWROb2RlID0gZnVuY3Rpb24gSW5kZXhlZE5vZGUoZWRpdCwgbWFzaywgY2hpbGRyZW4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBJTkRFWCxcbiAgICBlZGl0OiBlZGl0LFxuICAgIG1hc2s6IG1hc2ssXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIF9tb2RpZnk6IEluZGV4ZWROb2RlX19tb2RpZnlcbiAgfTtcbn07XG4vKipcbiAgICBJbnRlcm5hbCBub2RlIHdpdGggbWFueSBjaGlsZHJlbi5cblxuICAgIEBtZW1iZXIgZWRpdCBFZGl0IG9mIHRoZSBub2RlLlxuICAgIEBtZW1iZXIgc2l6ZSBOdW1iZXIgb2YgY2hpbGRyZW4uXG4gICAgQG1lbWJlciBjaGlsZHJlbiBBcnJheSBvZiBjaGlsZCBub2Rlcy5cbiovXG5cblxudmFyIEFycmF5Tm9kZSA9IGZ1bmN0aW9uIEFycmF5Tm9kZShlZGl0LCBzaXplLCBjaGlsZHJlbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFSUkFZLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgX21vZGlmeTogQXJyYXlOb2RlX19tb2RpZnlcbiAgfTtcbn07XG4vKipcbiAgICBJcyBgbm9kZWAgYSBsZWFmIG5vZGU/XG4qL1xuXG5cbnZhciBpc0xlYWYgPSBmdW5jdGlvbiBpc0xlYWYobm9kZSkge1xuICByZXR1cm4gbm9kZSA9PT0gZW1wdHkgfHwgbm9kZS50eXBlID09PSBMRUFGIHx8IG5vZGUudHlwZSA9PT0gQ09MTElTSU9OO1xufTtcbi8qIEludGVybmFsIG5vZGUgb3BlcmF0aW9ucy5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIEV4cGFuZCBhbiBpbmRleGVkIG5vZGUgaW50byBhbiBhcnJheSBub2RlLlxuXG4gIEBwYXJhbSBlZGl0IEN1cnJlbnQgZWRpdC5cbiAgICBAcGFyYW0gZnJhZyBJbmRleCBvZiBhZGRlZCBjaGlsZC5cbiAgICBAcGFyYW0gY2hpbGQgQWRkZWQgY2hpbGQuXG4gICAgQHBhcmFtIG1hc2sgSW5kZXggbm9kZSBtYXNrIGJlZm9yZSBjaGlsZCBhZGRlZC5cbiAgICBAcGFyYW0gc3ViTm9kZXMgSW5kZXggbm9kZSBjaGlsZHJlbiBiZWZvcmUgY2hpbGQgYWRkZWQuXG4qL1xuXG5cbnZhciBleHBhbmQgPSBmdW5jdGlvbiBleHBhbmQoZWRpdCwgZnJhZywgY2hpbGQsIGJpdG1hcCwgc3ViTm9kZXMpIHtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgYml0ID0gYml0bWFwO1xuICB2YXIgY291bnQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBiaXQ7ICsraSkge1xuICAgIGlmIChiaXQgJiAxKSBhcnJbaV0gPSBzdWJOb2Rlc1tjb3VudCsrXTtcbiAgICBiaXQgPj4+PSAxO1xuICB9XG5cbiAgYXJyW2ZyYWddID0gY2hpbGQ7XG4gIHJldHVybiBBcnJheU5vZGUoZWRpdCwgY291bnQgKyAxLCBhcnIpO1xufTtcbi8qKlxuICAgIENvbGxhcHNlIGFuIGFycmF5IG5vZGUgaW50byBhIGluZGV4ZWQgbm9kZS5cblxuICBAcGFyYW0gZWRpdCBDdXJyZW50IGVkaXQuXG4gICAgQHBhcmFtIGNvdW50IE51bWJlciBvZiBlbGVtZW50cyBpbiBuZXcgYXJyYXkuXG4gICAgQHBhcmFtIHJlbW92ZWQgSW5kZXggb2YgcmVtb3ZlZCBlbGVtZW50LlxuICAgIEBwYXJhbSBlbGVtZW50cyBBcnJheSBub2RlIGNoaWxkcmVuIGJlZm9yZSByZW1vdmUuXG4qL1xuXG5cbnZhciBwYWNrID0gZnVuY3Rpb24gcGFjayhlZGl0LCBjb3VudCwgcmVtb3ZlZCwgZWxlbWVudHMpIHtcbiAgdmFyIGNoaWxkcmVuID0gbmV3IEFycmF5KGNvdW50IC0gMSk7XG4gIHZhciBnID0gMDtcbiAgdmFyIGJpdG1hcCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGkgIT09IHJlbW92ZWQpIHtcbiAgICAgIHZhciBlbGVtID0gZWxlbWVudHNbaV07XG5cbiAgICAgIGlmIChlbGVtICYmICFpc0VtcHR5Tm9kZShlbGVtKSkge1xuICAgICAgICBjaGlsZHJlbltnKytdID0gZWxlbTtcbiAgICAgICAgYml0bWFwIHw9IDEgPDwgaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gSW5kZXhlZE5vZGUoZWRpdCwgYml0bWFwLCBjaGlsZHJlbik7XG59O1xuLyoqXG4gICAgTWVyZ2UgdHdvIGxlYWYgbm9kZXMuXG5cbiAgICBAcGFyYW0gc2hpZnQgQ3VycmVudCBzaGlmdC5cbiAgICBAcGFyYW0gaDEgTm9kZSAxIGhhc2guXG4gICAgQHBhcmFtIG4xIE5vZGUgMS5cbiAgICBAcGFyYW0gaDIgTm9kZSAyIGhhc2guXG4gICAgQHBhcmFtIG4yIE5vZGUgMi5cbiovXG5cblxudmFyIG1lcmdlTGVhdmVzID0gZnVuY3Rpb24gbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQsIGgxLCBuMSwgaDIsIG4yKSB7XG4gIGlmIChoMSA9PT0gaDIpIHJldHVybiBDb2xsaXNpb24oZWRpdCwgaDEsIFtuMiwgbjFdKTtcbiAgdmFyIHN1YkgxID0gaGFzaEZyYWdtZW50KHNoaWZ0LCBoMSk7XG4gIHZhciBzdWJIMiA9IGhhc2hGcmFnbWVudChzaGlmdCwgaDIpO1xuICByZXR1cm4gSW5kZXhlZE5vZGUoZWRpdCwgdG9CaXRtYXAoc3ViSDEpIHwgdG9CaXRtYXAoc3ViSDIpLCBzdWJIMSA9PT0gc3ViSDIgPyBbbWVyZ2VMZWF2ZXMoZWRpdCwgc2hpZnQgKyBTSVpFLCBoMSwgbjEsIGgyLCBuMildIDogc3ViSDEgPCBzdWJIMiA/IFtuMSwgbjJdIDogW24yLCBuMV0pO1xufTtcbi8qKlxuICAgIFVwZGF0ZSBhbiBlbnRyeSBpbiBhIGNvbGxpc2lvbiBsaXN0LlxuXG4gICAgQHBhcmFtIG11dGF0ZSBTaG91bGQgbXV0YXRpb24gYmUgdXNlZD9cbiAgICBAcGFyYW0gZWRpdCBDdXJyZW50IGVkaXQuXG4gICAgQHBhcmFtIGtleUVxIEtleSBjb21wYXJlIGZ1bmN0aW9uLlxuICAgIEBwYXJhbSBoYXNoIEhhc2ggb2YgY29sbGlzaW9uLlxuICAgIEBwYXJhbSBsaXN0IENvbGxpc2lvbiBsaXN0LlxuICAgIEBwYXJhbSBmIFVwZGF0ZSBmdW5jdGlvbi5cbiAgICBAcGFyYW0gayBLZXkgdG8gdXBkYXRlLlxuICAgIEBwYXJhbSBzaXplIFNpemUgcmVmLlxuKi9cblxuXG52YXIgdXBkYXRlQ29sbGlzaW9uTGlzdCA9IGZ1bmN0aW9uIHVwZGF0ZUNvbGxpc2lvbkxpc3QobXV0YXRlLCBlZGl0LCBrZXlFcSwgaCwgbGlzdCwgZiwgaywgc2l6ZSkge1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciBjaGlsZCA9IGxpc3RbaV07XG5cbiAgICBpZiAoa2V5RXEoaywgY2hpbGQua2V5KSkge1xuICAgICAgdmFyIHZhbHVlID0gY2hpbGQudmFsdWU7XG5cbiAgICAgIHZhciBfbmV3VmFsdWUgPSBmKHZhbHVlKTtcblxuICAgICAgaWYgKF9uZXdWYWx1ZSA9PT0gdmFsdWUpIHJldHVybiBsaXN0O1xuXG4gICAgICBpZiAoX25ld1ZhbHVlID09PSBub3RoaW5nKSB7XG4gICAgICAgIC0tc2l6ZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGFycmF5U3BsaWNlT3V0KG11dGF0ZSwgaSwgbGlzdCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheVVwZGF0ZShtdXRhdGUsIGksIExlYWYoZWRpdCwgaCwgaywgX25ld1ZhbHVlKSwgbGlzdCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld1ZhbHVlID0gZigpO1xuICBpZiAobmV3VmFsdWUgPT09IG5vdGhpbmcpIHJldHVybiBsaXN0O1xuICArK3NpemUudmFsdWU7XG4gIHJldHVybiBhcnJheVVwZGF0ZShtdXRhdGUsIGxlbiwgTGVhZihlZGl0LCBoLCBrLCBuZXdWYWx1ZSksIGxpc3QpO1xufTtcblxudmFyIGNhbkVkaXROb2RlID0gZnVuY3Rpb24gY2FuRWRpdE5vZGUoZWRpdCwgbm9kZSkge1xuICByZXR1cm4gZWRpdCA9PT0gbm9kZS5lZGl0O1xufTtcbi8qIEVkaXRpbmdcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxudmFyIExlYWZfX21vZGlmeSA9IGZ1bmN0aW9uIExlYWZfX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcbiAgaWYgKGtleUVxKGssIHRoaXMua2V5KSkge1xuICAgIHZhciBfdiA9IGYodGhpcy52YWx1ZSk7XG5cbiAgICBpZiAoX3YgPT09IHRoaXMudmFsdWUpIHJldHVybiB0aGlzO2Vsc2UgaWYgKF92ID09PSBub3RoaW5nKSB7XG4gICAgICAtLXNpemUudmFsdWU7XG4gICAgICByZXR1cm4gZW1wdHk7XG4gICAgfVxuXG4gICAgaWYgKGNhbkVkaXROb2RlKGVkaXQsIHRoaXMpKSB7XG4gICAgICB0aGlzLnZhbHVlID0gX3Y7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTGVhZihlZGl0LCBoLCBrLCBfdik7XG4gIH1cblxuICB2YXIgdiA9IGYoKTtcbiAgaWYgKHYgPT09IG5vdGhpbmcpIHJldHVybiB0aGlzO1xuICArK3NpemUudmFsdWU7XG4gIHJldHVybiBtZXJnZUxlYXZlcyhlZGl0LCBzaGlmdCwgdGhpcy5oYXNoLCB0aGlzLCBoLCBMZWFmKGVkaXQsIGgsIGssIHYpKTtcbn07XG5cbnZhciBDb2xsaXNpb25fX21vZGlmeSA9IGZ1bmN0aW9uIENvbGxpc2lvbl9fbW9kaWZ5KGVkaXQsIGtleUVxLCBzaGlmdCwgZiwgaCwgaywgc2l6ZSkge1xuICBpZiAoaCA9PT0gdGhpcy5oYXNoKSB7XG4gICAgdmFyIGNhbkVkaXQgPSBjYW5FZGl0Tm9kZShlZGl0LCB0aGlzKTtcbiAgICB2YXIgbGlzdCA9IHVwZGF0ZUNvbGxpc2lvbkxpc3QoY2FuRWRpdCwgZWRpdCwga2V5RXEsIHRoaXMuaGFzaCwgdGhpcy5jaGlsZHJlbiwgZiwgaywgc2l6ZSk7XG4gICAgaWYgKGxpc3QgPT09IHRoaXMuY2hpbGRyZW4pIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBsaXN0Lmxlbmd0aCA+IDEgPyBDb2xsaXNpb24oZWRpdCwgdGhpcy5oYXNoLCBsaXN0KSA6IGxpc3RbMF07IC8vIGNvbGxhcHNlIHNpbmdsZSBlbGVtZW50IGNvbGxpc2lvbiBsaXN0XG4gIH1cblxuICB2YXIgdiA9IGYoKTtcbiAgaWYgKHYgPT09IG5vdGhpbmcpIHJldHVybiB0aGlzO1xuICArK3NpemUudmFsdWU7XG4gIHJldHVybiBtZXJnZUxlYXZlcyhlZGl0LCBzaGlmdCwgdGhpcy5oYXNoLCB0aGlzLCBoLCBMZWFmKGVkaXQsIGgsIGssIHYpKTtcbn07XG5cbnZhciBJbmRleGVkTm9kZV9fbW9kaWZ5ID0gZnVuY3Rpb24gSW5kZXhlZE5vZGVfX21vZGlmeShlZGl0LCBrZXlFcSwgc2hpZnQsIGYsIGgsIGssIHNpemUpIHtcbiAgdmFyIG1hc2sgPSB0aGlzLm1hc2s7XG4gIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gIHZhciBmcmFnID0gaGFzaEZyYWdtZW50KHNoaWZ0LCBoKTtcbiAgdmFyIGJpdCA9IHRvQml0bWFwKGZyYWcpO1xuICB2YXIgaW5keCA9IGZyb21CaXRtYXAobWFzaywgYml0KTtcbiAgdmFyIGV4aXN0cyA9IG1hc2sgJiBiaXQ7XG4gIHZhciBjdXJyZW50ID0gZXhpc3RzID8gY2hpbGRyZW5baW5keF0gOiBlbXB0eTtcblxuICB2YXIgY2hpbGQgPSBjdXJyZW50Ll9tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0ICsgU0laRSwgZiwgaCwgaywgc2l6ZSk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IGNoaWxkKSByZXR1cm4gdGhpcztcbiAgdmFyIGNhbkVkaXQgPSBjYW5FZGl0Tm9kZShlZGl0LCB0aGlzKTtcbiAgdmFyIGJpdG1hcCA9IG1hc2s7XG4gIHZhciBuZXdDaGlsZHJlbiA9IHZvaWQgMDtcblxuICBpZiAoZXhpc3RzICYmIGlzRW1wdHlOb2RlKGNoaWxkKSkge1xuICAgIC8vIHJlbW92ZVxuICAgIGJpdG1hcCAmPSB+Yml0O1xuICAgIGlmICghYml0bWFwKSByZXR1cm4gZW1wdHk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA8PSAyICYmIGlzTGVhZihjaGlsZHJlbltpbmR4IF4gMV0pKSByZXR1cm4gY2hpbGRyZW5baW5keCBeIDFdOyAvLyBjb2xsYXBzZVxuXG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVNwbGljZU91dChjYW5FZGl0LCBpbmR4LCBjaGlsZHJlbik7XG4gIH0gZWxzZSBpZiAoIWV4aXN0cyAmJiAhaXNFbXB0eU5vZGUoY2hpbGQpKSB7XG4gICAgLy8gYWRkXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+PSBNQVhfSU5ERVhfTk9ERSkgcmV0dXJuIGV4cGFuZChlZGl0LCBmcmFnLCBjaGlsZCwgbWFzaywgY2hpbGRyZW4pO1xuICAgIGJpdG1hcCB8PSBiaXQ7XG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVNwbGljZUluKGNhbkVkaXQsIGluZHgsIGNoaWxkLCBjaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbW9kaWZ5XG4gICAgbmV3Q2hpbGRyZW4gPSBhcnJheVVwZGF0ZShjYW5FZGl0LCBpbmR4LCBjaGlsZCwgY2hpbGRyZW4pO1xuICB9XG5cbiAgaWYgKGNhbkVkaXQpIHtcbiAgICB0aGlzLm1hc2sgPSBiaXRtYXA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmV0dXJuIEluZGV4ZWROb2RlKGVkaXQsIGJpdG1hcCwgbmV3Q2hpbGRyZW4pO1xufTtcblxudmFyIEFycmF5Tm9kZV9fbW9kaWZ5ID0gZnVuY3Rpb24gQXJyYXlOb2RlX19tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIHZhciBjb3VudCA9IHRoaXMuc2l6ZTtcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgdmFyIGZyYWcgPSBoYXNoRnJhZ21lbnQoc2hpZnQsIGgpO1xuICB2YXIgY2hpbGQgPSBjaGlsZHJlbltmcmFnXTtcblxuICB2YXIgbmV3Q2hpbGQgPSAoY2hpbGQgfHwgZW1wdHkpLl9tb2RpZnkoZWRpdCwga2V5RXEsIHNoaWZ0ICsgU0laRSwgZiwgaCwgaywgc2l6ZSk7XG5cbiAgaWYgKGNoaWxkID09PSBuZXdDaGlsZCkgcmV0dXJuIHRoaXM7XG4gIHZhciBjYW5FZGl0ID0gY2FuRWRpdE5vZGUoZWRpdCwgdGhpcyk7XG4gIHZhciBuZXdDaGlsZHJlbiA9IHZvaWQgMDtcblxuICBpZiAoaXNFbXB0eU5vZGUoY2hpbGQpICYmICFpc0VtcHR5Tm9kZShuZXdDaGlsZCkpIHtcbiAgICAvLyBhZGRcbiAgICArK2NvdW50O1xuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlVcGRhdGUoY2FuRWRpdCwgZnJhZywgbmV3Q2hpbGQsIGNoaWxkcmVuKTtcbiAgfSBlbHNlIGlmICghaXNFbXB0eU5vZGUoY2hpbGQpICYmIGlzRW1wdHlOb2RlKG5ld0NoaWxkKSkge1xuICAgIC8vIHJlbW92ZVxuICAgIC0tY291bnQ7XG4gICAgaWYgKGNvdW50IDw9IE1JTl9BUlJBWV9OT0RFKSByZXR1cm4gcGFjayhlZGl0LCBjb3VudCwgZnJhZywgY2hpbGRyZW4pO1xuICAgIG5ld0NoaWxkcmVuID0gYXJyYXlVcGRhdGUoY2FuRWRpdCwgZnJhZywgZW1wdHksIGNoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtb2RpZnlcbiAgICBuZXdDaGlsZHJlbiA9IGFycmF5VXBkYXRlKGNhbkVkaXQsIGZyYWcsIG5ld0NoaWxkLCBjaGlsZHJlbik7XG4gIH1cblxuICBpZiAoY2FuRWRpdCkge1xuICAgIHRoaXMuc2l6ZSA9IGNvdW50O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJldHVybiBBcnJheU5vZGUoZWRpdCwgY291bnQsIG5ld0NoaWxkcmVuKTtcbn07XG5cbmVtcHR5Ll9tb2RpZnkgPSBmdW5jdGlvbiAoZWRpdCwga2V5RXEsIHNoaWZ0LCBmLCBoLCBrLCBzaXplKSB7XG4gIHZhciB2ID0gZigpO1xuICBpZiAodiA9PT0gbm90aGluZykgcmV0dXJuIGVtcHR5O1xuICArK3NpemUudmFsdWU7XG4gIHJldHVybiBMZWFmKGVkaXQsIGgsIGssIHYpO1xufTtcbi8qXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbmZ1bmN0aW9uIE1hcChlZGl0YWJsZSwgZWRpdCwgY29uZmlnLCByb290LCBzaXplKSB7XG4gIHRoaXMuX2VkaXRhYmxlID0gZWRpdGFibGU7XG4gIHRoaXMuX2VkaXQgPSBlZGl0O1xuICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9zaXplID0gc2l6ZTtcbn1cblxuTWFwLnByb3RvdHlwZS5zZXRUcmVlID0gZnVuY3Rpb24gKG5ld1Jvb3QsIG5ld1NpemUpIHtcbiAgaWYgKHRoaXMuX2VkaXRhYmxlKSB7XG4gICAgdGhpcy5fcm9vdCA9IG5ld1Jvb3Q7XG4gICAgdGhpcy5fc2l6ZSA9IG5ld1NpemU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXR1cm4gbmV3Um9vdCA9PT0gdGhpcy5fcm9vdCA/IHRoaXMgOiBuZXcgTWFwKHRoaXMuX2VkaXRhYmxlLCB0aGlzLl9lZGl0LCB0aGlzLl9jb25maWcsIG5ld1Jvb3QsIG5ld1NpemUpO1xufTtcbi8qIFF1ZXJpZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGEgY3VzdG9tIGBoYXNoYC5cblxuICAgIFJldHVybnMgdGhlIHZhbHVlIG9yIGBhbHRgIGlmIG5vbmUuXG4qL1xuXG5cbnZhciB0cnlHZXRIYXNoID0gaGFtdC50cnlHZXRIYXNoID0gZnVuY3Rpb24gKGFsdCwgaGFzaCwga2V5LCBtYXApIHtcbiAgdmFyIG5vZGUgPSBtYXAuX3Jvb3Q7XG4gIHZhciBzaGlmdCA9IDA7XG4gIHZhciBrZXlFcSA9IG1hcC5fY29uZmlnLmtleUVxO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgTEVBRjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBrZXlFcShrZXksIG5vZGUua2V5KSA/IG5vZGUudmFsdWUgOiBhbHQ7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDT0xMSVNJT046XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaGFzaCA9PT0gbm9kZS5oYXNoKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgIGlmIChrZXlFcShrZXksIGNoaWxkLmtleSkpIHJldHVybiBjaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgSU5ERVg6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZnJhZyA9IGhhc2hGcmFnbWVudChzaGlmdCwgaGFzaCk7XG4gICAgICAgICAgdmFyIGJpdCA9IHRvQml0bWFwKGZyYWcpO1xuXG4gICAgICAgICAgaWYgKG5vZGUubWFzayAmIGJpdCkge1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bZnJvbUJpdG1hcChub2RlLm1hc2ssIGJpdCldO1xuICAgICAgICAgICAgc2hpZnQgKz0gU0laRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhbHQ7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBBUlJBWTpcbiAgICAgICAge1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW2hhc2hGcmFnbWVudChzaGlmdCwgaGFzaCldO1xuXG4gICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIHNoaWZ0ICs9IFNJWkU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBhbHQ7XG4gICAgfVxuICB9XG59O1xuXG5NYXAucHJvdG90eXBlLnRyeUdldEhhc2ggPSBmdW5jdGlvbiAoYWx0LCBoYXNoLCBrZXkpIHtcbiAgcmV0dXJuIHRyeUdldEhhc2goYWx0LCBoYXNoLCBrZXksIHRoaXMpO1xufTtcbi8qKlxuICAgIExvb2t1cCB0aGUgdmFsdWUgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGB0cnlHZXRIYXNoYFxuKi9cblxuXG52YXIgdHJ5R2V0ID0gaGFtdC50cnlHZXQgPSBmdW5jdGlvbiAoYWx0LCBrZXksIG1hcCkge1xuICByZXR1cm4gdHJ5R2V0SGFzaChhbHQsIG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS50cnlHZXQgPSBmdW5jdGlvbiAoYWx0LCBrZXkpIHtcbiAgcmV0dXJuIHRyeUdldChhbHQsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgTG9va3VwIHRoZSB2YWx1ZSBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgYSBjdXN0b20gYGhhc2hgLlxuXG4gICAgUmV0dXJucyB0aGUgdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWYgbm9uZS5cbiovXG5cblxudmFyIGdldEhhc2ggPSBoYW10LmdldEhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCBtYXApIHtcbiAgcmV0dXJuIHRyeUdldEhhc2godW5kZWZpbmVkLCBoYXNoLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLmdldEhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XG4gIHJldHVybiBnZXRIYXNoKGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgTG9va3VwIHRoZSB2YWx1ZSBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cblxuICAgIEBzZWUgYGdldGBcbiovXG5cblxudmFyIGdldCA9IGhhbXQuZ2V0ID0gZnVuY3Rpb24gKGtleSwgbWFwKSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKHVuZGVmaW5lZCwgbWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXksIGFsdCkge1xuICByZXR1cm4gdHJ5R2V0KGFsdCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBEb2VzIGFuIGVudHJ5IGV4aXN0IGZvciBga2V5YCBpbiBgbWFwYD8gVXNlcyBjdXN0b20gYGhhc2hgLlxuKi9cblxuXG52YXIgaGFzSGFzaCA9IGhhbXQuaGFzID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgbWFwKSB7XG4gIHJldHVybiB0cnlHZXRIYXNoKG5vdGhpbmcsIGhhc2gsIGtleSwgbWFwKSAhPT0gbm90aGluZztcbn07XG5cbk1hcC5wcm90b3R5cGUuaGFzSGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXkpIHtcbiAgcmV0dXJuIGhhc0hhc2goaGFzaCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBEb2VzIGFuIGVudHJ5IGV4aXN0IGZvciBga2V5YCBpbiBgbWFwYD8gVXNlcyBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuKi9cblxuXG52YXIgaGFzID0gaGFtdC5oYXMgPSBmdW5jdGlvbiAoa2V5LCBtYXApIHtcbiAgcmV0dXJuIGhhc0hhc2gobWFwLl9jb25maWcuaGFzaChrZXkpLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGhhcyhrZXksIHRoaXMpO1xufTtcblxudmFyIGRlZktleUNvbXBhcmUgPSBmdW5jdGlvbiBkZWZLZXlDb21wYXJlKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHk7XG59O1xuLyoqXG4gICAgQ3JlYXRlIGFuIGVtcHR5IG1hcC5cblxuICAgIEBwYXJhbSBjb25maWcgQ29uZmlndXJhdGlvbi5cbiovXG5cblxuaGFtdC5tYWtlID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICByZXR1cm4gbmV3IE1hcCgwLCAwLCB7XG4gICAga2V5RXE6IGNvbmZpZyAmJiBjb25maWcua2V5RXEgfHwgZGVmS2V5Q29tcGFyZSxcbiAgICBoYXNoOiBjb25maWcgJiYgY29uZmlnLmhhc2ggfHwgaGFzaFxuICB9LCBlbXB0eSwgMCk7XG59O1xuLyoqXG4gICAgRW1wdHkgbWFwLlxuKi9cblxuXG5oYW10LmVtcHR5ID0gaGFtdC5tYWtlKCk7XG4vKipcbiAgICBEb2VzIGBtYXBgIGNvbnRhaW4gYW55IGVsZW1lbnRzP1xuKi9cblxudmFyIGlzRW1wdHkgPSBoYW10LmlzRW1wdHkgPSBmdW5jdGlvbiAobWFwKSB7XG4gIHJldHVybiBtYXAgJiYgISFpc0VtcHR5Tm9kZShtYXAuX3Jvb3QpO1xufTtcblxuTWFwLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFbXB0eSh0aGlzKTtcbn07XG4vKiBVcGRhdGVzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBBbHRlciB0aGUgdmFsdWUgc3RvcmVkIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBmdW5jdGlvbiBgZmAgdXNpbmdcbiAgICBjdXN0b20gaGFzaC5cblxuICAgIGBmYCBpcyBpbnZva2VkIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgZm9yIGBrYCBpZiBpdCBleGlzdHMsXG4gICAgb3Igbm8gYXJndW1lbnRzIGlmIG5vIHN1Y2ggdmFsdWUgZXhpc3RzLiBgbW9kaWZ5YCB3aWxsIGFsd2F5cyBlaXRoZXJcbiAgICB1cGRhdGUgb3IgaW5zZXJ0IGEgdmFsdWUgaW50byB0aGUgbWFwLlxuXG4gICAgUmV0dXJucyBhIG1hcCB3aXRoIHRoZSBtb2RpZmllZCB2YWx1ZS4gRG9lcyBub3QgYWx0ZXIgYG1hcGAuXG4qL1xuXG5cbnZhciBtb2RpZnlIYXNoID0gaGFtdC5tb2RpZnlIYXNoID0gZnVuY3Rpb24gKGYsIGhhc2gsIGtleSwgbWFwKSB7XG4gIHZhciBzaXplID0ge1xuICAgIHZhbHVlOiBtYXAuX3NpemVcbiAgfTtcblxuICB2YXIgbmV3Um9vdCA9IG1hcC5fcm9vdC5fbW9kaWZ5KG1hcC5fZWRpdGFibGUgPyBtYXAuX2VkaXQgOiBOYU4sIG1hcC5fY29uZmlnLmtleUVxLCAwLCBmLCBoYXNoLCBrZXksIHNpemUpO1xuXG4gIHJldHVybiBtYXAuc2V0VHJlZShuZXdSb290LCBzaXplLnZhbHVlKTtcbn07XG5cbk1hcC5wcm90b3R5cGUubW9kaWZ5SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIGYpIHtcbiAgcmV0dXJuIG1vZGlmeUhhc2goZiwgaGFzaCwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBBbHRlciB0aGUgdmFsdWUgc3RvcmVkIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBmdW5jdGlvbiBgZmAgdXNpbmdcbiAgICBpbnRlcm5hbCBoYXNoIGZ1bmN0aW9uLlxuXG4gICAgQHNlZSBgbW9kaWZ5SGFzaGBcbiovXG5cblxudmFyIG1vZGlmeSA9IGhhbXQubW9kaWZ5ID0gZnVuY3Rpb24gKGYsIGtleSwgbWFwKSB7XG4gIHJldHVybiBtb2RpZnlIYXNoKGYsIG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCBtYXApO1xufTtcblxuTWFwLnByb3RvdHlwZS5tb2RpZnkgPSBmdW5jdGlvbiAoa2V5LCBmKSB7XG4gIHJldHVybiBtb2RpZnkoZiwga2V5LCB0aGlzKTtcbn07XG4vKipcbiAgICBTdG9yZSBgdmFsdWVgIGZvciBga2V5YCBpbiBgbWFwYCB1c2luZyBjdXN0b20gYGhhc2hgLlxuXG4gICAgUmV0dXJucyBhIG1hcCB3aXRoIHRoZSBtb2RpZmllZCB2YWx1ZS4gRG9lcyBub3QgYWx0ZXIgYG1hcGAuXG4qL1xuXG5cbnZhciBzZXRIYXNoID0gaGFtdC5zZXRIYXNoID0gZnVuY3Rpb24gKGhhc2gsIGtleSwgdmFsdWUsIG1hcCkge1xuICByZXR1cm4gbW9kaWZ5SGFzaChjb25zdGFudCh2YWx1ZSksIGhhc2gsIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuc2V0SGFzaCA9IGZ1bmN0aW9uIChoYXNoLCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzZXRIYXNoKGhhc2gsIGtleSwgdmFsdWUsIHRoaXMpO1xufTtcbi8qKlxuICAgIFN0b3JlIGB2YWx1ZWAgZm9yIGBrZXlgIGluIGBtYXBgIHVzaW5nIGludGVybmFsIGhhc2ggZnVuY3Rpb24uXG5cbiAgICBAc2VlIGBzZXRIYXNoYFxuKi9cblxuXG52YXIgc2V0ID0gaGFtdC5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgbWFwKSB7XG4gIHJldHVybiBzZXRIYXNoKG1hcC5fY29uZmlnLmhhc2goa2V5KSwga2V5LCB2YWx1ZSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHNldChrZXksIHZhbHVlLCB0aGlzKTtcbn07XG4vKipcbiAgICBSZW1vdmUgdGhlIGVudHJ5IGZvciBga2V5YCBpbiBgbWFwYC5cblxuICAgIFJldHVybnMgYSBtYXAgd2l0aCB0aGUgdmFsdWUgcmVtb3ZlZC4gRG9lcyBub3QgYWx0ZXIgYG1hcGAuXG4qL1xuXG5cbnZhciBkZWwgPSBjb25zdGFudChub3RoaW5nKTtcblxudmFyIHJlbW92ZUhhc2ggPSBoYW10LnJlbW92ZUhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5LCBtYXApIHtcbiAgcmV0dXJuIG1vZGlmeUhhc2goZGVsLCBoYXNoLCBrZXksIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLnJlbW92ZUhhc2ggPSBNYXAucHJvdG90eXBlLmRlbGV0ZUhhc2ggPSBmdW5jdGlvbiAoaGFzaCwga2V5KSB7XG4gIHJldHVybiByZW1vdmVIYXNoKGhhc2gsIGtleSwgdGhpcyk7XG59O1xuLyoqXG4gICAgUmVtb3ZlIHRoZSBlbnRyeSBmb3IgYGtleWAgaW4gYG1hcGAgdXNpbmcgaW50ZXJuYWwgaGFzaCBmdW5jdGlvbi5cblxuICAgIEBzZWUgYHJlbW92ZUhhc2hgXG4qL1xuXG5cbnZhciByZW1vdmUgPSBoYW10LnJlbW92ZSA9IGZ1bmN0aW9uIChrZXksIG1hcCkge1xuICByZXR1cm4gcmVtb3ZlSGFzaChtYXAuX2NvbmZpZy5oYXNoKGtleSksIGtleSwgbWFwKTtcbn07XG5cbk1hcC5wcm90b3R5cGUucmVtb3ZlID0gTWFwLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiByZW1vdmUoa2V5LCB0aGlzKTtcbn07XG4vKiBNdXRhdGlvblxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gICAgTWFyayBgbWFwYCBhcyBtdXRhYmxlLlxuICovXG5cblxudmFyIGJlZ2luTXV0YXRpb24gPSBoYW10LmJlZ2luTXV0YXRpb24gPSBmdW5jdGlvbiAobWFwKSB7XG4gIHJldHVybiBuZXcgTWFwKG1hcC5fZWRpdGFibGUgKyAxLCBtYXAuX2VkaXQgKyAxLCBtYXAuX2NvbmZpZywgbWFwLl9yb290LCBtYXAuX3NpemUpO1xufTtcblxuTWFwLnByb3RvdHlwZS5iZWdpbk11dGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gYmVnaW5NdXRhdGlvbih0aGlzKTtcbn07XG4vKipcbiAgICBNYXJrIGBtYXBgIGFzIGltbXV0YWJsZS5cbiAqL1xuXG5cbnZhciBlbmRNdXRhdGlvbiA9IGhhbXQuZW5kTXV0YXRpb24gPSBmdW5jdGlvbiAobWFwKSB7XG4gIG1hcC5fZWRpdGFibGUgPSBtYXAuX2VkaXRhYmxlICYmIG1hcC5fZWRpdGFibGUgLSAxO1xuICByZXR1cm4gbWFwO1xufTtcblxuTWFwLnByb3RvdHlwZS5lbmRNdXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGVuZE11dGF0aW9uKHRoaXMpO1xufTtcbi8qKlxuICAgIE11dGF0ZSBgbWFwYCB3aXRoaW4gdGhlIGNvbnRleHQgb2YgYGZgLlxuICAgIEBwYXJhbSBmXG4gICAgQHBhcmFtIG1hcCBIQU1UXG4qL1xuXG5cbnZhciBtdXRhdGUgPSBoYW10Lm11dGF0ZSA9IGZ1bmN0aW9uIChmLCBtYXApIHtcbiAgdmFyIHRyYW5zaWVudCA9IGJlZ2luTXV0YXRpb24obWFwKTtcbiAgZih0cmFuc2llbnQpO1xuICByZXR1cm4gZW5kTXV0YXRpb24odHJhbnNpZW50KTtcbn07XG5cbk1hcC5wcm90b3R5cGUubXV0YXRlID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIG11dGF0ZShmLCB0aGlzKTtcbn07XG4vKiBUcmF2ZXJzYWxcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIEFwcGx5IGEgY29udGludWF0aW9uLlxuKi9cblxuXG52YXIgYXBwayA9IGZ1bmN0aW9uIGFwcGsoaykge1xuICByZXR1cm4gayAmJiBsYXp5VmlzaXRDaGlsZHJlbihrWzBdLCBrWzFdLCBrWzJdLCBrWzNdLCBrWzRdKTtcbn07XG4vKipcbiAgICBSZWN1cnNpdmVseSB2aXNpdCBhbGwgdmFsdWVzIHN0b3JlZCBpbiBhbiBhcnJheSBvZiBub2RlcyBsYXppbHkuXG4qL1xuXG5cbnZhciBsYXp5VmlzaXRDaGlsZHJlbiA9IGZ1bmN0aW9uIGxhenlWaXNpdENoaWxkcmVuKGxlbiwgY2hpbGRyZW4sIGksIGYsIGspIHtcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpKytdO1xuICAgIGlmIChjaGlsZCAmJiAhaXNFbXB0eU5vZGUoY2hpbGQpKSByZXR1cm4gbGF6eVZpc2l0KGNoaWxkLCBmLCBbbGVuLCBjaGlsZHJlbiwgaSwgZiwga10pO1xuICB9XG5cbiAgcmV0dXJuIGFwcGsoayk7XG59O1xuLyoqXG4gICAgUmVjdXJzaXZlbHkgdmlzaXQgYWxsIHZhbHVlcyBzdG9yZWQgaW4gYG5vZGVgIGxhemlseS5cbiovXG5cblxudmFyIGxhenlWaXNpdCA9IGZ1bmN0aW9uIGxhenlWaXNpdChub2RlLCBmLCBrKSB7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBMRUFGOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGYobm9kZSksXG4gICAgICAgIHJlc3Q6IGtcbiAgICAgIH07XG5cbiAgICBjYXNlIENPTExJU0lPTjpcbiAgICBjYXNlIEFSUkFZOlxuICAgIGNhc2UgSU5ERVg6XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgcmV0dXJuIGxhenlWaXNpdENoaWxkcmVuKGNoaWxkcmVuLmxlbmd0aCwgY2hpbGRyZW4sIDAsIGYsIGspO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBhcHBrKGspO1xuICB9XG59O1xuXG52YXIgRE9ORSA9IHtcbiAgZG9uZTogdHJ1ZVxufTtcbi8qKlxuICAgIEphdmFzY3JpcHQgaXRlcmF0b3Igb3ZlciBhIG1hcC5cbiovXG5cbmZ1bmN0aW9uIE1hcEl0ZXJhdG9yKHYpIHtcbiAgdGhpcy52ID0gdjtcbn1cblxuTWFwSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy52KSByZXR1cm4gRE9ORTtcbiAgdmFyIHYwID0gdGhpcy52O1xuICB0aGlzLnYgPSBhcHBrKHYwLnJlc3QpO1xuICByZXR1cm4gdjA7XG59O1xuXG5NYXBJdGVyYXRvci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gICAgTGF6aWx5IHZpc2l0IGVhY2ggdmFsdWUgaW4gbWFwIHdpdGggZnVuY3Rpb24gYGZgLlxuKi9cblxuXG52YXIgdmlzaXQgPSBmdW5jdGlvbiB2aXNpdChtYXAsIGYpIHtcbiAgcmV0dXJuIG5ldyBNYXBJdGVyYXRvcihsYXp5VmlzaXQobWFwLl9yb290LCBmKSk7XG59O1xuLyoqXG4gICAgR2V0IGEgSmF2YXNjc3JpcHQgaXRlcmF0b3Igb2YgYG1hcGAuXG5cbiAgICBJdGVyYXRlcyBvdmVyIGBba2V5LCB2YWx1ZV1gIGFycmF5cy5cbiovXG5cblxudmFyIGJ1aWxkUGFpcnMgPSBmdW5jdGlvbiBidWlsZFBhaXJzKHgpIHtcbiAgcmV0dXJuIFt4LmtleSwgeC52YWx1ZV07XG59O1xuXG52YXIgZW50cmllcyA9IGhhbXQuZW50cmllcyA9IGZ1bmN0aW9uIChtYXApIHtcbiAgcmV0dXJuIHZpc2l0KG1hcCwgYnVpbGRQYWlycyk7XG59O1xuXG5NYXAucHJvdG90eXBlLmVudHJpZXMgPSBNYXAucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBlbnRyaWVzKHRoaXMpO1xufTtcbi8qKlxuICAgIEdldCBhcnJheSBvZiBhbGwga2V5cyBpbiBgbWFwYC5cblxuICAgIE9yZGVyIGlzIG5vdCBndWFyYW50ZWVkLlxuKi9cblxuXG52YXIgYnVpbGRLZXlzID0gZnVuY3Rpb24gYnVpbGRLZXlzKHgpIHtcbiAgcmV0dXJuIHgua2V5O1xufTtcblxudmFyIGtleXMgPSBoYW10LmtleXMgPSBmdW5jdGlvbiAobWFwKSB7XG4gIHJldHVybiB2aXNpdChtYXAsIGJ1aWxkS2V5cyk7XG59O1xuXG5NYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBrZXlzKHRoaXMpO1xufTtcbi8qKlxuICAgIEdldCBhcnJheSBvZiBhbGwgdmFsdWVzIGluIGBtYXBgLlxuXG4gICAgT3JkZXIgaXMgbm90IGd1YXJhbnRlZWQsIGR1cGxpY2F0ZXMgYXJlIHByZXNlcnZlZC5cbiovXG5cblxudmFyIGJ1aWxkVmFsdWVzID0gZnVuY3Rpb24gYnVpbGRWYWx1ZXMoeCkge1xuICByZXR1cm4geC52YWx1ZTtcbn07XG5cbnZhciB2YWx1ZXMgPSBoYW10LnZhbHVlcyA9IE1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKG1hcCkge1xuICByZXR1cm4gdmlzaXQobWFwLCBidWlsZFZhbHVlcyk7XG59O1xuXG5NYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHZhbHVlcyh0aGlzKTtcbn07XG4vKiBGb2xkXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4vKipcbiAgICBWaXNpdCBldmVyeSBlbnRyeSBpbiB0aGUgbWFwLCBhZ2dyZWdhdGluZyBkYXRhLlxuXG4gICAgT3JkZXIgb2Ygbm9kZXMgaXMgbm90IGd1YXJhbnRlZWQuXG5cbiAgICBAcGFyYW0gZiBGdW5jdGlvbiBtYXBwaW5nIGFjY3VtdWxhdGVkIHZhbHVlLCB2YWx1ZSwgYW5kIGtleSB0byBuZXcgdmFsdWUuXG4gICAgQHBhcmFtIHogU3RhcnRpbmcgdmFsdWUuXG4gICAgQHBhcmFtIG0gSEFNVFxuKi9cblxuXG52YXIgZm9sZCA9IGhhbXQuZm9sZCA9IGZ1bmN0aW9uIChmLCB6LCBtKSB7XG4gIHZhciByb290ID0gbS5fcm9vdDtcbiAgaWYgKHJvb3QudHlwZSA9PT0gTEVBRikgcmV0dXJuIGYoeiwgcm9vdC52YWx1ZSwgcm9vdC5rZXkpO1xuICB2YXIgdG9WaXNpdCA9IFtyb290LmNoaWxkcmVuXTtcbiAgdmFyIGNoaWxkcmVuID0gdm9pZCAwO1xuXG4gIHdoaWxlIChjaGlsZHJlbiA9IHRvVmlzaXQucG9wKCkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baSsrXTtcblxuICAgICAgaWYgKGNoaWxkICYmIGNoaWxkLnR5cGUpIHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IExFQUYpIHogPSBmKHosIGNoaWxkLnZhbHVlLCBjaGlsZC5rZXkpO2Vsc2UgdG9WaXNpdC5wdXNoKGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gejtcbn07XG5cbk1hcC5wcm90b3R5cGUuZm9sZCA9IGZ1bmN0aW9uIChmLCB6KSB7XG4gIHJldHVybiBmb2xkKGYsIHosIHRoaXMpO1xufTtcbi8qKlxuICAgIFZpc2l0IGV2ZXJ5IGVudHJ5IGluIHRoZSBtYXAsIGFnZ3JlZ2F0aW5nIGRhdGEuXG5cbiAgICBPcmRlciBvZiBub2RlcyBpcyBub3QgZ3VhcmFudGVlZC5cblxuICAgIEBwYXJhbSBmIEZ1bmN0aW9uIGludm9rZWQgd2l0aCB2YWx1ZSBhbmQga2V5XG4gICAgQHBhcmFtIG1hcCBIQU1UXG4qL1xuXG5cbnZhciBmb3JFYWNoID0gaGFtdC5mb3JFYWNoID0gZnVuY3Rpb24gKGYsIG1hcCkge1xuICByZXR1cm4gZm9sZChmdW5jdGlvbiAoXywgdmFsdWUsIGtleSkge1xuICAgIHJldHVybiBmKHZhbHVlLCBrZXksIG1hcCk7XG4gIH0sIG51bGwsIG1hcCk7XG59O1xuXG5NYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gZm9yRWFjaChmLCB0aGlzKTtcbn07XG4vKiBBZ2dyZWdhdGVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICAgIEdldCB0aGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gYG1hcGAuXG4qL1xuXG5cbnZhciBjb3VudCA9IGhhbXQuY291bnQgPSBmdW5jdGlvbiAobWFwKSB7XG4gIHJldHVybiBtYXAuX3NpemU7XG59O1xuXG5NYXAucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY291bnQodGhpcyk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWFwLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gIGdldDogTWFwLnByb3RvdHlwZS5jb3VudFxufSk7XG4vKiBFeHBvcnRcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmlmICggbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBoYW10O1xufSBlbHNlIHtcbiAgdW5kZWZpbmVkLmhhbXQgPSBoYW10O1xufVxufSk7XG5cbmNsYXNzIEJ1aWx0SW5NYXAge1xuICBjb25zdHJ1Y3RvcihleGlzdGluZykge1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXBcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoZXhpc3RpbmcgPT09IG51bGwgfHwgZXhpc3RpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4aXN0aW5nLmVudHJpZXMoKSk7XG4gIH1cblxuICBrZXlzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXAua2V5cygpO1xuICB9XG5cbiAgZW50cmllcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLmVudHJpZXMoKTtcbiAgfVxuXG4gIGdldChrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoayk7XG4gIH1cblxuICBoYXMoaykge1xuICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGspO1xuICB9XG5cbiAgc2V0KGssIHYpIHtcbiAgICB0aGlzLl9tYXAuc2V0KGssIHYpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWxldGUoaykge1xuICAgIHRoaXMuX21hcC5kZWxldGUoayk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBwZXJzaXN0ZW50TWFwKHRoaXMpO1xuICB9XG5cbiAgdG9NYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAodGhpcy5fbWFwKTtcbiAgfVxuXG59XG5cbmNsYXNzIEhhc2hBcnJheU1hcHBlZFRyaWVNYXAge1xuICAvLyBCZWNhdXNlIGhhbXQuZW1wdHkgaXMgbm90IGEgZnVuY3Rpb24gdGhlcmUgaXMgbm8gd2F5IHRvIGludHJvZHVjZSB0eXBlXG4gIC8vIHBhcmFtZXRlcnMgb24gaXQsIHNvIGVtcHR5IGlzIHR5cGVkIGFzIEhBTVRQbHVzTWFwPHN0cmluZywgbWl4ZWQ+LlxuICAvLyAkRmxvd0lzc3VlXG4gIGNvbnN0cnVjdG9yKGV4aXN0aW5nKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2hhbXRcIiwgaGFtdF8xLmVtcHR5LmJlZ2luTXV0YXRpb24oKSk7XG5cbiAgICBpZiAoZXhpc3RpbmcgaW5zdGFuY2VvZiBIYXNoQXJyYXlNYXBwZWRUcmllTWFwKSB7XG4gICAgICBjb25zdCBoID0gZXhpc3RpbmcuX2hhbXQuZW5kTXV0YXRpb24oKTtcblxuICAgICAgZXhpc3RpbmcuX2hhbXQgPSBoLmJlZ2luTXV0YXRpb24oKTtcbiAgICAgIHRoaXMuX2hhbXQgPSBoLmJlZ2luTXV0YXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKGV4aXN0aW5nKSB7XG4gICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBleGlzdGluZy5lbnRyaWVzKCkpIHtcbiAgICAgICAgdGhpcy5faGFtdC5zZXQoaywgdik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAga2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5faGFtdC5rZXlzKCk7XG4gIH1cblxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9oYW10LmVudHJpZXMoKTtcbiAgfVxuXG4gIGdldChrKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbXQuZ2V0KGspO1xuICB9XG5cbiAgaGFzKGspIHtcbiAgICByZXR1cm4gdGhpcy5faGFtdC5oYXMoayk7XG4gIH1cblxuICBzZXQoaywgdikge1xuICAgIHRoaXMuX2hhbXQuc2V0KGssIHYpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkZWxldGUoaykge1xuICAgIHRoaXMuX2hhbXQuZGVsZXRlKGspO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gcGVyc2lzdGVudE1hcCh0aGlzKTtcbiAgfVxuXG4gIHRvTWFwKCkge1xuICAgIHJldHVybiBuZXcgTWFwKHRoaXMuX2hhbXQpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gcGVyc2lzdGVudE1hcChleGlzdGluZykge1xuICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX2hhbXRfMjAyMCcpKSB7XG4gICAgcmV0dXJuIG5ldyBIYXNoQXJyYXlNYXBwZWRUcmllTWFwKGV4aXN0aW5nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEJ1aWx0SW5NYXAoZXhpc3RpbmcpO1xuICB9XG59XG5cbnZhciBSZWNvaWxfUGVyc2lzdGVudE1hcCA9IHtcbiAgcGVyc2lzdGVudE1hcFxufTtcblxudmFyIFJlY29pbF9QZXJzaXN0ZW50TWFwXzEgPSBSZWNvaWxfUGVyc2lzdGVudE1hcC5wZXJzaXN0ZW50TWFwO1xuXG52YXIgUmVjb2lsX1BlcnNpc3RlbnRNYXAkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBwZXJzaXN0ZW50TWFwOiBSZWNvaWxfUGVyc2lzdGVudE1hcF8xXG59KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgc2V0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgZmlyc3Qgc2V0IHRoYXQgYXJlIG5vdFxuICogcHJlc2VudCBpbiBhbnkgb2YgdGhlIHN1YnNlcXVlbnQgc2V0cy5cbiAqXG4gKiBOb3RlOiB0aGlzIGlzIHdyaXR0ZW4gcHJvY2VkdXJhbGx5IChpLmUuLCB3aXRob3V0IGZpbHRlclNldCkgZm9yIHBlcmZvcm1hbnRcbiAqIHVzZSBpbiB0aWdodCBsb29wcy5cbiAqL1xuXG5mdW5jdGlvbiBkaWZmZXJlbmNlU2V0cyhzZXQsIC4uLnNldHNXaXRoVmFsdWVzVG9SZW1vdmUpIHtcbiAgY29uc3QgcmV0ID0gbmV3IFNldCgpO1xuXG4gIEZJUlNUOiBmb3IgKGNvbnN0IHZhbHVlIG9mIHNldCkge1xuICAgIGZvciAoY29uc3Qgb3RoZXJTZXQgb2Ygc2V0c1dpdGhWYWx1ZXNUb1JlbW92ZSkge1xuICAgICAgaWYgKG90aGVyU2V0Lmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgY29udGludWUgRklSU1Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0LmFkZCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG52YXIgUmVjb2lsX2RpZmZlcmVuY2VTZXRzID0gZGlmZmVyZW5jZVNldHM7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIG5ldyBNYXAgb2JqZWN0IHdpdGggdGhlIHNhbWUga2V5cyBhcyB0aGUgb3JpZ2luYWwsIGJ1dCB3aXRoIHRoZVxuICogdmFsdWVzIHJlcGxhY2VkIHdpdGggdGhlIG91dHB1dCBvZiB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWFwTWFwKG1hcCwgY2FsbGJhY2spIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICBtYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHJlc3VsdC5zZXQoa2V5LCBjYWxsYmFjayh2YWx1ZSwga2V5KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgUmVjb2lsX21hcE1hcCA9IG1hcE1hcDtcblxuZnVuY3Rpb24gbWFrZUdyYXBoKCkge1xuICByZXR1cm4ge1xuICAgIG5vZGVEZXBzOiBuZXcgTWFwKCksXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjbG9uZUdyYXBoKGdyYXBoKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZURlcHM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZURlcHMsIHMgPT4gbmV3IFNldChzKSksXG4gICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnM6IFJlY29pbF9tYXBNYXAoZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMsIHMgPT4gbmV3IFNldChzKSlcbiAgfTtcbn0gLy8gTm90ZSB0aGF0IHRoaXMgb3ZlcndyaXRlcyB0aGUgZGVwcyBvZiBleGlzdGluZyBub2RlcywgcmF0aGVyIHRoYW4gdW5pb25pbmdcbi8vIHRoZSBuZXcgZGVwcyB3aXRoIHRoZSBvbGQgZGVwcy5cblxuXG5mdW5jdGlvbiBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBuZXdEZXBzLCBncmFwaCwgLy8gSWYgb2xkZXJHcmFwaCBpcyBnaXZlbiB0aGVuIHdlIHdpbGwgbm90IG92ZXJ3cml0ZSBjaGFuZ2VzIG1hZGUgdG8gdGhlIGdpdmVuXG4vLyBncmFwaCBjb21wYXJlZCB3aXRoIG9sZGVyR3JhcGg6XG5vbGRlckdyYXBoKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlRGVwcyxcbiAgICBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uc1xuICB9ID0gZ3JhcGg7XG4gIGNvbnN0IG9sZERlcHMgPSBub2RlRGVwcy5nZXQoa2V5KTtcblxuICBpZiAob2xkRGVwcyAmJiBvbGRlckdyYXBoICYmIG9sZERlcHMgIT09IG9sZGVyR3JhcGgubm9kZURlcHMuZ2V0KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVXBkYXRlIG5vZGVEZXBzOlxuXG5cbiAgbm9kZURlcHMuc2V0KGtleSwgbmV3RGVwcyk7IC8vIEFkZCBuZXcgZGVwcyB0byBub2RlVG9Ob2RlU3Vic2NyaXB0aW9uczpcblxuICBjb25zdCBhZGRlZERlcHMgPSBvbGREZXBzID09IG51bGwgPyBuZXdEZXBzIDogUmVjb2lsX2RpZmZlcmVuY2VTZXRzKG5ld0RlcHMsIG9sZERlcHMpO1xuXG4gIGZvciAoY29uc3QgZGVwIG9mIGFkZGVkRGVwcykge1xuICAgIGlmICghbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuaGFzKGRlcCkpIHtcbiAgICAgIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zLnNldChkZXAsIG5ldyBTZXQoKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XG4gICAgZXhpc3RpbmcuYWRkKGtleSk7XG4gIH0gLy8gUmVtb3ZlIHJlbW92ZWQgZGVwcyBmcm9tIG5vZGVUb05vZGVTdWJzY3JpcHRpb25zOlxuXG5cbiAgaWYgKG9sZERlcHMpIHtcbiAgICBjb25zdCByZW1vdmVkRGVwcyA9IFJlY29pbF9kaWZmZXJlbmNlU2V0cyhvbGREZXBzLCBuZXdEZXBzKTtcblxuICAgIGZvciAoY29uc3QgZGVwIG9mIHJlbW92ZWREZXBzKSB7XG4gICAgICBpZiAoIW5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmhhcyhkZXApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoZGVwKSk7XG4gICAgICBleGlzdGluZy5kZWxldGUoa2V5KTtcblxuICAgICAgaWYgKGV4aXN0aW5nLnNpemUgPT09IDApIHtcbiAgICAgICAgbm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGRlcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhdmVEZXBzVG9TdG9yZShrZXksIGRlcHMsIHN0b3JlLCB2ZXJzaW9uKSB7XG4gIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZSwgX3N0b3JlU3RhdGUkcHJldmlvdXNULCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QzO1xuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmICghKHZlcnNpb24gPT09IHN0b3JlU3RhdGUuY3VycmVudFRyZWUudmVyc2lvbiB8fCB2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbmV4dFRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5leHRUcmVlLnZlcnNpb24pIHx8IHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJpZWQgdG8gc2F2ZSBkZXBlbmRlbmNpZXMgdG8gYSBkaXNjYXJkZWQgdHJlZScpO1xuICB9IC8vIE1lcmdlIHRoZSBkZXBlbmRlbmNpZXMgZGlzY292ZXJlZCBpbnRvIHRoZSBzdG9yZSdzIGRlcGVuZGVuY3kgbWFwXG4gIC8vIGZvciB0aGUgdmVyc2lvbiB0aGF0IHdhcyByZWFkOlxuXG5cbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaCh2ZXJzaW9uKTtcbiAgbWVyZ2VEZXBzSW50b0dyYXBoKGtleSwgZGVwcywgZ3JhcGgpOyAvLyBJZiB0aGlzIHZlcnNpb24gaXMgbm90IHRoZSBsYXRlc3QgdmVyc2lvbiwgYWxzbyB3cml0ZSB0aGVzZSBkZXBlbmRlbmNpZXNcbiAgLy8gaW50byBsYXRlciB2ZXJzaW9ucyBpZiB0aGV5IGRvbid0IGFscmVhZHkgaGF2ZSB0aGVpciBvd246XG5cbiAgaWYgKHZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUMiA9IHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRwcmV2aW91c1QyLnZlcnNpb24pKSB7XG4gICAgY29uc3QgY3VycmVudEdyYXBoID0gc3RvcmUuZ2V0R3JhcGgoc3RvcmVTdGF0ZS5jdXJyZW50VHJlZS52ZXJzaW9uKTtcbiAgICBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBkZXBzLCBjdXJyZW50R3JhcGgsIGdyYXBoKTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uID09PSAoKF9zdG9yZVN0YXRlJHByZXZpb3VzVDMgPSBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkcHJldmlvdXNUMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNUMy52ZXJzaW9uKSB8fCB2ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24pIHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUyO1xuXG4gICAgY29uc3QgbmV4dFZlcnNpb24gPSAoX3N0b3JlU3RhdGUkbmV4dFRyZWUyID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlU3RhdGUkbmV4dFRyZWUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIudmVyc2lvbjtcblxuICAgIGlmIChuZXh0VmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXh0R3JhcGggPSBzdG9yZS5nZXRHcmFwaChuZXh0VmVyc2lvbik7XG4gICAgICBtZXJnZURlcHNJbnRvR3JhcGgoa2V5LCBkZXBzLCBuZXh0R3JhcGgsIGdyYXBoKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlY29pbF9HcmFwaCA9IHtcbiAgY2xvbmVHcmFwaCxcbiAgZ3JhcGg6IG1ha2VHcmFwaCxcbiAgc2F2ZURlcHNUb1N0b3JlXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmxldCBuZXh0VHJlZVN0YXRlVmVyc2lvbiA9IDA7XG5cbmNvbnN0IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uID0gKCkgPT4gbmV4dFRyZWVTdGF0ZVZlcnNpb24rKztcblxubGV0IG5leHRTdG9yZUlEID0gMDtcblxuY29uc3QgZ2V0TmV4dFN0b3JlSUQgPSAoKSA9PiBuZXh0U3RvcmVJRCsrO1xuXG5sZXQgbmV4dENvbXBvbmVudElEID0gMDtcblxuY29uc3QgZ2V0TmV4dENvbXBvbmVudElEID0gKCkgPT4gbmV4dENvbXBvbmVudElEKys7XG5cbnZhciBSZWNvaWxfS2V5cyA9IHtcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24sXG4gIGdldE5leHRTdG9yZUlELFxuICBnZXROZXh0Q29tcG9uZW50SURcbn07XG5cbmNvbnN0IHtcbiAgcGVyc2lzdGVudE1hcDogcGVyc2lzdGVudE1hcCQxXG59ID0gUmVjb2lsX1BlcnNpc3RlbnRNYXAkMTtcblxuY29uc3Qge1xuICBncmFwaFxufSA9IFJlY29pbF9HcmFwaDtcblxuY29uc3Qge1xuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMVxufSA9IFJlY29pbF9LZXlzO1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlUcmVlU3RhdGUoKSB7XG4gIGNvbnN0IHZlcnNpb24gPSBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQxKCk7XG4gIHJldHVybiB7XG4gICAgdmVyc2lvbixcbiAgICBzdGF0ZUlEOiB2ZXJzaW9uLFxuICAgIHRyYW5zYWN0aW9uTWV0YWRhdGE6IHt9LFxuICAgIGRpcnR5QXRvbXM6IG5ldyBTZXQoKSxcbiAgICBhdG9tVmFsdWVzOiBwZXJzaXN0ZW50TWFwJDEoKSxcbiAgICBub252YWxpZGF0ZWRBdG9tczogcGVyc2lzdGVudE1hcCQxKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWFrZUVtcHR5U3RvcmVTdGF0ZSgpIHtcbiAgY29uc3QgY3VycmVudFRyZWUgPSBtYWtlRW1wdHlUcmVlU3RhdGUoKTtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50VHJlZSxcbiAgICBuZXh0VHJlZTogbnVsbCxcbiAgICBwcmV2aW91c1RyZWU6IG51bGwsXG4gICAgY29tbWl0RGVwdGg6IDAsXG4gICAga25vd25BdG9tczogbmV3IFNldCgpLFxuICAgIGtub3duU2VsZWN0b3JzOiBuZXcgU2V0KCksXG4gICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIG5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRDogW10sXG4gICAgc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzOiBuZXcgU2V0KCksXG4gICAgZ3JhcGhzQnlWZXJzaW9uOiBuZXcgTWFwKCkuc2V0KGN1cnJlbnRUcmVlLnZlcnNpb24sIGdyYXBoKCkpLFxuICAgIHJldGVudGlvbjoge1xuICAgICAgcmVmZXJlbmNlQ291bnRzOiBuZXcgTWFwKCksXG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lOiBuZXcgTWFwKCksXG4gICAgICByZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlOiBuZXcgU2V0KClcbiAgICB9LFxuICAgIG5vZGVDbGVhbnVwRnVuY3Rpb25zOiBuZXcgTWFwKClcbiAgfTtcbn1cblxudmFyIFJlY29pbF9TdGF0ZSA9IHtcbiAgbWFrZUVtcHR5VHJlZVN0YXRlLFxuICBtYWtlRW1wdHlTdG9yZVN0YXRlLFxuICBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbjogZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMVxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5jbGFzcyBSZXRlbnRpb25ab25lIHt9XG5cbmZ1bmN0aW9uIHJldGVudGlvblpvbmUoKSB7XG4gIHJldHVybiBuZXcgUmV0ZW50aW9uWm9uZSgpO1xufVxuXG52YXIgUmVjb2lsX1JldGVudGlvblpvbmUgPSB7XG4gIFJldGVudGlvblpvbmUsXG4gIHJldGVudGlvblpvbmVcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBVdGlsaXRpZXMgZm9yIHdvcmtpbmcgd2l0aCBidWlsdC1pbiBNYXBzIGFuZCBTZXRzIHdpdGhvdXQgbXV0YXRpbmcgdGhlbS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gc2V0QnlBZGRpbmdUb1NldChzZXQsIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcbiAgbmV4dC5hZGQodik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBzZXRCeURlbGV0aW5nRnJvbVNldChzZXQsIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBTZXQoc2V0KTtcbiAgbmV4dC5kZWxldGUodik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeVNldHRpbmdJbk1hcChtYXAsIGssIHYpIHtcbiAgY29uc3QgbmV4dCA9IG5ldyBNYXAobWFwKTtcbiAgbmV4dC5zZXQoaywgdik7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiBtYXBCeVVwZGF0aW5nSW5NYXAobWFwLCBrLCB1cGRhdGVyKSB7XG4gIGNvbnN0IG5leHQgPSBuZXcgTWFwKG1hcCk7XG4gIG5leHQuc2V0KGssIHVwZGF0ZXIobmV4dC5nZXQoaykpKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5RGVsZXRpbmdGcm9tTWFwKG1hcCwgaykge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBuZXh0LmRlbGV0ZShrKTtcbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIG1hcEJ5RGVsZXRpbmdNdWx0aXBsZUZyb21NYXAobWFwLCBrcykge1xuICBjb25zdCBuZXh0ID0gbmV3IE1hcChtYXApO1xuICBrcy5mb3JFYWNoKGsgPT4gbmV4dC5kZWxldGUoaykpO1xuICByZXR1cm4gbmV4dDtcbn1cblxudmFyIFJlY29pbF9Db3B5T25Xcml0ZSA9IHtcbiAgc2V0QnlBZGRpbmdUb1NldCxcbiAgc2V0QnlEZWxldGluZ0Zyb21TZXQsXG4gIG1hcEJ5U2V0dGluZ0luTWFwLFxuICBtYXBCeVVwZGF0aW5nSW5NYXAsXG4gIG1hcEJ5RGVsZXRpbmdGcm9tTWFwLFxuICBtYXBCeURlbGV0aW5nTXVsdGlwbGVGcm9tTWFwXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaXRlcmFibGUgd2hvc2Ugb3V0cHV0IGlzIGdlbmVyYXRlZCBieSBwYXNzaW5nIHRoZSBpbnB1dFxuICogaXRlcmFibGUncyB2YWx1ZXMgdGhyb3VnaCB0aGUgZmlsdGVyIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uKiBmaWx0ZXJJdGVyYWJsZShpdGVyYWJsZSwgcHJlZGljYXRlKSB7XG4gIC8vIFVzZSBnZW5lcmF0b3IgdG8gY3JlYXRlIGl0ZXJhYmxlL2l0ZXJhdG9yXG4gIGxldCBpbmRleCA9IDA7XG5cbiAgZm9yIChjb25zdCB2YWx1ZSBvZiBpdGVyYWJsZSkge1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4KyspKSB7XG4gICAgICB5aWVsZCB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlY29pbF9maWx0ZXJJdGVyYWJsZSA9IGZpbHRlckl0ZXJhYmxlO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFJldHVybiBhIHByb3h5IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYmFzZSBhbmQgZmFjdG9yaWVzIG9iamVjdHMuXG4gKiBUaGUgcHJveHkgd2lsbCBpbmNsdWRlIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBiYXNlIG9iamVjdCBhcy1pcy5cbiAqIFRoZSBmYWN0b3JpZXMgb2JqZWN0IGNvbnRhaW5zIGNhbGxiYWNrcyB0byBvYnRhaW4gdGhlIHZhbHVlcyBvZiB0aGUgcHJvcGVyaWVzXG4gKiBmb3IgaXRzIGtleXMuXG4gKlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIHByb3ZpZGluZyB1c2VycyBhbiBvYmplY3Qgd2hlcmUgc29tZSBwcm9wZXJ0aWVzIG1heSBiZVxuICogbGF6aWx5IGNvbXB1dGVkIG9ubHkgb24gZmlyc3QgYWNjZXNzLlxuICovXG4vLyAkRmxvd0lzc3VlW3VuY2xlYXItdHlwZV1cblxuZnVuY3Rpb24gbGF6eVByb3h5KGJhc2UsIGZhY3Rvcmllcykge1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShiYXNlLCB7XG4gICAgLy8gQ29tcHV0ZSBhbmQgY2FjaGUgbGF6eSBwcm9wZXJ0eSBpZiBub3QgYWxyZWFkeSBkb25lLlxuICAgIGdldDogKHRhcmdldCwgcHJvcCkgPT4ge1xuICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpICYmIHByb3AgaW4gZmFjdG9yaWVzKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IGZhY3Rvcmllc1twcm9wXSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH0sXG4gICAgLy8gVGhpcyBtZXRob2QgYWxsb3dzIHVzZXIgdG8gaXRlcmF0ZSBrZXlzIGFzIG5vcm1hbFxuICAgIG93bktleXM6IHRhcmdldCA9PiB7XG5cbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpO1xuICAgIH1cbiAgfSk7IC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICByZXR1cm4gcHJveHk7XG59XG5cbnZhciBSZWNvaWxfbGF6eVByb3h5ID0gbGF6eVByb3h5O1xuXG5jb25zdCB7XG4gIGdldE5vZGU6IGdldE5vZGUkMSxcbiAgZ2V0Tm9kZU1heWJlOiBnZXROb2RlTWF5YmUkMSxcbiAgcmVjb2lsVmFsdWVzRm9yS2V5czogcmVjb2lsVmFsdWVzRm9yS2V5cyQxXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgUmV0ZW50aW9uWm9uZTogUmV0ZW50aW9uWm9uZSQxXG59ID0gUmVjb2lsX1JldGVudGlvblpvbmU7XG5cbmNvbnN0IHtcbiAgc2V0QnlBZGRpbmdUb1NldDogc2V0QnlBZGRpbmdUb1NldCQxXG59ID0gUmVjb2lsX0NvcHlPbldyaXRlO1xuXG5cblxuXG5cblxuXG4gLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5jb25zdCBlbXB0eVNldCA9IE9iamVjdC5mcmVlemUobmV3IFNldCgpKTtcblxuY2xhc3MgUmVhZE9ubHlSZWNvaWxWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVJldGVudGlvbkZvck5vZGUoc3RvcmUsIG5vZGVLZXksIHJldGFpbmVkQnkpIHtcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBub2Rlc1JldGFpbmVkQnlab25lXG4gIH0gPSBzdG9yZS5nZXRTdGF0ZSgpLnJldGVudGlvbjtcblxuICBmdW5jdGlvbiBhZGRUb1pvbmUoem9uZSkge1xuICAgIGxldCBzZXQgPSBub2Rlc1JldGFpbmVkQnlab25lLmdldCh6b25lKTtcblxuICAgIGlmICghc2V0KSB7XG4gICAgICBub2Rlc1JldGFpbmVkQnlab25lLnNldCh6b25lLCBzZXQgPSBuZXcgU2V0KCkpO1xuICAgIH1cblxuICAgIHNldC5hZGQobm9kZUtleSk7XG4gIH1cblxuICBpZiAocmV0YWluZWRCeSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMSkge1xuICAgIGFkZFRvWm9uZShyZXRhaW5lZEJ5KTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldGFpbmVkQnkpKSB7XG4gICAgZm9yIChjb25zdCB6b25lIG9mIHJldGFpbmVkQnkpIHtcbiAgICAgIGFkZFRvWm9uZSh6b25lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHJldGVudGlvblxuICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgZnVuY3Rpb24gZGVsZXRlRnJvbVpvbmUoem9uZSkge1xuICAgICAgY29uc3Qgc2V0ID0gcmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpO1xuICAgICAgc2V0ID09PSBudWxsIHx8IHNldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0LmRlbGV0ZShub2RlS2V5KTtcblxuICAgICAgaWYgKHNldCAmJiBzZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5kZWxldGUoem9uZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJldGFpbmVkQnkgaW5zdGFuY2VvZiBSZXRlbnRpb25ab25lJDEpIHtcbiAgICAgIGRlbGV0ZUZyb21ab25lKHJldGFpbmVkQnkpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRhaW5lZEJ5KSkge1xuICAgICAgZm9yIChjb25zdCB6b25lIG9mIHJldGFpbmVkQnkpIHtcbiAgICAgICAgZGVsZXRlRnJvbVpvbmUoem9uZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgdHJlZVN0YXRlLCBrZXksIHRyaWdnZXIpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgaWYgKHN0b3JlU3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuaGFzKGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBub2RlID0gZ2V0Tm9kZSQxKGtleSk7XG4gIGNvbnN0IHJldGVudGlvbkNsZWFudXAgPSBpbml0aWFsaXplUmV0ZW50aW9uRm9yTm9kZShzdG9yZSwga2V5LCBub2RlLnJldGFpbmVkQnkpO1xuICBjb25zdCBub2RlQ2xlYW51cCA9IG5vZGUuaW5pdChzdG9yZSwgdHJlZVN0YXRlLCB0cmlnZ2VyKTtcbiAgc3RvcmVTdGF0ZS5ub2RlQ2xlYW51cEZ1bmN0aW9ucy5zZXQoa2V5LCAoKSA9PiB7XG4gICAgbm9kZUNsZWFudXAoKTtcbiAgICByZXRlbnRpb25DbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplTm9kZShzdG9yZSwga2V5LCB0cmlnZ2VyKSB7XG4gIGluaXRpYWxpemVOb2RlSWZOZXdUb1N0b3JlKHN0b3JlLCBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCBrZXksIHRyaWdnZXIpO1xufVxuXG5mdW5jdGlvbiBjbGVhblVwTm9kZShzdG9yZSwga2V5KSB7XG4gIHZhciBfc3RhdGUkbm9kZUNsZWFudXBGdW47XG5cbiAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAoX3N0YXRlJG5vZGVDbGVhbnVwRnVuID0gc3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdGF0ZSRub2RlQ2xlYW51cEZ1biA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0YXRlJG5vZGVDbGVhbnVwRnVuKCk7XG4gIHN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmRlbGV0ZShrZXkpO1xufSAvLyBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgbG9hZGFibGUgb2YgYSBub2RlIGFuZCB1cGRhdGUgdGhlIHN0YXRlLlxuLy8gVXBkYXRlIGRlcGVuZGVuY2llcyBhbmQgc3Vic2NyaXB0aW9ucyBmb3Igc2VsZWN0b3JzLlxuLy8gVXBkYXRlIHNhdmVkIHZhbHVlIHZhbGlkYXRpb24gZm9yIGF0b21zLlxuXG5cbmZ1bmN0aW9uIGdldE5vZGVMb2FkYWJsZShzdG9yZSwgc3RhdGUsIGtleSkge1xuICBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgc3RhdGUsIGtleSwgJ2dldCcpO1xuICByZXR1cm4gZ2V0Tm9kZSQxKGtleSkuZ2V0KHN0b3JlLCBzdGF0ZSk7XG59IC8vIFBlZWsgYXQgdGhlIGN1cnJlbnQgdmFsdWUgbG9hZGFibGUgZm9yIGEgbm9kZSB3aXRob3V0IGFueSBldmFsdWF0aW9uIG9yIHN0YXRlIGNoYW5nZVxuXG5cbmZ1bmN0aW9uIHBlZWtOb2RlTG9hZGFibGUoc3RvcmUsIHN0YXRlLCBrZXkpIHtcbiAgcmV0dXJuIGdldE5vZGUkMShrZXkpLnBlZWsoc3RvcmUsIHN0YXRlKTtcbn0gLy8gV3JpdGUgdmFsdWUgZGlyZWN0bHkgdG8gc3RhdGUgYnlwYXNzaW5nIHRoZSBOb2RlIGludGVyZmFjZSBhcyB0aGUgbm9kZVxuLy8gZGVmaW5pdGlvbnMgbWF5IG5vdCBoYXZlIGJlZW4gbG9hZGVkIHlldCB3aGVuIHByb2Nlc3NpbmcgdGhlIGluaXRpYWwgc25hcHNob3QuXG5cblxuZnVuY3Rpb24gc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRChzdGF0ZSwga2V5LCBuZXdWYWx1ZSkge1xuICB2YXIgX25vZGUkaW52YWxpZGF0ZTtcblxuICBjb25zdCBub2RlID0gZ2V0Tm9kZU1heWJlJDEoa2V5KTtcbiAgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX25vZGUkaW52YWxpZGF0ZSA9IG5vZGUuaW52YWxpZGF0ZSkgPT09IG51bGwgfHwgX25vZGUkaW52YWxpZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkaW52YWxpZGF0ZS5jYWxsKG5vZGUsIHN0YXRlKTtcbiAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgYXRvbVZhbHVlczogc3RhdGUuYXRvbVZhbHVlcy5jbG9uZSgpLmRlbGV0ZShrZXkpLFxuICAgIG5vbnZhbGlkYXRlZEF0b21zOiBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5jbG9uZSgpLnNldChrZXksIG5ld1ZhbHVlKSxcbiAgICBkaXJ0eUF0b21zOiBzZXRCeUFkZGluZ1RvU2V0JDEoc3RhdGUuZGlydHlBdG9tcywga2V5KVxuICB9O1xufSAvLyBSZXR1cm4gdGhlIGRpc2NvdmVyZWQgZGVwZW5kZW5jaWVzIGFuZCB2YWx1ZXMgdG8gYmUgd3JpdHRlbiBieSBzZXR0aW5nXG4vLyBhIG5vZGUgdmFsdWUuIChNdWx0aXBsZSB2YWx1ZXMgbWF5IGJlIHdyaXR0ZW4gZHVlIHRvIHNlbGVjdG9ycyBnZXR0aW5nIHRvXG4vLyBzZXQgdXBzdHJlYW1zOyBkZXBzIG1heSBiZSBkaXNjb3ZlcmVkIGJlY2F1c2Ugb2YgcmVhZHMgaW4gdXBkYXRlciBmdW5jdGlvbnMuKVxuXG5cbmZ1bmN0aW9uIHNldE5vZGVWYWx1ZShzdG9yZSwgc3RhdGUsIGtleSwgbmV3VmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IGdldE5vZGUkMShrZXkpO1xuXG4gIGlmIChub2RlLnNldCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFJlYWRPbmx5UmVjb2lsVmFsdWVFcnJvcihgQXR0ZW1wdCB0byBzZXQgcmVhZC1vbmx5IFJlY29pbFZhbHVlOiAke2tleX1gKTtcbiAgfVxuXG4gIGNvbnN0IHNldCA9IG5vZGUuc2V0OyAvLyBzbyBmbG93IGRvZXNuJ3QgbG9zZSB0aGUgYWJvdmUgcmVmaW5lbWVudC5cblxuICBpbml0aWFsaXplTm9kZUlmTmV3VG9TdG9yZShzdG9yZSwgc3RhdGUsIGtleSwgJ3NldCcpO1xuICByZXR1cm4gc2V0KHN0b3JlLCBzdGF0ZSwgbmV3VmFsdWUpO1xufVxuXG5mdW5jdGlvbiBwZWVrTm9kZUluZm8oc3RvcmUsIHN0YXRlLCBrZXkpIHtcbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IGdyYXBoID0gc3RvcmUuZ2V0R3JhcGgoc3RhdGUudmVyc2lvbik7XG4gIGNvbnN0IHR5cGUgPSBnZXROb2RlJDEoa2V5KS5ub2RlVHlwZTtcbiAgcmV0dXJuIFJlY29pbF9sYXp5UHJveHkoe1xuICAgIHR5cGVcbiAgfSwge1xuICAgIC8vICRGbG93Rml4TWVbdW5kZXJjb25zdHJhaW5lZC1pbXBsaWNpdC1pbnN0YW50aWF0aW9uXVxuICAgIGxvYWRhYmxlOiAoKSA9PiBwZWVrTm9kZUxvYWRhYmxlKHN0b3JlLCBzdGF0ZSwga2V5KSxcbiAgICBpc0FjdGl2ZTogKCkgPT4gc3RvcmVTdGF0ZS5rbm93bkF0b21zLmhhcyhrZXkpIHx8IHN0b3JlU3RhdGUua25vd25TZWxlY3RvcnMuaGFzKGtleSksXG4gICAgaXNTZXQ6ICgpID0+IHR5cGUgPT09ICdzZWxlY3RvcicgPyBmYWxzZSA6IHN0YXRlLmF0b21WYWx1ZXMuaGFzKGtleSksXG4gICAgaXNNb2RpZmllZDogKCkgPT4gc3RhdGUuZGlydHlBdG9tcy5oYXMoa2V5KSxcbiAgICAvLyBSZXBvcnQgY3VycmVudCBkZXBlbmRlbmNpZXMuICBJZiB0aGUgbm9kZSBoYXNuJ3QgYmVlbiBldmFsdWF0ZWQsIHRoZW5cbiAgICAvLyBkZXBlbmRlbmNpZXMgbWF5IGJlIG1pc3NpbmcgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgZGVwczogKCkgPT4ge1xuICAgICAgdmFyIF9ncmFwaCRub2RlRGVwcyRnZXQ7XG5cbiAgICAgIHJldHVybiByZWNvaWxWYWx1ZXNGb3JLZXlzJDEoKF9ncmFwaCRub2RlRGVwcyRnZXQgPSBncmFwaC5ub2RlRGVwcy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2dyYXBoJG5vZGVEZXBzJGdldCAhPT0gdm9pZCAwID8gX2dyYXBoJG5vZGVEZXBzJGdldCA6IFtdKTtcbiAgICB9LFxuICAgIC8vIFJlcG9ydHMgYWxsIFwiY3VycmVudFwiIHN1YnNjcmliZXJzLiAgRXZhbHVhdGluZyBvdGhlciBub2RlcyBvclxuICAgIC8vIHByZXZpb3VzIGluLXByb2dyZXNzIGFzeW5jIGV2YWx1YXRpb25zIG1heSBpbnRyb2R1Y2UgbmV3IHN1YnNjcmliZXJzLlxuICAgIHN1YnNjcmliZXJzOiAoKSA9PiB7XG4gICAgICB2YXIgX3N0b3JlU3RhdGUkbm9kZVRvQ29tLCBfc3RvcmVTdGF0ZSRub2RlVG9Db20yO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlczogcmVjb2lsVmFsdWVzRm9yS2V5cyQxKFJlY29pbF9maWx0ZXJJdGVyYWJsZShnZXREb3duc3RyZWFtTm9kZXMoc3RvcmUsIHN0YXRlLCBuZXcgU2V0KFtrZXldKSksIG5vZGVLZXkgPT4gbm9kZUtleSAhPT0ga2V5KSksXG4gICAgICAgIGNvbXBvbmVudHM6IFJlY29pbF9tYXBJdGVyYWJsZSgoX3N0b3JlU3RhdGUkbm9kZVRvQ29tID0gKF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIgPSBzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSkpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJG5vZGVUb0NvbTIudmFsdWVzKCkpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5vZGVUb0NvbSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbm9kZVRvQ29tIDogW10sIChbbmFtZV0pID0+ICh7XG4gICAgICAgICAgbmFtZVxuICAgICAgICB9KSlcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn0gLy8gRmluZCBhbGwgb2YgdGhlIHJlY3Vyc2l2ZWx5IGRlcGVuZGVudCBub2Rlc1xuXG5cbmZ1bmN0aW9uIGdldERvd25zdHJlYW1Ob2RlcyhzdG9yZSwgc3RhdGUsIGtleXMpIHtcbiAgY29uc3QgdmlzaXRlZE5vZGVzID0gbmV3IFNldCgpO1xuICBjb25zdCB2aXNpdGluZ05vZGVzID0gQXJyYXkuZnJvbShrZXlzKTtcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaChzdGF0ZS52ZXJzaW9uKTtcblxuICBmb3IgKGxldCBrZXkgPSB2aXNpdGluZ05vZGVzLnBvcCgpOyBrZXk7IGtleSA9IHZpc2l0aW5nTm9kZXMucG9wKCkpIHtcbiAgICB2YXIgX2dyYXBoJG5vZGVUb05vZGVTdWJzO1xuXG4gICAgdmlzaXRlZE5vZGVzLmFkZChrZXkpO1xuICAgIGNvbnN0IHN1YnNjcmliZWROb2RlcyA9IChfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgPSBncmFwaC5ub2RlVG9Ob2RlU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2dyYXBoJG5vZGVUb05vZGVTdWJzICE9PSB2b2lkIDAgPyBfZ3JhcGgkbm9kZVRvTm9kZVN1YnMgOiBlbXB0eVNldDtcblxuICAgIGZvciAoY29uc3QgZG93bnN0cmVhbU5vZGUgb2Ygc3Vic2NyaWJlZE5vZGVzKSB7XG4gICAgICBpZiAoIXZpc2l0ZWROb2Rlcy5oYXMoZG93bnN0cmVhbU5vZGUpKSB7XG4gICAgICAgIHZpc2l0aW5nTm9kZXMucHVzaChkb3duc3RyZWFtTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZpc2l0ZWROb2Rlcztcbn1cblxudmFyIFJlY29pbF9GdW5jdGlvbmFsQ29yZSA9IHtcbiAgZ2V0Tm9kZUxvYWRhYmxlLFxuICBwZWVrTm9kZUxvYWRhYmxlLFxuICBzZXROb2RlVmFsdWUsXG4gIGluaXRpYWxpemVOb2RlLFxuICBjbGVhblVwTm9kZSxcbiAgc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVfREVQUkVDQVRFRCxcbiAgcGVla05vZGVJbmZvLFxuICBnZXREb3duc3RyZWFtTm9kZXNcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxubGV0IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCA9IG51bGw7XG5cbmZ1bmN0aW9uIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90KGludmFsaWRhdGUpIHtcbiAgX2ludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90ID0gaW52YWxpZGF0ZTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QoKSB7XG4gIHZhciBfaW52YWxpZGF0ZU1lbW9pemVkU247XG5cbiAgKF9pbnZhbGlkYXRlTWVtb2l6ZWRTbiA9IF9pbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCkgPT09IG51bGwgfHwgX2ludmFsaWRhdGVNZW1vaXplZFNuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW52YWxpZGF0ZU1lbW9pemVkU24oKTtcbn1cblxudmFyIFJlY29pbF9TbmFwc2hvdENhY2hlID0ge1xuICBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCxcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Rcbn07XG5cbmNvbnN0IHtcbiAgZ2V0RG93bnN0cmVhbU5vZGVzOiBnZXREb3duc3RyZWFtTm9kZXMkMSxcbiAgZ2V0Tm9kZUxvYWRhYmxlOiBnZXROb2RlTG9hZGFibGUkMSxcbiAgc2V0Tm9kZVZhbHVlOiBzZXROb2RlVmFsdWUkMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBnZXROZXh0Q29tcG9uZW50SUQ6IGdldE5leHRDb21wb25lbnRJRCQxXG59ID0gUmVjb2lsX0tleXM7XG5cbmNvbnN0IHtcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQyLFxuICBnZXROb2RlTWF5YmU6IGdldE5vZGVNYXliZSQyXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDFcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIEFic3RyYWN0UmVjb2lsVmFsdWU6IEFic3RyYWN0UmVjb2lsVmFsdWUkMSxcbiAgUmVjb2lsU3RhdGU6IFJlY29pbFN0YXRlJDEsXG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbFZhbHVlUmVhZE9ubHkkMSxcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQxXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3Q6IGludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3RDYWNoZTtcblxuXG5cblxuXG5cblxuZnVuY3Rpb24gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlKHN0b3JlLCB7XG4gIGtleVxufSwgdHJlZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSkge1xuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWUsIF9zdG9yZVN0YXRlJHByZXZpb3VzVDtcblxuICAvLyBSZWFkaW5nIGZyb20gYW4gb2xkZXIgdHJlZSBjYW4gY2F1c2UgYnVncyBiZWNhdXNlIHRoZSBkZXBlbmRlbmNpZXMgdGhhdCB3ZVxuICAvLyBkaXNjb3ZlciBkdXJpbmcgdGhlIHJlYWQgYXJlIGxvc3QuXG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gIGlmICghKHRyZWVTdGF0ZS52ZXJzaW9uID09PSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb24gfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmVTdGF0ZSRuZXh0VHJlZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkbmV4dFRyZWUudmVyc2lvbikgfHwgdHJlZVN0YXRlLnZlcnNpb24gPT09ICgoX3N0b3JlU3RhdGUkcHJldmlvdXNUID0gc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHByZXZpb3VzVCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlU3RhdGUkcHJldmlvdXNULnZlcnNpb24pKSkge1xuICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignVHJpZWQgdG8gcmVhZCBmcm9tIGEgZGlzY2FyZGVkIHRyZWUnKTtcbiAgfVxuXG4gIGNvbnN0IGxvYWRhYmxlID0gZ2V0Tm9kZUxvYWRhYmxlJDEoc3RvcmUsIHRyZWVTdGF0ZSwga2V5KTtcblxuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIGxvYWRhYmxlLmNvbnRlbnRzLmNhdGNoKCgpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogSEFDSzogaW50ZXJjZXB0IHRocm93biBlcnJvciBoZXJlIHRvIHByZXZlbnQgYW4gdW5jYXVnaHQgcHJvbWlzZSBleGNlcHRpb24uIElkZWFsbHkgdGhpcyB3b3VsZCBoYXBwZW4gY2xvc2VyIHRvIHNlbGVjdG9yXG4gICAgICAgKiBleGVjdXRpb24gKHBlcmhhcHMgaW50cm9kdWNpbmcgYSBuZXcgRVJST1IgY2xhc3MgdG8gYmUgcmVzb2x2ZWQgYnkgYXN5bmMgc2VsZWN0b3JzIHRoYXQgYXJlIGluIGFuIGVycm9yIHN0YXRlKVxuICAgICAgICovXG4gICAgICByZXR1cm47XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QXRvbVZhbHVlV3JpdGVzKGF0b21WYWx1ZXMsIHdyaXRlcykge1xuICBjb25zdCByZXN1bHQgPSBhdG9tVmFsdWVzLmNsb25lKCk7XG4gIHdyaXRlcy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgaWYgKHYuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgdi5jb250ZW50cyBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQxKSB7XG4gICAgICByZXN1bHQuZGVsZXRlKGspO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuc2V0KGssIHYpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHZhbHVlRnJvbVZhbHVlT3JVcGRhdGVyKHN0b3JlLCBzdGF0ZSwge1xuICBrZXlcbn0sIHZhbHVlT3JVcGRhdGVyKSB7XG4gIGlmICh0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVcGRhdGVyIGZvcm06IHBhc3MgaW4gdGhlIGN1cnJlbnQgdmFsdWUuIFRocm93IGlmIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgLy8gaXMgdW5hdmFpbGFibGUgKG5hbWVseSB3aGVuIHVwZGF0aW5nIGFuIGFzeW5jIHNlbGVjdG9yIHRoYXQnc1xuICAgIC8vIHBlbmRpbmcgb3IgZXJyb3JlZCk6XG4gICAgY29uc3QgY3VycmVudCA9IGdldE5vZGVMb2FkYWJsZSQxKHN0b3JlLCBzdGF0ZSwga2V5KTtcblxuICAgIGlmIChjdXJyZW50LnN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBUcmllZCB0byBzZXQgYXRvbSBvciBzZWxlY3RvciBcIiR7a2V5fVwiIHVzaW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24gd2hpbGUgdGhlIGN1cnJlbnQgc3RhdGUgaXMgcGVuZGluZywgdGhpcyBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZC5gO1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKG1zZyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50LnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgICB0aHJvdyBjdXJyZW50LmNvbnRlbnRzO1xuICAgIH0gLy8gVCBpdHNlbGYgbWF5IGJlIGEgZnVuY3Rpb24sIHNvIG91ciByZWZpbmVtZW50IGlzIG5vdCBzdWZmaWNpZW50OlxuXG5cbiAgICByZXR1cm4gdmFsdWVPclVwZGF0ZXIoY3VycmVudC5jb250ZW50cyk7IC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZU9yVXBkYXRlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseUFjdGlvbihzdG9yZSwgc3RhdGUsIGFjdGlvbikge1xuICBpZiAoYWN0aW9uLnR5cGUgPT09ICdzZXQnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWUsXG4gICAgICB2YWx1ZU9yVXBkYXRlclxuICAgIH0gPSBhY3Rpb247XG4gICAgY29uc3QgbmV3VmFsdWUgPSB2YWx1ZUZyb21WYWx1ZU9yVXBkYXRlcihzdG9yZSwgc3RhdGUsIHJlY29pbFZhbHVlLCB2YWx1ZU9yVXBkYXRlcik7XG4gICAgY29uc3Qgd3JpdGVzID0gc2V0Tm9kZVZhbHVlJDEoc3RvcmUsIHN0YXRlLCByZWNvaWxWYWx1ZS5rZXksIG5ld1ZhbHVlKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgbG9hZGFibGVdIG9mIHdyaXRlcy5lbnRyaWVzKCkpIHtcbiAgICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0TG9hZGFibGUnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgbG9hZGFibGVcbiAgICB9ID0gYWN0aW9uO1xuICAgIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSk7XG4gIH0gZWxzZSBpZiAoYWN0aW9uLnR5cGUgPT09ICdtYXJrTW9kaWZpZWQnKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9XG4gICAgfSA9IGFjdGlvbjtcbiAgICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xuICB9IGVsc2UgaWYgKGFjdGlvbi50eXBlID09PSAnc2V0VW52YWxpZGF0ZWQnKSB7XG4gICAgdmFyIF9ub2RlJGludmFsaWRhdGU7XG5cbiAgICAvLyBXcml0ZSB2YWx1ZSBkaXJlY3RseSB0byBzdGF0ZSBieXBhc3NpbmcgdGhlIE5vZGUgaW50ZXJmYWNlIGFzIHRoZSBub2RlXG4gICAgLy8gZGVmaW5pdGlvbnMgbWF5IG5vdCBoYXZlIGJlZW4gbG9hZGVkIHlldCB3aGVuIHByb2Nlc3NpbmcgdGhlIGluaXRpYWwgc25hcHNob3QuXG4gICAgY29uc3Qge1xuICAgICAgcmVjb2lsVmFsdWU6IHtcbiAgICAgICAga2V5XG4gICAgICB9LFxuICAgICAgdW52YWxpZGF0ZWRWYWx1ZVxuICAgIH0gPSBhY3Rpb247XG4gICAgY29uc3Qgbm9kZSA9IGdldE5vZGVNYXliZSQyKGtleSk7XG4gICAgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX25vZGUkaW52YWxpZGF0ZSA9IG5vZGUuaW52YWxpZGF0ZSkgPT09IG51bGwgfHwgX25vZGUkaW52YWxpZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkaW52YWxpZGF0ZS5jYWxsKG5vZGUsIHN0YXRlKTtcbiAgICBzdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLnNldChrZXksIHVudmFsaWRhdGVkVmFsdWUpO1xuICAgIHN0YXRlLmRpcnR5QXRvbXMuYWRkKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKGBVbmtub3duIGFjdGlvbiAke2FjdGlvbi50eXBlfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZShzdGF0ZSwga2V5LCBsb2FkYWJsZSkge1xuICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScgJiYgbG9hZGFibGUuY29udGVudHMgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMSkge1xuICAgIHN0YXRlLmF0b21WYWx1ZXMuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQoa2V5LCBsb2FkYWJsZSk7XG4gIH1cblxuICBzdGF0ZS5kaXJ0eUF0b21zLmFkZChrZXkpO1xuICBzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy5kZWxldGUoa2V5KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlBY3Rpb25zVG9TdG9yZShzdG9yZSwgYWN0aW9ucykge1xuICBzdG9yZS5yZXBsYWNlU3RhdGUoc3RhdGUgPT4ge1xuICAgIGNvbnN0IG5ld1N0YXRlID0gY29weVRyZWVTdGF0ZShzdGF0ZSk7XG5cbiAgICBmb3IgKGNvbnN0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgICBhcHBseUFjdGlvbihzdG9yZSwgbmV3U3RhdGUsIGFjdGlvbik7XG4gICAgfVxuXG4gICAgaW52YWxpZGF0ZURvd25zdHJlYW1zKHN0b3JlLCBuZXdTdGF0ZSk7XG4gICAgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMSgpO1xuICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIGFjdGlvbikge1xuICBpZiAoYmF0Y2hTdGFjay5sZW5ndGgpIHtcbiAgICBjb25zdCBhY3Rpb25zQnlTdG9yZSA9IGJhdGNoU3RhY2tbYmF0Y2hTdGFjay5sZW5ndGggLSAxXTtcbiAgICBsZXQgYWN0aW9ucyA9IGFjdGlvbnNCeVN0b3JlLmdldChzdG9yZSk7XG5cbiAgICBpZiAoIWFjdGlvbnMpIHtcbiAgICAgIGFjdGlvbnNCeVN0b3JlLnNldChzdG9yZSwgYWN0aW9ucyA9IFtdKTtcbiAgICB9XG5cbiAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBhcHBseUFjdGlvbnNUb1N0b3JlKHN0b3JlLCBbYWN0aW9uXSk7XG4gIH1cbn1cblxuY29uc3QgYmF0Y2hTdGFjayA9IFtdO1xuXG5mdW5jdGlvbiBiYXRjaFN0YXJ0KCkge1xuICBjb25zdCBhY3Rpb25zQnlTdG9yZSA9IG5ldyBNYXAoKTtcbiAgYmF0Y2hTdGFjay5wdXNoKGFjdGlvbnNCeVN0b3JlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtzdG9yZSwgYWN0aW9uc10gb2YgYWN0aW9uc0J5U3RvcmUpIHtcbiAgICAgIGFwcGx5QWN0aW9uc1RvU3RvcmUoc3RvcmUsIGFjdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcHBlZCA9IGJhdGNoU3RhY2sucG9wKCk7XG5cbiAgICBpZiAocG9wcGVkICE9PSBhY3Rpb25zQnlTdG9yZSkge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdJbmNvcnJlY3Qgb3JkZXIgb2YgYmF0Y2ggcG9wcGluZycpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY29weVRyZWVTdGF0ZShzdGF0ZSkge1xuICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICBhdG9tVmFsdWVzOiBzdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCksXG4gICAgbm9udmFsaWRhdGVkQXRvbXM6IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCksXG4gICAgZGlydHlBdG9tczogbmV3IFNldChzdGF0ZS5kaXJ0eUF0b21zKVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlRG93bnN0cmVhbXMoc3RvcmUsIHN0YXRlKSB7XG4gIC8vIEluZm9ybSBhbnkgbm9kZXMgdGhhdCB3ZXJlIGNoYW5nZWQgb3IgZG93bnN0cmVhbSBvZiBjaGFuZ2VzIHNvIHRoYXQgdGhleVxuICAvLyBjYW4gY2xlYXIgb3V0IGFueSBjYWNoZXMgYXMgbmVlZGVkIGR1ZSB0byB0aGUgdXBkYXRlOlxuICBjb25zdCBkb3duc3RyZWFtcyA9IGdldERvd25zdHJlYW1Ob2RlcyQxKHN0b3JlLCBzdGF0ZSwgc3RhdGUuZGlydHlBdG9tcyk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgZG93bnN0cmVhbXMpIHtcbiAgICB2YXIgX2dldE5vZGVNYXliZSwgX2dldE5vZGVNYXliZSRpbnZhbGlkO1xuXG4gICAgKF9nZXROb2RlTWF5YmUgPSBnZXROb2RlTWF5YmUkMihrZXkpKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2dldE5vZGVNYXliZSRpbnZhbGlkID0gX2dldE5vZGVNYXliZS5pbnZhbGlkYXRlKSA9PT0gbnVsbCB8fCBfZ2V0Tm9kZU1heWJlJGludmFsaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nZXROb2RlTWF5YmUkaW52YWxpZC5jYWxsKF9nZXROb2RlTWF5YmUsIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRSZWNvaWxWYWx1ZShzdG9yZSwgcmVjb2lsVmFsdWUsIHZhbHVlT3JVcGRhdGVyKSB7XG4gIHF1ZXVlT3JQZXJmb3JtU3RhdGVVcGRhdGUoc3RvcmUsIHtcbiAgICB0eXBlOiAnc2V0JyxcbiAgICByZWNvaWxWYWx1ZSxcbiAgICB2YWx1ZU9yVXBkYXRlclxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2V0UmVjb2lsVmFsdWVMb2FkYWJsZShzdG9yZSwgcmVjb2lsVmFsdWUsIGxvYWRhYmxlKSB7XG4gIGlmIChsb2FkYWJsZSBpbnN0YW5jZW9mIERlZmF1bHRWYWx1ZSQxKSB7XG4gICAgcmV0dXJuIHNldFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgbG9hZGFibGUpO1xuICB9XG5cbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdzZXRMb2FkYWJsZScsXG4gICAgcmVjb2lsVmFsdWUsXG4gICAgbG9hZGFibGU6IGxvYWRhYmxlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZChzdG9yZSwgcmVjb2lsVmFsdWUpIHtcbiAgcXVldWVPclBlcmZvcm1TdGF0ZVVwZGF0ZShzdG9yZSwge1xuICAgIHR5cGU6ICdtYXJrTW9kaWZpZWQnLFxuICAgIHJlY29pbFZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlKHN0b3JlLCByZWNvaWxWYWx1ZSwgdW52YWxpZGF0ZWRWYWx1ZSkge1xuICBxdWV1ZU9yUGVyZm9ybVN0YXRlVXBkYXRlKHN0b3JlLCB7XG4gICAgdHlwZTogJ3NldFVudmFsaWRhdGVkJyxcbiAgICByZWNvaWxWYWx1ZSxcbiAgICB1bnZhbGlkYXRlZFZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmVUb1JlY29pbFZhbHVlKHN0b3JlLCB7XG4gIGtleVxufSwgY2FsbGJhY2ssIGNvbXBvbmVudERlYnVnTmFtZSA9IG51bGwpIHtcbiAgY29uc3Qgc3ViSUQgPSBnZXROZXh0Q29tcG9uZW50SUQkMSgpO1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoIXN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5oYXMoa2V5KSkge1xuICAgIHN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBuZXcgTWFwKCkpO1xuICB9XG5cbiAgUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZS5ub2RlVG9Db21wb25lbnRTdWJzY3JpcHRpb25zLmdldChrZXkpKS5zZXQoc3ViSUQsIFtjb21wb25lbnREZWJ1Z05hbWUgIT09IG51bGwgJiYgY29tcG9uZW50RGVidWdOYW1lICE9PSB2b2lkIDAgPyBjb21wb25lbnREZWJ1Z05hbWUgOiAnPG5vdCBjYXB0dXJlZD4nLCBjYWxsYmFja10pOyAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCwgZHVyaW5nIHRoZSBzYW1lIHRpY2sgdGhhdCB3ZSBhcmUgc3Vic2NyaWJpbmcsIGFuIGF0b21cbiAgLy8gaGFzIGJlZW4gdXBkYXRlZCBieSBzb21lIGVmZmVjdCBoYW5kbGVyLiBPdGhlcndpc2Ugd2Ugd2lsbCBtaXNzIHRoZSB1cGRhdGUuXG5cbiAgY29uc3QgbW9kZSA9IHJlYWN0TW9kZSQxKCk7XG5cbiAgaWYgKG1vZGUuZWFybHkgJiYgKG1vZGUubW9kZSA9PT0gJ0xFR0FDWScgfHwgbW9kZS5tb2RlID09PSAnTVVUQUJMRV9TT1VSQ0UnKSkge1xuICAgIGNvbnN0IG5leHRUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZTtcblxuICAgIGlmIChuZXh0VHJlZSAmJiBuZXh0VHJlZS5kaXJ0eUF0b21zLmhhcyhrZXkpKSB7XG4gICAgICBjYWxsYmFjayhuZXh0VHJlZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZWxlYXNlOiAoKSA9PiB7XG4gICAgICBjb25zdCByZWxlYXNlU3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBzdWJzID0gcmVsZWFzZVN0b3JlU3RhdGUubm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgICAgaWYgKHN1YnMgPT09IHVuZGVmaW5lZCB8fCAhc3Vicy5oYXMoc3ViSUQpKSB7XG4gICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihgU3Vic2NyaXB0aW9uIG1pc3NpbmcgYXQgcmVsZWFzZSB0aW1lIGZvciBhdG9tICR7a2V5fS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWNvaWwuYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3Vicy5kZWxldGUoc3ViSUQpO1xuXG4gICAgICBpZiAoc3Vicy5zaXplID09PSAwKSB7XG4gICAgICAgIHJlbGVhc2VTdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWZyZXNoUmVjb2lsVmFsdWUoc3RvcmUsIHJlY29pbFZhbHVlKSB7XG4gIHZhciBfbm9kZSRjbGVhckNhY2hlO1xuXG4gIGNvbnN0IHtcbiAgICBjdXJyZW50VHJlZVxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3Qgbm9kZSA9IGdldE5vZGUkMihyZWNvaWxWYWx1ZS5rZXkpO1xuICAoX25vZGUkY2xlYXJDYWNoZSA9IG5vZGUuY2xlYXJDYWNoZSkgPT09IG51bGwgfHwgX25vZGUkY2xlYXJDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkY2xlYXJDYWNoZS5jYWxsKG5vZGUsIHN0b3JlLCBjdXJyZW50VHJlZSk7XG59XG5cbnZhciBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2UgPSB7XG4gIFJlY29pbFZhbHVlUmVhZE9ubHk6IFJlY29pbFZhbHVlUmVhZE9ubHkkMSxcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQxLFxuICBSZWNvaWxTdGF0ZTogUmVjb2lsU3RhdGUkMSxcbiAgZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlLFxuICBzZXRSZWNvaWxWYWx1ZSxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSxcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQsXG4gIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUsXG4gIHN1YnNjcmliZVRvUmVjb2lsVmFsdWUsXG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkMSxcbiAgYXBwbHlBdG9tVmFsdWVXcml0ZXMsXG4gIC8vIFRPRE8gUmVtb3ZlIGV4cG9ydCB3aGVuIGRlcHJlY2F0aW5nIGluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQgaW4gUmVjb2lsUm9vdFxuICBiYXRjaFN0YXJ0LFxuICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUsXG4gIGludmFsaWRhdGVEb3duc3RyZWFtcyxcbiAgY29weVRyZWVTdGF0ZSxcbiAgcmVmcmVzaFJlY29pbFZhbHVlXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFRoZSBzb21lU2V0KCkgbWV0aG9kIHRlc3RzIHdoZXRoZXIgc29tZSBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gU2V0IHBhc3MgdGhlXG4gKiB0ZXN0IGltcGxlbWVudGVkIGJ5IHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBzb21lU2V0KHNldCwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgY29uc3QgaXRlcmF0b3IgPSBzZXQuZW50cmllcygpO1xuICBsZXQgY3VycmVudCA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICB3aGlsZSAoIWN1cnJlbnQuZG9uZSkge1xuICAgIGNvbnN0IGVudHJ5ID0gY3VycmVudC52YWx1ZTtcblxuICAgIGlmIChjYWxsYmFjay5jYWxsKGNvbnRleHQsIGVudHJ5WzFdLCBlbnRyeVswXSwgc2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY3VycmVudCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFJlY29pbF9zb21lU2V0ID0gc29tZVNldDtcblxuY29uc3Qge1xuICBjbGVhblVwTm9kZTogY2xlYW5VcE5vZGUkMVxufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBkZWxldGVOb2RlQ29uZmlnSWZQb3NzaWJsZTogZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUkMSxcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQzXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgUmV0ZW50aW9uWm9uZTogUmV0ZW50aW9uWm9uZSQyXG59ID0gUmVjb2lsX1JldGVudGlvblpvbmU7XG5cblxuXG5cblxuXG5cbiAvLyBDb21wb25lbnRzIHRoYXQgYXJlbid0IG1vdW50ZWQgYWZ0ZXIgc3VzcGVuZGluZyBmb3IgdGhpcyBsb25nIHdpbGwgYmUgYXNzdW1lZFxuLy8gdG8gYmUgZGlzY2FyZGVkIGFuZCB0aGVpciByZXNvdXJjZXMgcmVsZWFzZWQuXG5cblxuY29uc3QgU1VTUEVOU0VfVElNRU9VVF9NUyA9IDEyMDAwMDtcbmNvbnN0IGVtcHR5U2V0JDEgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIHJlbGVhc2VSZXRhaW5hYmxlc05vd09uQ3VycmVudFRyZWUoc3RvcmUsIHJldGFpbmFibGVzKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB0cmVlU3RhdGUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuXG4gIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlKSB7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdyZWxlYXNlTm9kZXNOb3dPbkN1cnJlbnRUcmVlIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGEgYmF0Y2gnKTtcbiAgICByZXR1cm47IC8vIGxlYWsgbWVtb3J5IHJhdGhlciB0aGFuIGVyYXNlIHNvbWV0aGluZyB0aGF0J3MgYWJvdXQgdG8gYmUgdXNlZC5cbiAgfVxuXG4gIGNvbnN0IG5vZGVzID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3QgciBvZiByZXRhaW5hYmxlcykge1xuICAgIGlmIChyIGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQyKSB7XG4gICAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXNSZXRhaW5lZEJ5Wm9uZShzdG9yZVN0YXRlLCByKSkge1xuICAgICAgICBub2Rlcy5hZGQobik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVzLmFkZChyKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCByZWxlYXNhYmxlTm9kZXMgPSBmaW5kUmVsZWFzYWJsZU5vZGVzKHN0b3JlLCBub2Rlcyk7XG5cbiAgZm9yIChjb25zdCBub2RlIG9mIHJlbGVhc2FibGVOb2Rlcykge1xuICAgIHJlbGVhc2VOb2RlKHN0b3JlLCB0cmVlU3RhdGUsIG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRSZWxlYXNhYmxlTm9kZXMoc3RvcmUsIHNlYXJjaEZyb21Ob2Rlcykge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgdHJlZVN0YXRlID0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbik7XG4gIGNvbnN0IHJlbGVhc2FibGVOb2RlcyA9IG5ldyBTZXQoKTsgLy8gbXV0YXRlZCB0byBjb2xsZWN0IGFuc3dlclxuXG4gIGNvbnN0IG5vblJlbGVhc2FibGVOb2RlcyA9IG5ldyBTZXQoKTtcbiAgZmluZFJlbGVhc2FibGVOb2Rlc0lubmVyKHNlYXJjaEZyb21Ob2Rlcyk7XG4gIHJldHVybiByZWxlYXNhYmxlTm9kZXM7XG5cbiAgZnVuY3Rpb24gZmluZFJlbGVhc2FibGVOb2Rlc0lubmVyKHNlYXJjaEZyb21Ob2Rlcykge1xuICAgIGNvbnN0IHJlbGVhc2FibGVOb2Rlc0ZvdW5kVGhpc0l0ZXJhdGlvbiA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBkb3duc3RyZWFtcyA9IGdldERvd25zdHJlYW1Ob2Rlc0luVG9wb2xvZ2ljYWxPcmRlcihzdG9yZSwgdHJlZVN0YXRlLCBzZWFyY2hGcm9tTm9kZXMsIHJlbGVhc2FibGVOb2RlcywgLy8gZG9uJ3QgZGVzY2VuZCBpbnRvIHRoZXNlXG4gICAgbm9uUmVsZWFzYWJsZU5vZGVzIC8vIGRvbid0IGRlc2NlbmQgaW50byB0aGVzZVxuICAgICk7IC8vIEZpbmQgd2hpY2ggb2YgdGhlIGRvd25zdHJlYW0gbm9kZXMgYXJlIHJlbGVhc2FibGUgYW5kIHdoaWNoIGFyZSBub3Q6XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgZG93bnN0cmVhbXMpIHtcbiAgICAgIHZhciBfc3RvcmVTdGF0ZSRyZXRlbnRpb247XG5cbiAgICAgIC8vIE5vdCByZWxlYXNhYmxlIGlmIGNvbmZpZ3VyZWQgdG8gYmUgcmV0YWluZWQgZm9yZXZlcjpcbiAgICAgIGlmIChnZXROb2RlJDMobm9kZSkucmV0YWluZWRCeSA9PT0gJ3JlY29pbFJvb3QnKSB7XG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBOb3QgcmVsZWFzYWJsZSBpZiByZXRhaW5lZCBkaXJlY3RseSBieSBhIGNvbXBvbmVudDpcblxuXG4gICAgICBpZiAoKChfc3RvcmVTdGF0ZSRyZXRlbnRpb24gPSBzdG9yZVN0YXRlLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHMuZ2V0KG5vZGUpKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRyZXRlbnRpb24gIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJHJldGVudGlvbiA6IDApID4gMCkge1xuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gTm90IHJlbGVhc2FibGUgaWYgcmV0YWluZWQgYnkgYSB6b25lOlxuXG5cbiAgICAgIGlmICh6b25lc1RoYXRDb3VsZFJldGFpbk5vZGUobm9kZSkuc29tZSh6ID0+IHN0b3JlU3RhdGUucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cy5nZXQoeikpKSB7XG4gICAgICAgIG5vblJlbGVhc2FibGVOb2Rlcy5hZGQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBOb3QgcmVsZWFzYWJsZSBpZiBpdCBoYXMgYSBub24tcmVsZWFzYWJsZSBjaGlsZCAod2hpY2ggd2lsbCBhbHJlYWR5IGJlIGluXG4gICAgICAvLyBub25SZWxlYXNhYmxlTm9kZXMgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgaW4gdG9wb2xvZ2ljYWwgb3JkZXIpOlxuXG5cbiAgICAgIGNvbnN0IG5vZGVDaGlsZHJlbiA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChub2RlKTtcblxuICAgICAgaWYgKG5vZGVDaGlsZHJlbiAmJiBSZWNvaWxfc29tZVNldChub2RlQ2hpbGRyZW4sIGNoaWxkID0+IG5vblJlbGVhc2FibGVOb2Rlcy5oYXMoY2hpbGQpKSkge1xuICAgICAgICBub25SZWxlYXNhYmxlTm9kZXMuYWRkKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmVsZWFzYWJsZU5vZGVzLmFkZChub2RlKTtcbiAgICAgIHJlbGVhc2FibGVOb2Rlc0ZvdW5kVGhpc0l0ZXJhdGlvbi5hZGQobm9kZSk7XG4gICAgfSAvLyBJZiB3ZSBmb3VuZCBhbnkgcmVsZWFzYWJsZSBub2Rlcywgd2UgbmVlZCB0byB3YWxrIFVQIGZyb20gdGhvc2Ugbm9kZXMgdG9cbiAgICAvLyBmaW5kIHdoZXRoZXIgdGhlaXIgcGFyZW50cyBjYW4gbm93IGJlIHJlbGVhc2VkIGFzIHdlbGw6XG5cblxuICAgIGNvbnN0IHBhcmVudHMgPSBuZXcgU2V0KCk7XG5cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgcmVsZWFzYWJsZU5vZGVzRm91bmRUaGlzSXRlcmF0aW9uKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiAoX2dyYXBoJG5vZGVEZXBzJGdldCA9IGdyYXBoLm5vZGVEZXBzLmdldChub2RlKSkgIT09IG51bGwgJiYgX2dyYXBoJG5vZGVEZXBzJGdldCAhPT0gdm9pZCAwID8gX2dyYXBoJG5vZGVEZXBzJGdldCA6IGVtcHR5U2V0JDEpIHtcbiAgICAgICAgdmFyIF9ncmFwaCRub2RlRGVwcyRnZXQ7XG5cbiAgICAgICAgaWYgKCFyZWxlYXNhYmxlTm9kZXMuaGFzKHBhcmVudCkpIHtcbiAgICAgICAgICBwYXJlbnRzLmFkZChwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudHMuc2l6ZSkge1xuICAgICAgZmluZFJlbGVhc2FibGVOb2Rlc0lubmVyKHBhcmVudHMpO1xuICAgIH1cbiAgfVxufSAvLyBDaGlsZHJlbiBiZWZvcmUgcGFyZW50c1xuXG5cbmZ1bmN0aW9uIGdldERvd25zdHJlYW1Ob2Rlc0luVG9wb2xvZ2ljYWxPcmRlcihzdG9yZSwgdHJlZVN0YXRlLCBub2RlcywgLy8gTXV0YWJsZSBzZXQgaXMgZGVzdHJveWVkIGluIHBsYWNlXG5kb05vdERlc2NlbmRJbnRvMSwgZG9Ob3REZXNjZW5kSW50bzIpIHtcbiAgY29uc3QgZ3JhcGggPSBzdG9yZS5nZXRHcmFwaCh0cmVlU3RhdGUudmVyc2lvbik7XG4gIGNvbnN0IGFuc3dlciA9IFtdO1xuICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuXG4gIHdoaWxlIChub2Rlcy5zaXplID4gMCkge1xuICAgIHZpc2l0KFJlY29pbF9udWxsdGhyb3dzKG5vZGVzLnZhbHVlcygpLm5leHQoKS52YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIGFuc3dlcjtcblxuICBmdW5jdGlvbiB2aXNpdChub2RlKSB7XG4gICAgaWYgKGRvTm90RGVzY2VuZEludG8xLmhhcyhub2RlKSB8fCBkb05vdERlc2NlbmRJbnRvMi5oYXMobm9kZSkpIHtcbiAgICAgIG5vZGVzLmRlbGV0ZShub2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmlzaXRlZC5oYXMobm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjaGlsZHJlbiA9IGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmdldChub2RlKTtcblxuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICB2aXNpdChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmlzaXRlZC5hZGQobm9kZSk7XG4gICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgIGFuc3dlci5wdXNoKG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VOb2RlKHN0b3JlLCB0cmVlU3RhdGUsIG5vZGUpIHtcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIEF0b20gZWZmZWN0cywgaW4tY2xvc3VyZSBjYWNoZXMsIGV0Yy46XG5cblxuICBjbGVhblVwTm9kZSQxKHN0b3JlLCBub2RlKTsgLy8gRGVsZXRlIGZyb20gc3RvcmUgc3RhdGU6XG5cbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIHN0b3JlU3RhdGUua25vd25BdG9tcy5kZWxldGUobm9kZSk7XG4gIHN0b3JlU3RhdGUua25vd25TZWxlY3RvcnMuZGVsZXRlKG5vZGUpO1xuICBzdG9yZVN0YXRlLm5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnMuZGVsZXRlKG5vZGUpO1xuICBzdG9yZVN0YXRlLnJldGVudGlvbi5yZWZlcmVuY2VDb3VudHMuZGVsZXRlKG5vZGUpO1xuICBjb25zdCB6b25lcyA9IHpvbmVzVGhhdENvdWxkUmV0YWluTm9kZShub2RlKTtcblxuICBmb3IgKGNvbnN0IHpvbmUgb2Ygem9uZXMpIHtcbiAgICB2YXIgX3N0b3JlU3RhdGUkcmV0ZW50aW9uMjtcblxuICAgIChfc3RvcmVTdGF0ZSRyZXRlbnRpb24yID0gc3RvcmVTdGF0ZS5yZXRlbnRpb24ubm9kZXNSZXRhaW5lZEJ5Wm9uZS5nZXQoem9uZSkpID09PSBudWxsIHx8IF9zdG9yZVN0YXRlJHJldGVudGlvbjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZVN0YXRlJHJldGVudGlvbjIuZGVsZXRlKG5vZGUpO1xuICB9IC8vIE5vdGUgdGhhdCB3ZSBETyBOT1QgZGVsZXRlIGZyb20gbm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9ucyBiZWNhdXNlIHRoaXNcbiAgLy8gYWxyZWFkeSBoYXBwZW5zIHdoZW4gdGhlIGxhc3QgY29tcG9uZW50IHRoYXQgd2FzIHJldGFpbmluZyB0aGUgbm9kZSB1bm1vdW50cyxcbiAgLy8gYW5kIHRoaXMgY291bGQgaGFwcGVuIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhhdC5cbiAgLy8gRGVsZXRlIGZyb20gVHJlZVN0YXRlIGFuZCBkZXAgZ3JhcGg6XG5cblxuICB0cmVlU3RhdGUuYXRvbVZhbHVlcy5kZWxldGUobm9kZSk7XG4gIHRyZWVTdGF0ZS5kaXJ0eUF0b21zLmRlbGV0ZShub2RlKTtcbiAgdHJlZVN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmRlbGV0ZShub2RlKTtcbiAgY29uc3QgZ3JhcGggPSBzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5nZXQodHJlZVN0YXRlLnZlcnNpb24pO1xuXG4gIGlmIChncmFwaCkge1xuICAgIGNvbnN0IGRlcHMgPSBncmFwaC5ub2RlRGVwcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoZGVwcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBncmFwaC5ub2RlRGVwcy5kZWxldGUobm9kZSk7XG5cbiAgICAgIGZvciAoY29uc3QgZGVwIG9mIGRlcHMpIHtcbiAgICAgICAgdmFyIF9ncmFwaCRub2RlVG9Ob2RlU3VicztcblxuICAgICAgICAoX2dyYXBoJG5vZGVUb05vZGVTdWJzID0gZ3JhcGgubm9kZVRvTm9kZVN1YnNjcmlwdGlvbnMuZ2V0KGRlcCkpID09PSBudWxsIHx8IF9ncmFwaCRub2RlVG9Ob2RlU3VicyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dyYXBoJG5vZGVUb05vZGVTdWJzLmRlbGV0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9IC8vIE5vIG5lZWQgdG8gZGVsZXRlIHN1YidzIGRlcHMgYXMgdGhlcmUgc2hvdWxkIGJlIG5vIHN1YnMgYXQgdGhpcyBwb2ludC5cbiAgICAvLyBCdXQgYW4gaW52YXJpYW50IHdvdWxkIHJlcXVpcmUgZGVsZXRpbmcgbm9kZXMgaW4gdG9wb2xvZ2ljYWwgb3JkZXIuXG5cblxuICAgIGdyYXBoLm5vZGVUb05vZGVTdWJzY3JpcHRpb25zLmRlbGV0ZShub2RlKTtcbiAgfSAvLyBOb2RlIGNvbmZpZyAoZm9yIGZhbWlseSBtZW1iZXJzIG9ubHkgYXMgdGhlaXIgY29uZmlncyBjYW4gYmUgcmVjcmVhdGVkLCBhbmRcbiAgLy8gb25seSBpZiB0aGV5IGFyZSBub3QgcmV0YWluZWQgd2l0aGluIGFueSBvdGhlciBTdG9yZXMpOlxuXG5cbiAgZGVsZXRlTm9kZUNvbmZpZ0lmUG9zc2libGUkMShub2RlKTtcbn1cblxuZnVuY3Rpb24gbm9kZXNSZXRhaW5lZEJ5Wm9uZShzdG9yZVN0YXRlLCB6b25lKSB7XG4gIHZhciBfc3RvcmVTdGF0ZSRyZXRlbnRpb24zO1xuXG4gIHJldHVybiAoX3N0b3JlU3RhdGUkcmV0ZW50aW9uMyA9IHN0b3JlU3RhdGUucmV0ZW50aW9uLm5vZGVzUmV0YWluZWRCeVpvbmUuZ2V0KHpvbmUpKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRyZXRlbnRpb24zICE9PSB2b2lkIDAgPyBfc3RvcmVTdGF0ZSRyZXRlbnRpb24zIDogZW1wdHlTZXQkMTtcbn1cblxuZnVuY3Rpb24gem9uZXNUaGF0Q291bGRSZXRhaW5Ob2RlKG5vZGUpIHtcbiAgY29uc3QgcmV0YWluZWRCeSA9IGdldE5vZGUkMyhub2RlKS5yZXRhaW5lZEJ5O1xuXG4gIGlmIChyZXRhaW5lZEJ5ID09PSB1bmRlZmluZWQgfHwgcmV0YWluZWRCeSA9PT0gJ2NvbXBvbmVudHMnIHx8IHJldGFpbmVkQnkgPT09ICdyZWNvaWxSb290Jykge1xuICAgIHJldHVybiBbXTtcbiAgfSBlbHNlIGlmIChyZXRhaW5lZEJ5IGluc3RhbmNlb2YgUmV0ZW50aW9uWm9uZSQyKSB7XG4gICAgcmV0dXJuIFtyZXRhaW5lZEJ5XTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmV0YWluZWRCeTsgLy8gaXQncyBhbiBhcnJheSBvZiB6b25lc1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlT3JQZXJmb3JtUG9zc2libGVSZWxlYXNlT2ZSZXRhaW5hYmxlKHN0b3JlLCByZXRhaW5hYmxlKSB7XG4gIGNvbnN0IHN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICBpZiAoc3RhdGUubmV4dFRyZWUpIHtcbiAgICBzdGF0ZS5yZXRlbnRpb24ucmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZS5hZGQocmV0YWluYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVsZWFzZVJldGFpbmFibGVzTm93T25DdXJyZW50VHJlZShzdG9yZSwgbmV3IFNldChbcmV0YWluYWJsZV0pKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVSZXRhaW5Db3VudChzdG9yZSwgcmV0YWluYWJsZSwgZGVsdGEpIHtcbiAgdmFyIF9tYXAkZ2V0O1xuXG4gIGlmICghUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IHN0b3JlLmdldFN0YXRlKCkucmV0ZW50aW9uLnJlZmVyZW5jZUNvdW50cztcbiAgY29uc3QgbmV3Q291bnQgPSAoKF9tYXAkZ2V0ID0gbWFwLmdldChyZXRhaW5hYmxlKSkgIT09IG51bGwgJiYgX21hcCRnZXQgIT09IHZvaWQgMCA/IF9tYXAkZ2V0IDogMCkgKyBkZWx0YTtcblxuICBpZiAobmV3Q291bnQgPT09IDApIHtcbiAgICB1cGRhdGVSZXRhaW5Db3VudFRvWmVybyhzdG9yZSwgcmV0YWluYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgbWFwLnNldChyZXRhaW5hYmxlLCBuZXdDb3VudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlUmV0YWluQ291bnRUb1plcm8oc3RvcmUsIHJldGFpbmFibGUpIHtcbiAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgbWFwID0gc3RvcmUuZ2V0U3RhdGUoKS5yZXRlbnRpb24ucmVmZXJlbmNlQ291bnRzO1xuICBtYXAuZGVsZXRlKHJldGFpbmFibGUpO1xuICBzY2hlZHVsZU9yUGVyZm9ybVBvc3NpYmxlUmVsZWFzZU9mUmV0YWluYWJsZShzdG9yZSwgcmV0YWluYWJsZSk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyhzdG9yZSkge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIHJlbGVhc2VSZXRhaW5hYmxlc05vd09uQ3VycmVudFRyZWUoc3RvcmUsIHN0YXRlLnJldGVudGlvbi5yZXRhaW5hYmxlc1RvQ2hlY2tGb3JSZWxlYXNlKTtcbiAgc3RhdGUucmV0ZW50aW9uLnJldGFpbmFibGVzVG9DaGVja0ZvclJlbGVhc2UuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0KHIpIHtcbiAgLy8gVGhlIGRlZmF1bHQgd2lsbCBjaGFuZ2UgZnJvbSAncmVjb2lsUm9vdCcgdG8gJ2NvbXBvbmVudHMnIGluIHRoZSBmdXR1cmUuXG4gIHJldHVybiByID09PSB1bmRlZmluZWQgPyAncmVjb2lsUm9vdCcgOiByO1xufVxuXG52YXIgUmVjb2lsX1JldGVudGlvbiA9IHtcbiAgU1VTUEVOU0VfVElNRU9VVF9NUyxcbiAgdXBkYXRlUmV0YWluQ291bnQsXG4gIHVwZGF0ZVJldGFpbkNvdW50VG9aZXJvLFxuICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3csXG4gIHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdFxufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFRoaXMgaXMgdG8gZXhwb3J0IGVzc3RpZW50aWFsIGZ1bmN0aW9ucyBmcm9tIHJlYWN0LWRvbVxuICogZm9yIG91ciB3ZWIgYnVpbGRcbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbmNvbnN0IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXNcbn0gPSByZWFjdERvbTtcblxudmFyIFJlYWN0QmF0Y2hlZFVwZGF0ZXMgPSB7XG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogVGhpcyBpcyB0byBleHBvcnQgZXNzdGllbnRpYWwgZnVuY3Rpb25zIGZyb20gcmVhY3QtZG9tXG4gKiBmb3Igb3VyIHdlYiBidWlsZFxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLy8gQGZiLW9ubHk6IGNvbnN0IHt1bnN0YWJsZV9iYXRjaGVkVXBkYXRlc30gPSByZXF1aXJlKCdSZWFjdERPTUNvbWV0Jyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHtcbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDFcbn0gPSBSZWFjdEJhdGNoZWRVcGRhdGVzOyAvLyBAb3NzLW9ubHlcblxuXG52YXIgUmVjb2lsX1JlYWN0QmF0Y2hlZFVwZGF0ZXMgPSB7XG4gIHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOiB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyQxXG59O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5jb25zdCB7XG4gIGJhdGNoU3RhcnQ6IGJhdGNoU3RhcnQkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMkMlxufSA9IFJlY29pbF9SZWFjdEJhdGNoZWRVcGRhdGVzOyAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbi8qXG4gKiBEdXJpbmcgU1NSLCB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyBtYXkgYmUgdW5kZWZpbmVkIHNvIHRoaXNcbiAqIGZhbGxzIGJhY2sgdG8gYSBiYXNpYyBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHRoZSBiYXRjaFxuICovXG5sZXQgYmF0Y2hlciA9IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzJDIgfHwgKGJhdGNoRm4gPT4gYmF0Y2hGbigpKTtcbi8qKlxuICogU2V0cyB0aGUgcHJvdmlkZWQgYmF0Y2hlciBmdW5jdGlvbiBhcyB0aGUgYmF0Y2hlciBmdW5jdGlvbiB1c2VkIGJ5IFJlY29pbC5cbiAqXG4gKiBTZXQgdGhlIGJhdGNoZXIgdG8gYSBjdXN0b20gYmF0Y2hlciBmb3IgeW91ciByZW5kZXJlcixcbiAqIGlmIHlvdSB1c2UgYSByZW5kZXJlciBvdGhlciB0aGFuIFJlYWN0IERPTSBvciBSZWFjdCBOYXRpdmUuXG4gKi9cblxuXG5jb25zdCBzZXRCYXRjaGVyID0gbmV3QmF0Y2hlciA9PiB7XG4gIGJhdGNoZXIgPSBuZXdCYXRjaGVyO1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBiYXRjaGVyIGZ1bmN0aW9uLlxuICovXG5cblxuY29uc3QgZ2V0QmF0Y2hlciA9ICgpID0+IGJhdGNoZXI7XG4vKipcbiAqIENhbGxzIHRoZSBjdXJyZW50IGJhdGNoZXIgZnVuY3Rpb24gYW5kIHBhc3NlcyB0aGVcbiAqIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICovXG5cblxuY29uc3QgYmF0Y2hVcGRhdGVzID0gY2FsbGJhY2sgPT4ge1xuICBiYXRjaGVyKCgpID0+IHtcbiAgICBsZXQgYmF0Y2hFbmQgPSAoKSA9PiB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgYmF0Y2hFbmQgPSBiYXRjaFN0YXJ0JDEoKTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGJhdGNoRW5kKCk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBSZWNvaWxfQmF0Y2hpbmcgPSB7XG4gIGdldEJhdGNoZXIsXG4gIHNldEJhdGNoZXIsXG4gIGJhdGNoVXBkYXRlc1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBJdGVyYWJsZXMgaW50byBhIHNpbmdsZSBJdGVyYWJsZS5cbiAqIFRyYXZlcnNlcyB0aGUgaW5wdXQgSXRlcmFibGVzIGluIHRoZSBvcmRlciBwcm92aWRlZCBhbmQgbWFpbnRhaW5zIHRoZSBvcmRlclxuICogb2YgdGhlaXIgZWxlbWVudHMuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYFxuICogY29uc3QgciA9IEFycmF5LmZyb20oY29uY2F0SXRlcmFibGVzKFsnYScsICdiJ10sIFsnYyddLCBbJ2QnLCAnZScsICdmJ10pKTtcbiAqIHIgPT0gWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZiddO1xuICogYGBgXG4gKi9cblxuZnVuY3Rpb24qIGNvbmNhdEl0ZXJhYmxlcyhpdGVycykge1xuICBmb3IgKGNvbnN0IGl0ZXIgb2YgaXRlcnMpIHtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBpdGVyKSB7XG4gICAgICB5aWVsZCB2YWw7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWNvaWxfY29uY2F0SXRlcmFibGVzID0gY29uY2F0SXRlcmFibGVzO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xuXG5jb25zdCBpc1NTUiA9IC8vICRGbG93Rml4TWUoc2l0ZT1yZWNvaWwpIFdpbmRvdyBkb2VzIG5vdCBoYXZlIGEgRmxvd1R5cGUgZGVmaW5pdGlvbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvNjcwOVxudHlwZW9mIFdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG4vKiBlc2xpbnQtZW5hYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbmNvbnN0IGlzV2luZG93ID0gdmFsdWUgPT4gIWlzU1NSICYmICggLy8gJEZsb3dGaXhNZShzaXRlPXJlY29pbCkgV2luZG93IGRvZXMgbm90IGhhdmUgYSBGbG93VHlwZSBkZWZpbml0aW9uIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy82NzA5XG52YWx1ZSA9PT0gd2luZG93IHx8IHZhbHVlIGluc3RhbmNlb2YgV2luZG93KTtcblxuY29uc3QgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkXG5cbnZhciBSZWNvaWxfRW52aXJvbm1lbnQgPSB7XG4gIGlzU1NSLFxuICBpc1JlYWN0TmF0aXZlLFxuICBpc1dpbmRvd1xufTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuLyoqXG4gKiBDYWNoZXMgYSBmdW5jdGlvbidzIHJlc3VsdHMgYmFzZWQgb24gdGhlIGtleSByZXR1cm5lZCBieSB0aGUgcGFzc2VkXG4gKiBoYXNoRnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gbWVtb2l6ZVdpdGhBcmdzSGFzaChmbiwgaGFzaEZ1bmN0aW9uKSB7XG4gIGxldCBjYWNoZTtcbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCFjYWNoZSkge1xuICAgICAgY2FjaGUgPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBoYXNoRnVuY3Rpb24oLi4uYXJncyk7XG5cbiAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpKSB7XG4gICAgICBjYWNoZVtrZXldID0gZm4oLi4uYXJncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG4gIH07XG59XG4vKipcbiAqIENhY2hlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0cyBiYXNlZCBvbiBhIGNvbXBhcmlzb24gb2YgdGhlIGFyZ3VtZW50cy5cbiAqIE9ubHkgY2FjaGVzIHRoZSBsYXN0IHJldHVybiBvZiB0aGUgZnVuY3Rpb24uXG4gKiBEZWZhdWx0cyB0byByZWZlcmVuY2UgZXF1YWxpdHlcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lbW9pemVPbmVXaXRoQXJnc0hhc2goZm4sIGhhc2hGdW5jdGlvbikge1xuICBsZXQgbGFzdEtleTtcbiAgbGV0IGxhc3RSZXN1bHQ7IC8vIGJyZWFraW5nIGNhY2hlIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxuXG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGtleSA9IGhhc2hGdW5jdGlvbiguLi5hcmdzKTtcblxuICAgIGlmIChsYXN0S2V5ID09PSBrZXkpIHtcbiAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgIH1cblxuICAgIGxhc3RLZXkgPSBrZXk7XG4gICAgbGFzdFJlc3VsdCA9IGZuKC4uLmFyZ3MpO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xufVxuLyoqXG4gKiBDYWNoZXMgYSBmdW5jdGlvbidzIHJlc3VsdHMgYmFzZWQgb24gYSBjb21wYXJpc29uIG9mIHRoZSBhcmd1bWVudHMuXG4gKiBPbmx5IGNhY2hlcyB0aGUgbGFzdCByZXR1cm4gb2YgdGhlIGZ1bmN0aW9uLlxuICogRGVmYXVsdHMgdG8gcmVmZXJlbmNlIGVxdWFsaXR5XG4gKi9cblxuXG5mdW5jdGlvbiBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uKGZuLCBoYXNoRnVuY3Rpb24pIHtcbiAgbGV0IGxhc3RLZXk7XG4gIGxldCBsYXN0UmVzdWx0OyAvLyBicmVha2luZyBjYWNoZSB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcblxuICBjb25zdCBtZW1vaXplZEZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBrZXkgPSBoYXNoRnVuY3Rpb24oLi4uYXJncyk7XG5cbiAgICBpZiAobGFzdEtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgICB9XG5cbiAgICBsYXN0S2V5ID0ga2V5O1xuICAgIGxhc3RSZXN1bHQgPSBmbiguLi5hcmdzKTtcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgfTtcblxuICBjb25zdCBpbnZhbGlkYXRlID0gKCkgPT4ge1xuICAgIGxhc3RLZXkgPSBudWxsO1xuICB9O1xuXG4gIHJldHVybiBbbWVtb2l6ZWRGbiwgaW52YWxpZGF0ZV07XG59XG5cbnZhciBSZWNvaWxfTWVtb2l6ZSA9IHtcbiAgbWVtb2l6ZVdpdGhBcmdzSGFzaCxcbiAgbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaCxcbiAgbWVtb2l6ZU9uZVdpdGhBcmdzSGFzaEFuZEludmFsaWRhdGlvblxufTtcblxuY29uc3Qge1xuICBiYXRjaFVwZGF0ZXM6IGJhdGNoVXBkYXRlcyQxXG59ID0gUmVjb2lsX0JhdGNoaW5nO1xuXG5jb25zdCB7XG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQxLFxuICBwZWVrTm9kZUluZm86IHBlZWtOb2RlSW5mbyQxXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIGdyYXBoOiBncmFwaCQxXG59ID0gUmVjb2lsX0dyYXBoO1xuXG5jb25zdCB7XG4gIGdldE5leHRTdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQxXG59ID0gUmVjb2lsX0tleXM7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQxLFxuICByZWNvaWxWYWx1ZXM6IHJlY29pbFZhbHVlcyQxLFxuICByZWNvaWxWYWx1ZXNGb3JLZXlzOiByZWNvaWxWYWx1ZXNGb3JLZXlzJDJcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDIsXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDEsXG4gIHNldFJlY29pbFZhbHVlOiBzZXRSZWNvaWxWYWx1ZSQxLFxuICBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlOiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgdXBkYXRlUmV0YWluQ291bnQ6IHVwZGF0ZVJldGFpbkNvdW50JDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIHNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90OiBzZXRJbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQxXG59ID0gUmVjb2lsX1NuYXBzaG90Q2FjaGU7XG5cbmNvbnN0IHtcbiAgZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb246IGdldE5leHRUcmVlU3RhdGVWZXJzaW9uJDIsXG4gIG1ha2VFbXB0eVN0b3JlU3RhdGU6IG1ha2VFbXB0eVN0b3JlU3RhdGUkMVxufSA9IFJlY29pbF9TdGF0ZTtcblxuXG5cbmNvbnN0IHtcbiAgaXNTU1I6IGlzU1NSJDFcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuXG5cblxuXG5jb25zdCB7XG4gIG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb246IG1lbW9pemVPbmVXaXRoQXJnc0hhc2hBbmRJbnZhbGlkYXRpb24kMVxufSA9IFJlY29pbF9NZW1vaXplO1xuXG5cblxuIC8vIE9wYXF1ZSBhdCB0aGlzIHN1cmZhY2UgYmVjYXVzZSBpdCdzIHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkgZnJvbSBoZXJlLlxuXG5cbmNvbnN0IHJldGFpbldhcm5pbmcgPSBgXG5SZWNvaWwgU25hcHNob3RzIG9ubHkgbGFzdCBmb3IgdGhlIGR1cmF0aW9uIG9mIHRoZSBjYWxsYmFjayB0aGV5IGFyZSBwcm92aWRlZCB0by4gVG8ga2VlcCBhIFNuYXBzaG90IGxvbmdlciwgZG8gdGhpczpcblxuICBjb25zdCByZWxlYXNlID0gc25hcHNob3QucmV0YWluKCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgZG9Tb21ldGhpbmdXaXRoU25hcHNob3Qoc25hcHNob3QpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbGVhc2UoKTtcbiAgfVxuXG5UaGlzIGlzIGN1cnJlbnRseSBhIERFVi1vbmx5IHdhcm5pbmcgYnV0IHdpbGwgYmVjb21lIGEgdGhyb3duIGV4Y2VwdGlvbiBpbiB0aGUgbmV4dCByZWxlYXNlIG9mIFJlY29pbC5cbmA7IC8vIEEgXCJTbmFwc2hvdFwiIGlzIFwicmVhZC1vbmx5XCIgYW5kIGNhcHR1cmVzIGEgc3BlY2lmaWMgc2V0IG9mIHZhbHVlcyBvZiBhdG9tcy5cbi8vIEhvd2V2ZXIsIHRoZSBkYXRhLWZsb3ctZ3JhcGggYW5kIHNlbGVjdG9yIHZhbHVlcyBtYXkgZXZvbHZlIGFzIHNlbGVjdG9yXG4vLyBldmFsdWF0aW9uIGZ1bmN0aW9ucyBhcmUgZXhlY3V0ZWQgYW5kIGFzeW5jIHNlbGVjdG9ycyByZXNvbHZlLlxuXG5jbGFzcyBTbmFwc2hvdCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvbm8tdW5pbml0aWFsaXplZC1wcm9wZXJ0aWVzXG4gIGNvbnN0cnVjdG9yKHN0b3JlU3RhdGUsIHBhcmVudFN0b3JlSUQpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RvcmVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9yZWZDb3VudFwiLCAxKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldExvYWRhYmxlXCIsIHJlY29pbFZhbHVlID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQxKHRoaXMuX3N0b3JlLCByZWNvaWxWYWx1ZSk7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRQcm9taXNlXCIsIHJlY29pbFZhbHVlID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9hZGFibGUocmVjb2lsVmFsdWUpLnRvUHJvbWlzZSgpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0Tm9kZXNfVU5TVEFCTEVcIiwgb3B0ID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpOyAvLyBUT0RPIERlYWwgd2l0aCBtb2RpZmllZCBzZWxlY3RvcnNcblxuICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuaXNNb2RpZmllZCkgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuaXNJbml0aWFsaXplZCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuXG4gICAgICAgIHJldHVybiByZWNvaWxWYWx1ZXNGb3JLZXlzJDIoc3RhdGUuZGlydHlBdG9tcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtub3duQXRvbXMgPSB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmtub3duQXRvbXM7XG5cbiAgICAgIGNvbnN0IGtub3duU2VsZWN0b3JzID0gdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5rbm93blNlbGVjdG9ycztcblxuICAgICAgcmV0dXJuIChvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuaXNJbml0aWFsaXplZCkgPT0gbnVsbCA/IHJlY29pbFZhbHVlcyQxLnZhbHVlcygpIDogb3B0LmlzSW5pdGlhbGl6ZWQgPT09IHRydWUgPyByZWNvaWxWYWx1ZXNGb3JLZXlzJDIoUmVjb2lsX2NvbmNhdEl0ZXJhYmxlcyhba25vd25BdG9tcywga25vd25TZWxlY3RvcnNdKSkgOiBSZWNvaWxfZmlsdGVySXRlcmFibGUocmVjb2lsVmFsdWVzJDEudmFsdWVzKCksICh7XG4gICAgICAgIGtleVxuICAgICAgfSkgPT4gIWtub3duQXRvbXMuaGFzKGtleSkgJiYgIWtub3duU2VsZWN0b3JzLmhhcyhrZXkpKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldEluZm9fVU5TVEFCTEVcIiwgKHtcbiAgICAgIGtleVxuICAgIH0pID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgcmV0dXJuIHBlZWtOb2RlSW5mbyQxKHRoaXMuX3N0b3JlLCB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCBrZXkpO1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwibWFwXCIsIG1hcHBlciA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IG11dGFibGVTbmFwc2hvdCA9IG5ldyBNdXRhYmxlU25hcHNob3QodGhpcywgYmF0Y2hVcGRhdGVzJDEpO1xuICAgICAgbWFwcGVyKG11dGFibGVTbmFwc2hvdCk7IC8vIGlmIHJlbW92aW5nIGJhdGNoVXBkYXRlcyBmcm9tIGBzZXRgIGFkZCBpdCBoZXJlXG5cbiAgICAgIHJldHVybiBtdXRhYmxlU25hcHNob3Q7XG4gICAgfSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhc3luY01hcFwiLCBhc3luYyBtYXBwZXIgPT4ge1xuICAgICAgdGhpcy5jaGVja1JlZkNvdW50X0lOVEVSTkFMKCk7XG4gICAgICBjb25zdCBtdXRhYmxlU25hcHNob3QgPSBuZXcgTXV0YWJsZVNuYXBzaG90KHRoaXMsIGJhdGNoVXBkYXRlcyQxKTtcbiAgICAgIG11dGFibGVTbmFwc2hvdC5yZXRhaW4oKTsgLy8gUmV0YWluIG5ldyBzbmFwc2hvdCBkdXJpbmcgYXN5bmMgbWFwcGVyXG5cbiAgICAgIGF3YWl0IG1hcHBlcihtdXRhYmxlU25hcHNob3QpOyAvLyBDb250aW51ZSB0byByZXRhaW4gdGhlIG5ldyBzbmFwc2hvdCBmb3IgdGhlIHVzZXIsIGJ1dCBhdXRvLXJlbGVhc2UgaXRcbiAgICAgIC8vIGFmdGVyIHRoZSBuZXh0IHRpY2ssIHRoZSBzYW1lIGFzIGEgbmV3IHN5bmNocm9ub3VzIHNuYXBzaG90LlxuXG4gICAgICBtdXRhYmxlU25hcHNob3QuYXV0b1JlbGVhc2VfSU5URVJOQUwoKTtcbiAgICAgIHJldHVybiBtdXRhYmxlU25hcHNob3Q7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zdG9yZSA9IHtcbiAgICAgIHN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDEoKSxcbiAgICAgIHBhcmVudFN0b3JlSUQsXG4gICAgICBnZXRTdGF0ZTogKCkgPT4gc3RvcmVTdGF0ZSxcbiAgICAgIHJlcGxhY2VTdGF0ZTogcmVwbGFjZXIgPT4ge1xuICAgICAgICAvLyBubyBiYXRjaGluZywgc28gbmV4dFRyZWUgaXMgbmV2ZXIgYWN0aXZlXG4gICAgICAgIHN0b3JlU3RhdGUuY3VycmVudFRyZWUgPSByZXBsYWNlcihzdG9yZVN0YXRlLmN1cnJlbnRUcmVlKTtcbiAgICAgIH0sXG4gICAgICBnZXRHcmFwaDogdmVyc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGdyYXBocyA9IHN0b3JlU3RhdGUuZ3JhcGhzQnlWZXJzaW9uO1xuXG4gICAgICAgIGlmIChncmFwaHMuaGFzKHZlcnNpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIFJlY29pbF9udWxsdGhyb3dzKGdyYXBocy5nZXQodmVyc2lvbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV3R3JhcGggPSBncmFwaCQxKCk7XG4gICAgICAgIGdyYXBocy5zZXQodmVyc2lvbiwgbmV3R3JhcGgpO1xuICAgICAgICByZXR1cm4gbmV3R3JhcGg7XG4gICAgICB9LFxuICAgICAgc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnM6ICgpID0+ICh7XG4gICAgICAgIHJlbGVhc2U6ICgpID0+IHt9XG4gICAgICB9KSxcbiAgICAgIGFkZFRyYW5zYWN0aW9uTWV0YWRhdGE6ICgpID0+IHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignQ2Fubm90IHN1YnNjcmliZSB0byBTbmFwc2hvdHMnKTtcbiAgICAgIH1cbiAgICB9OyAvLyBJbml0aWFsaXplIGFueSBub2RlcyB0aGF0IGFyZSBsaXZlIGluIHRoZSBwYXJlbnQgc3RvcmUgKHByaW1hcmlseSBzbyB0aGF0XG4gICAgLy8gdGhpcyBzbmFwc2hvdCBnZXRzIGNvdW50ZWQgdG93YXJkcyB0aGUgbm9kZSdzIGxpdmUgc3RvcmVzIGNvdW50KS5cbiAgICAvLyBUT0RPIE9wdGltaXplIHRoaXMgd2hlbiBjbG9uaW5nIHNuYXBzaG90cyBmb3IgY2FsbGJhY2tzXG5cbiAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zKSB7XG4gICAgICBpbml0aWFsaXplTm9kZSQxKHRoaXMuX3N0b3JlLCBub2RlS2V5LCAnZ2V0Jyk7XG4gICAgICB1cGRhdGVSZXRhaW5Db3VudCQxKHRoaXMuX3N0b3JlLCBub2RlS2V5LCAxKTtcbiAgICB9XG5cbiAgICB0aGlzLmF1dG9SZWxlYXNlX0lOVEVSTkFMKCk7XG4gIH1cblxuICByZXRhaW4oKSB7XG4gICAgaWYgKHRoaXMuX3JlZkNvdW50IDw9IDApIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgUmVjb2lsX2VycignU25hcHNob3QgaGFzIGFscmVhZHkgYmVlbiByZWxlYXNlZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignQXR0ZW1wdCB0byByZXRhaW4oKSBTbmFwc2hvdCB0aGF0IHdhcyBhbHJlYWR5IHJlbGVhc2VkLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3JlZkNvdW50Kys7XG4gICAgbGV0IHJlbGVhc2VkID0gZmFsc2U7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcmVsZWFzZWQpIHtcbiAgICAgICAgcmVsZWFzZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3JlbGVhc2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWxlYXNlIHRoZSBzbmFwc2hvdCBvbiB0aGUgbmV4dCB0aWNrLiAgVGhpcyBtZWFucyB0aGUgc25hcHNob3QgaXMgcmV0YWluZWRcbiAgICogZHVyaW5nIHRoZSBleGVjdXRpb24gb2YgdGhlIGN1cnJlbnQgZnVuY3Rpb24gdXNpbmcgaXQuXG4gICAqL1xuXG5cbiAgYXV0b1JlbGVhc2VfSU5URVJOQUwoKSB7XG4gICAgaWYgKCFpc1NTUiQxKSB7XG4gICAgICAvLyBVc2UgdGltZW91dCBvZiAxMCB0byB3b3JrYXJvdW5kIEZpcmVmb3ggaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2V4cGVyaW1lbnRhbC9SZWNvaWwvaXNzdWVzLzE5MzZcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuX3JlbGVhc2UoKSwgMTApO1xuICAgIH1cbiAgfVxuXG4gIF9yZWxlYXNlKCkge1xuICAgIHRoaXMuX3JlZkNvdW50LS07XG5cbiAgICBpZiAodGhpcy5fcmVmQ291bnQgPT09IDApIHtcbiAgICAgIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkubm9kZUNsZWFudXBGdW5jdGlvbnMuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XG5cbiAgICAgIHRoaXMuX3N0b3JlLmdldFN0YXRlKCkubm9kZUNsZWFudXBGdW5jdGlvbnMuY2xlYXIoKTtcblxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVGVtcG9yYXJpbHkgbmVyZmluZyB0aGlzIHRvIGFsbG93IHVzIHRvIGZpbmQgYnJva2VuIGNhbGwgc2l0ZXMgd2l0aG91dFxuICAgICAgLy8gYWN0dWFsbHkgYnJlYWtpbmcgYW55Ym9keSB5ZXQuXG4gICAgICAvLyBmb3IgKGNvbnN0IGsgb2YgdGhpcy5fc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zKSB7XG4gICAgICAvLyAgIHVwZGF0ZVJldGFpbkNvdW50VG9aZXJvKHRoaXMuX3N0b3JlLCBrKTtcbiAgICAgIC8vIH1cblxuICAgIH0gZWxzZSBpZiAodGhpcy5fcmVmQ291bnQgPCAwKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignU25hcHNob3QgcmVsZWFzZWQgYW4gZXh0cmEgdGltZS4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1JldGFpbmVkKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWZDb3VudCA+IDA7XG4gIH1cblxuICBjaGVja1JlZkNvdW50X0lOVEVSTkFMKCkge1xuICAgIGlmIChSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpICYmIHRoaXMuX3JlZkNvdW50IDw9IDApIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKHJldGFpbldhcm5pbmcpO1xuICAgICAgfSAvLyBXaGF0IHdlIHdpbGwgc2hpcCBsYXRlcjpcbiAgICAgIC8vIHRocm93IGVycihyZXRhaW5XYXJuaW5nKTtcblxuICAgIH1cbiAgfVxuXG4gIGdldFN0b3JlX0lOVEVSTkFMKCkge1xuICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgIHJldHVybiB0aGlzLl9zdG9yZTtcbiAgfVxuXG4gIGdldElEKCkge1xuICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLnN0YXRlSUQ7XG4gIH1cblxuICBnZXRTdG9yZUlEKCkge1xuICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5zdG9yZUlEO1xuICB9IC8vIFdlIHdhbnQgdG8gYWxsb3cgdGhlIG1ldGhvZHMgdG8gYmUgZGVzdHJ1Y3R1cmVkIGFuZCB1c2VkIGFzIGFjY2Vzc29yc1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy9leHRyYS1hcnJvdy1pbml0aWFsaXplciAqL1xuXG4gIC8qIGVzbGludC1lbmFibGUgZmItd3d3L2V4dHJhLWFycm93LWluaXRpYWxpemVyICovXG5cblxufVxuXG5mdW5jdGlvbiBjbG9uZVN0b3JlU3RhdGUoc3RvcmUsIHRyZWVTdGF0ZSwgYnVtcFZlcnNpb24gPSBmYWxzZSkge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgY29uc3QgdmVyc2lvbiA9IGJ1bXBWZXJzaW9uID8gZ2V0TmV4dFRyZWVTdGF0ZVZlcnNpb24kMigpIDogdHJlZVN0YXRlLnZlcnNpb247XG4gIHJldHVybiB7XG4gICAgLy8gQWx3YXlzIGNsb25lIHRoZSBUcmVlU3RhdGUgdG8gaXNvbGF0ZSBzdG9yZXMgZnJvbSBhY2NpZGVudGFsIG11dGF0aW9ucy5cbiAgICAvLyBGb3IgZXhhbXBsZSwgcmVhZGluZyBhIHNlbGVjdG9yIGZyb20gYSBjbG9uZWQgc25hcHNob3Qgc2hvdWxkbid0IGNhY2hlXG4gICAgLy8gaW4gdGhlIG9yaWdpbmFsIHRyZWVzdGF0ZSB3aGljaCBtYXkgY2F1c2UgdGhlIG9yaWdpbmFsIHRvIHNraXBcbiAgICAvLyBpbml0aWFsaXphdGlvbiBvZiB1cHN0cmVhbSBhdG9tcy5cbiAgICBjdXJyZW50VHJlZToge1xuICAgICAgLy8gVE9ETyBzbmFwc2hvdHMgc2hvdWxkbid0IHJlYWxseSBoYXZlIHZlcnNpb25zIGJlY2F1c2UgYSBuZXcgdmVyc2lvbiBudW1iZXJcbiAgICAgIC8vIGlzIGFsd2F5cyBhc3NpZ25lZCB3aGVuIHRoZSBzbmFwc2hvdCBpcyBnb25lIHRvLlxuICAgICAgdmVyc2lvbjogYnVtcFZlcnNpb24gPyB2ZXJzaW9uIDogdHJlZVN0YXRlLnZlcnNpb24sXG4gICAgICBzdGF0ZUlEOiBidW1wVmVyc2lvbiA/IHZlcnNpb24gOiB0cmVlU3RhdGUuc3RhdGVJRCxcbiAgICAgIHRyYW5zYWN0aW9uTWV0YWRhdGE6IHsgLi4udHJlZVN0YXRlLnRyYW5zYWN0aW9uTWV0YWRhdGFcbiAgICAgIH0sXG4gICAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KHRyZWVTdGF0ZS5kaXJ0eUF0b21zKSxcbiAgICAgIGF0b21WYWx1ZXM6IHRyZWVTdGF0ZS5hdG9tVmFsdWVzLmNsb25lKCksXG4gICAgICBub252YWxpZGF0ZWRBdG9tczogdHJlZVN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKClcbiAgICB9LFxuICAgIGNvbW1pdERlcHRoOiAwLFxuICAgIG5leHRUcmVlOiBudWxsLFxuICAgIHByZXZpb3VzVHJlZTogbnVsbCxcbiAgICBrbm93bkF0b21zOiBuZXcgU2V0KHN0b3JlU3RhdGUua25vd25BdG9tcyksXG4gICAgLy8gRklYTUUgaGVyZSdzIGEgY29weVxuICAgIGtub3duU2VsZWN0b3JzOiBuZXcgU2V0KHN0b3JlU3RhdGUua25vd25TZWxlY3RvcnMpLFxuICAgIC8vIEZJWE1FIGhlcmUncyBhIGNvcHlcbiAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnM6IG5ldyBNYXAoKSxcbiAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zOiBuZXcgTWFwKCksXG4gICAgbm9kZVRvQ29tcG9uZW50U3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEOiBbXSxcbiAgICBzdXNwZW5kZWRDb21wb25lbnRSZXNvbHZlcnM6IG5ldyBTZXQoKSxcbiAgICBncmFwaHNCeVZlcnNpb246IG5ldyBNYXAoKS5zZXQodmVyc2lvbiwgc3RvcmUuZ2V0R3JhcGgodHJlZVN0YXRlLnZlcnNpb24pKSxcbiAgICByZXRlbnRpb246IHtcbiAgICAgIHJlZmVyZW5jZUNvdW50czogbmV3IE1hcCgpLFxuICAgICAgbm9kZXNSZXRhaW5lZEJ5Wm9uZTogbmV3IE1hcCgpLFxuICAgICAgcmV0YWluYWJsZXNUb0NoZWNrRm9yUmVsZWFzZTogbmV3IFNldCgpXG4gICAgfSxcbiAgICAvLyBGSVhNRSBoZXJlJ3MgYSBjb3B5XG4gICAgLy8gQ3JlYXRlIGJsYW5rIGNsZWFudXAgaGFuZGxlcnMgZm9yIGF0b21zIHNvIHNuYXBzaG90cyBkb24ndCByZS1ydW5cbiAgICAvLyBhdG9tIGVmZmVjdHMuXG4gICAgbm9kZUNsZWFudXBGdW5jdGlvbnM6IG5ldyBNYXAoUmVjb2lsX21hcEl0ZXJhYmxlKHN0b3JlU3RhdGUubm9kZUNsZWFudXBGdW5jdGlvbnMuZW50cmllcygpLCAoW2tleV0pID0+IFtrZXksICgpID0+IHt9XSkpXG4gIH07XG59IC8vIEZhY3RvcnkgdG8gYnVpbGQgYSBmcmVzaCBzbmFwc2hvdFxuXG5cbmZ1bmN0aW9uIGZyZXNoU25hcHNob3QoaW5pdGlhbGl6ZVN0YXRlKSB7XG4gIGNvbnN0IHNuYXBzaG90ID0gbmV3IFNuYXBzaG90KG1ha2VFbXB0eVN0b3JlU3RhdGUkMSgpKTtcbiAgcmV0dXJuIGluaXRpYWxpemVTdGF0ZSAhPSBudWxsID8gc25hcHNob3QubWFwKGluaXRpYWxpemVTdGF0ZSkgOiBzbmFwc2hvdDtcbn0gLy8gRmFjdG9yeSB0byBjbG9uZSBhIHNuYXBzaG90IHN0YXRlXG5cblxuY29uc3QgW21lbW9pemVkQ2xvbmVTbmFwc2hvdCwgaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMl0gPSBtZW1vaXplT25lV2l0aEFyZ3NIYXNoQW5kSW52YWxpZGF0aW9uJDEoIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbihzdG9yZSwgdmVyc2lvbikgPT4ge1xuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU7XG5cbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHRyZWVTdGF0ZSA9IHZlcnNpb24gPT09ICdsYXRlc3QnID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IFJlY29pbF9udWxsdGhyb3dzKHN0b3JlU3RhdGUucHJldmlvdXNUcmVlKTtcbiAgcmV0dXJuIG5ldyBTbmFwc2hvdChjbG9uZVN0b3JlU3RhdGUoc3RvcmUsIHRyZWVTdGF0ZSksIHN0b3JlLnN0b3JlSUQpO1xufSwgKHN0b3JlLCB2ZXJzaW9uKSA9PiB7XG4gIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQsIF9zdG9yZSRnZXRTdGF0ZSRwcmV2aTtcblxuICByZXR1cm4gU3RyaW5nKHZlcnNpb24pICsgU3RyaW5nKHN0b3JlLnN0b3JlSUQpICsgU3RyaW5nKChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPSBzdG9yZS5nZXRTdGF0ZSgpLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VC52ZXJzaW9uKSArIFN0cmluZyhzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLnZlcnNpb24pICsgU3RyaW5nKChfc3RvcmUkZ2V0U3RhdGUkcHJldmkgPSBzdG9yZS5nZXRTdGF0ZSgpLnByZXZpb3VzVHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlJHByZXZpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkcHJldmkudmVyc2lvbik7XG59KTsgLy8gQXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG5cbnNldEludmFsaWRhdGVNZW1vaXplZFNuYXBzaG90JDEoaW52YWxpZGF0ZU1lbW9pemVkU25hcHNob3QkMik7XG5cbmZ1bmN0aW9uIGNsb25lU25hcHNob3Qoc3RvcmUsIHZlcnNpb24gPSAnbGF0ZXN0Jykge1xuICBjb25zdCBzbmFwc2hvdCA9IG1lbW9pemVkQ2xvbmVTbmFwc2hvdChzdG9yZSwgdmVyc2lvbik7XG5cbiAgaWYgKCFzbmFwc2hvdC5pc1JldGFpbmVkKCkpIHtcbiAgICBpbnZhbGlkYXRlTWVtb2l6ZWRTbmFwc2hvdCQyKCk7XG4gICAgcmV0dXJuIG1lbW9pemVkQ2xvbmVTbmFwc2hvdChzdG9yZSwgdmVyc2lvbik7XG4gIH1cblxuICByZXR1cm4gc25hcHNob3Q7XG59XG5cbmNsYXNzIE11dGFibGVTbmFwc2hvdCBleHRlbmRzIFNuYXBzaG90IHtcbiAgY29uc3RydWN0b3Ioc25hcHNob3QsIGJhdGNoKSB7XG4gICAgc3VwZXIoY2xvbmVTdG9yZVN0YXRlKHNuYXBzaG90LmdldFN0b3JlX0lOVEVSTkFMKCksIHNuYXBzaG90LmdldFN0b3JlX0lOVEVSTkFMKCkuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZSwgdHJ1ZSksIHNuYXBzaG90LmdldFN0b3JlSUQoKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfYmF0Y2hcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFwiLCAocmVjb2lsU3RhdGUsIG5ld1ZhbHVlT3JVcGRhdGVyKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBUaGlzIGJhdGNoVXBkYXRlcyBlbnN1cmVzIHRoaXMgYHNldGAgaXMgYXBwbGllZCBpbW1lZGlhdGVseSBhbmQgeW91IGNhblxuICAgICAgLy8gcmVhZCB0aGUgd3JpdHRlbiB2YWx1ZSBhZnRlciBjYWxsaW5nIGBzZXRgLiBJIHdvdWxkIGxpa2UgdG8gcmVtb3ZlIHRoaXNcbiAgICAgIC8vIGJlaGF2aW9yIGFuZCBvbmx5IGJhdGNoIGluIGBTbmFwc2hvdC5tYXBgLCBidXQgdGhpcyB3b3VsZCBiZSBhIGJyZWFraW5nXG4gICAgICAvLyBjaGFuZ2UgcG90ZW50aWFsbHkuXG5cbiAgICAgIHRoaXMuX2JhdGNoKCgpID0+IHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMShzdG9yZSwgcmVjb2lsU3RhdGUua2V5LCAxKTtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkMSh0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCksIHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcik7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInJlc2V0XCIsIHJlY29pbFN0YXRlID0+IHtcbiAgICAgIHRoaXMuY2hlY2tSZWZDb3VudF9JTlRFUk5BTCgpO1xuICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLmdldFN0b3JlX0lOVEVSTkFMKCk7IC8vIFNlZSBub3RlIGF0IGBzZXRgIGFib3V0IGJhdGNoZWQgdXBkYXRlcy5cblxuICAgICAgdGhpcy5fYmF0Y2goKCkgPT4ge1xuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQxKHN0b3JlLCByZWNvaWxTdGF0ZS5rZXksIDEpO1xuICAgICAgICBzZXRSZWNvaWxWYWx1ZSQxKHRoaXMuZ2V0U3RvcmVfSU5URVJOQUwoKSwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNldFVudmFsaWRhdGVkQXRvbVZhbHVlc19ERVBSRUNBVEVEXCIsIHZhbHVlcyA9PiB7XG4gICAgICB0aGlzLmNoZWNrUmVmQ291bnRfSU5URVJOQUwoKTtcbiAgICAgIGNvbnN0IHN0b3JlID0gdGhpcy5nZXRTdG9yZV9JTlRFUk5BTCgpOyAvLyBTZWUgbm90ZSBhdCBgc2V0YCBhYm91dCBiYXRjaGVkIHVwZGF0ZXMuXG5cbiAgICAgIGJhdGNoVXBkYXRlcyQxKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWVzLmVudHJpZXMoKSkge1xuICAgICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDEoc3RvcmUsIGssIDEpO1xuICAgICAgICAgIHNldFVudmFsaWRhdGVkUmVjb2lsVmFsdWUkMShzdG9yZSwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkMihrKSwgdik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fYmF0Y2ggPSBiYXRjaDtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfU25hcHNob3QgPSB7XG4gIFNuYXBzaG90LFxuICBNdXRhYmxlU25hcHNob3QsXG4gIGZyZXNoU25hcHNob3QsXG4gIGNsb25lU25hcHNob3Rcbn07XG5cbnZhciBSZWNvaWxfU25hcHNob3RfMSA9IFJlY29pbF9TbmFwc2hvdC5TbmFwc2hvdDtcbnZhciBSZWNvaWxfU25hcHNob3RfMiA9IFJlY29pbF9TbmFwc2hvdC5NdXRhYmxlU25hcHNob3Q7XG52YXIgUmVjb2lsX1NuYXBzaG90XzMgPSBSZWNvaWxfU25hcHNob3QuZnJlc2hTbmFwc2hvdDtcbnZhciBSZWNvaWxfU25hcHNob3RfNCA9IFJlY29pbF9TbmFwc2hvdC5jbG9uZVNuYXBzaG90O1xuXG52YXIgUmVjb2lsX1NuYXBzaG90JDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF8xLFxuICBNdXRhYmxlU25hcHNob3Q6IFJlY29pbF9TbmFwc2hvdF8yLFxuICBmcmVzaFNuYXBzaG90OiBSZWNvaWxfU25hcHNob3RfMyxcbiAgY2xvbmVTbmFwc2hvdDogUmVjb2lsX1NuYXBzaG90XzRcbn0pO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIHVuaW9uU2V0cyguLi5zZXRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQoKTtcblxuICBmb3IgKGNvbnN0IHNldCBvZiBzZXRzKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBzZXQpIHtcbiAgICAgIHJlc3VsdC5hZGQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWNvaWxfdW5pb25TZXRzID0gdW5pb25TZXRzO1xuXG5jb25zdCB7XG4gIHVzZVJlZlxufSA9IHJlYWN0O1xuLyoqXG4gKiBUaGUgc2FtZSBhcyBgdXNlUmVmKClgIGV4Y2VwdCB0aGF0IGlmIGEgZnVuY3Rpb24gaXMgc3BlY2lmaWVkIHRoZW4gaXQgd2lsbFxuICogY2FsbCB0aGF0IGZ1bmN0aW9uIHRvIGdldCB0aGUgdmFsdWUgdG8gaW5pdGlhbGl6ZSB0aGUgcmVmZXJlbmNlIHdpdGguXG4gKiBUaGlzIGlzIHNpbWlsYXIgdG8gaG93IGB1c2VTdGF0ZSgpYCBiZWhhdmVzIHdoZW4gZ2l2ZW4gYSBmdW5jdGlvbi4gIEl0IGFsbG93c1xuICogdGhlIHVzZXIgdG8gYXZvaWQgZ2VuZXJhdGluZyB0aGUgaW5pdGlhbCB2YWx1ZSBmb3Igc3Vic2VxdWVudCByZW5kZXJzLlxuICogVGhlIHRyYWRlb2ZmIGlzIHRoYXQgdG8gc2V0IHRoZSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBpdHNlbGYgeW91IG5lZWQgdG9cbiAqIG5lc3QgaXQ6IHVzZVJlZkluaXRPbmNlKCgpID0+ICgpID0+IHsuLi59KTtcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZVJlZkluaXRPbmNlKGluaXRpYWxWYWx1ZSkge1xuICAvLyAkRmxvd0V4cGVjdGVkRXJyb3JbaW5jb21wYXRpYmxlLWNhbGxdXG4gIGNvbnN0IHJlZiA9IHVzZVJlZihpbml0aWFsVmFsdWUpO1xuXG4gIGlmIChyZWYuY3VycmVudCA9PT0gaW5pdGlhbFZhbHVlICYmIHR5cGVvZiBpbml0aWFsVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAkRmxvd0V4cGVjdGVkRXJyb3JbaW5jb21wYXRpYmxlLXVzZV1cbiAgICByZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHJlZjtcbn1cblxudmFyIFJlY29pbF91c2VSZWZJbml0T25jZSA9IHVzZVJlZkluaXRPbmNlO1xuXG4vLyBAZmItb25seTogY29uc3QgUmVjb2lsdXNhZ2Vsb2dFdmVudCA9IHJlcXVpcmUoJ1JlY29pbHVzYWdlbG9nRXZlbnQnKTtcbi8vIEBmYi1vbmx5OiBjb25zdCBSZWNvaWxVc2FnZUxvZ0ZhbGNvRXZlbnQgPSByZXF1aXJlKCdSZWNvaWxVc2FnZUxvZ0ZhbGNvRXZlbnQnKTtcbi8vIEBmYi1vbmx5OiBjb25zdCBVUkkgPSByZXF1aXJlKCdVUkknKTtcblxuXG5jb25zdCB7XG4gIGdldE5leHRUcmVlU3RhdGVWZXJzaW9uOiBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQzLFxuICBtYWtlRW1wdHlTdG9yZVN0YXRlOiBtYWtlRW1wdHlTdG9yZVN0YXRlJDJcbn0gPSBSZWNvaWxfU3RhdGU7XG5cbmNvbnN0IHtcbiAgY2xlYW5VcE5vZGU6IGNsZWFuVXBOb2RlJDIsXG4gIGdldERvd25zdHJlYW1Ob2RlczogZ2V0RG93bnN0cmVhbU5vZGVzJDIsXG4gIGluaXRpYWxpemVOb2RlOiBpbml0aWFsaXplTm9kZSQyLFxuICBzZXROb2RlVmFsdWU6IHNldE5vZGVWYWx1ZSQyLFxuICBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEOiBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEJDFcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgZ3JhcGg6IGdyYXBoJDJcbn0gPSBSZWNvaWxfR3JhcGg7XG5cbmNvbnN0IHtcbiAgY2xvbmVHcmFwaDogY2xvbmVHcmFwaCQxXG59ID0gUmVjb2lsX0dyYXBoO1xuXG5jb25zdCB7XG4gIGdldE5leHRTdG9yZUlEOiBnZXROZXh0U3RvcmVJRCQyXG59ID0gUmVjb2lsX0tleXM7XG5cbmNvbnN0IHtcbiAgY3JlYXRlTXV0YWJsZVNvdXJjZTogY3JlYXRlTXV0YWJsZVNvdXJjZSQxLFxuICByZWFjdE1vZGU6IHJlYWN0TW9kZSQyXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuY29uc3Qge1xuICBhcHBseUF0b21WYWx1ZVdyaXRlczogYXBwbHlBdG9tVmFsdWVXcml0ZXMkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICByZWxlYXNlU2NoZWR1bGVkUmV0YWluYWJsZXNOb3c6IHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuY29uc3Qge1xuICBmcmVzaFNuYXBzaG90OiBmcmVzaFNuYXBzaG90JDFcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcblxuXG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQsXG4gIHVzZUVmZmVjdCxcbiAgdXNlTWVtbyxcbiAgdXNlUmVmOiB1c2VSZWYkMSxcbiAgdXNlU3RhdGVcbn0gPSByZWFjdDtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIG5vdEluQUNvbnRleHQoKSB7XG4gIHRocm93IFJlY29pbF9lcnIoJ1RoaXMgY29tcG9uZW50IG11c3QgYmUgdXNlZCBpbnNpZGUgYSA8UmVjb2lsUm9vdD4gY29tcG9uZW50LicpO1xufVxuXG5jb25zdCBkZWZhdWx0U3RvcmUgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RvcmVJRDogZ2V0TmV4dFN0b3JlSUQkMigpLFxuICBnZXRTdGF0ZTogbm90SW5BQ29udGV4dCxcbiAgcmVwbGFjZVN0YXRlOiBub3RJbkFDb250ZXh0LFxuICBnZXRHcmFwaDogbm90SW5BQ29udGV4dCxcbiAgc3Vic2NyaWJlVG9UcmFuc2FjdGlvbnM6IG5vdEluQUNvbnRleHQsXG4gIGFkZFRyYW5zYWN0aW9uTWV0YWRhdGE6IG5vdEluQUNvbnRleHRcbn0pO1xubGV0IHN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlKSB7XG4gIGlmIChzdGF0ZVJlcGxhY2VySXNCZWluZ0V4ZWN1dGVkKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycignQW4gYXRvbSB1cGRhdGUgd2FzIHRyaWdnZXJlZCB3aXRoaW4gdGhlIGV4ZWN1dGlvbiBvZiBhIHN0YXRlIHVwZGF0ZXIgZnVuY3Rpb24uIFN0YXRlIHVwZGF0ZXIgZnVuY3Rpb25zIHByb3ZpZGVkIHRvIFJlY29pbCBtdXN0IGJlIHB1cmUgZnVuY3Rpb25zLicpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgaWYgKHN0b3JlU3RhdGUubmV4dFRyZWUgPT09IG51bGwpIHtcbiAgICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSAmJiBSZWNvaWxfZ2t4KCdyZWNvaWxfcmVsZWFzZV9vbl9jYXNjYWRpbmdfdXBkYXRlX2tpbGxzd2l0Y2hfMjAyMScpKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY2FzY2FkaW5nIHVwZGF0ZSAodGhhdCBpcywgcmVuZGVyaW5nIGR1ZSB0byBvbmUgc3RhdGUgY2hhbmdlXG4gICAgICAvLyBpbnZva2VzIGEgc2Vjb25kIHN0YXRlIGNoYW5nZSksIHdlIHdvbid0IGhhdmUgY2xlYW5lZCB1cCByZXRhaW5hYmxlcyB5ZXRcbiAgICAgIC8vIGJlY2F1c2UgdGhpcyBub3JtYWxseSBoYXBwZW5zIGFmdGVyIG5vdGlmeWluZyBjb21wb25lbnRzLiBEbyBpdCBiZWZvcmVcbiAgICAgIC8vIHByb2NlZWRpbmcgd2l0aCB0aGUgY2FzY2FkaW5nIHVwZGF0ZSBzbyB0aGF0IGl0IHJlbWFpbnMgcHJlZGljdGFibGU6XG4gICAgICBpZiAoc3RvcmVTdGF0ZS5jb21taXREZXB0aCA+IDApIHtcbiAgICAgICAgcmVsZWFzZVNjaGVkdWxlZFJldGFpbmFibGVzTm93JDEoc3RvcmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZlcnNpb24gPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlLnZlcnNpb247XG4gICAgY29uc3QgbmV4dFZlcnNpb24gPSBnZXROZXh0VHJlZVN0YXRlVmVyc2lvbiQzKCk7XG4gICAgc3RvcmVTdGF0ZS5uZXh0VHJlZSA9IHsgLi4uc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSxcbiAgICAgIHZlcnNpb246IG5leHRWZXJzaW9uLFxuICAgICAgc3RhdGVJRDogbmV4dFZlcnNpb24sXG4gICAgICBkaXJ0eUF0b21zOiBuZXcgU2V0KCksXG4gICAgICB0cmFuc2FjdGlvbk1ldGFkYXRhOiB7fVxuICAgIH07XG4gICAgc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uc2V0KG5leHRWZXJzaW9uLCBjbG9uZUdyYXBoJDEoUmVjb2lsX251bGx0aHJvd3Moc3RvcmVTdGF0ZS5ncmFwaHNCeVZlcnNpb24uZ2V0KHZlcnNpb24pKSkpO1xuICB9XG59XG5cbmNvbnN0IEFwcENvbnRleHQgPSByZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgY3VycmVudDogZGVmYXVsdFN0b3JlXG59KTtcblxuY29uc3QgdXNlU3RvcmVSZWYgPSAoKSA9PiB1c2VDb250ZXh0KEFwcENvbnRleHQpOyAvLyAkRmxvd0V4cGVjdGVkRXJyb3JbaW5jb21wYXRpYmxlLWNhbGxdXG5cblxuY29uc3QgTXV0YWJsZVNvdXJjZUNvbnRleHQgPSByZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5mdW5jdGlvbiB1c2VSZWNvaWxNdXRhYmxlU291cmNlKCkge1xuICBjb25zdCBtdXRhYmxlU291cmNlID0gdXNlQ29udGV4dChNdXRhYmxlU291cmNlQ29udGV4dCk7XG5cbiAgaWYgKG11dGFibGVTb3VyY2UgPT0gbnVsbCkge1xuICAgIFJlY29pbF9leHBlY3RhdGlvblZpb2xhdGlvbignQXR0ZW1wdGVkIHRvIHVzZSBhIFJlY29pbCBob29rIG91dHNpZGUgb2YgYSA8UmVjb2lsUm9vdD4uICcgKyAnPFJlY29pbFJvb3Q+IG11c3QgYmUgYW4gYW5jZXN0b3Igb2YgYW55IGNvbXBvbmVudCB0aGF0IHVzZXMgJyArICdSZWNvaWwgaG9va3MuJyk7XG4gIH1cblxuICByZXR1cm4gbXV0YWJsZVNvdXJjZTtcbn1cblxuZnVuY3Rpb24gbm90aWZ5Q29tcG9uZW50cyhzdG9yZSwgc3RvcmVTdGF0ZSwgdHJlZVN0YXRlKSB7XG4gIGNvbnN0IGRlcGVuZGVudE5vZGVzID0gZ2V0RG93bnN0cmVhbU5vZGVzJDIoc3RvcmUsIHRyZWVTdGF0ZSwgdHJlZVN0YXRlLmRpcnR5QXRvbXMpO1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGRlcGVuZGVudE5vZGVzKSB7XG4gICAgY29uc3QgY29tcHMgPSBzdG9yZVN0YXRlLm5vZGVUb0NvbXBvbmVudFN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XG5cbiAgICBpZiAoY29tcHMpIHtcbiAgICAgIGZvciAoY29uc3QgW19zdWJJRCwgW19kZWJ1Z05hbWUsIGNhbGxiYWNrXV0gb2YgY29tcHMpIHtcbiAgICAgICAgY2FsbGJhY2sodHJlZVN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zKHN0b3JlKSB7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICBjb25zdCB0cmVlU3RhdGUgPSBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlOyAvLyBJbmZvcm0gdHJhbnNhY3Rpb24gc3Vic2NyaWJlcnMgb2YgdGhlIHRyYW5zYWN0aW9uOlxuXG4gIGNvbnN0IGRpcnR5QXRvbXMgPSB0cmVlU3RhdGUuZGlydHlBdG9tcztcblxuICBpZiAoZGlydHlBdG9tcy5zaXplKSB7XG4gICAgLy8gRXhlY3V0ZSBOb2RlLXNwZWNpZmljIHN1YnNjcmliZXJzIGJlZm9yZSBnbG9iYWwgc3Vic2NyaWJlcnNcbiAgICBmb3IgKGNvbnN0IFtrZXksIHN1YnNjcmlwdGlvbnNdIG9mIHN0b3JlU3RhdGUubm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucykge1xuICAgICAgaWYgKGRpcnR5QXRvbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbXywgc3Vic2NyaXB0aW9uXSBvZiBzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uKHN0b3JlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW18sIHN1YnNjcmlwdGlvbl0gb2Ygc3RvcmVTdGF0ZS50cmFuc2FjdGlvblN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHN1YnNjcmlwdGlvbihzdG9yZSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZWFjdE1vZGUkMigpLmVhcmx5IHx8IHN0b3JlU3RhdGUuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLnNpemUgPiAwKSB7XG4gICAgICAvLyBOb3RpZnlpbmcgY29tcG9uZW50cyBpcyBuZWVkZWQgdG8gd2FrZSBmcm9tIHN1c3BlbnNlLCBldmVuIHdoZW4gdXNpbmdcbiAgICAgIC8vIGVhcmx5IHJlbmRlcmluZy5cbiAgICAgIG5vdGlmeUNvbXBvbmVudHMoc3RvcmUsIHN0b3JlU3RhdGUsIHRyZWVTdGF0ZSk7IC8vIFdha2UgYWxsIHN1c3BlbmRlZCBjb21wb25lbnRzIHNvIHRoZSByaWdodCBvbmUocykgY2FuIHRyeSB0byByZS1yZW5kZXIuXG4gICAgICAvLyBXZSBuZWVkIHRvIHdha2UgdXAgY29tcG9uZW50cyBub3QganVzdCB3aGVuIHNvbWUgYXN5bmNocm9ub3VzIHNlbGVjdG9yXG4gICAgICAvLyByZXNvbHZlZCwgYnV0IGFsc28gd2hlbiBjaGFuZ2luZyBzeW5jaHJvbm91cyB2YWx1ZXMgYmVjYXVzZSB0aGlzIG1heSBjYXVzZVxuICAgICAgLy8gYSBzZWxlY3RvciB0byBjaGFuZ2UgZnJvbSBhc3luY2hyb25vdXMgdG8gc3luY2hyb25vdXMsIGluIHdoaWNoIGNhc2UgdGhlcmVcbiAgICAgIC8vIHdvdWxkIGJlIG5vIGZvbGxvdy11cCBhc3luY2hyb25vdXMgcmVzb2x1dGlvbiB0byB3YWtlIHVzIHVwLlxuICAgICAgLy8gVE9ETyBPUFRJTUlaQVRJT04gT25seSB3YWtlIHVwIHJlbGF0ZWQgZG93bnN0cmVhbSBjb21wb25lbnRzXG5cbiAgICAgIHN0b3JlU3RhdGUuc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzLmZvckVhY2goY2IgPT4gY2IoKSk7XG4gICAgICBzdG9yZVN0YXRlLnN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycy5jbGVhcigpO1xuICAgIH1cbiAgfSAvLyBTcGVjaWFsIGJlaGF2aW9yIE9OTFkgaW52b2tlZCBieSB1c2VJbnRlcmZhY2UuXG4gIC8vIEZJWE1FIGRlbGV0ZSBxdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRCB3aGVuIGRlbGV0aW5nIHVzZUludGVyZmFjZS5cblxuXG4gIHN0b3JlU3RhdGUucXVldWVkQ29tcG9uZW50Q2FsbGJhY2tzX0RFUFJFQ0FURUQuZm9yRWFjaChjYiA9PiBjYih0cmVlU3RhdGUpKTtcbiAgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5zcGxpY2UoMCwgc3RvcmVTdGF0ZS5xdWV1ZWRDb21wb25lbnRDYWxsYmFja3NfREVQUkVDQVRFRC5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBlbmRCYXRjaChzdG9yZSkge1xuICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgc3RvcmVTdGF0ZS5jb21taXREZXB0aCsrO1xuXG4gIHRyeSB7XG4gICAgY29uc3Qge1xuICAgICAgbmV4dFRyZWVcbiAgICB9ID0gc3RvcmVTdGF0ZTsgLy8gSWdub3JlIGNvbW1pdHMgdGhhdCBhcmUgbm90IGJlY2F1c2Ugb2YgUmVjb2lsIHRyYW5zYWN0aW9ucyAtLSBuYW1lbHksXG4gICAgLy8gYmVjYXVzZSBzb21ldGhpbmcgYWJvdmUgUmVjb2lsUm9vdCByZS1yZW5kZXJlZDpcblxuICAgIGlmIChuZXh0VHJlZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBuZXh0VHJlZSBpcyBub3cgY29tbWl0dGVkIC0tIG5vdGUgdGhhdCBjb3B5aW5nIGFuZCByZXNldCBvY2N1cnMgd2hlblxuICAgIC8vIGEgdHJhbnNhY3Rpb24gYmVnaW5zLCBpbiBzdGFydE5leHRUcmVlSWZOZWVkZWQ6XG5cblxuICAgIHN0b3JlU3RhdGUucHJldmlvdXNUcmVlID0gc3RvcmVTdGF0ZS5jdXJyZW50VHJlZTtcbiAgICBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlID0gbmV4dFRyZWU7XG4gICAgc3RvcmVTdGF0ZS5uZXh0VHJlZSA9IG51bGw7XG4gICAgc2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zKHN0b3JlKTtcblxuICAgIGlmIChzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSAhPSBudWxsKSB7XG4gICAgICBzdG9yZVN0YXRlLmdyYXBoc0J5VmVyc2lvbi5kZWxldGUoc3RvcmVTdGF0ZS5wcmV2aW91c1RyZWUudmVyc2lvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbignRW5kZWQgYmF0Y2ggd2l0aCBubyBwcmV2aW91cyBzdGF0ZSwgd2hpY2ggaXMgdW5leHBlY3RlZCcsICdyZWNvaWwnKTtcbiAgICB9XG5cbiAgICBzdG9yZVN0YXRlLnByZXZpb3VzVHJlZSA9IG51bGw7XG5cbiAgICBpZiAoUmVjb2lsX2dreCgncmVjb2lsX21lbW9yeV9tYW5hZ2FtZW50XzIwMjAnKSkge1xuICAgICAgLy8gT25seSByZWxlYXNlIHJldGFpbmFibGVzIGlmIHRoZXJlIHdlcmUgbm8gd3JpdGVzIGR1cmluZyB0aGUgZW5kIG9mIHRoZVxuICAgICAgLy8gYmF0Y2guICBUaGlzIGF2b2lkcyByZWxlYXNpbmcgc29tZXRoaW5nIHdlIG1pZ2h0IGJlIGFib3V0IHRvIHVzZS5cbiAgICAgIGlmIChuZXh0VHJlZSA9PSBudWxsKSB7XG4gICAgICAgIHJlbGVhc2VTY2hlZHVsZWRSZXRhaW5hYmxlc05vdyQxKHN0b3JlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgc3RvcmVTdGF0ZS5jb21taXREZXB0aC0tO1xuICB9XG59XG4vKlxuICogVGhlIHB1cnBvc2Ugb2YgdGhlIEJhdGNoZXIgaXMgdG8gb2JzZXJ2ZSB3aGVuIFJlYWN0IGJhdGNoZXMgZW5kIHNvIHRoYXRcbiAqIFJlY29pbCBzdGF0ZSBjaGFuZ2VzIGNhbiBiZSBiYXRjaGVkLiBXaGVuZXZlciBSZWNvaWwgc3RhdGUgY2hhbmdlcywgd2UgY2FsbFxuICogc2V0U3RhdGUgb24gdGhlIGJhdGNoZXIuIFRoZW4gd2Ugd2FpdCBmb3IgdGhhdCBjaGFuZ2UgdG8gYmUgY29tbWl0dGVkLCB3aGljaFxuICogc2lnbmlmaWVzIHRoZSBlbmQgb2YgdGhlIGJhdGNoLiBUaGF0J3Mgd2hlbiB3ZSByZXNwb25kIHRvIHRoZSBSZWNvaWwgY2hhbmdlLlxuICovXG5cblxuZnVuY3Rpb24gQmF0Y2hlcih7XG4gIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZVxufSkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmKCk7XG4gIGNvbnN0IFssIHNldFN0YXRlXSA9IHVzZVN0YXRlKFtdKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF1cblxuICBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UoKCkgPT4gc2V0U3RhdGUoe30pKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuICAgIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSgoKSA9PiBzZXRTdGF0ZSh7fSkpOyAvLyBJZiBhbiBhc3luY2hyb25vdXMgc2VsZWN0b3IgcmVzb2x2ZXMgYWZ0ZXIgdGhlIEJhdGNoZXIgaXMgdW5tb3VudGVkLFxuICAgIC8vIG5vdGlmeUJhdGNoZXJPZkNoYW5nZSB3aWxsIHN0aWxsIGJlIGNhbGxlZC4gQW4gZXJyb3IgZ2V0cyB0aHJvd24gd2hlbmV2ZXJcbiAgICAvLyBzZXRTdGF0ZSBpcyBjYWxsZWQgYWZ0ZXIgYSBjb21wb25lbnQgaXMgYWxyZWFkeSB1bm1vdW50ZWQsIHNvIHRoaXMgc2V0c1xuICAgIC8vIG5vdGlmeUJhdGNoZXJPZkNoYW5nZSB0byBiZSBhIG5vLW9wLlxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHNldE5vdGlmeUJhdGNoZXJPZkNoYW5nZSgoKSA9PiB7fSk7XG4gICAgfTtcbiAgfSwgW3NldE5vdGlmeUJhdGNoZXJPZkNoYW5nZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIGVucXVldWVFeGVjdXRpb24gcnVucyB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5OyBpdCBpcyBvbmx5IHVzZWQgdG9cbiAgICAvLyBtYW5pcHVsYXRlIHRoZSBvcmRlciBvZiB1c2VFZmZlY3RzIGR1cmluZyB0ZXN0cywgc2luY2UgUmVhY3Qgc2VlbXMgdG9cbiAgICAvLyBjYWxsIHVzZUVmZmVjdCBpbiBhbiB1bnByZWRpY3RhYmxlIG9yZGVyIHNvbWV0aW1lcy5cbiAgICBSZWNvaWxfUXVldWUuZW5xdWV1ZUV4ZWN1dGlvbignQmF0Y2hlcicsICgpID0+IHtcbiAgICAgIGVuZEJhdGNoKHN0b3JlUmVmLmN1cnJlbnQpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuJHJlY29pbERlYnVnU3RhdGVzKSB7XG4gICAgd2luZG93LiRyZWNvaWxEZWJ1Z1N0YXRlcyA9IFtdO1xuICB9XG59IC8vIFdoZW4gcmVtb3ZpbmcgdGhpcyBkZXByZWNhdGVkIGZ1bmN0aW9uLCByZW1vdmUgc3RhdGVCeVNldHRpbmdSZWNvaWxWYWx1ZVxuLy8gd2hpY2ggd2lsbCBubyBsb25nZXIgYmUgbmVlZGVkLlxuXG5cbmZ1bmN0aW9uIGluaXRpYWxTdG9yZVN0YXRlX0RFUFJFQ0FURUQoc3RvcmUsIGluaXRpYWxpemVTdGF0ZSkge1xuICBjb25zdCBpbml0aWFsID0gbWFrZUVtcHR5U3RvcmVTdGF0ZSQyKCk7XG4gIGluaXRpYWxpemVTdGF0ZSh7XG4gICAgc2V0OiAoYXRvbSwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0gaW5pdGlhbC5jdXJyZW50VHJlZTtcbiAgICAgIGNvbnN0IHdyaXRlcyA9IHNldE5vZGVWYWx1ZSQyKHN0b3JlLCBzdGF0ZSwgYXRvbS5rZXksIHZhbHVlKTtcbiAgICAgIGNvbnN0IHdyaXR0ZW5Ob2RlcyA9IG5ldyBTZXQod3JpdGVzLmtleXMoKSk7XG4gICAgICBjb25zdCBub252YWxpZGF0ZWRBdG9tcyA9IHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmNsb25lKCk7XG5cbiAgICAgIGZvciAoY29uc3QgbiBvZiB3cml0dGVuTm9kZXMpIHtcbiAgICAgICAgbm9udmFsaWRhdGVkQXRvbXMuZGVsZXRlKG4pO1xuICAgICAgfVxuXG4gICAgICBpbml0aWFsLmN1cnJlbnRUcmVlID0geyAuLi5zdGF0ZSxcbiAgICAgICAgZGlydHlBdG9tczogUmVjb2lsX3VuaW9uU2V0cyhzdGF0ZS5kaXJ0eUF0b21zLCB3cml0dGVuTm9kZXMpLFxuICAgICAgICBhdG9tVmFsdWVzOiBhcHBseUF0b21WYWx1ZVdyaXRlcyQxKHN0YXRlLmF0b21WYWx1ZXMsIHdyaXRlcyksXG4gICAgICAgIC8vIE5COiBQTEVBU0UgdW4tZXhwb3J0IGFwcGx5QXRvbVZhbHVlV3JpdGVzIHdoZW4gZGVsZXRpbmcgdGhpcyBjb2RlXG4gICAgICAgIG5vbnZhbGlkYXRlZEF0b21zXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzOiBhdG9tVmFsdWVzID0+IHtcbiAgICAgIC8vIEZJWE1FIHJlcGxhY2UgdGhpcyB3aXRoIGEgbXV0YXRpdmUgbG9vcFxuICAgICAgYXRvbVZhbHVlcy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgICAgIGluaXRpYWwuY3VycmVudFRyZWUgPSBzZXRVbnZhbGlkYXRlZEF0b21WYWx1ZV9ERVBSRUNBVEVEJDEoaW5pdGlhbC5jdXJyZW50VHJlZSwgaywgdik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5pdGlhbDtcbn0gLy8gSW5pdGlhbGl6ZSBzdGF0ZSBzbmFwc2hvdCBmb3IgPFJlY29pbFJvb3Q+IGZvciB0aGUgaW5pdGlhbGl6ZVN0YXRlIHByb3AuXG4vLyBBdG9tIGVmZmVjdCBpbml0aWFsaXphdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyBwcm9wLlxuLy8gQW55IGF0b20gZWZmZWN0cyB3aWxsIGJlIHJ1biBiZWZvcmUgaW5pdGlhbGl6YXRpb24sIGJ1dCB0aGVuIGNsZWFuZWQgdXAsXG4vLyB0aGV5IGFyZSB0aGVuIHJlLXJ1biB3aGVuIHVzZWQgYXMgcGFydCBvZiByZW5kZXJpbmcuICBUaGVzZSBzZW1hbnRpY3MgYXJlXG4vLyBjb21wYXRpYmxlIHdpdGggUmVhY3QgU3RyaWN0TW9kZSB3aGVyZSBlZmZlY3RzIG1heSBiZSByZS1ydW4gbXVsdGlwbGUgdGltZXNcbi8vIGJ1dCBzdGF0ZSBpbml0aWFsaXphdGlvbiBvbmx5IGhhcHBlbnMgb25jZSB0aGUgZmlyc3QgdGltZS5cblxuXG5mdW5jdGlvbiBpbml0aWFsU3RvcmVTdGF0ZShpbml0aWFsaXplU3RhdGUpIHtcbiAgLy8gSW5pdGlhbGl6ZSBhIHNuYXBzaG90IGFuZCBnZXQgaXRzIHN0b3JlXG4gIGNvbnN0IHNuYXBzaG90ID0gZnJlc2hTbmFwc2hvdCQxKGluaXRpYWxpemVTdGF0ZSk7XG4gIGNvbnN0IHN0b3JlU3RhdGUgPSBzbmFwc2hvdC5nZXRTdG9yZV9JTlRFUk5BTCgpLmdldFN0YXRlKCk7IC8vIENvdW50ZXJhY3QgdGhlIHNuYXBzaG90IGF1dG8tcmVsZWFzZVxuXG4gIHNuYXBzaG90LnJldGFpbigpOyAvLyBDbGVhbnVwIGFueSBlZmZlY3RzIHJ1biBkdXJpbmcgaW5pdGlhbGl6YXRpb24gYW5kIGNsZWFyIHRoZSBoYW5kbGVycyBzb1xuICAvLyB0aGV5IHdpbGwgcmUtaW5pdGlhbGl6ZSBpZiB1c2VkIGR1cmluZyByZW5kZXJpbmcuICBUaGlzIGFsbG93cyBhdG9tIGVmZmVjdFxuICAvLyBpbml0aWFsaXphdGlvbiB0byB0YWtlIHByZWNlZGVuY2Ugb3ZlciBpbml0aWFsaXplU3RhdGUgYW5kIGJlIGNvbXBhdGlibGVcbiAgLy8gd2l0aCBTdHJpY3RNb2RlIHNlbWFudGljcy5cblxuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmZvckVhY2goY2xlYW51cCA9PiBjbGVhbnVwKCkpO1xuICBzdG9yZVN0YXRlLm5vZGVDbGVhbnVwRnVuY3Rpb25zLmNsZWFyKCk7XG4gIHJldHVybiBzdG9yZVN0YXRlO1xufVxuXG5sZXQgbmV4dElEID0gMDtcblxuZnVuY3Rpb24gUmVjb2lsUm9vdF9JTlRFUk5BTCh7XG4gIGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVELFxuICBpbml0aWFsaXplU3RhdGUsXG4gIHN0b3JlX0lOVEVSTkFMOiBzdG9yZVByb3AsXG4gIC8vIEZvciB1c2Ugd2l0aCBSZWFjdCBcImNvbnRleHQgYnJpZGdpbmdcIlxuICBjaGlsZHJlblxufSkge1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgLy8gQGZiLW9ubHk6IHVzZUVmZmVjdCgoKSA9PiB7XG4gIC8vIEBmYi1vbmx5OiBpZiAoZ2t4KCdyZWNvaWxfdXNhZ2VfbG9nZ2luZycpKSB7XG4gIC8vIEBmYi1vbmx5OiB0cnkge1xuICAvLyBAZmItb25seTogUmVjb2lsVXNhZ2VMb2dGYWxjb0V2ZW50LmxvZygoKSA9PiAoe1xuICAvLyBAZmItb25seTogdHlwZTogUmVjb2lsdXNhZ2Vsb2dFdmVudC5SRUNPSUxfUk9PVF9NT1VOVEVELFxuICAvLyBAZmItb25seTogcGF0aDogVVJJLmdldFJlcXVlc3RVUkkoKS5nZXRQYXRoKCksXG4gIC8vIEBmYi1vbmx5OiB9KSk7XG4gIC8vIEBmYi1vbmx5OiB9IGNhdGNoIHtcbiAgLy8gQGZiLW9ubHk6IHJlY292ZXJhYmxlVmlvbGF0aW9uKFxuICAvLyBAZmItb25seTogJ0Vycm9yIHdoZW4gbG9nZ2luZyBSZWNvaWwgVXNhZ2UgZXZlbnQnLFxuICAvLyBAZmItb25seTogJ3JlY29pbCcsXG4gIC8vIEBmYi1vbmx5OiApO1xuICAvLyBAZmItb25seTogfVxuICAvLyBAZmItb25seTogfVxuICAvLyBAZmItb25seTogfSwgW10pO1xuICBsZXQgc3RvcmVTdGF0ZVJlZjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcblxuICBjb25zdCBnZXRHcmFwaCA9IHZlcnNpb24gPT4ge1xuICAgIGNvbnN0IGdyYXBocyA9IHN0b3JlU3RhdGVSZWYuY3VycmVudC5ncmFwaHNCeVZlcnNpb247XG5cbiAgICBpZiAoZ3JhcGhzLmhhcyh2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIFJlY29pbF9udWxsdGhyb3dzKGdyYXBocy5nZXQodmVyc2lvbikpO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0dyYXBoID0gZ3JhcGgkMigpO1xuICAgIGdyYXBocy5zZXQodmVyc2lvbiwgbmV3R3JhcGgpO1xuICAgIHJldHVybiBuZXdHcmFwaDtcbiAgfTtcblxuICBjb25zdCBzdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyA9IChjYWxsYmFjaywga2V5KSA9PiB7XG4gICAgaWYgKGtleSA9PSBudWxsKSB7XG4gICAgICAvLyBHbG9iYWwgdHJhbnNhY3Rpb24gc3Vic2NyaXB0aW9uc1xuICAgICAgY29uc3Qge1xuICAgICAgICB0cmFuc2FjdGlvblN1YnNjcmlwdGlvbnNcbiAgICAgIH0gPSBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCk7XG4gICAgICBjb25zdCBpZCA9IG5leHRJRCsrO1xuICAgICAgdHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLnNldChpZCwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVsZWFzZTogKCkgPT4ge1xuICAgICAgICAgIHRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUoaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb2RlLXNwZWNpZmljIHRyYW5zYWN0aW9uIHN1YnNjcmlwdGlvbnM6XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5vZGVUcmFuc2FjdGlvblN1YnNjcmlwdGlvbnNcbiAgICAgIH0gPSBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCk7XG5cbiAgICAgIGlmICghbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5oYXMoa2V5KSkge1xuICAgICAgICBub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLnNldChrZXksIG5ldyBNYXAoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlkID0gbmV4dElEKys7XG4gICAgICBSZWNvaWxfbnVsbHRocm93cyhub2RlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb25zLmdldChrZXkpKS5zZXQoaWQsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbGVhc2U6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdWJzID0gbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcblxuICAgICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICBzdWJzLmRlbGV0ZShpZCk7XG5cbiAgICAgICAgICAgIGlmIChzdWJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgbm9kZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGFkZFRyYW5zYWN0aW9uTWV0YWRhdGEgPSBtZXRhZGF0YSA9PiB7XG4gICAgc3RhcnROZXh0VHJlZUlmTmVlZGVkKHN0b3JlUmVmLmN1cnJlbnQpO1xuXG4gICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKG1ldGFkYXRhKSkge1xuICAgICAgUmVjb2lsX251bGx0aHJvd3Moc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLm5leHRUcmVlKS50cmFuc2FjdGlvbk1ldGFkYXRhW2tdID0gbWV0YWRhdGFba107XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlcGxhY2VTdGF0ZSA9IHJlcGxhY2VyID0+IHtcbiAgICBzdGFydE5leHRUcmVlSWZOZWVkZWQoc3RvcmVSZWYuY3VycmVudCk7IC8vIFVzZSByZXBsYWNlciB0byBnZXQgdGhlIG5leHQgc3RhdGU6XG5cbiAgICBjb25zdCBuZXh0VHJlZSA9IFJlY29pbF9udWxsdGhyb3dzKHN0b3JlU3RhdGVSZWYuY3VycmVudC5uZXh0VHJlZSk7XG4gICAgbGV0IHJlcGxhY2VkO1xuXG4gICAgdHJ5IHtcbiAgICAgIHN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQgPSB0cnVlO1xuICAgICAgcmVwbGFjZWQgPSByZXBsYWNlcihuZXh0VHJlZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHN0YXRlUmVwbGFjZXJJc0JlaW5nRXhlY3V0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAocmVwbGFjZWQgPT09IG5leHRUcmVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy4kcmVjb2lsRGVidWdTdGF0ZXMucHVzaChyZXBsYWNlZCk7IC8vIFRPRE8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuIGhlcmUgYmVjYXVzZSBpdCdzIG5vdCBiYXRjaGVkXG4gICAgICB9XG4gICAgfSAvLyBTYXZlIGNoYW5nZXMgdG8gbmV4dFRyZWUgYW5kIHNjaGVkdWxlIGEgUmVhY3QgdXBkYXRlOlxuXG5cbiAgICBzdG9yZVN0YXRlUmVmLmN1cnJlbnQubmV4dFRyZWUgPSByZXBsYWNlZDtcblxuICAgIGlmIChyZWFjdE1vZGUkMigpLmVhcmx5KSB7XG4gICAgICBub3RpZnlDb21wb25lbnRzKHN0b3JlUmVmLmN1cnJlbnQsIHN0b3JlU3RhdGVSZWYuY3VycmVudCwgcmVwbGFjZWQpO1xuICAgIH1cblxuICAgIFJlY29pbF9udWxsdGhyb3dzKG5vdGlmeUJhdGNoZXJPZkNoYW5nZS5jdXJyZW50KSgpO1xuICB9O1xuXG4gIGNvbnN0IG5vdGlmeUJhdGNoZXJPZkNoYW5nZSA9IHVzZVJlZiQxKG51bGwpO1xuICBjb25zdCBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2UgPSB1c2VDYWxsYmFjayh4ID0+IHtcbiAgICBub3RpZnlCYXRjaGVyT2ZDaGFuZ2UuY3VycmVudCA9IHg7XG4gIH0sIFtub3RpZnlCYXRjaGVyT2ZDaGFuZ2VdKTtcbiAgY29uc3Qgc3RvcmVSZWYgPSBSZWNvaWxfdXNlUmVmSW5pdE9uY2UoKCkgPT4gc3RvcmVQcm9wICE9PSBudWxsICYmIHN0b3JlUHJvcCAhPT0gdm9pZCAwID8gc3RvcmVQcm9wIDoge1xuICAgIHN0b3JlSUQ6IGdldE5leHRTdG9yZUlEJDIoKSxcbiAgICBnZXRTdGF0ZTogKCkgPT4gc3RvcmVTdGF0ZVJlZi5jdXJyZW50LFxuICAgIHJlcGxhY2VTdGF0ZSxcbiAgICBnZXRHcmFwaCxcbiAgICBzdWJzY3JpYmVUb1RyYW5zYWN0aW9ucyxcbiAgICBhZGRUcmFuc2FjdGlvbk1ldGFkYXRhXG4gIH0pO1xuXG4gIGlmIChzdG9yZVByb3AgIT0gbnVsbCkge1xuICAgIHN0b3JlUmVmLmN1cnJlbnQgPSBzdG9yZVByb3A7XG4gIH1cblxuICBzdG9yZVN0YXRlUmVmID0gUmVjb2lsX3VzZVJlZkluaXRPbmNlKCgpID0+IGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEICE9IG51bGwgPyBpbml0aWFsU3RvcmVTdGF0ZV9ERVBSRUNBVEVEKHN0b3JlUmVmLmN1cnJlbnQsIGluaXRpYWxpemVTdGF0ZV9ERVBSRUNBVEVEKSA6IGluaXRpYWxpemVTdGF0ZSAhPSBudWxsID8gaW5pdGlhbFN0b3JlU3RhdGUoaW5pdGlhbGl6ZVN0YXRlKSA6IG1ha2VFbXB0eVN0b3JlU3RhdGUkMigpKTtcbiAgY29uc3QgbXV0YWJsZVNvdXJjZSA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlTXV0YWJsZVNvdXJjZSQxID09PSBudWxsIHx8IGNyZWF0ZU11dGFibGVTb3VyY2UkMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlYXRlTXV0YWJsZVNvdXJjZSQxKHN0b3JlU3RhdGVSZWYsICgpID0+IHN0b3JlU3RhdGVSZWYuY3VycmVudC5jdXJyZW50VHJlZS52ZXJzaW9uKSwgW3N0b3JlU3RhdGVSZWZdKTsgLy8gQ2xlYW51cCB3aGVuIHRoZSA8UmVjb2lsUm9vdD4gaXMgdW5tb3VudGVkXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBSZWFjdCBpcyBmcmVlIHRvIGNhbGwgZWZmZWN0IGNsZWFudXAgaGFuZGxlcnMgYW5kIGVmZmVjdHMgYXQgd2lsbCwgdGhlXG4gICAgLy8gZGVwcyBhcnJheSBpcyBvbmx5IGFuIG9wdGltaXphdGlvbi4gIEZvciBleGFtcGxlLCBSZWFjdCBzdHJpY3QgbW9kZVxuICAgIC8vIHdpbGwgZXhlY3V0ZSBlYWNoIGVmZmVjdCB0d2ljZSBmb3IgdGVzdGluZy4gIFRoZXJlZm9yZSwgd2UgbmVlZCBzeW1tZXRyeVxuICAgIC8vIHRvIHJlLWluaXRpYWxpemUgYWxsIGtub3duIGF0b21zIGFmdGVyIHRoZXkgd2VyZSBjbGVhbmVkIHVwLlxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcblxuICAgIGZvciAoY29uc3QgYXRvbUtleSBvZiBuZXcgU2V0KHN0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcykpIHtcbiAgICAgIGluaXRpYWxpemVOb2RlJDIoc3RvcmUsIGF0b21LZXksICdnZXQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBhdG9tS2V5IG9mIHN0b3JlLmdldFN0YXRlKCkua25vd25BdG9tcykge1xuICAgICAgICBjbGVhblVwTm9kZSQyKHN0b3JlLCBhdG9tS2V5KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbc3RvcmVSZWZdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9yZWFjdC5jcmVhdGVFbGVtZW50KEFwcENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RvcmVSZWZcbiAgfSwgLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoTXV0YWJsZVNvdXJjZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbXV0YWJsZVNvdXJjZVxuICB9LCAvKiNfX1BVUkVfXyovcmVhY3QuY3JlYXRlRWxlbWVudChCYXRjaGVyLCB7XG4gICAgc2V0Tm90aWZ5QmF0Y2hlck9mQ2hhbmdlOiBzZXROb3RpZnlCYXRjaGVyT2ZDaGFuZ2VcbiAgfSksIGNoaWxkcmVuKSk7XG59XG5cbmZ1bmN0aW9uIFJlY29pbFJvb3QocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIG92ZXJyaWRlLFxuICAgIC4uLnByb3BzRXhjZXB0T3ZlcnJpZGVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBhbmNlc3RvclN0b3JlUmVmID0gdXNlU3RvcmVSZWYoKTtcblxuICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlICYmIGFuY2VzdG9yU3RvcmVSZWYuY3VycmVudCAhPT0gZGVmYXVsdFN0b3JlKSB7XG4gICAgLy8gSWYgYW5jZXN0b3JTdG9yZVJlZi5jdXJyZW50ICE9PSBkZWZhdWx0U3RvcmUsIGl0IG1lYW5zIHRoYXQgdGhpc1xuICAgIC8vIFJlY29pbFJvb3QgaXMgbm90IG5lc3RlZCB3aXRoaW4gYW5vdGhlci5cbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjb2lsUm9vdF9JTlRFUk5BTCwgcHJvcHNFeGNlcHRPdmVycmlkZSk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFN0b3JlSUQoKSB7XG4gIHJldHVybiB1c2VTdG9yZVJlZigpLmN1cnJlbnQuc3RvcmVJRDtcbn1cblxudmFyIFJlY29pbF9SZWNvaWxSb290ID0ge1xuICBSZWNvaWxSb290LFxuICB1c2VTdG9yZVJlZixcbiAgdXNlUmVjb2lsTXV0YWJsZVNvdXJjZSxcbiAgdXNlUmVjb2lsU3RvcmVJRCxcbiAgbm90aWZ5Q29tcG9uZW50c19GT1JfVEVTVElORzogbm90aWZ5Q29tcG9uZW50cyxcbiAgc2VuZEVuZE9mQmF0Y2hOb3RpZmljYXRpb25zX0ZPUl9URVNUSU5HOiBzZW5kRW5kT2ZCYXRjaE5vdGlmaWNhdGlvbnNcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gc2hhbGxvd0FycmF5RXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgUmVjb2lsX3NoYWxsb3dBcnJheUVxdWFsID0gc2hhbGxvd0FycmF5RXF1YWw7XG5cbmNvbnN0IHtcbiAgdXNlRWZmZWN0OiB1c2VFZmZlY3QkMSxcbiAgdXNlUmVmOiB1c2VSZWYkMlxufSA9IHJlYWN0O1xuXG5mdW5jdGlvbiB1c2VQcmV2aW91cyh2YWx1ZSkge1xuICBjb25zdCByZWYgPSB1c2VSZWYkMigpO1xuICB1c2VFZmZlY3QkMSgoKSA9PiB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG52YXIgUmVjb2lsX3VzZVByZXZpb3VzID0gdXNlUHJldmlvdXM7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDFcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICBTVVNQRU5TRV9USU1FT1VUX01TOiBTVVNQRU5TRV9USU1FT1VUX01TJDFcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIHVwZGF0ZVJldGFpbkNvdW50OiB1cGRhdGVSZXRhaW5Db3VudCQyXG59ID0gUmVjb2lsX1JldGVudGlvbjtcblxuY29uc3Qge1xuICBSZXRlbnRpb25ab25lOiBSZXRlbnRpb25ab25lJDNcbn0gPSBSZWNvaWxfUmV0ZW50aW9uWm9uZTtcblxuY29uc3Qge1xuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQyLFxuICB1c2VSZWY6IHVzZVJlZiQzXG59ID0gcmVhY3Q7XG5cbmNvbnN0IHtcbiAgaXNTU1I6IGlzU1NSJDJcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuIC8vIEkgZG9uJ3Qgc2VlIGEgd2F5IHRvIGF2b2lkIHRoZSBhbnkgdHlwZSBoZXJlIGJlY2F1c2Ugd2Ugd2FudCB0byBhY2NlcHQgcmVhZGFibGVcbi8vIGFuZCB3cml0YWJsZSB2YWx1ZXMgd2l0aCBhbnkgdHlwZSBwYXJhbWV0ZXIsIGJ1dCBub3JtYWxseSB3aXRoIHdyaXRhYmxlIG9uZXNcbi8vIFJlY29pbFN0YXRlPFNvbWVUPiBpcyBub3QgYSBzdWJ0eXBlIG9mIFJlY29pbFN0YXRlPG1peGVkPi5cblxuXG4vLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbmZ1bmN0aW9uIHVzZVJldGFpbih0b1JldGFpbikge1xuICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9yZWFjdC1ob29rc1xuXG5cbiAgcmV0dXJuIHVzZVJldGFpbl9BQ1RVQUwodG9SZXRhaW4pO1xufVxuXG5mdW5jdGlvbiB1c2VSZXRhaW5fQUNUVUFMKHRvUmV0YWluKSB7XG4gIGNvbnN0IGFycmF5ID0gQXJyYXkuaXNBcnJheSh0b1JldGFpbikgPyB0b1JldGFpbiA6IFt0b1JldGFpbl07XG4gIGNvbnN0IHJldGFpbmFibGVzID0gYXJyYXkubWFwKGEgPT4gYSBpbnN0YW5jZW9mIFJldGVudGlvblpvbmUkMyA/IGEgOiBhLmtleSk7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMSgpO1xuICB1c2VFZmZlY3QkMigoKSA9PiB7XG4gICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfbWVtb3J5X21hbmFnYW1lbnRfMjAyMCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50ICYmICFpc1NTUiQyKSB7XG4gICAgICAvLyBBbHJlYWR5IHBlcmZvcm1lZCBhIHRlbXBvcmFyeSByZXRhaW4gb24gcmVuZGVyLCBzaW1wbHkgY2FuY2VsIHRoZSByZWxlYXNlXG4gICAgICAvLyBvZiB0aGF0IHRlbXBvcmFyeSByZXRhaW4uXG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgICAgdXBkYXRlUmV0YWluQ291bnQkMihzdG9yZSwgciwgLTEpO1xuICAgICAgfVxuICAgIH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3QtaG9va3MtZGVwc1xuICB9LCBbc3RvcmVSZWYsIC4uLnJldGFpbmFibGVzXSk7IC8vIFdlIHdhbnQgdG8gcmV0YWluIGlmIHRoZSBjb21wb25lbnQgc3VzcGVuZHMuIFRoaXMgaXMgdGVycmlibGUgYnV0IHRoZSBTdXNwZW5zZVxuICAvLyBBUEkgYWZmb3JkcyB1cyBubyBiZXR0ZXIgb3B0aW9uLiBJZiB3ZSBzdXNwZW5kIGFuZCBuZXZlciBjb21taXQgYWZ0ZXIgc29tZVxuICAvLyBzZWNvbmRzLCB0aGVuIHJlbGVhc2UuIFRoZSAnYWN0dWFsJyByZXRhaW4vcmVsZWFzZSBpbiB0aGUgZWZmZWN0IGFib3ZlXG4gIC8vIGNhbmNlbHMgdGhpcy5cblxuICBjb25zdCB0aW1lb3V0SUQgPSB1c2VSZWYkMygpO1xuICBjb25zdCBwcmV2aW91c1JldGFpbmFibGVzID0gUmVjb2lsX3VzZVByZXZpb3VzKHJldGFpbmFibGVzKTtcblxuICBpZiAoIWlzU1NSJDIgJiYgKHByZXZpb3VzUmV0YWluYWJsZXMgPT09IHVuZGVmaW5lZCB8fCAhUmVjb2lsX3NoYWxsb3dBcnJheUVxdWFsKHByZXZpb3VzUmV0YWluYWJsZXMsIHJldGFpbmFibGVzKSkpIHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG5cbiAgICBmb3IgKGNvbnN0IHIgb2YgcmV0YWluYWJsZXMpIHtcbiAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIDEpO1xuICAgIH1cblxuICAgIGlmIChwcmV2aW91c1JldGFpbmFibGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgcHJldmlvdXNSZXRhaW5hYmxlcykge1xuICAgICAgICB1cGRhdGVSZXRhaW5Db3VudCQyKHN0b3JlLCByLCAtMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRpbWVvdXRJRC5jdXJyZW50KSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJRC5jdXJyZW50KTtcbiAgICB9XG5cbiAgICB0aW1lb3V0SUQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRpbWVvdXRJRC5jdXJyZW50ID0gbnVsbDtcblxuICAgICAgZm9yIChjb25zdCByIG9mIHJldGFpbmFibGVzKSB7XG4gICAgICAgIHVwZGF0ZVJldGFpbkNvdW50JDIoc3RvcmUsIHIsIC0xKTtcbiAgICAgIH1cbiAgICB9LCBTVVNQRU5TRV9USU1FT1VUX01TJDEpO1xuICB9XG59XG5cbnZhciBSZWNvaWxfdXNlUmV0YWluID0gdXNlUmV0YWluO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG4vKipcbiAqIFRISVMgQ09ERSBIQVMgQkVFTiBDT01NRU5URUQgT1VUIElOVEVOVElPTkFMTFlcbiAqXG4gKiBUaGlzIHRlY2huaXF1ZSBvZiBnZXR0aW5nIHRoZSBjb21wb25lbnQgbmFtZSBpcyBpbXBlcmZlY3QsIHNpbmNlIGl0IGJvdGggb25seVxuICogd29ya3MgaW4gYSBub24tbWluaWZpZWQgY29kZSBiYXNlLCBhbmQgbW9yZSBpbXBvcnRhbnRseSBpbnRyb2R1Y2VzIHBlcmZvcm1hbmNlXG4gKiBwcm9ibGVtcyBzaW5jZSBpdCByZWxpZXMgaW4gdGhyb3dpbmcgZXJyb3JzIHdoaWNoIGlzIGFuIGV4cGVuc2l2ZSBvcGVyYXRpb24uXG4gKlxuICogQXQgc29tZSBwb2ludCB3ZSBtYXkgd2FudCB0byByZWV2YWx1YXRlIHRoaXMgdGVjaG5pcXVlIGhlbmNlIHdoeSB3ZSBoYXZlIGNvbW1lbnRlZFxuICogdGhpcyBjb2RlIG91dCwgcmF0aGVyIHRoYW4gZGVsZXRlIGl0IGFsbCB0b2dldGhlci5cbiAqL1xuLy8gY29uc3Qge3VzZVJlZn0gPSByZXF1aXJlKCdyZWFjdCcpO1xuLy8gY29uc3QgZ2t4ID0gcmVxdWlyZSgncmVjb2lsLXNoYXJlZC91dGlsL1JlY29pbF9na3gnKTtcbi8vIGNvbnN0IHN0YWNrVHJhY2VQYXJzZXIgPSByZXF1aXJlKCdyZWNvaWwtc2hhcmVkL3V0aWwvUmVjb2lsX3N0YWNrVHJhY2VQYXJzZXInKTtcblxuZnVuY3Rpb24gdXNlQ29tcG9uZW50TmFtZSgpIHtcbiAgLy8gY29uc3QgbmFtZVJlZiA9IHVzZVJlZigpO1xuICAvLyBpZiAoX19ERVZfXykge1xuICAvLyAgIGlmIChna3goJ3JlY29pbF9pbmZlcl9jb21wb25lbnRfbmFtZXMnKSkge1xuICAvLyAgICAgaWYgKG5hbWVSZWYuY3VycmVudCA9PT0gdW5kZWZpbmVkKSB7XG4gIC8vICAgICAgIC8vIFRoZXJlIGlzIG5vIGJsZXNzZWQgd2F5IHRvIGRldGVybWluZSB0aGUgY2FsbGluZyBSZWFjdCBjb21wb25lbnQgZnJvbVxuICAvLyAgICAgICAvLyB3aXRoaW4gYSBob29rLiBUaGlzIGhhY2sgdXNlcyB0aGUgZmFjdCB0aGF0IGhvb2tzIG11c3Qgc3RhcnQgd2l0aCAndXNlJ1xuICAvLyAgICAgICAvLyBhbmQgdGhhdCBob29rcyBhcmUgZWl0aGVyIGNhbGxlZCBieSBSZWFjdCBDb21wb25lbnRzIG9yIG90aGVyIGhvb2tzLiBJdFxuICAvLyAgICAgICAvLyBmb2xsb3dzIHRoZXJlZm9yZSwgdGhhdCB0byBmaW5kIHRoZSBjYWxsaW5nIGNvbXBvbmVudCwgeW91IHNpbXBseSBuZWVkXG4gIC8vICAgICAgIC8vIHRvIGxvb2sgZG93biB0aGUgc3RhY2sgYW5kIGZpbmQgdGhlIGZpcnN0IGZ1bmN0aW9uIHdoaWNoIGRvZXNuJ3Qgc3RhcnRcbiAgLy8gICAgICAgLy8gd2l0aCAndXNlJy4gV2UgYXJlIG9ubHkgZW5hYmxpbmcgdGhpcyBpbiBkZXYgZm9yIG5vdywgc2luY2Ugb25jZSB0aGVcbiAgLy8gICAgICAgLy8gY29kZWJhc2UgaXMgbWluaWZpZWQsIHRoZSBuYW1pbmcgYXNzdW1wdGlvbnMgbm8gbG9uZ2VyIGhvbGQgdHJ1ZS5cbiAgLy8gICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZiLXd3dy9uby1uZXctZXJyb3JcbiAgLy8gICAgICAgY29uc3QgZnJhbWVzID0gc3RhY2tUcmFjZVBhcnNlcihuZXcgRXJyb3IoKS5zdGFjayk7XG4gIC8vICAgICAgIGZvciAoY29uc3Qge21ldGhvZE5hbWV9IG9mIGZyYW1lcykge1xuICAvLyAgICAgICAgIC8vIEkgb2JzZXJ2ZWQgY2FzZXMgd2hlcmUgdGhlIGZyYW1lIHdhcyBvZiB0aGUgZm9ybSAnT2JqZWN0LnVzZVhYWCdcbiAgLy8gICAgICAgICAvLyBoZW5jZSB3aHkgSSdtIHNlYXJjaGluZyBmb3IgaG9va3MgZm9sbG93aW5nIGEgd29yZCBib3VuZGFyeVxuICAvLyAgICAgICAgIGlmICghbWV0aG9kTmFtZS5tYXRjaCgvXFxidXNlW15cXGJdKyQvKSkge1xuICAvLyAgICAgICAgICAgcmV0dXJuIChuYW1lUmVmLmN1cnJlbnQgPSBtZXRob2ROYW1lKTtcbiAgLy8gICAgICAgICB9XG4gIC8vICAgICAgIH1cbiAgLy8gICAgICAgbmFtZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgLy8gICAgIH1cbiAgLy8gICAgIHJldHVybiBuYW1lUmVmLmN1cnJlbnQgPz8gJzx1bmFibGUgdG8gZGV0ZXJtaW5lIGNvbXBvbmVudCBuYW1lPic7XG4gIC8vICAgfVxuICAvLyB9XG4gIC8vIEBmYi1vbmx5OiByZXR1cm4gXCI8Y29tcG9uZW50IG5hbWUgb25seSBhdmFpbGFibGUgd2hlbiBib3RoIGluIGRldiBtb2RlIGFuZCB3aGVuIHBhc3NpbmcgR0sgJ3JlY29pbF9pbmZlcl9jb21wb25lbnRfbmFtZXMnPlwiO1xuICByZXR1cm4gJzxjb21wb25lbnQgbmFtZSBub3QgYXZhaWxhYmxlPic7IC8vIEBvc3Mtb25seVxufVxuXG52YXIgUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUgPSB1c2VDb21wb25lbnROYW1lO1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDJcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQyXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZTogY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZSQxLFxuICByZWFjdE1vZGU6IHJlYWN0TW9kZSQzLFxuICB1c2VNdXRhYmxlU291cmNlOiB1c2VNdXRhYmxlU291cmNlJDEsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxXG59ID0gUmVjb2lsX1JlYWN0TW9kZTtcblxuY29uc3Qge1xuICB1c2VSZWNvaWxNdXRhYmxlU291cmNlOiB1c2VSZWNvaWxNdXRhYmxlU291cmNlJDEsXG4gIHVzZVN0b3JlUmVmOiB1c2VTdG9yZVJlZiQyXG59ID0gUmVjb2lsX1JlY29pbFJvb3Q7XG5cbmNvbnN0IHtcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgQWJzdHJhY3RSZWNvaWxWYWx1ZTogQWJzdHJhY3RSZWNvaWxWYWx1ZSQzLFxuICBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGU6IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyLFxuICBzZXRSZWNvaWxWYWx1ZTogc2V0UmVjb2lsVmFsdWUkMixcbiAgc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZTogc2V0VW52YWxpZGF0ZWRSZWNvaWxWYWx1ZSQyLFxuICBzdWJzY3JpYmVUb1JlY29pbFZhbHVlOiBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cblxuXG5jb25zdCB7XG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayQxLFxuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQzLFxuICB1c2VNZW1vOiB1c2VNZW1vJDEsXG4gIHVzZVJlZjogdXNlUmVmJDQsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSQxXG59ID0gcmVhY3Q7XG5cbmNvbnN0IHtcbiAgc2V0QnlBZGRpbmdUb1NldDogc2V0QnlBZGRpbmdUb1NldCQyXG59ID0gUmVjb2lsX0NvcHlPbldyaXRlO1xuXG5cblxuY29uc3Qge1xuICBpc1NTUjogaXNTU1IkM1xufSA9IFJlY29pbF9FbnZpcm9ubWVudDtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gaGFuZGxlTG9hZGFibGUobG9hZGFibGUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZikge1xuICAvLyBXZSBjYW4ndCBqdXN0IHRocm93IHRoZSBwcm9taXNlIHdlIGFyZSB3YWl0aW5nIG9uIHRvIFN1c3BlbnNlLiAgSWYgdGhlXG4gIC8vIHVwc3RyZWFtIGRlcGVuZGVuY2llcyBjaGFuZ2UgaXQgbWF5IHByb2R1Y2UgYSBzdGF0ZSBpbiB3aGljaCB0aGUgY29tcG9uZW50XG4gIC8vIGNhbiByZW5kZXIsIGJ1dCBpdCB3b3VsZCBzdGlsbCBiZSBzdXNwZW5kZWQgb24gYSBQcm9taXNlIHRoYXQgbWF5IG5ldmVyIHJlc29sdmUuXG4gIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcbiAgfSBlbHNlIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3Qgc3VzcGVuZGVkQ29tcG9uZW50UmVzb2x2ZXJzID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpLnN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycztcbiAgICAgIHN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycy5hZGQocmVzb2x2ZSk7IC8vIFNTUiBzaG91bGQgY2xlYXIgb3V0IHRoZSB3YWtlLXVwIHJlc29sdmVyIGlmIHRoZSBQcm9taXNlIGlzIHJlc29sdmVkXG4gICAgICAvLyB0byBhdm9pZCBpbmZpbml0ZSBsb29wcy4gIChTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rZXhwZXJpbWVudGFsL1JlY29pbC9wdWxsLzIwNzMpXG5cbiAgICAgIGlmIChpc1NTUiQzICYmIFJlY29pbF9pc1Byb21pc2UobG9hZGFibGUuY29udGVudHMpKSB7XG4gICAgICAgIGxvYWRhYmxlLmNvbnRlbnRzLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHN1c3BlbmRlZENvbXBvbmVudFJlc29sdmVycy5kZWxldGUocmVzb2x2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0V4cGVjdGVkRXJyb3IgRmxvdyhwcm9wLW1pc3NpbmcpIGZvciBpbnRlZ3JhdGluZyB3aXRoIHRvb2xzIHRoYXQgaW5zcGVjdCB0aHJvd24gcHJvbWlzZXMgQGZiLW9ubHlcbiAgICAvLyBAZmItb25seTogcHJvbWlzZS5kaXNwbGF5TmFtZSA9IGBSZWNvaWwgU3RhdGU6ICR7cmVjb2lsVmFsdWUua2V5fWA7XG5cbiAgICB0aHJvdyBwcm9taXNlO1xuICB9IGVsc2UgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzRXJyb3InKSB7XG4gICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycihgSW52YWxpZCB2YWx1ZSBvZiBsb2FkYWJsZSBhdG9tIFwiJHtyZWNvaWxWYWx1ZS5rZXl9XCJgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCBob29rTmFtZSAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4pIHtcbiAgaWYgKCFpc1JlY29pbFZhbHVlJDIocmVjb2lsVmFsdWUpKSB7XG4gICAgdGhyb3cgUmVjb2lsX2VycihgSW52YWxpZCBhcmd1bWVudCB0byAke2hvb2tOYW1lfTogZXhwZWN0ZWQgYW4gYXRvbSBvciBzZWxlY3RvciBidXQgZ290ICR7U3RyaW5nKHJlY29pbFZhbHVlKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFZhcmlvdXMgdGhpbmdzIGFyZSBicm9rZW4gd2l0aCB1c2VSZWNvaWxJbnRlcmZhY2UsIHBhcnRpY3VsYXJseSBjb25jdXJyZW50XG4gKiBtb2RlLCBSZWFjdCBzdHJpY3QgbW9kZSwgYW5kIG1lbW9yeSBtYW5hZ2VtZW50LiBUaGV5IHdpbGwgbm90IGJlIGZpeGVkLlxuICogKi9cbmZ1bmN0aW9uIHVzZVJlY29pbEludGVyZmFjZV9ERVBSRUNBVEVEKCkge1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3Qtbm8tdW51c2VkLXN0YXRlLWhvb2tcblxuICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSQxKFtdKTtcbiAgY29uc3QgcmVjb2lsVmFsdWVzVXNlZCA9IHVzZVJlZiQ0KG5ldyBTZXQoKSk7XG4gIHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCA9IG5ldyBTZXQoKTsgLy8gVHJhY2sgdGhlIFJlY29pbFZhbHVlcyB1c2VkIGp1c3QgZHVyaW5nIHRoaXMgcmVuZGVyXG5cbiAgY29uc3QgcHJldmlvdXNTdWJzY3JpcHRpb25zID0gdXNlUmVmJDQobmV3IFNldCgpKTtcbiAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHVzZVJlZiQ0KG5ldyBNYXAoKSk7XG4gIGNvbnN0IHVuc3Vic2NyaWJlRnJvbSA9IHVzZUNhbGxiYWNrJDEoa2V5ID0+IHtcbiAgICBjb25zdCBzdWIgPSBzdWJzY3JpcHRpb25zLmN1cnJlbnQuZ2V0KGtleSk7XG5cbiAgICBpZiAoc3ViKSB7XG4gICAgICBzdWIucmVsZWFzZSgpO1xuICAgICAgc3Vic2NyaXB0aW9ucy5jdXJyZW50LmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfSwgW3N1YnNjcmlwdGlvbnNdKTtcbiAgY29uc3QgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjayQxKChfc3RhdGUsIGtleSkgPT4ge1xuICAgIGlmIChzdWJzY3JpcHRpb25zLmN1cnJlbnQuaGFzKGtleSkpIHtcbiAgICAgIGZvcmNlVXBkYXRlKFtdKTtcbiAgICB9XG4gIH0sIFtdKTsgLy8gRWZmZWN0IHRvIGFkZC9yZW1vdmUgc3Vic2NyaXB0aW9ucyBhcyBub2RlcyBhcmUgdXNlZFxuXG4gIHVzZUVmZmVjdCQzKCgpID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgUmVjb2lsX2RpZmZlcmVuY2VTZXRzKHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCwgcHJldmlvdXNTdWJzY3JpcHRpb25zLmN1cnJlbnQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChzdWJzY3JpcHRpb25zLmN1cnJlbnQuaGFzKGtleSkpIHtcbiAgICAgICAgUmVjb2lsX2V4cGVjdGF0aW9uVmlvbGF0aW9uKGBEb3VibGUgc3Vic2NyaXB0aW9uIHRvIFJlY29pbFZhbHVlIFwiJHtrZXl9XCJgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBzdWIgPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIG5ldyBBYnN0cmFjdFJlY29pbFZhbHVlJDMoa2V5KSwgc3RhdGUgPT4gdXBkYXRlU3RhdGUoc3RhdGUsIGtleSksIGNvbXBvbmVudE5hbWUpO1xuICAgICAgc3Vic2NyaXB0aW9ucy5jdXJyZW50LnNldChrZXksIHN1Yik7XG4gICAgICAvKipcbiAgICAgICAqIFNpbmNlIHdlJ3JlIHN1YnNjcmliaW5nIGluIGFuIGVmZmVjdCB3ZSBuZWVkIHRvIHVwZGF0ZSB0byB0aGUgbGF0ZXN0XG4gICAgICAgKiB2YWx1ZSBvZiB0aGUgYXRvbSBzaW5jZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHdlIHJlbmRlcmVkLiBXZSBjYW5cbiAgICAgICAqIGdvIGFoZWFkIGFuZCBkbyB0aGF0IG5vdywgdW5sZXNzIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSBiYXRjaCAtLVxuICAgICAgICogaW4gd2hpY2ggY2FzZSB3ZSBzaG91bGQgZG8gaXQgYXQgdGhlIGVuZCBvZiB0aGUgYmF0Y2gsIGR1ZSB0byB0aGVcbiAgICAgICAqIGZvbGxvd2luZyBlZGdlIGNhc2U6IFN1cHBvc2UgYW4gYXRvbSBpcyB1cGRhdGVkIGluIGFub3RoZXIgdXNlRWZmZWN0XG4gICAgICAgKiBvZiB0aGlzIHNhbWUgY29tcG9uZW50LiBUaGVuIHRoZSBmb2xsb3dpbmcgc2VxdWVuY2Ugb2YgZXZlbnRzIG9jY3VyOlxuICAgICAgICogMS4gQXRvbSBpcyB1cGRhdGVkIGFuZCBzdWJzIGZpcmVkIChidXQgd2UgbWF5IG5vdCBiZSBzdWJzY3JpYmVkXG4gICAgICAgKiAgICB5ZXQgZGVwZW5kaW5nIG9uIG9yZGVyIG9mIGVmZmVjdHMsIHNvIHdlIG1pc3MgdGhpcykgVXBkYXRlZCB2YWx1ZVxuICAgICAgICogICAgaXMgbm93IGluIG5leHRUcmVlLCBidXQgbm90IGN1cnJlbnRUcmVlLlxuICAgICAgICogMi4gVGhpcyBlZmZlY3QgaGFwcGVucy4gV2Ugc3Vic2NyaWJlIGFuZCB1cGRhdGUuXG4gICAgICAgKiAzLiBGcm9tIHRoZSB1cGRhdGUgd2UgcmUtcmVuZGVyIGFuZCByZWFkIGN1cnJlbnRUcmVlLCB3aXRoIG9sZCB2YWx1ZS5cbiAgICAgICAqIDQuIEJhdGNoZXIncyBlZmZlY3Qgc2V0cyBjdXJyZW50VHJlZSB0byBuZXh0VHJlZS5cbiAgICAgICAqIEluIHRoaXMgc2VxdWVuY2Ugd2UgbWlzcyB0aGUgdXBkYXRlLiBUbyBhdm9pZCB0aGF0LCBhZGQgdGhlIHVwZGF0ZVxuICAgICAgICogdG8gcXVldWVkQ29tcG9uZW50Q2FsbGJhY2sgaWYgYSBiYXRjaCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAqL1xuICAgICAgLy8gRklYTUUgZGVsZXRlIHF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVEIHdoZW4gZGVsZXRpbmcgdXNlSW50ZXJmYWNlLlxuXG4gICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIGlmIChzdGF0ZS5uZXh0VHJlZSkge1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnB1c2goKCkgPT4ge1xuICAgICAgICAgIHVwZGF0ZVN0YXRlKHN0b3JlLmdldFN0YXRlKCksIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU3RhdGUoc3RvcmUuZ2V0U3RhdGUoKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBSZWNvaWxfZGlmZmVyZW5jZVNldHMocHJldmlvdXNTdWJzY3JpcHRpb25zLmN1cnJlbnQsIHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgdW5zdWJzY3JpYmVGcm9tKGtleSk7XG4gICAgfSk7XG4gICAgcHJldmlvdXNTdWJzY3JpcHRpb25zLmN1cnJlbnQgPSByZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQ7XG4gIH0pOyAvLyBFZmZlY3QgdG8gdW5zdWJzY3JpYmUgZnJvbSBhbGwgd2hlbiB1bm1vdW50aW5nXG5cbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRTdWJzY3JpcHRpb25zID0gc3Vic2NyaXB0aW9ucy5jdXJyZW50OyAvLyBSZXN0b3JlIHN1YnNjcmlwdGlvbnMgdGhhdCB3ZXJlIGNsZWFyZWQgZHVlIHRvIFN0cmljdE1vZGUgcnVubmluZyB0aGlzIGVmZmVjdCB0d2ljZVxuXG4gICAgUmVjb2lsX2RpZmZlcmVuY2VTZXRzKHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCwgbmV3IFNldChjdXJyZW50U3Vic2NyaXB0aW9ucy5rZXlzKCkpKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBzdWIgPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmVSZWYuY3VycmVudCwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkMyhrZXkpLCBzdGF0ZSA9PiB1cGRhdGVTdGF0ZShzdGF0ZSwga2V5KSwgY29tcG9uZW50TmFtZSk7XG4gICAgICBjdXJyZW50U3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBzdWIpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiBjdXJyZW50U3Vic2NyaXB0aW9ucy5mb3JFYWNoKChfLCBrZXkpID0+IHVuc3Vic2NyaWJlRnJvbShrZXkpKTtcbiAgfSwgW2NvbXBvbmVudE5hbWUsIHN0b3JlUmVmLCB1bnN1YnNjcmliZUZyb20sIHVwZGF0ZVN0YXRlXSk7XG4gIHJldHVybiB1c2VNZW1vJDEoKCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICBmdW5jdGlvbiB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlU2V0UmVjb2lsU3RhdGUnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1ZhbHVlT3JVcGRhdGVyID0+IHtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgbmV3VmFsdWVPclVwZGF0ZXIpO1xuICAgICAgfTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVzZXRSZWNvaWxTdGF0ZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKCkgPT4gc2V0UmVjb2lsVmFsdWUkMihzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxTdGF0ZSwgREVGQVVMVF9WQUxVRSQyKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xuICAgICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlO1xuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghcmVjb2lsVmFsdWVzVXNlZC5jdXJyZW50LmhhcyhyZWNvaWxWYWx1ZS5rZXkpKSB7XG4gICAgICAgIHJlY29pbFZhbHVlc1VzZWQuY3VycmVudCA9IHNldEJ5QWRkaW5nVG9TZXQkMihyZWNvaWxWYWx1ZXNVc2VkLmN1cnJlbnQsIHJlY29pbFZhbHVlLmtleSk7XG4gICAgICB9IC8vIFRPRE8gUmVzdG9yZSBvcHRpbWl6YXRpb24gdG8gbWVtb2l6ZSBsb29rdXBcblxuXG4gICAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmVSZWYuY3VycmVudC5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFZhbHVlLCByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlID0gc3RvcmVTdGF0ZS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlU3RhdGUkbmV4dFRyZWUgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUpO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXG5cbiAgICBmdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZShyZWNvaWxWYWx1ZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKTtcbiAgICAgIHJldHVybiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblxuXG4gICAgZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdmFsaWRhdGVSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSwgJ3VzZVJlY29pbFN0YXRlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdXNlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUpLCB1c2VTZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSldO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXG5cbiAgICBmdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxTdGF0ZSksIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSxcbiAgICAgIGdldFJlY29pbFZhbHVlTG9hZGFibGU6IHVzZVJlY29pbFZhbHVlTG9hZGFibGUsXG4gICAgICBnZXRSZWNvaWxTdGF0ZTogdXNlUmVjb2lsU3RhdGUsXG4gICAgICBnZXRSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlLFxuICAgICAgZ2V0U2V0UmVjb2lsU3RhdGU6IHVzZVNldFJlY29pbFN0YXRlLFxuICAgICAgZ2V0UmVzZXRSZWNvaWxTdGF0ZTogdXNlUmVzZXRSZWNvaWxTdGF0ZVxuICAgIH07XG4gIH0sIFtyZWNvaWxWYWx1ZXNVc2VkLCBzdG9yZVJlZl0pO1xufVxuXG5jb25zdCByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HID0ge1xuICBjdXJyZW50OiAwXG59O1xuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1NZTkNfRVhURVJOQUxfU1RPUkUocmVjb2lsVmFsdWUpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBSZWNvaWxfdXNlQ29tcG9uZW50TmFtZSgpO1xuICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHZhciBfc3RvcmVTdGF0ZSRuZXh0VHJlZTI7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICByZWNvaWxDb21wb25lbnRHZXRSZWNvaWxWYWx1ZUNvdW50X0ZPUl9URVNUSU5HLmN1cnJlbnQrKztcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZSA9IHN0b3JlUmVmLmN1cnJlbnQ7XG4gICAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgdHJlZVN0YXRlID0gcmVhY3RNb2RlJDMoKS5lYXJseSA/IChfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZTIgIT09IHZvaWQgMCA/IF9zdG9yZVN0YXRlJG5leHRUcmVlMiA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICAgIGNvbnN0IGxvYWRhYmxlID0gZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDIoc3RvcmUsIHJlY29pbFZhbHVlLCB0cmVlU3RhdGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkYWJsZSxcbiAgICAgIGtleTogcmVjb2lsVmFsdWUua2V5XG4gICAgfTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pOyAvLyBNZW1vaXplIHRoZSBzdGF0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZXJlbmRlcnNcblxuICBjb25zdCBtZW1vaXplUHJldmlvdXNTbmFwc2hvdCA9IHVzZUNhbGxiYWNrJDEoZ2V0U3RhdGUgPT4ge1xuICAgIGxldCBwcmV2U3RhdGU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHZhciBfcHJldlN0YXRlLCBfcHJldlN0YXRlMjtcblxuICAgICAgY29uc3QgbmV4dFN0YXRlID0gZ2V0U3RhdGUoKTtcblxuICAgICAgaWYgKChfcHJldlN0YXRlID0gcHJldlN0YXRlKSAhPT0gbnVsbCAmJiBfcHJldlN0YXRlICE9PSB2b2lkIDAgJiYgX3ByZXZTdGF0ZS5sb2FkYWJsZS5pcyhuZXh0U3RhdGUubG9hZGFibGUpICYmICgoX3ByZXZTdGF0ZTIgPSBwcmV2U3RhdGUpID09PSBudWxsIHx8IF9wcmV2U3RhdGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHJldlN0YXRlMi5rZXkpID09PSBuZXh0U3RhdGUua2V5KSB7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHByZXZTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBnZXRNZW1vaXplZFNuYXBzaG90ID0gdXNlTWVtbyQxKCgpID0+IG1lbW9pemVQcmV2aW91c1NuYXBzaG90KGdldFNuYXBzaG90KSwgW2dldFNuYXBzaG90LCBtZW1vaXplUHJldmlvdXNTbmFwc2hvdF0pO1xuICBjb25zdCBzdWJzY3JpYmUgPSB1c2VDYWxsYmFjayQxKG5vdGlmeSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZSwgcmVjb2lsVmFsdWUsIG5vdGlmeSwgY29tcG9uZW50TmFtZSk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5yZWxlYXNlO1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlLCBjb21wb25lbnROYW1lXSk7XG4gIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0TWVtb2l6ZWRTbmFwc2hvdCwgLy8gZ2V0U25hcHNob3QoKVxuICBnZXRNZW1vaXplZFNuYXBzaG90IC8vIGdldFNlcnZlclNuYXBzaG90KCkgZm9yIFNTUiBzdXBwb3J0XG4gICkubG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTVVUQUJMRV9TT1VSQ0UocmVjb2lsVmFsdWUpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlMztcblxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlMyA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlMyAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUzIDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xuICBjb25zdCBnZXRMb2FkYWJsZVdpdGhUZXN0aW5nID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldExvYWRhYmxlKCk7XG4gIH0sIFtnZXRMb2FkYWJsZV0pO1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gdXNlQ2FsbGJhY2skMSgoX3N0b3JlU3RhdGUsIG5vdGlmeSkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1JlY29pbFZhbHVlJDEoc3RvcmUsIHJlY29pbFZhbHVlLCAoKSA9PiB7XG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpKSB7XG4gICAgICAgIHJldHVybiBub3RpZnkoKTtcbiAgICAgIH0gLy8gT25seSByZS1yZW5kZXIgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAgLy8gVGhpcyB3aWxsIGV2YWx1YXRlIHRoZSBhdG9tL3NlbGVjdG9yIG5vdyBhcyB3ZWxsIGFzIHdoZW4gdGhlXG4gICAgICAvLyBjb21wb25lbnQgcmVuZGVycywgYnV0IHRoYXQgbWF5IGhlbHAgd2l0aCBwcmVmZXRjaGluZy5cblxuXG4gICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG5cbiAgICAgIGlmICghcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQuaXMobmV3TG9hZGFibGUpKSB7XG4gICAgICAgIG5vdGlmeSgpO1xuICAgICAgfSAvLyBJZiB0aGUgY29tcG9uZW50IGlzIHN1c3BlbmRlZCB0aGVuIHRoZSBlZmZlY3Qgc2V0dGluZyBwcmV2TG9hZGFibGVSZWZcbiAgICAgIC8vIHdpbGwgbm90IHJ1bi4gIFNvLCBzZXQgdGhlIHByZXZpb3VzIHZhbHVlIGhlcmUgd2hlbiBpdHMgc3Vic2NyaXB0aW9uXG4gICAgICAvLyBpcyBmaXJlZCB0byB3YWtlIGl0IHVwLiAgV2UgY2FuJ3QganVzdCByZWx5IG9uIHRoaXMsIHRob3VnaCwgYmVjYXVzZVxuICAgICAgLy8gdGhpcyBvbmx5IGV4ZWN1dGVzIHdoZW4gYW4gYXRvbS9zZWxlY3RvciBpcyBkaXJ0eSBhbmQgdGhlIGF0b20vc2VsZWN0b3JcbiAgICAgIC8vIHBhc3NlZCB0byB0aGUgaG9vayBjYW4gZHluYW1pY2FsbHkgY2hhbmdlLlxuXG5cbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XG4gICAgfSwgY29tcG9uZW50TmFtZSk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5yZWxlYXNlO1xuICB9LCBbc3RvcmVSZWYsIHJlY29pbFZhbHVlLCBjb21wb25lbnROYW1lLCBnZXRMb2FkYWJsZV0pO1xuICBjb25zdCBzb3VyY2UgPSB1c2VSZWNvaWxNdXRhYmxlU291cmNlJDEoKTtcblxuICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICB0aHJvdyBSZWNvaWxfZXJyKCdSZWNvaWwgaG9va3MgbXVzdCBiZSB1c2VkIGluIGNvbXBvbmVudHMgY29udGFpbmVkIHdpdGhpbiBhIDxSZWNvaWxSb290PiBjb21wb25lbnQuJyk7XG4gIH1cblxuICBjb25zdCBsb2FkYWJsZSA9IHVzZU11dGFibGVTb3VyY2UkMShzb3VyY2UsIGdldExvYWRhYmxlV2l0aFRlc3RpbmcsIHN1YnNjcmliZSk7XG4gIGNvbnN0IHByZXZMb2FkYWJsZVJlZiA9IHVzZVJlZiQ0KGxvYWRhYmxlKTtcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbG9hZGFibGU7XG4gIH0pO1xuICByZXR1cm4gbG9hZGFibGU7XG59XG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBjb21wb25lbnROYW1lID0gUmVjb2lsX3VzZUNvbXBvbmVudE5hbWUoKTsgLy8gQWNjZXNzb3JzIHRvIGdldCB0aGUgY3VycmVudCBzdGF0ZVxuXG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlNDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlNCA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlNCAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWU0IDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xuICBjb25zdCBnZXRTdGF0ZSA9IHVzZUNhbGxiYWNrJDEoKCkgPT4gKHtcbiAgICBsb2FkYWJsZTogZ2V0TG9hZGFibGUoKSxcbiAgICBrZXk6IHJlY29pbFZhbHVlLmtleVxuICB9KSwgW2dldExvYWRhYmxlLCByZWNvaWxWYWx1ZS5rZXldKTsgLy8gTWVtb2l6ZSBzdGF0ZSBzbmFwc2hvdHNcblxuICBjb25zdCB1cGRhdGVTdGF0ZSA9IHVzZUNhbGxiYWNrJDEocHJldlN0YXRlID0+IHtcbiAgICBjb25zdCBuZXh0U3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIHJldHVybiBwcmV2U3RhdGUubG9hZGFibGUuaXMobmV4dFN0YXRlLmxvYWRhYmxlKSAmJiBwcmV2U3RhdGUua2V5ID09PSBuZXh0U3RhdGUua2V5ID8gcHJldlN0YXRlIDogbmV4dFN0YXRlO1xuICB9LCBbZ2V0U3RhdGVdKTsgLy8gU3Vic2NyaWJlIHRvIFJlY29pbCBzdGF0ZSBjaGFuZ2VzXG5cbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZVJlZi5jdXJyZW50LCByZWNvaWxWYWx1ZSwgX3N0YXRlID0+IHtcbiAgICAgIHNldFN0YXRlKHVwZGF0ZVN0YXRlKTtcbiAgICB9LCBjb21wb25lbnROYW1lKTsgLy8gVXBkYXRlIHN0YXRlIGluIGNhc2Ugd2UgYXJlIHVzaW5nIGEgZGlmZmVyZW50IGtleVxuXG4gICAgc2V0U3RhdGUodXBkYXRlU3RhdGUpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW2NvbXBvbmVudE5hbWUsIHJlY29pbFZhbHVlLCBzdG9yZVJlZiwgdXBkYXRlU3RhdGVdKTsgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlXG5cbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSB1c2VTdGF0ZSQxKGdldFN0YXRlKTsgLy8gSWYgd2UgY2hhbmdlZCBrZXlzLCB0aGVuIHJldHVybiB0aGUgc3RhdGUgZm9yIHRoZSBuZXcga2V5LlxuICAvLyBUaGlzIGlzIGltcG9ydGFudCBpbiBjYXNlIHRoZSBvbGQga2V5IHdvdWxkIGNhdXNlIHRoZSBjb21wb25lbnQgdG8gc3VzcGVuZC5cbiAgLy8gV2UgZG9uJ3QgaGF2ZSB0byBzZXQgdGhlIG5ldyBzdGF0ZSBoZXJlIHNpbmNlIHRoZSBzdWJzY3JpYmluZyBlZmZlY3QgYWJvdmVcbiAgLy8gd2lsbCBkbyB0aGF0LlxuXG4gIHJldHVybiBzdGF0ZS5rZXkgIT09IHJlY29pbFZhbHVlLmtleSA/IGdldFN0YXRlKCkubG9hZGFibGUgOiBzdGF0ZS5sb2FkYWJsZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9MRUdBQ1kocmVjb2lsVmFsdWUpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvcmVhY3Qtbm8tdW51c2VkLXN0YXRlLWhvb2tcblxuICBjb25zdCBbLCBmb3JjZVVwZGF0ZV0gPSB1c2VTdGF0ZSQxKFtdKTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IFJlY29pbF91c2VDb21wb25lbnROYW1lKCk7XG4gIGNvbnN0IGdldExvYWRhYmxlID0gdXNlQ2FsbGJhY2skMSgoKSA9PiB7XG4gICAgdmFyIF9zdG9yZVN0YXRlJG5leHRUcmVlNTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHJlY29pbENvbXBvbmVudEdldFJlY29pbFZhbHVlQ291bnRfRk9SX1RFU1RJTkcuY3VycmVudCsrO1xuICAgIH1cblxuICAgIGNvbnN0IHN0b3JlID0gc3RvcmVSZWYuY3VycmVudDtcbiAgICBjb25zdCBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB0cmVlU3RhdGUgPSByZWFjdE1vZGUkMygpLmVhcmx5ID8gKF9zdG9yZVN0YXRlJG5leHRUcmVlNSA9IHN0b3JlU3RhdGUubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZVN0YXRlJG5leHRUcmVlNSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWU1IDogc3RvcmVTdGF0ZS5jdXJyZW50VHJlZSA6IHN0b3JlU3RhdGUuY3VycmVudFRyZWU7XG4gICAgcmV0dXJuIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSwgdHJlZVN0YXRlKTtcbiAgfSwgW3N0b3JlUmVmLCByZWNvaWxWYWx1ZV0pO1xuICBjb25zdCBsb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG4gIGNvbnN0IHByZXZMb2FkYWJsZVJlZiA9IHVzZVJlZiQ0KGxvYWRhYmxlKTtcbiAgdXNlRWZmZWN0JDMoKCkgPT4ge1xuICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbG9hZGFibGU7XG4gIH0pO1xuICB1c2VFZmZlY3QkMygoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVjb2lsVmFsdWUkMShzdG9yZSwgcmVjb2lsVmFsdWUsIF9zdGF0ZSA9PiB7XG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyO1xuXG4gICAgICBpZiAoIVJlY29pbF9na3goJ3JlY29pbF9zdXBwcmVzc19yZXJlbmRlcl9pbl9jYWxsYmFjaycpKSB7XG4gICAgICAgIHJldHVybiBmb3JjZVVwZGF0ZShbXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0xvYWRhYmxlID0gZ2V0TG9hZGFibGUoKTtcblxuICAgICAgaWYgKCEoKF9wcmV2TG9hZGFibGVSZWYkY3VyciA9IHByZXZMb2FkYWJsZVJlZi5jdXJyZW50KSAhPT0gbnVsbCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIuaXMobmV3TG9hZGFibGUpKSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuICAgICAgICBmb3JjZVVwZGF0ZShuZXdMb2FkYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIHByZXZMb2FkYWJsZVJlZi5jdXJyZW50ID0gbmV3TG9hZGFibGU7XG4gICAgfSwgY29tcG9uZW50TmFtZSk7XG4gICAgLyoqXG4gICAgICogU2luY2Ugd2UncmUgc3Vic2NyaWJpbmcgaW4gYW4gZWZmZWN0IHdlIG5lZWQgdG8gdXBkYXRlIHRvIHRoZSBsYXRlc3RcbiAgICAgKiB2YWx1ZSBvZiB0aGUgYXRvbSBzaW5jZSBpdCBtYXkgaGF2ZSBjaGFuZ2VkIHNpbmNlIHdlIHJlbmRlcmVkLiBXZSBjYW5cbiAgICAgKiBnbyBhaGVhZCBhbmQgZG8gdGhhdCBub3csIHVubGVzcyB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgYmF0Y2ggLS1cbiAgICAgKiBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBkbyBpdCBhdCB0aGUgZW5kIG9mIHRoZSBiYXRjaCwgZHVlIHRvIHRoZVxuICAgICAqIGZvbGxvd2luZyBlZGdlIGNhc2U6IFN1cHBvc2UgYW4gYXRvbSBpcyB1cGRhdGVkIGluIGFub3RoZXIgdXNlRWZmZWN0XG4gICAgICogb2YgdGhpcyBzYW1lIGNvbXBvbmVudC4gVGhlbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIG9mIGV2ZW50cyBvY2N1cjpcbiAgICAgKiAxLiBBdG9tIGlzIHVwZGF0ZWQgYW5kIHN1YnMgZmlyZWQgKGJ1dCB3ZSBtYXkgbm90IGJlIHN1YnNjcmliZWRcbiAgICAgKiAgICB5ZXQgZGVwZW5kaW5nIG9uIG9yZGVyIG9mIGVmZmVjdHMsIHNvIHdlIG1pc3MgdGhpcykgVXBkYXRlZCB2YWx1ZVxuICAgICAqICAgIGlzIG5vdyBpbiBuZXh0VHJlZSwgYnV0IG5vdCBjdXJyZW50VHJlZS5cbiAgICAgKiAyLiBUaGlzIGVmZmVjdCBoYXBwZW5zLiBXZSBzdWJzY3JpYmUgYW5kIHVwZGF0ZS5cbiAgICAgKiAzLiBGcm9tIHRoZSB1cGRhdGUgd2UgcmUtcmVuZGVyIGFuZCByZWFkIGN1cnJlbnRUcmVlLCB3aXRoIG9sZCB2YWx1ZS5cbiAgICAgKiA0LiBCYXRjaGVyJ3MgZWZmZWN0IHNldHMgY3VycmVudFRyZWUgdG8gbmV4dFRyZWUuXG4gICAgICogSW4gdGhpcyBzZXF1ZW5jZSB3ZSBtaXNzIHRoZSB1cGRhdGUuIFRvIGF2b2lkIHRoYXQsIGFkZCB0aGUgdXBkYXRlXG4gICAgICogdG8gcXVldWVkQ29tcG9uZW50Q2FsbGJhY2sgaWYgYSBiYXRjaCBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cblxuICAgIGlmIChzdG9yZVN0YXRlLm5leHRUcmVlKSB7XG4gICAgICBzdG9yZS5nZXRTdGF0ZSgpLnF1ZXVlZENvbXBvbmVudENhbGxiYWNrc19ERVBSRUNBVEVELnB1c2goKCkgPT4ge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXVxuICAgICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGZvcmNlVXBkYXRlKFtdKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX3ByZXZMb2FkYWJsZVJlZiRjdXJyMjtcblxuICAgICAgaWYgKCFSZWNvaWxfZ2t4KCdyZWNvaWxfc3VwcHJlc3NfcmVyZW5kZXJfaW5fY2FsbGJhY2snKSkge1xuICAgICAgICByZXR1cm4gZm9yY2VVcGRhdGUoW10pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IGdldExvYWRhYmxlKCk7XG5cbiAgICAgIGlmICghKChfcHJldkxvYWRhYmxlUmVmJGN1cnIyID0gcHJldkxvYWRhYmxlUmVmLmN1cnJlbnQpICE9PSBudWxsICYmIF9wcmV2TG9hZGFibGVSZWYkY3VycjIgIT09IHZvaWQgMCAmJiBfcHJldkxvYWRhYmxlUmVmJGN1cnIyLmlzKG5ld0xvYWRhYmxlKSkpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF1cbiAgICAgICAgZm9yY2VVcGRhdGUobmV3TG9hZGFibGUpO1xuICAgICAgfVxuXG4gICAgICBwcmV2TG9hZGFibGVSZWYuY3VycmVudCA9IG5ld0xvYWRhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucmVsZWFzZTtcbiAgfSwgW2NvbXBvbmVudE5hbWUsIGdldExvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWZdKTtcbiAgcmV0dXJuIGxvYWRhYmxlO1xufVxuLyoqXG4gIExpa2UgdXNlUmVjb2lsVmFsdWUoKSwgYnV0IGVpdGhlciByZXR1cm5zIHRoZSB2YWx1ZSBpZiBhdmFpbGFibGUgb3JcbiAganVzdCB1bmRlZmluZWQgaWYgbm90IGF2YWlsYWJsZSBmb3IgYW55IHJlYXNvbiwgc3VjaCBhcyBwZW5kaW5nIG9yIGVycm9yLlxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVMb2FkYWJsZScpO1xuICB9XG5cbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXG4gICAgUmVjb2lsX3VzZVJldGFpbihyZWNvaWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFRSQU5TSVRJT05fU1VQUE9SVDogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlQsXG4gICAgLy8gUmVjb2lsIHdpbGwgYXR0ZW1wIHRvIGRldGVjdCBpZiBgdXNlU3luY0V4dGVybmFsU3RvcmUoKWAgaXMgc3VwcG9ydGVkIHdpdGhcbiAgICAvLyBgcmVhY3RNb2RlKClgIGJlZm9yZSBjYWxsaW5nIGl0LiAgSG93ZXZlciwgc29tZXRpbWVzIHRoZSBob3N0IFJlYWN0XG4gICAgLy8gZW52aXJvbm1lbnQgc3VwcG9ydHMgaXQgYnV0IHVzZXMgYWRkaXRpb25hbCBSZWFjdCByZW5kZXJlcnMgKHN1Y2ggYXMgd2l0aFxuICAgIC8vIGByZWFjdC10aHJlZS1maWJlcmApIHdoaWNoIGRvIG5vdC4gIFdoaWxlIHRoaXMgaXMgdGVjaG5pY2FsbHkgYSB1c2VyIGlzc3VlXG4gICAgLy8gYnkgdXNpbmcgYSByZW5kZXJlciB3aXRoIFJlYWN0IDE4KyB0aGF0IGRvZXNuJ3QgZnVsbHkgc3VwcG9ydCBSZWFjdCAxOCB3ZVxuICAgIC8vIGRvbid0IHdhbnQgdG8gYnJlYWsgdXNlcnMgaWYgaXQgY2FuIGJlIGF2b2lkZWQuIEFzIHRoZSBjdXJyZW50IHJlbmRlcmVyIGNhblxuICAgIC8vIGNoYW5nZSBhdCBydW50aW1lLCB3ZSBuZWVkIHRvIGR5bmFtaWNhbGx5IGNoZWNrIGFuZCBmYWxsYmFjayBpZiBuZWNlc3NhcnkuXG4gICAgU1lOQ19FWFRFUk5BTF9TVE9SRTogY3VycmVudFJlbmRlcmVyU3VwcG9ydHNVc2VTeW5jRXh0ZXJuYWxTdG9yZSQxKCkgPyB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1NZTkNfRVhURVJOQUxfU1RPUkUgOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVCxcbiAgICBNVVRBQkxFX1NPVVJDRTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9NVVRBQkxFX1NPVVJDRSxcbiAgICBMRUdBQ1k6IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfTEVHQUNZXG4gIH1bcmVhY3RNb2RlJDMoKS5tb2RlXShyZWNvaWxWYWx1ZSk7XG59XG4vKipcbiAgUmV0dXJucyB0aGUgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIFJlY29pbFZhbHVlLlxuICBJZiB0aGUgdmFsdWUgaXMgcGVuZGluZywgaXQgd2lsbCB0aHJvdyBhIFByb21pc2UgdG8gc3VzcGVuZCB0aGUgY29tcG9uZW50LFxuICBpZiB0aGUgdmFsdWUgaXMgYW4gZXJyb3IgaXQgd2lsbCB0aHJvdyBpdCBmb3IgdGhlIG5lYXJlc3QgUmVhY3QgZXJyb3IgYm91bmRhcnkuXG4gIFRoaXMgd2lsbCBhbHNvIHN1YnNjcmliZSB0aGUgY29tcG9uZW50IGZvciBhbnkgdXBkYXRlcyBpbiB0aGUgdmFsdWUuXG4gICovXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZScpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIGNvbnN0IGxvYWRhYmxlID0gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZShyZWNvaWxWYWx1ZSk7XG4gIHJldHVybiBoYW5kbGVMb2FkYWJsZShsb2FkYWJsZSwgcmVjb2lsVmFsdWUsIHN0b3JlUmVmKTtcbn1cbi8qKlxuICBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIHZhbHVlIG9mIGEgUmVjb2lsU3RhdGUgdG8gYmUgdXBkYXRlZCwgYnV0IGRvZXNcbiAgbm90IHN1YnNjcmliZSB0aGUgY29tcG9uZW50IHRvIGNoYW5nZXMgdG8gdGhhdCBSZWNvaWxTdGF0ZS5cbiovXG5cblxuZnVuY3Rpb24gdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VTZXRSZWNvaWxTdGF0ZScpO1xuICB9XG5cbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQyKCk7XG4gIHJldHVybiB1c2VDYWxsYmFjayQxKG5ld1ZhbHVlT3JVcGRhdGVyID0+IHtcbiAgICBzZXRSZWNvaWxWYWx1ZSQyKHN0b3JlUmVmLmN1cnJlbnQsIHJlY29pbFN0YXRlLCBuZXdWYWx1ZU9yVXBkYXRlcik7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsU3RhdGVdKTtcbn1cbi8qKlxuICBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlc2V0IHRoZSB2YWx1ZSBvZiBhIFJlY29pbFN0YXRlIHRvIGl0cyBkZWZhdWx0XG4qL1xuXG5cbmZ1bmN0aW9uIHVzZVJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZXNldFJlY29pbFN0YXRlJyk7XG4gIH1cblxuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDEoKCkgPT4ge1xuICAgIHNldFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgcmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkMik7XG4gIH0sIFtzdG9yZVJlZiwgcmVjb2lsU3RhdGVdKTtcbn1cbi8qKlxuICBFcXVpdmFsZW50IHRvIHVzZVN0YXRlKCkuIEFsbG93cyB0aGUgdmFsdWUgb2YgdGhlIFJlY29pbFN0YXRlIHRvIGJlIHJlYWQgYW5kIHdyaXR0ZW4uXG4gIFN1YnNlcXVlbnQgdXBkYXRlcyB0byB0aGUgUmVjb2lsU3RhdGUgd2lsbCBjYXVzZSB0aGUgY29tcG9uZW50IHRvIHJlLXJlbmRlci4gSWYgdGhlXG4gIFJlY29pbFN0YXRlIGlzIHBlbmRpbmcsIHRoaXMgd2lsbCBzdXNwZW5kIHRoZSBjb21wb25lbnQgYW5kIGluaXRpYXRlIHRoZVxuICByZXRyaWV2YWwgb2YgdGhlIHZhbHVlLiBJZiBldmFsdWF0aW5nIHRoZSBSZWNvaWxTdGF0ZSByZXN1bHRlZCBpbiBhbiBlcnJvciwgdGhpcyB3aWxsXG4gIHRocm93IHRoZSBlcnJvciBzbyB0aGF0IHRoZSBuZWFyZXN0IFJlYWN0IGVycm9yIGJvdW5kYXJ5IGNhbiBjYXRjaCBpdC5cbiovXG5cblxuZnVuY3Rpb24gdXNlUmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZScpO1xuICB9XG5cbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSksIHVzZVNldFJlY29pbFN0YXRlKHJlY29pbFN0YXRlKV07XG59XG4vKipcbiAgTGlrZSB1c2VSZWNvaWxTdGF0ZSgpLCBidXQgZG9lcyBub3QgY2F1c2UgU3VzcGVuc2Ugb3IgUmVhY3QgZXJyb3IgaGFuZGxpbmcuIFJldHVybnNcbiAgYW4gb2JqZWN0IHRoYXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIFJlY29pbFN0YXRlIGlzIGF2YWlsYWJsZSwgcGVuZGluZywgb3JcbiAgdW5hdmFpbGFibGUgZHVlIHRvIGFuIGVycm9yLlxuKi9cblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFN0YXRlLCAndXNlUmVjb2lsU3RhdGVMb2FkYWJsZScpO1xuICB9XG5cbiAgcmV0dXJuIFt1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzKCkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDIoKTtcbiAgcmV0dXJuICh2YWx1ZXMsIHRyYW5zYWN0aW9uTWV0YWRhdGEgPSB7fSkgPT4ge1xuICAgIGJhdGNoVXBkYXRlcyQyKCgpID0+IHtcbiAgICAgIHN0b3JlUmVmLmN1cnJlbnQuYWRkVHJhbnNhY3Rpb25NZXRhZGF0YSh0cmFuc2FjdGlvbk1ldGFkYXRhKTtcbiAgICAgIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiBzZXRVbnZhbGlkYXRlZFJlY29pbFZhbHVlJDIoc3RvcmVSZWYuY3VycmVudCwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkMyhrZXkpLCB2YWx1ZSkpO1xuICAgIH0pO1xuICB9O1xufVxuLyoqXG4gKiBFeHBlcmltZW50YWwgdmFyaWFudHMgb2YgaG9va3Mgd2l0aCBzdXBwb3J0IGZvciB1c2VUcmFuc2l0aW9uKClcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVJlY29pbFZhbHVlKHJlY29pbFZhbHVlLCAndXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUnKTtcblxuICAgIGlmICghcmVhY3RNb2RlJDMoKS5lYXJseSkge1xuICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdBdHRlcG10IHRvIHVzZSBhIGhvb2sgd2l0aCBVTlNUQUJMRV9UUkFOU0lUSU9OX1NVUFBPUlQgaW4gYSByZW5kZXJpbmcgbW9kZSBpbmNvbXBhdGlibGUgd2l0aCBjb25jdXJyZW50IHJlbmRlcmluZy4gIFRyeSBlbmFibGluZyB0aGUgcmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUgb3IgcmVjb2lsX3RyYW5zaXRpb25fc3VwcG9ydCBHS3MuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKFJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzXG4gICAgUmVjb2lsX3VzZVJldGFpbihyZWNvaWxWYWx1ZSk7XG4gIH1cblxuICByZXR1cm4gdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlQocmVjb2lsVmFsdWUpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsVmFsdWUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsVmFsdWUsICd1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUnKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkMigpO1xuICBjb25zdCBsb2FkYWJsZSA9IHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFZhbHVlKTtcbiAgcmV0dXJuIGhhbmRsZUxvYWRhYmxlKGxvYWRhYmxlLCByZWNvaWxWYWx1ZSwgc3RvcmVSZWYpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUocmVjb2lsU3RhdGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlUmVjb2lsVmFsdWUocmVjb2lsU3RhdGUsICd1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUnKTtcbiAgfVxuXG4gIHJldHVybiBbdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFKHJlY29pbFN0YXRlKSwgdXNlU2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpXTtcbn1cblxudmFyIFJlY29pbF9Ib29rcyA9IHtcbiAgcmVjb2lsQ29tcG9uZW50R2V0UmVjb2lsVmFsdWVDb3VudF9GT1JfVEVTVElORyxcbiAgdXNlUmVjb2lsSW50ZXJmYWNlOiB1c2VSZWNvaWxJbnRlcmZhY2VfREVQUkVDQVRFRCxcbiAgdXNlUmVjb2lsU3RhdGUsXG4gIHVzZVJlY29pbFN0YXRlTG9hZGFibGUsXG4gIHVzZVJlY29pbFZhbHVlLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlLFxuICB1c2VSZXNldFJlY29pbFN0YXRlLFxuICB1c2VTZXRSZWNvaWxTdGF0ZSxcbiAgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSxcbiAgdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFLFxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEVcbn07XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIG1hcCBjb250YWluaW5nIGFsbCBvZiB0aGUga2V5cyArIHZhbHVlcyBmcm9tIHRoZSBvcmlnaW5hbCBtYXAgd2hlcmVcbiAqIHRoZSBnaXZlbiBjYWxsYmFjayByZXR1cm5lZCB0cnVlLlxuICovXG5cbmZ1bmN0aW9uIGZpbHRlck1hcChtYXAsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAoKTtcblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXApIHtcbiAgICBpZiAoY2FsbGJhY2sodmFsdWUsIGtleSkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF9maWx0ZXJNYXAgPSBmaWx0ZXJNYXA7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIHNldCBjb250YWluaW5nIGFsbCBvZiB0aGUgdmFsdWVzIGZyb20gdGhlIG9yaWdpbmFsIHNldCB3aGVyZVxuICogdGhlIGdpdmVuIGNhbGxiYWNrIHJldHVybmVkIHRydWUuXG4gKi9cblxuZnVuY3Rpb24gZmlsdGVyU2V0KHNldCwgY2FsbGJhY2spIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuXG4gIGZvciAoY29uc3QgdmFsdWUgb2Ygc2V0KSB7XG4gICAgaWYgKGNhbGxiYWNrKHZhbHVlKSkge1xuICAgICAgcmVzdWx0LmFkZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlY29pbF9maWx0ZXJTZXQgPSBmaWx0ZXJTZXQ7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gbWVyZ2VNYXBzKC4uLm1hcHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gbWFwc1tpXS5rZXlzKCk7XG4gICAgbGV0IG5leHRLZXk7XG5cbiAgICB3aGlsZSAoIShuZXh0S2V5ID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS1jYWxsXSAtIG1hcC9pdGVyYXRvciBrbm93cyBub3RoaW5nIGFib3V0IGZsb3cgdHlwZXNcbiAgICAgIHJlc3VsdC5zZXQobmV4dEtleS52YWx1ZSwgbWFwc1tpXS5nZXQobmV4dEtleS52YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWNvaWxfbWVyZ2VNYXBzID0gbWVyZ2VNYXBzO1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDNcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQzLFxuICBnZXROb2RlOiBnZXROb2RlJDQsXG4gIG5vZGVzOiBub2RlcyQxXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDNcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICBBYnN0cmFjdFJlY29pbFZhbHVlOiBBYnN0cmFjdFJlY29pbFZhbHVlJDQsXG4gIHNldFJlY29pbFZhbHVlTG9hZGFibGU6IHNldFJlY29pbFZhbHVlTG9hZGFibGUkMVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICBTVVNQRU5TRV9USU1FT1VUX01TOiBTVVNQRU5TRV9USU1FT1VUX01TJDJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5jb25zdCB7XG4gIGNsb25lU25hcHNob3Q6IGNsb25lU25hcHNob3QkMVxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayQyLFxuICB1c2VFZmZlY3Q6IHVzZUVmZmVjdCQ0LFxuICB1c2VSZWY6IHVzZVJlZiQ1LFxuICB1c2VTdGF0ZTogdXNlU3RhdGUkMlxufSA9IHJlYWN0O1xuXG5jb25zdCB7XG4gIGlzU1NSOiBpc1NTUiQ0XG59ID0gUmVjb2lsX0Vudmlyb25tZW50O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZnVuY3Rpb24gdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24oY2FsbGJhY2spIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQzKCk7XG4gIHVzZUVmZmVjdCQ0KCgpID0+IHtcbiAgICBjb25zdCBzdWIgPSBzdG9yZVJlZi5jdXJyZW50LnN1YnNjcmliZVRvVHJhbnNhY3Rpb25zKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gc3ViLnJlbGVhc2U7XG4gIH0sIFtjYWxsYmFjaywgc3RvcmVSZWZdKTtcbn1cblxuZnVuY3Rpb24gZXh0ZXJuYWxseVZpc2libGVBdG9tVmFsdWVzSW5TdGF0ZShzdGF0ZSkge1xuICBjb25zdCBhdG9tVmFsdWVzID0gc3RhdGUuYXRvbVZhbHVlcy50b01hcCgpO1xuICBjb25zdCBwZXJzaXN0ZWRBdG9tQ29udGVudHNWYWx1ZXMgPSBSZWNvaWxfbWFwTWFwKFJlY29pbF9maWx0ZXJNYXAoYXRvbVZhbHVlcywgKHYsIGspID0+IHtcbiAgICBjb25zdCBub2RlID0gZ2V0Tm9kZSQ0KGspO1xuICAgIGNvbnN0IHBlcnNpc3RlbmNlID0gbm9kZS5wZXJzaXN0ZW5jZV9VTlNUQUJMRTtcbiAgICByZXR1cm4gcGVyc2lzdGVuY2UgIT0gbnVsbCAmJiBwZXJzaXN0ZW5jZS50eXBlICE9PSAnbm9uZScgJiYgdi5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJztcbiAgfSksIHYgPT4gdi5jb250ZW50cyk7IC8vIE1lcmdlIGluIG5vbnZhbGlkYXRlZCBhdG9tczsgd2UgbWF5IG5vdCBoYXZlIGRlZnMgZm9yIHRoZW0gYnV0IHRoZXkgd2lsbFxuICAvLyBhbGwgaGF2ZSBwZXJzaXN0ZW5jZSBvbiBvciB0aGV5IHdvdWxkbid0IGJlIHRoZXJlIGluIHRoZSBmaXJzdCBwbGFjZS5cblxuICByZXR1cm4gUmVjb2lsX21lcmdlTWFwcyhzdGF0ZS5ub252YWxpZGF0ZWRBdG9tcy50b01hcCgpLCBwZXJzaXN0ZWRBdG9tQ29udGVudHNWYWx1ZXMpO1xufVxuXG4vKipcbiAgQ2FsbHMgdGhlIGdpdmVuIGNhbGxiYWNrIGFmdGVyIGFueSBhdG9tcyBoYXZlIGJlZW4gbW9kaWZpZWQgYW5kIHRoZSBjb25zZXF1ZW50XG4gIGNvbXBvbmVudCByZS1yZW5kZXJzIGhhdmUgYmVlbiBjb21taXR0ZWQuIFRoaXMgaXMgaW50ZW5kZWQgZm9yIHBlcnNpc3RpbmdcbiAgdGhlIHZhbHVlcyBvZiB0aGUgYXRvbXMgdG8gc3RvcmFnZS4gVGhlIHN0b3JlZCB2YWx1ZXMgY2FuIHRoZW4gYmUgcmVzdG9yZWRcbiAgdXNpbmcgdGhlIHVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlcyBob29rLlxuXG4gIFRoZSBjYWxsYmFjayByZWNlaXZlcyB0aGUgZm9sbG93aW5nIGluZm86XG5cbiAgYXRvbVZhbHVlczogVGhlIGN1cnJlbnQgdmFsdWUgb2YgZXZlcnkgYXRvbSB0aGF0IGlzIGJvdGggcGVyc2lzdGFibGUgKHBlcnNpc3RlbmNlXG4gICAgICAgICAgICAgIHR5cGUgbm90IHNldCB0byAnbm9uZScpIGFuZCB3aG9zZSB2YWx1ZSBpcyBhdmFpbGFibGUgKG5vdCBpbiBhblxuICAgICAgICAgICAgICBlcnJvciBvciBsb2FkaW5nIHN0YXRlKS5cblxuICBwcmV2aW91c0F0b21WYWx1ZXM6IFRoZSB2YWx1ZSBvZiBldmVyeSBwZXJzaXN0YWJsZSBhbmQgYXZhaWxhYmxlIGF0b20gYmVmb3JlXG4gICAgICAgICAgICAgICB0aGUgdHJhbnNhY3Rpb24gYmVnYW4uXG5cbiAgYXRvbUluZm86IEEgbWFwIGNvbnRhaW5pbmcgdGhlIHBlcnNpc3RlbmNlIHNldHRpbmdzIGZvciBlYWNoIGF0b20uIEV2ZXJ5IGtleVxuICAgICAgICAgICAgdGhhdCBleGlzdHMgaW4gYXRvbVZhbHVlcyB3aWxsIGFsc28gZXhpc3QgaW4gYXRvbUluZm8uXG5cbiAgbW9kaWZpZWRBdG9tczogVGhlIHNldCBvZiBhdG9tcyB0aGF0IHdlcmUgd3JpdHRlbiB0byBkdXJpbmcgdGhlIHRyYW5zYWN0aW9uLlxuXG4gIHRyYW5zYWN0aW9uTWV0YWRhdGE6IEFyYml0cmFyeSBpbmZvcm1hdGlvbiB0aGF0IHdhcyBhZGRlZCB2aWEgdGhlXG4gICAgICAgICAgdXNlU2V0VW52YWxpZGF0ZWRBdG9tVmFsdWVzIGhvb2suIFVzZWZ1bCBmb3IgaWdub3JpbmcgdGhlIHVzZVNldFVudmFsaWRhdGVkQXRvbVZhbHVlc1xuICAgICAgICAgIHRyYW5zYWN0aW9uLCB0byBhdm9pZCBsb29wcy5cbiovXG5mdW5jdGlvbiB1c2VUcmFuc2FjdGlvbk9ic2VydmF0aW9uX0RFUFJFQ0FURUQoY2FsbGJhY2spIHtcbiAgdXNlVHJhbnNhY3Rpb25TdWJzY3JpcHRpb24odXNlQ2FsbGJhY2skMihzdG9yZSA9PiB7XG4gICAgbGV0IHByZXZpb3VzVHJlZSA9IHN0b3JlLmdldFN0YXRlKCkucHJldmlvdXNUcmVlO1xuICAgIGNvbnN0IGN1cnJlbnRUcmVlID0gc3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50VHJlZTtcblxuICAgIGlmICghcHJldmlvdXNUcmVlKSB7XG4gICAgICBSZWNvaWxfcmVjb3ZlcmFibGVWaW9sYXRpb24oJ1RyYW5zYWN0aW9uIHN1YnNjcmliZXJzIG5vdGlmaWVkIHdpdGhvdXQgYSBwcmV2aW91cyB0cmVlIGJlaW5nIHByZXNlbnQgLS0gdGhpcyBpcyBhIGJ1ZyBpbiBSZWNvaWwnKTtcbiAgICAgIHByZXZpb3VzVHJlZSA9IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7IC8vIGF0dGVtcHQgdG8gdHJ1bmRsZSBvblxuICAgIH1cblxuICAgIGNvbnN0IGF0b21WYWx1ZXMgPSBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKGN1cnJlbnRUcmVlKTtcbiAgICBjb25zdCBwcmV2aW91c0F0b21WYWx1ZXMgPSBleHRlcm5hbGx5VmlzaWJsZUF0b21WYWx1ZXNJblN0YXRlKHByZXZpb3VzVHJlZSk7XG4gICAgY29uc3QgYXRvbUluZm8gPSBSZWNvaWxfbWFwTWFwKG5vZGVzJDEsIG5vZGUgPT4ge1xuICAgICAgdmFyIF9ub2RlJHBlcnNpc3RlbmNlX1VOUywgX25vZGUkcGVyc2lzdGVuY2VfVU5TMiwgX25vZGUkcGVyc2lzdGVuY2VfVU5TMywgX25vZGUkcGVyc2lzdGVuY2VfVU5TNDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IHtcbiAgICAgICAgICB0eXBlOiAoX25vZGUkcGVyc2lzdGVuY2VfVU5TID0gKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzIgPSBub2RlLnBlcnNpc3RlbmNlX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwZXJzaXN0ZW5jZV9VTlMyLnR5cGUpICE9PSBudWxsICYmIF9ub2RlJHBlcnNpc3RlbmNlX1VOUyAhPT0gdm9pZCAwID8gX25vZGUkcGVyc2lzdGVuY2VfVU5TIDogJ25vbmUnLFxuICAgICAgICAgIGJhY2tCdXR0b246IChfbm9kZSRwZXJzaXN0ZW5jZV9VTlMzID0gKF9ub2RlJHBlcnNpc3RlbmNlX1VOUzQgPSBub2RlLnBlcnNpc3RlbmNlX1VOU1RBQkxFKSA9PT0gbnVsbCB8fCBfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbm9kZSRwZXJzaXN0ZW5jZV9VTlM0LmJhY2tCdXR0b24pICE9PSBudWxsICYmIF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMgIT09IHZvaWQgMCA/IF9ub2RlJHBlcnNpc3RlbmNlX1VOUzMgOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pOyAvLyBGaWx0ZXIgb24gZXhpc3RhbmNlIGluIGF0b21WYWx1ZXMgc28gdGhhdCBleHRlcm5hbGx5LXZpc2libGUgcnVsZXNcbiAgICAvLyBhcmUgYWxzbyBhcHBsaWVkIHRvIG1vZGlmaWVkIGF0b21zIChzcGVjaWZpY2FsbHkgZXhjbHVkZSBzZWxlY3RvcnMpOlxuXG4gICAgY29uc3QgbW9kaWZpZWRBdG9tcyA9IFJlY29pbF9maWx0ZXJTZXQoY3VycmVudFRyZWUuZGlydHlBdG9tcywgayA9PiBhdG9tVmFsdWVzLmhhcyhrKSB8fCBwcmV2aW91c0F0b21WYWx1ZXMuaGFzKGspKTtcbiAgICBjYWxsYmFjayh7XG4gICAgICBhdG9tVmFsdWVzLFxuICAgICAgcHJldmlvdXNBdG9tVmFsdWVzLFxuICAgICAgYXRvbUluZm8sXG4gICAgICBtb2RpZmllZEF0b21zLFxuICAgICAgdHJhbnNhY3Rpb25NZXRhZGF0YTogeyAuLi5jdXJyZW50VHJlZS50cmFuc2FjdGlvbk1ldGFkYXRhXG4gICAgICB9XG4gICAgfSk7XG4gIH0sIFtjYWxsYmFja10pKTtcbn1cblxuZnVuY3Rpb24gdXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICB1c2VUcmFuc2FjdGlvblN1YnNjcmlwdGlvbih1c2VDYWxsYmFjayQyKHN0b3JlID0+IHtcbiAgICBjb25zdCBzbmFwc2hvdCA9IGNsb25lU25hcHNob3QkMShzdG9yZSwgJ2xhdGVzdCcpO1xuICAgIGNvbnN0IHByZXZpb3VzU25hcHNob3QgPSBjbG9uZVNuYXBzaG90JDEoc3RvcmUsICdwcmV2aW91cycpO1xuICAgIGNhbGxiYWNrKHtcbiAgICAgIHNuYXBzaG90LFxuICAgICAgcHJldmlvdXNTbmFwc2hvdFxuICAgIH0pO1xuICB9LCBbY2FsbGJhY2tdKSk7XG59IC8vIFJldHVybiBhIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHN0YXRlIGFuZCBzdWJzY3JpYmUgdG8gYWxsIHN0YXRlIGNoYW5nZXNcblxuXG5mdW5jdGlvbiB1c2VSZWNvaWxTbmFwc2hvdCgpIHtcbiAgY29uc3Qgc3RvcmVSZWYgPSB1c2VTdG9yZVJlZiQzKCk7XG4gIGNvbnN0IFtzbmFwc2hvdCwgc2V0U25hcHNob3RdID0gdXNlU3RhdGUkMigoKSA9PiBjbG9uZVNuYXBzaG90JDEoc3RvcmVSZWYuY3VycmVudCkpO1xuICBjb25zdCBwcmV2aW91c1NuYXBzaG90ID0gUmVjb2lsX3VzZVByZXZpb3VzKHNuYXBzaG90KTtcbiAgY29uc3QgdGltZW91dElEID0gdXNlUmVmJDUoKTtcbiAgY29uc3QgcmVsZWFzZVJlZiA9IHVzZVJlZiQ1KCk7XG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uKHVzZUNhbGxiYWNrJDIoc3RvcmUgPT4gc2V0U25hcHNob3QoY2xvbmVTbmFwc2hvdCQxKHN0b3JlKSksIFtdKSk7IC8vIFJldGFpbiBzbmFwc2hvdCBmb3IgZHVyYXRpb24gY29tcG9uZW50IGlzIG1vdW50ZWRcblxuICB1c2VFZmZlY3QkNCgoKSA9PiB7XG4gICAgY29uc3QgcmVsZWFzZSA9IHNuYXBzaG90LnJldGFpbigpOyAvLyBSZWxlYXNlIHRoZSByZXRhaW4gZnJvbSB0aGUgcmVuZGVyaW5nIGNhbGxcblxuICAgIGlmICh0aW1lb3V0SUQuY3VycmVudCAmJiAhaXNTU1IkNCkge1xuICAgICAgdmFyIF9yZWxlYXNlUmVmJGN1cnJlbnQ7XG5cbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dElELmN1cnJlbnQpO1xuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xuICAgICAgKF9yZWxlYXNlUmVmJGN1cnJlbnQgPSByZWxlYXNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWxlYXNlUmVmJGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWxlYXNlUmVmJGN1cnJlbnQuY2FsbChyZWxlYXNlUmVmKTtcbiAgICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIERlZmVyIHRoZSByZWxlYXNlLiAgSWYgXCJGYXN0IFJlZnJlc2hcIlwiIGlzIHVzZWQgdGhlbiB0aGUgY29tcG9uZW50IG1heVxuICAgICAgLy8gcmUtcmVuZGVyIHdpdGggdGhlIHNhbWUgc3RhdGUuICBUaGUgcHJldmlvdXMgY2xlYW51cCB3aWxsIHRoZW4gcnVuIGFuZFxuICAgICAgLy8gdGhlbiB0aGUgbmV3IGVmZmVjdCB3aWxsIHJ1bi4gV2UgZG9uJ3Qgd2FudCB0aGUgc25hcHNob3QgdG8gYmUgcmVsZWFzZWRcbiAgICAgIC8vIGJ5IHRoYXQgY2xlYW51cCBiZWZvcmUgdGhlIG5ldyBlZmZlY3QgaGFzIGEgY2hhbmNlIHRvIHJldGFpbiBpdCBhZ2Fpbi5cbiAgICAgIC8vIFVzZSB0aW1lb3V0IG9mIDEwIHRvIHdvcmthcm91bmQgRmlyZWZveCBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rZXhwZXJpbWVudGFsL1JlY29pbC9pc3N1ZXMvMTkzNlxuICAgICAgd2luZG93LnNldFRpbWVvdXQocmVsZWFzZSwgMTApO1xuICAgIH07XG4gIH0sIFtzbmFwc2hvdF0pOyAvLyBSZXRhaW4gc25hcHNob3QgdW50aWwgYWJvdmUgZWZmZWN0IGlzIHJ1bi5cbiAgLy8gUmVsZWFzZSBhZnRlciBhIHRocmVzaG9sZCBpbiBjYXNlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWQuXG5cbiAgaWYgKHByZXZpb3VzU25hcHNob3QgIT09IHNuYXBzaG90ICYmICFpc1NTUiQ0KSB7XG4gICAgLy8gUmVsZWFzZSB0aGUgcHJldmlvdXMgc25hcHNob3RcbiAgICBpZiAodGltZW91dElELmN1cnJlbnQpIHtcbiAgICAgIHZhciBfcmVsZWFzZVJlZiRjdXJyZW50MjtcblxuICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0SUQuY3VycmVudCk7XG4gICAgICB0aW1lb3V0SUQuY3VycmVudCA9IG51bGw7XG4gICAgICAoX3JlbGVhc2VSZWYkY3VycmVudDIgPSByZWxlYXNlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9yZWxlYXNlUmVmJGN1cnJlbnQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVsZWFzZVJlZiRjdXJyZW50Mi5jYWxsKHJlbGVhc2VSZWYpO1xuICAgICAgcmVsZWFzZVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICByZWxlYXNlUmVmLmN1cnJlbnQgPSBzbmFwc2hvdC5yZXRhaW4oKTtcbiAgICB0aW1lb3V0SUQuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHZhciBfcmVsZWFzZVJlZiRjdXJyZW50MztcblxuICAgICAgdGltZW91dElELmN1cnJlbnQgPSBudWxsO1xuICAgICAgKF9yZWxlYXNlUmVmJGN1cnJlbnQzID0gcmVsZWFzZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVsZWFzZVJlZiRjdXJyZW50MyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VSZWYkY3VycmVudDMuY2FsbChyZWxlYXNlUmVmKTtcbiAgICAgIHJlbGVhc2VSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfSwgU1VTUEVOU0VfVElNRU9VVF9NUyQyKTtcbiAgfVxuXG4gIHJldHVybiBzbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gZ290b1NuYXBzaG90KHN0b3JlLCBzbmFwc2hvdCkge1xuICB2YXIgX3N0b3JlU3RhdGUkbmV4dFRyZWU7XG5cbiAgY29uc3Qgc3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gIGNvbnN0IHByZXYgPSAoX3N0b3JlU3RhdGUkbmV4dFRyZWUgPSBzdG9yZVN0YXRlLm5leHRUcmVlKSAhPT0gbnVsbCAmJiBfc3RvcmVTdGF0ZSRuZXh0VHJlZSAhPT0gdm9pZCAwID8gX3N0b3JlU3RhdGUkbmV4dFRyZWUgOiBzdG9yZVN0YXRlLmN1cnJlbnRUcmVlO1xuICBjb25zdCBuZXh0ID0gc25hcHNob3QuZ2V0U3RvcmVfSU5URVJOQUwoKS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuICBiYXRjaFVwZGF0ZXMkMygoKSA9PiB7XG4gICAgY29uc3Qga2V5c1RvVXBkYXRlID0gbmV3IFNldCgpO1xuXG4gICAgZm9yIChjb25zdCBrZXlzIG9mIFtwcmV2LmF0b21WYWx1ZXMua2V5cygpLCBuZXh0LmF0b21WYWx1ZXMua2V5cygpXSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICB2YXIgX3ByZXYkYXRvbVZhbHVlcyRnZXQsIF9uZXh0JGF0b21WYWx1ZXMkZ2V0O1xuXG4gICAgICAgIGlmICgoKF9wcmV2JGF0b21WYWx1ZXMkZ2V0ID0gcHJldi5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfcHJldiRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3ByZXYkYXRvbVZhbHVlcyRnZXQuY29udGVudHMpICE9PSAoKF9uZXh0JGF0b21WYWx1ZXMkZ2V0ID0gbmV4dC5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfbmV4dCRhdG9tVmFsdWVzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25leHQkYXRvbVZhbHVlcyRnZXQuY29udGVudHMpICYmIGdldE5vZGUkNChrZXkpLnNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzKSB7XG4gICAgICAgICAga2V5c1RvVXBkYXRlLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5c1RvVXBkYXRlLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHNldFJlY29pbFZhbHVlTG9hZGFibGUkMShzdG9yZSwgbmV3IEFic3RyYWN0UmVjb2lsVmFsdWUkNChrZXkpLCBuZXh0LmF0b21WYWx1ZXMuaGFzKGtleSkgPyBSZWNvaWxfbnVsbHRocm93cyhuZXh0LmF0b21WYWx1ZXMuZ2V0KGtleSkpIDogREVGQVVMVF9WQUxVRSQzKTtcbiAgICB9KTtcbiAgICBzdG9yZS5yZXBsYWNlU3RhdGUoc3RhdGUgPT4gKHsgLi4uc3RhdGUsXG4gICAgICBzdGF0ZUlEOiBzbmFwc2hvdC5nZXRJRCgpXG4gICAgfSkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdXNlR290b1JlY29pbFNuYXBzaG90KCkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDMoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDIoc25hcHNob3QgPT4gZ290b1NuYXBzaG90KHN0b3JlUmVmLmN1cnJlbnQsIHNuYXBzaG90KSwgW3N0b3JlUmVmXSk7XG59XG5cbnZhciBSZWNvaWxfU25hcHNob3RIb29rcyA9IHtcbiAgdXNlUmVjb2lsU25hcHNob3QsXG4gIGdvdG9TbmFwc2hvdCxcbiAgdXNlR290b1JlY29pbFNuYXBzaG90LFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyLFxuICB1c2VUcmFuc2FjdGlvbk9ic2VydmF0aW9uX0RFUFJFQ0FURUQsXG4gIHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uX0RFUFJFQ0FURUQ6IHVzZVRyYW5zYWN0aW9uU3Vic2NyaXB0aW9uXG59O1xuXG5jb25zdCB7XG4gIHBlZWtOb2RlSW5mbzogcGVla05vZGVJbmZvJDJcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDRcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuZnVuY3Rpb24gdXNlR2V0UmVjb2lsVmFsdWVJbmZvKCkge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDQoKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gIHJldHVybiAoe1xuICAgIGtleVxuICB9KSA9PiBwZWVrTm9kZUluZm8kMihzdG9yZVJlZi5jdXJyZW50LCBzdG9yZVJlZi5jdXJyZW50LmdldFN0YXRlKCkuY3VycmVudFRyZWUsIGtleSk7XG59XG5cbnZhciBSZWNvaWxfdXNlR2V0UmVjb2lsVmFsdWVJbmZvID0gdXNlR2V0UmVjb2lsVmFsdWVJbmZvO1xuXG5jb25zdCB7XG4gIHJlYWN0TW9kZTogcmVhY3RNb2RlJDRcbn0gPSBSZWNvaWxfUmVhY3RNb2RlO1xuXG5jb25zdCB7XG4gIFJlY29pbFJvb3Q6IFJlY29pbFJvb3QkMSxcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDVcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuXG5cbmNvbnN0IHtcbiAgdXNlTWVtbzogdXNlTWVtbyQyXG59ID0gcmVhY3Q7XG5cbmZ1bmN0aW9uIHVzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMoKSB7XG4gIC8vIFRoZSB0ZXN0IGZhaWxzIHdoZW4gdXNpbmcgdXNlTXV0YWJsZVNvdXJjZSgpLCBidXQgb25seSBpZiBhY3QoKSBpcyB1c2VkXG4gIC8vIGZvciB0aGUgbmVzdGVkIHJvb3QuICBTbywgdGhpcyBtYXkgb25seSBiZSBhIHRlc3RpbmcgZW52aXJvbm1lbnQgaXNzdWUuXG4gIGlmIChyZWFjdE1vZGUkNCgpLm1vZGUgPT09ICdNVVRBQkxFX1NPVVJDRScpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZmItd3d3L25vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IFRoZXJlIGFyZSBrbm93biBpc3N1ZXMgdXNpbmcgdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cygpIGluIHJlY29pbF9tdXRhYmxlX3NvdXJjZSByZW5kZXJpbmcgbW9kZS4gIFBsZWFzZSBjb25zaWRlciB1cGdyYWRpbmcgdG8gcmVjb2lsX3N5bmNfZXh0ZXJuYWxfc3RvcmUgbW9kZS4nKTtcbiAgfVxuXG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVSZWYkNSgpLmN1cnJlbnQ7XG4gIHJldHVybiB1c2VNZW1vJDIoKCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgICBmdW5jdGlvbiBSZWNvaWxCcmlkZ2Uoe1xuICAgICAgY2hpbGRyZW5cbiAgICB9KSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL3JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVjb2lsUm9vdCQxLCB7XG4gICAgICAgIHN0b3JlX0lOVEVSTkFMOiBzdG9yZVxuICAgICAgfSwgY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBSZWNvaWxCcmlkZ2U7XG4gIH0sIFtzdG9yZV0pO1xufVxuXG52YXIgUmVjb2lsX3VzZVJlY29pbEJyaWRnZUFjcm9zc1JlYWN0Um9vdHMgPSB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzO1xuXG5jb25zdCB7XG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBsb2FkYWJsZVdpdGhWYWx1ZSQxXG59ID0gUmVjb2lsX0xvYWRhYmxlJDE7XG5cbmNvbnN0IHtcbiAgaW5pdGlhbGl6ZU5vZGU6IGluaXRpYWxpemVOb2RlJDNcbn0gPSBSZWNvaWxfRnVuY3Rpb25hbENvcmU7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ0LFxuICBnZXROb2RlOiBnZXROb2RlJDVcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBjb3B5VHJlZVN0YXRlOiBjb3B5VHJlZVN0YXRlJDEsXG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDMsXG4gIGludmFsaWRhdGVEb3duc3RyZWFtczogaW52YWxpZGF0ZURvd25zdHJlYW1zJDEsXG4gIHdyaXRlTG9hZGFibGVUb1RyZWVTdGF0ZTogd3JpdGVMb2FkYWJsZVRvVHJlZVN0YXRlJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cblxuXG5mdW5jdGlvbiBpc0F0b20ocmVjb2lsVmFsdWUpIHtcbiAgcmV0dXJuIGdldE5vZGUkNShyZWNvaWxWYWx1ZS5rZXkpLm5vZGVUeXBlID09PSAnYXRvbSc7XG59XG5cbmNsYXNzIFRyYW5zYWN0aW9uSW50ZXJmYWNlSW1wbCB7XG4gIGNvbnN0cnVjdG9yKHN0b3JlLCB0cmVlU3RhdGUpIHtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfc3RvcmVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl90cmVlU3RhdGVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9jaGFuZ2VzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJnZXRcIiwgcmVjb2lsVmFsdWUgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NoYW5nZXMuaGFzKHJlY29pbFZhbHVlLmtleSkpIHtcbiAgICAgICAgLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlcy5nZXQocmVjb2lsVmFsdWUua2V5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc0F0b20ocmVjb2lsVmFsdWUpKSB7XG4gICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1JlYWRpbmcgc2VsZWN0b3JzIHdpdGhpbiBhdG9taWNVcGRhdGUgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb2FkYWJsZSA9IGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZSQzKHRoaXMuX3N0b3JlLCByZWNvaWxWYWx1ZSwgdGhpcy5fdHJlZVN0YXRlKTtcblxuICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKGBFeHBlY3RlZCBSZWNvaWwgYXRvbSAke3JlY29pbFZhbHVlLmtleX0gdG8gaGF2ZSBhIHZhbHVlLCBidXQgaXQgaXMgaW4gYSBsb2FkaW5nIHN0YXRlLmApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwic2V0XCIsIChyZWNvaWxTdGF0ZSwgdmFsdWVPclVwZGF0ZXIpID0+IHtcbiAgICAgIGlmICghaXNBdG9tKHJlY29pbFN0YXRlKSkge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdTZXR0aW5nIHNlbGVjdG9ycyB3aXRoaW4gYXRvbWljVXBkYXRlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5nZXQocmVjb2lsU3RhdGUpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZXMuc2V0KHJlY29pbFN0YXRlLmtleSwgdmFsdWVPclVwZGF0ZXIoY3VycmVudCkpOyAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhdG9tIGFuZCBydW4gZWZmZWN0cyBpZiBub3QgaW5pdGlhbGl6ZWQgeWV0XG4gICAgICAgIGluaXRpYWxpemVOb2RlJDModGhpcy5fc3RvcmUsIHJlY29pbFN0YXRlLmtleSwgJ3NldCcpO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZXMuc2V0KHJlY29pbFN0YXRlLmtleSwgdmFsdWVPclVwZGF0ZXIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicmVzZXRcIiwgcmVjb2lsU3RhdGUgPT4ge1xuICAgICAgdGhpcy5zZXQocmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkNCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuX3RyZWVTdGF0ZSA9IHRyZWVTdGF0ZTtcbiAgICB0aGlzLl9jaGFuZ2VzID0gbmV3IE1hcCgpO1xuICB9IC8vIEFsbG93IGRlc3RydWN0aW5nXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmYi13d3cvZXh0cmEtYXJyb3ctaW5pdGlhbGl6ZXJcblxuXG4gIG5ld1RyZWVTdGF0ZV9JTlRFUk5BTCgpIHtcbiAgICBpZiAodGhpcy5fY2hhbmdlcy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJlZVN0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld1N0YXRlID0gY29weVRyZWVTdGF0ZSQxKHRoaXMuX3RyZWVTdGF0ZSk7XG5cbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB0aGlzLl9jaGFuZ2VzKSB7XG4gICAgICB3cml0ZUxvYWRhYmxlVG9UcmVlU3RhdGUkMShuZXdTdGF0ZSwgaywgbG9hZGFibGVXaXRoVmFsdWUkMSh2KSk7XG4gICAgfVxuXG4gICAgaW52YWxpZGF0ZURvd25zdHJlYW1zJDEodGhpcy5fc3RvcmUsIG5ld1N0YXRlKTtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBhdG9taWNVcGRhdGVyKHN0b3JlKSB7XG4gIHJldHVybiBmbiA9PiB7XG4gICAgc3RvcmUucmVwbGFjZVN0YXRlKHRyZWVTdGF0ZSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2VzZXQgPSBuZXcgVHJhbnNhY3Rpb25JbnRlcmZhY2VJbXBsKHN0b3JlLCB0cmVlU3RhdGUpO1xuICAgICAgZm4oY2hhbmdlc2V0KTtcbiAgICAgIHJldHVybiBjaGFuZ2VzZXQubmV3VHJlZVN0YXRlX0lOVEVSTkFMKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbnZhciBSZWNvaWxfQXRvbWljVXBkYXRlcyA9IHtcbiAgYXRvbWljVXBkYXRlclxufTtcblxudmFyIFJlY29pbF9BdG9taWNVcGRhdGVzXzEgPSBSZWNvaWxfQXRvbWljVXBkYXRlcy5hdG9taWNVcGRhdGVyO1xuXG52YXIgUmVjb2lsX0F0b21pY1VwZGF0ZXMkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhdG9taWNVcGRhdGVyOiBSZWNvaWxfQXRvbWljVXBkYXRlc18xXG59KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICogQGZvcm1hdFxuICogQG9uY2FsbCByZWNvaWxcbiAqL1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZhcmlhbnRfMSA9IGludmFyaWFudDtcblxuLy8gQG9zcy1vbmx5XG5cblxudmFyIFJlY29pbF9pbnZhcmlhbnQgPSBpbnZhcmlhbnRfMTtcblxuY29uc3Qge1xuICBhdG9taWNVcGRhdGVyOiBhdG9taWNVcGRhdGVyJDFcbn0gPSBSZWNvaWxfQXRvbWljVXBkYXRlcyQxO1xuXG5jb25zdCB7XG4gIGJhdGNoVXBkYXRlczogYmF0Y2hVcGRhdGVzJDRcbn0gPSBSZWNvaWxfQmF0Y2hpbmc7XG5cbmNvbnN0IHtcbiAgREVGQVVMVF9WQUxVRTogREVGQVVMVF9WQUxVRSQ1XG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgdXNlU3RvcmVSZWY6IHVzZVN0b3JlUmVmJDZcbn0gPSBSZWNvaWxfUmVjb2lsUm9vdDtcblxuY29uc3Qge1xuICByZWZyZXNoUmVjb2lsVmFsdWU6IHJlZnJlc2hSZWNvaWxWYWx1ZSQxLFxuICBzZXRSZWNvaWxWYWx1ZTogc2V0UmVjb2lsVmFsdWUkM1xufSA9IFJlY29pbF9SZWNvaWxWYWx1ZUludGVyZmFjZTtcblxuY29uc3Qge1xuICBjbG9uZVNuYXBzaG90OiBjbG9uZVNuYXBzaG90JDJcbn0gPSBSZWNvaWxfU25hcHNob3QkMTtcblxuY29uc3Qge1xuICBnb3RvU25hcHNob3Q6IGdvdG9TbmFwc2hvdCQxXG59ID0gUmVjb2lsX1NuYXBzaG90SG9va3M7XG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDNcbn0gPSByZWFjdDtcblxuXG5cblxuXG5cblxuXG5cbmNsYXNzIFNlbnRpbmVsIHt9XG5cbmNvbnN0IFNFTlRJTkVMID0gbmV3IFNlbnRpbmVsKCk7XG5cbmZ1bmN0aW9uIHJlY29pbENhbGxiYWNrKHN0b3JlLCBmbiwgYXJncywgZXh0cmFJbnRlcmZhY2UpIHtcbiAgbGV0IHJldCA9IFNFTlRJTkVMO1xuICBsZXQgcmVsZWFzZVNuYXBzaG90O1xuICBiYXRjaFVwZGF0ZXMkNCgoKSA9PiB7XG4gICAgY29uc3QgZXJyTXNnID0gJ3VzZVJlY29pbENhbGxiYWNrKCkgZXhwZWN0cyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGZ1bmN0aW9uOiAnICsgJ2l0IGFjY2VwdHMgYSBmdW5jdGlvbiBvZiB0aGUgdHlwZSAoUmVjb2lsSW50ZXJmYWNlKSA9PiAoQXJncykgPT4gUmV0dXJuVHlwZSAnICsgJ2FuZCByZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gKEFyZ3MpID0+IFJldHVyblR5cGUsIHdoZXJlIFJlY29pbEludGVyZmFjZSBpcyAnICsgJ2FuIG9iamVjdCB7c25hcHNob3QsIHNldCwgLi4ufSBhbmQgQXJncyBhbmQgUmV0dXJuVHlwZSBhcmUgdGhlIGFyZ3VtZW50IGFuZCByZXR1cm4gJyArICd0eXBlcyBvZiB0aGUgY2FsbGJhY2sgeW91IHdhbnQgdG8gY3JlYXRlLiAgUGxlYXNlIHNlZSB0aGUgZG9jcyAnICsgJ2F0IHJlY29pbGpzLm9yZyBmb3IgZGV0YWlscy4nO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihlcnJNc2cpO1xuICAgIH0gLy8gQ2xvbmUgdGhlIHNuYXBzaG90IGxhemlseSB0byBhdm9pZCBvdmVyaGVhZCBpZiB0aGUgY2FsbGJhY2sgZG9lcyBub3QgdXNlIGl0LlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1lYW5zIHRoZSBzbmFwc2hvdCBtYXkgcmVwcmVzZW50IGxhdGVyIHN0YXRlIGZyb20gd2hlblxuICAgIC8vIHRoZSBjYWxsYmFjayB3YXMgY2FsbGVkIGlmIGl0IGZpcnN0IGFjY2Vzc2VzIHRoZSBzbmFwc2hvdCBhc3luY2hyb25vdXNseS5cblxuXG4gICAgY29uc3QgY2FsbGJhY2tJbnRlcmZhY2UgPSBSZWNvaWxfbGF6eVByb3h5KHsgLi4uKGV4dHJhSW50ZXJmYWNlICE9PSBudWxsICYmIGV4dHJhSW50ZXJmYWNlICE9PSB2b2lkIDAgPyBleHRyYUludGVyZmFjZSA6IHt9KSxcbiAgICAgIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICAgICAgc2V0OiAobm9kZSwgbmV3VmFsdWUpID0+IHNldFJlY29pbFZhbHVlJDMoc3RvcmUsIG5vZGUsIG5ld1ZhbHVlKSxcbiAgICAgIC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cbiAgICAgIHJlc2V0OiBub2RlID0+IHNldFJlY29pbFZhbHVlJDMoc3RvcmUsIG5vZGUsIERFRkFVTFRfVkFMVUUkNSksXG4gICAgICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gICAgICByZWZyZXNoOiBub2RlID0+IHJlZnJlc2hSZWNvaWxWYWx1ZSQxKHN0b3JlLCBub2RlKSxcbiAgICAgIGdvdG9TbmFwc2hvdDogc25hcHNob3QgPT4gZ290b1NuYXBzaG90JDEoc3RvcmUsIHNuYXBzaG90KSxcbiAgICAgIHRyYW5zYWN0X1VOU1RBQkxFOiB0cmFuc2FjdGlvbiA9PiBhdG9taWNVcGRhdGVyJDEoc3RvcmUpKHRyYW5zYWN0aW9uKVxuICAgIH0sIHtcbiAgICAgIHNuYXBzaG90OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gY2xvbmVTbmFwc2hvdCQyKHN0b3JlKTtcbiAgICAgICAgcmVsZWFzZVNuYXBzaG90ID0gc25hcHNob3QucmV0YWluKCk7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBjYWxsYmFjayA9IGZuKGNhbGxiYWNrSW50ZXJmYWNlKTtcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoZXJyTXNnKTtcbiAgICB9XG5cbiAgICByZXQgPSBjYWxsYmFjayguLi5hcmdzKTtcbiAgfSk7XG4gICEhKHJldCBpbnN0YW5jZW9mIFNlbnRpbmVsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdiYXRjaFVwZGF0ZXMgc2hvdWxkIHJldHVybiBpbW1lZGlhdGVseScpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG5cbiAgaWYgKFJlY29pbF9pc1Byb21pc2UocmV0KSkge1xuICAgIHJldCA9IHJldC5maW5hbGx5KCgpID0+IHtcbiAgICAgIHZhciBfcmVsZWFzZVNuYXBzaG90O1xuXG4gICAgICAoX3JlbGVhc2VTbmFwc2hvdCA9IHJlbGVhc2VTbmFwc2hvdCkgPT09IG51bGwgfHwgX3JlbGVhc2VTbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlbGVhc2VTbmFwc2hvdCgpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBfcmVsZWFzZVNuYXBzaG90MjtcblxuICAgIChfcmVsZWFzZVNuYXBzaG90MiA9IHJlbGVhc2VTbmFwc2hvdCkgPT09IG51bGwgfHwgX3JlbGVhc2VTbmFwc2hvdDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZWxlYXNlU25hcHNob3QyKCk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiB1c2VSZWNvaWxDYWxsYmFjayhmbiwgZGVwcykge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDYoKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrJDMoIC8vICRGbG93SXNzdWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIHJlY29pbENhbGxiYWNrKHN0b3JlUmVmLmN1cnJlbnQsIGZuLCBhcmdzKTtcbiAgfSwgZGVwcyAhPSBudWxsID8gWy4uLmRlcHMsIHN0b3JlUmVmXSA6IHVuZGVmaW5lZCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZiLXd3dy9yZWFjdC1ob29rcy1kZXBzXG4gICk7XG59XG5cbnZhciBSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2sgPSB7XG4gIHJlY29pbENhbGxiYWNrLFxuICB1c2VSZWNvaWxDYWxsYmFja1xufTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkN1xufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIHJlZnJlc2hSZWNvaWxWYWx1ZTogcmVmcmVzaFJlY29pbFZhbHVlJDJcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgdXNlQ2FsbGJhY2s6IHVzZUNhbGxiYWNrJDRcbn0gPSByZWFjdDtcblxuZnVuY3Rpb24gdXNlUmVjb2lsUmVmcmVzaGVyKHJlY29pbFZhbHVlKSB7XG4gIGNvbnN0IHN0b3JlUmVmID0gdXNlU3RvcmVSZWYkNygpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2skNCgoKSA9PiB7XG4gICAgY29uc3Qgc3RvcmUgPSBzdG9yZVJlZi5jdXJyZW50O1xuICAgIHJlZnJlc2hSZWNvaWxWYWx1ZSQyKHN0b3JlLCByZWNvaWxWYWx1ZSk7XG4gIH0sIFtyZWNvaWxWYWx1ZSwgc3RvcmVSZWZdKTtcbn1cblxudmFyIFJlY29pbF91c2VSZWNvaWxSZWZyZXNoZXIgPSB1c2VSZWNvaWxSZWZyZXNoZXI7XG5cbmNvbnN0IHtcbiAgYXRvbWljVXBkYXRlcjogYXRvbWljVXBkYXRlciQyXG59ID0gUmVjb2lsX0F0b21pY1VwZGF0ZXMkMTtcblxuY29uc3Qge1xuICB1c2VTdG9yZVJlZjogdXNlU3RvcmVSZWYkOFxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIHVzZU1lbW86IHVzZU1lbW8kM1xufSA9IHJlYWN0O1xuXG5mdW5jdGlvbiB1c2VSZWNvaWxUcmFuc2FjdGlvbihmbiwgZGVwcykge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVN0b3JlUmVmJDgoKTtcbiAgcmV0dXJuIHVzZU1lbW8kMygoKSA9PiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGF0b21pY1VwZGF0ZSA9IGF0b21pY1VwZGF0ZXIkMihzdG9yZVJlZi5jdXJyZW50KTtcbiAgICBhdG9taWNVcGRhdGUodHJhbnNhY3Rpb25JbnRlcmZhY2UgPT4ge1xuICAgICAgZm4odHJhbnNhY3Rpb25JbnRlcmZhY2UpKC4uLmFyZ3MpO1xuICAgIH0pO1xuICB9LCBkZXBzICE9IG51bGwgPyBbLi4uZGVwcywgc3RvcmVSZWZdIDogdW5kZWZpbmVkIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZmItd3d3L3JlYWN0LWhvb2tzLWRlcHNcbiAgKTtcbn1cblxudmFyIFJlY29pbF91c2VSZWNvaWxUcmFuc2FjdGlvbiA9IHVzZVJlY29pbFRyYW5zYWN0aW9uO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNsYXNzIFdyYXBwZWRWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfV3JhcHBlciA9IHtcbiAgV3JhcHBlZFZhbHVlXG59O1xuXG52YXIgUmVjb2lsX1dyYXBwZXJfMSA9IFJlY29pbF9XcmFwcGVyLldyYXBwZWRWYWx1ZTtcblxudmFyIFJlY29pbF9XcmFwcGVyJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgV3JhcHBlZFZhbHVlOiBSZWNvaWxfV3JhcHBlcl8xXG59KTtcblxuY29uc3Qge1xuICBpc0Zhc3RSZWZyZXNoRW5hYmxlZDogaXNGYXN0UmVmcmVzaEVuYWJsZWQkMlxufSA9IFJlY29pbF9SZWFjdE1vZGU7XG5cblxuXG5jbGFzcyBDaGFuZ2VkUGF0aEVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuY2xhc3MgVHJlZUNhY2hlIHtcbiAgLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkb25IaXQsIF9vcHRpb25zJG9uU2V0LCBfb3B0aW9ucyRtYXBOb2RlVmFsdWU7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbmFtZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX251bUxlYWZzXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfcm9vdFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX29uSGl0XCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfb25TZXRcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9tYXBOb2RlVmFsdWVcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX25hbWUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLl9udW1MZWFmcyA9IDA7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fb25IaXQgPSAoX29wdGlvbnMkb25IaXQgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub25IaXQpICE9PSBudWxsICYmIF9vcHRpb25zJG9uSGl0ICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRvbkhpdCA6ICgpID0+IHt9O1xuICAgIHRoaXMuX29uU2V0ID0gKF9vcHRpb25zJG9uU2V0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uU2V0KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRvblNldCAhPT0gdm9pZCAwID8gX29wdGlvbnMkb25TZXQgOiAoKSA9PiB7fTtcbiAgICB0aGlzLl9tYXBOb2RlVmFsdWUgPSAoX29wdGlvbnMkbWFwTm9kZVZhbHVlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1hcE5vZGVWYWx1ZSkgIT09IG51bGwgJiYgX29wdGlvbnMkbWFwTm9kZVZhbHVlICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRtYXBOb2RlVmFsdWUgOiB2YWwgPT4gdmFsO1xuICB9XG5cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbnVtTGVhZnM7XG4gIH0gLy8gJEZsb3dJc3N1ZVt1bmNsZWFyLXR5cGVdXG5cblxuICByb290KCkge1xuICAgIHJldHVybiB0aGlzLl9yb290O1xuICB9XG5cbiAgZ2V0KGdldE5vZGVWYWx1ZSwgaGFuZGxlcnMpIHtcbiAgICB2YXIgX3RoaXMkZ2V0TGVhZk5vZGU7XG5cbiAgICByZXR1cm4gKF90aGlzJGdldExlYWZOb2RlID0gdGhpcy5nZXRMZWFmTm9kZShnZXROb2RlVmFsdWUsIGhhbmRsZXJzKSkgPT09IG51bGwgfHwgX3RoaXMkZ2V0TGVhZk5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGdldExlYWZOb2RlLnZhbHVlO1xuICB9XG5cbiAgZ2V0TGVhZk5vZGUoZ2V0Tm9kZVZhbHVlLCBoYW5kbGVycykge1xuICAgIGlmICh0aGlzLl9yb290ID09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSAvLyBJdGVyYXRlIGRvd24gdGhlIHRyZWUgYmFzZWQgb24gdGhlIGN1cnJlbnQgbm9kZSB2YWx1ZXMgdW50aWwgd2UgaGl0IGEgbGVhZlxuICAgIC8vICRGbG93SXNzdWVbdW5jbGVhci10eXBlXVxuXG5cbiAgICBsZXQgbm9kZSA9IHRoaXMuX3Jvb3Q7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgaGFuZGxlcnMgPT09IG51bGwgfHwgaGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uTm9kZVZpc2l0KG5vZGUpO1xuXG4gICAgICBpZiAobm9kZS50eXBlID09PSAnbGVhZicpIHtcbiAgICAgICAgdGhpcy5fb25IaXQobm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGVWYWx1ZSA9IHRoaXMuX21hcE5vZGVWYWx1ZShnZXROb2RlVmFsdWUobm9kZS5ub2RlS2V5KSk7XG5cbiAgICAgIG5vZGUgPSBub2RlLmJyYW5jaGVzLmdldChub2RlVmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBzZXQocm91dGUsIHZhbHVlLCBoYW5kbGVycykge1xuICAgIGNvbnN0IGFkZExlYWYgPSAoKSA9PiB7XG4gICAgICB2YXIgX25vZGUyLCBfbm9kZTMsIF90aGlzJF9yb290MiwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0MjtcblxuICAgICAgLy8gRmlyc3QsIHNldHVwIHRoZSBicmFuY2ggbm9kZXMgZm9yIHRoZSByb3V0ZTpcbiAgICAgIC8vIEl0ZXJhdGUgZG93biB0aGUgdHJlZSB0byBmaW5kIG9yIGFkZCBicmFuY2ggbm9kZXMgZm9sbG93aW5nIHRoZSByb3V0ZVxuICAgICAgbGV0IG5vZGU7XG4gICAgICBsZXQgYnJhbmNoS2V5O1xuXG4gICAgICBmb3IgKGNvbnN0IFtub2RlS2V5LCBub2RlVmFsdWVdIG9mIHJvdXRlKSB7XG4gICAgICAgIHZhciBfbm9kZSwgX2hhbmRsZXJzJG9uTm9kZVZpc2l0LCBfdGhpcyRfcm9vdDtcblxuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgcm9vdCB3YXMgYSBsZWFmLCB3aGlsZSB3ZSBub3QgaGF2ZSBhIGdldCgpLCBpdCBtZWFuc1xuICAgICAgICAvLyB0aGUgc2VsZWN0b3IgaGFzIGluY29uc2lzdGVudCB2YWx1ZXMgb3IgaW1wbGVtZW50YXRpb24gY2hhbmdlZC5cbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3Q7XG5cbiAgICAgICAgaWYgKChyb290ID09PSBudWxsIHx8IHJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QudHlwZSkgPT09ICdsZWFmJykge1xuICAgICAgICAgIHRocm93IHRoaXMuaW52YWxpZENhY2hlRXJyb3IoKTtcbiAgICAgICAgfSAvLyBub2RlIG5vdyByZWZlcnMgdG8gdGhlIG5leHQgbm9kZSBkb3duIGluIHRoZSB0cmVlXG5cblxuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlOyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cblxuICAgICAgICBub2RlID0gcGFyZW50ID8gcGFyZW50LmJyYW5jaGVzLmdldChicmFuY2hLZXkpIDogcm9vdDsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdXG5cbiAgICAgICAgbm9kZSA9IChfbm9kZSA9IG5vZGUpICE9PSBudWxsICYmIF9ub2RlICE9PSB2b2lkIDAgPyBfbm9kZSA6IHtcbiAgICAgICAgICB0eXBlOiAnYnJhbmNoJyxcbiAgICAgICAgICBub2RlS2V5LFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBicmFuY2hlczogbmV3IE1hcCgpLFxuICAgICAgICAgIGJyYW5jaEtleVxuICAgICAgICB9OyAvLyBJZiB3ZSBmb3VuZCBhbiBleGlzdGluZyBub2RlLCBjb25maXJtIGl0IGhhcyBhIGNvbnNpc3RlbnQgdmFsdWVcblxuICAgICAgICBpZiAobm9kZS50eXBlICE9PSAnYnJhbmNoJyB8fCBub2RlLm5vZGVLZXkgIT09IG5vZGVLZXkpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLmludmFsaWRDYWNoZUVycm9yKCk7XG4gICAgICAgIH0gLy8gQWRkIHRoZSBicmFuY2ggbm9kZSB0byB0aGUgdHJlZVxuXG5cbiAgICAgICAgcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmJyYW5jaGVzLnNldChicmFuY2hLZXksIG5vZGUpO1xuICAgICAgICBoYW5kbGVycyA9PT0gbnVsbCB8fCBoYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9oYW5kbGVycyRvbk5vZGVWaXNpdCA9IGhhbmRsZXJzLm9uTm9kZVZpc2l0KSA9PT0gbnVsbCB8fCBfaGFuZGxlcnMkb25Ob2RlVmlzaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oYW5kbGVycyRvbk5vZGVWaXNpdC5jYWxsKGhhbmRsZXJzLCBub2RlKTsgLy8gUHJlcGFyZSBmb3IgbmV4dCBpdGVyYXRpb24gYW5kIGluc3RhbGwgcm9vdCBpZiBpdCBpcyBuZXcuXG5cbiAgICAgICAgYnJhbmNoS2V5ID0gdGhpcy5fbWFwTm9kZVZhbHVlKG5vZGVWYWx1ZSk7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSAoX3RoaXMkX3Jvb3QgPSB0aGlzLl9yb290KSAhPT0gbnVsbCAmJiBfdGhpcyRfcm9vdCAhPT0gdm9pZCAwID8gX3RoaXMkX3Jvb3QgOiBub2RlO1xuICAgICAgfSAvLyBTZWNvbmQsIHNldHVwIHRoZSBsZWFmIG5vZGU6XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBsZWFmIGZvciB0aGlzIHJvdXRlIGNvbmZpcm0gaXQgaXMgY29uc2lzdGVudFxuXG5cbiAgICAgIGNvbnN0IG9sZExlYWYgPSBub2RlID8gKF9ub2RlMiA9IG5vZGUpID09PSBudWxsIHx8IF9ub2RlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUyLmJyYW5jaGVzLmdldChicmFuY2hLZXkpIDogdGhpcy5fcm9vdDtcblxuICAgICAgaWYgKG9sZExlYWYgIT0gbnVsbCAmJiAob2xkTGVhZi50eXBlICE9PSAnbGVhZicgfHwgb2xkTGVhZi5icmFuY2hLZXkgIT09IGJyYW5jaEtleSkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnZhbGlkQ2FjaGVFcnJvcigpO1xuICAgICAgfSAvLyBDcmVhdGUgYSBuZXcgb3IgcmVwbGFjZW1lbnQgbGVhZi5cblxuXG4gICAgICBjb25zdCBsZWFmTm9kZSA9IHtcbiAgICAgICAgdHlwZTogJ2xlYWYnLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICBicmFuY2hLZXlcbiAgICAgIH07IC8vIEluc3RhbGwgdGhlIGxlYWYgYW5kIGNhbGwgaGFuZGxlcnNcblxuICAgICAgKF9ub2RlMyA9IG5vZGUpID09PSBudWxsIHx8IF9ub2RlMyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUzLmJyYW5jaGVzLnNldChicmFuY2hLZXksIGxlYWZOb2RlKTtcbiAgICAgIHRoaXMuX3Jvb3QgPSAoX3RoaXMkX3Jvb3QyID0gdGhpcy5fcm9vdCkgIT09IG51bGwgJiYgX3RoaXMkX3Jvb3QyICE9PSB2b2lkIDAgPyBfdGhpcyRfcm9vdDIgOiBsZWFmTm9kZTtcbiAgICAgIHRoaXMuX251bUxlYWZzKys7XG5cbiAgICAgIHRoaXMuX29uU2V0KGxlYWZOb2RlKTtcblxuICAgICAgaGFuZGxlcnMgPT09IG51bGwgfHwgaGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfaGFuZGxlcnMkb25Ob2RlVmlzaXQyID0gaGFuZGxlcnMub25Ob2RlVmlzaXQpID09PSBudWxsIHx8IF9oYW5kbGVycyRvbk5vZGVWaXNpdDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oYW5kbGVycyRvbk5vZGVWaXNpdDIuY2FsbChoYW5kbGVycywgbGVhZk5vZGUpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgYWRkTGVhZigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgY2FjaGUgd2FzIHN0YWxlIG9yIG9ic2VydmVkIGluY29uc2lzdGVudCB2YWx1ZXMsIHN1Y2ggYXMgd2l0aFxuICAgICAgLy8gRmFzdCBSZWZyZXNoLCB0aGVuIGNsZWFyIGl0IGFuZCByZWJ1aWxkIHdpdGggdGhlIG5ldyB2YWx1ZXMuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDaGFuZ2VkUGF0aEVycm9yKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgYWRkTGVhZigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJldHVybnMgdHJ1ZSBpZiBsZWFmIHdhcyBhY3R1YWxseSBkZWxldGVkIGZyb20gdGhlIHRyZWVcblxuXG4gIGRlbGV0ZShsZWFmKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMucm9vdCgpO1xuXG4gICAgaWYgKCFyb290KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGxlYWYgPT09IHJvb3QpIHtcbiAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgdGhpcy5fbnVtTGVhZnMgPSAwO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBJdGVyYXRlIHVwIGZyb20gdGhlIGxlYWYgZGVsZXRlaW5nIGl0IGZyb20gaXQncyBwYXJlbnQncyBicmFuY2hlcy5cblxuXG4gICAgbGV0IG5vZGUgPSBsZWFmLnBhcmVudDtcbiAgICBsZXQgYnJhbmNoS2V5ID0gbGVhZi5icmFuY2hLZXk7XG5cbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgdmFyIF9ub2RlNDtcblxuICAgICAgbm9kZS5icmFuY2hlcy5kZWxldGUoYnJhbmNoS2V5KTsgLy8gU3RvcCBpdGVyYXRpbmcgaWYgd2UgaGl0IHRoZSByb290LlxuXG4gICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICBpZiAobm9kZS5icmFuY2hlcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fbnVtTGVhZnMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX251bUxlYWZzLS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gU3RvcCBpdGVyYXRpbmcgaWYgdGhlcmUgYXJlIG90aGVyIGJyYW5jaGVzIHNpbmNlIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgIC8vIHJlbW92ZSBhbnkgbW9yZSBub2Rlcy5cblxuXG4gICAgICBpZiAobm9kZS5icmFuY2hlcy5zaXplID4gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gLy8gSXRlcmF0ZSB1cCB0byBvdXIgcGFyZW50XG5cblxuICAgICAgYnJhbmNoS2V5ID0gKF9ub2RlNCA9IG5vZGUpID09PSBudWxsIHx8IF9ub2RlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGU0LmJyYW5jaEtleTtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9IC8vIENvbmZpcm0gdGhhdCB0aGUgbGVhZiB3ZSBhcmUgZGVsZXRpbmcgaXMgYWN0dWFsbHkgYXR0YWNoZWQgdG8gb3VyIHRyZWVcblxuXG4gICAgZm9yICg7IG5vZGUgIT09IHJvb3Q7IG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbnVtTGVhZnMtLTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX251bUxlYWZzID0gMDtcbiAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgfVxuXG4gIGludmFsaWRDYWNoZUVycm9yKCkge1xuICAgIGNvbnN0IENIQU5HRURfUEFUSF9FUlJPUl9NRVNTQUdFID0gaXNGYXN0UmVmcmVzaEVuYWJsZWQkMigpID8gJ1Bvc3NpYmxlIEZhc3QgUmVmcmVzaCBtb2R1bGUgcmVsb2FkIGRldGVjdGVkLiAgJyArICdUaGlzIG1heSBhbHNvIGJlIGNhdXNlZCBieSBhbiBzZWxlY3RvciByZXR1cm5pbmcgaW5jb25zaXN0ZW50IHZhbHVlcy4gJyArICdSZXNldHRpbmcgY2FjaGUuJyA6ICdJbnZhbGlkIGNhY2hlIHZhbHVlcy4gIFRoaXMgaGFwcGVucyB3aGVuIHNlbGVjdG9ycyBkbyBub3QgcmV0dXJuICcgKyAnY29uc2lzdGVudCB2YWx1ZXMgZm9yIHRoZSBzYW1lIGlucHV0IGRlcGVuZGVuY3kgdmFsdWVzLiAgVGhhdCBtYXkgYWxzbyAnICsgJ2JlIGNhdXNlZCB3aGVuIHVzaW5nIEZhc3QgUmVmcmVzaCB0byBjaGFuZ2UgYSBzZWxlY3RvciBpbXBsZW1lbnRhdGlvbi4gICcgKyAnUmVzZXR0aW5nIGNhY2hlLic7XG4gICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKENIQU5HRURfUEFUSF9FUlJPUl9NRVNTQUdFICsgKHRoaXMuX25hbWUgIT0gbnVsbCA/IGAgLSAke3RoaXMuX25hbWV9YCA6ICcnKSk7XG4gICAgdGhyb3cgbmV3IENoYW5nZWRQYXRoRXJyb3IoKTtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfVHJlZUNhY2hlID0ge1xuICBUcmVlQ2FjaGVcbn07XG5cbnZhciBSZWNvaWxfVHJlZUNhY2hlXzEgPSBSZWNvaWxfVHJlZUNhY2hlLlRyZWVDYWNoZTtcblxudmFyIFJlY29pbF9UcmVlQ2FjaGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBUcmVlQ2FjaGU6IFJlY29pbF9UcmVlQ2FjaGVfMVxufSk7XG5cbmNsYXNzIExSVUNhY2hlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRtYXBLZXk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWF4U2l6ZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX3NpemVcIiwgdm9pZCAwKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9oZWFkXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfdGFpbFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX21hcFwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiX2tleU1hcHBlclwiLCB2b2lkIDApO1xuXG4gICAgdGhpcy5fbWF4U2l6ZSA9IG9wdGlvbnMubWF4U2l6ZTtcbiAgICB0aGlzLl9zaXplID0gMDtcbiAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICB0aGlzLl90YWlsID0gbnVsbDtcbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fa2V5TWFwcGVyID0gKF9vcHRpb25zJG1hcEtleSA9IG9wdGlvbnMubWFwS2V5KSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRtYXBLZXkgIT09IHZvaWQgMCA/IF9vcHRpb25zJG1hcEtleSA6IHYgPT4gdjtcbiAgfVxuXG4gIGhlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWQ7XG4gIH1cblxuICB0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLl90YWlsO1xuICB9XG5cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgfVxuXG4gIG1heFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heFNpemU7XG4gIH1cblxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXModGhpcy5fa2V5TWFwcGVyKGtleSkpO1xuICB9XG5cbiAgZ2V0KGtleSkge1xuICAgIGNvbnN0IG1hcHBlZEtleSA9IHRoaXMuX2tleU1hcHBlcihrZXkpO1xuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuX21hcC5nZXQobWFwcGVkS2V5KTtcblxuICAgIGlmICghbm9kZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLnNldChrZXksIG5vZGUudmFsdWUpO1xuICAgIHJldHVybiBub2RlLnZhbHVlO1xuICB9XG5cbiAgc2V0KGtleSwgdmFsKSB7XG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XG5cbiAgICBjb25zdCBleGlzdGluZ05vZGUgPSB0aGlzLl9tYXAuZ2V0KG1hcHBlZEtleSk7XG5cbiAgICBpZiAoZXhpc3RpbmdOb2RlKSB7XG4gICAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIH1cblxuICAgIGNvbnN0IGhlYWQgPSB0aGlzLmhlYWQoKTtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAga2V5LFxuICAgICAgcmlnaHQ6IGhlYWQsXG4gICAgICBsZWZ0OiBudWxsLFxuICAgICAgdmFsdWU6IHZhbFxuICAgIH07XG5cbiAgICBpZiAoaGVhZCkge1xuICAgICAgaGVhZC5sZWZ0ID0gbm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdGFpbCA9IG5vZGU7XG4gICAgfVxuXG4gICAgdGhpcy5fbWFwLnNldChtYXBwZWRLZXksIG5vZGUpO1xuXG4gICAgdGhpcy5faGVhZCA9IG5vZGU7XG4gICAgdGhpcy5fc2l6ZSsrO1xuXG4gICAgdGhpcy5fbWF5YmVEZWxldGVMUlUoKTtcbiAgfVxuXG4gIF9tYXliZURlbGV0ZUxSVSgpIHtcbiAgICBpZiAodGhpcy5zaXplKCkgPiB0aGlzLm1heFNpemUoKSkge1xuICAgICAgdGhpcy5kZWxldGVMcnUoKTtcbiAgICB9XG4gIH1cblxuICBkZWxldGVMcnUoKSB7XG4gICAgY29uc3QgdGFpbCA9IHRoaXMudGFpbCgpO1xuXG4gICAgaWYgKHRhaWwpIHtcbiAgICAgIHRoaXMuZGVsZXRlKHRhaWwua2V5KTtcbiAgICB9XG4gIH1cblxuICBkZWxldGUoa2V5KSB7XG4gICAgY29uc3QgbWFwcGVkS2V5ID0gdGhpcy5fa2V5TWFwcGVyKGtleSk7XG5cbiAgICBpZiAoIXRoaXMuX3NpemUgfHwgIXRoaXMuX21hcC5oYXMobWFwcGVkS2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5vZGUgPSBSZWNvaWxfbnVsbHRocm93cyh0aGlzLl9tYXAuZ2V0KG1hcHBlZEtleSkpO1xuICAgIGNvbnN0IHJpZ2h0ID0gbm9kZS5yaWdodDtcbiAgICBjb25zdCBsZWZ0ID0gbm9kZS5sZWZ0O1xuXG4gICAgaWYgKHJpZ2h0KSB7XG4gICAgICByaWdodC5sZWZ0ID0gbm9kZS5sZWZ0O1xuICAgIH1cblxuICAgIGlmIChsZWZ0KSB7XG4gICAgICBsZWZ0LnJpZ2h0ID0gbm9kZS5yaWdodDtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKCkpIHtcbiAgICAgIHRoaXMuX2hlYWQgPSByaWdodDtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKCkpIHtcbiAgICAgIHRoaXMuX3RhaWwgPSBsZWZ0O1xuICAgIH1cblxuICAgIHRoaXMuX21hcC5kZWxldGUobWFwcGVkS2V5KTtcblxuICAgIHRoaXMuX3NpemUtLTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgIHRoaXMuX3RhaWwgPSBudWxsO1xuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfTFJVQ2FjaGUgPSB7XG4gIExSVUNhY2hlXG59O1xuXG52YXIgUmVjb2lsX0xSVUNhY2hlXzEgPSBSZWNvaWxfTFJVQ2FjaGUuTFJVQ2FjaGU7XG5cbnZhciBSZWNvaWxfTFJVQ2FjaGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBMUlVDYWNoZTogUmVjb2lsX0xSVUNhY2hlXzFcbn0pO1xuXG5jb25zdCB7XG4gIExSVUNhY2hlOiBMUlVDYWNoZSQxXG59ID0gUmVjb2lsX0xSVUNhY2hlJDE7XG5cbmNvbnN0IHtcbiAgVHJlZUNhY2hlOiBUcmVlQ2FjaGUkMVxufSA9IFJlY29pbF9UcmVlQ2FjaGUkMTtcblxuZnVuY3Rpb24gdHJlZUNhY2hlTFJVKHtcbiAgbmFtZSxcbiAgbWF4U2l6ZSxcbiAgbWFwTm9kZVZhbHVlID0gdiA9PiB2XG59KSB7XG4gIGNvbnN0IGxydUNhY2hlID0gbmV3IExSVUNhY2hlJDEoe1xuICAgIG1heFNpemVcbiAgfSk7XG4gIGNvbnN0IGNhY2hlID0gbmV3IFRyZWVDYWNoZSQxKHtcbiAgICBuYW1lLFxuICAgIG1hcE5vZGVWYWx1ZSxcbiAgICBvbkhpdDogbm9kZSA9PiB7XG4gICAgICBscnVDYWNoZS5zZXQobm9kZSwgdHJ1ZSk7XG4gICAgfSxcbiAgICBvblNldDogbm9kZSA9PiB7XG4gICAgICBjb25zdCBscnVOb2RlID0gbHJ1Q2FjaGUudGFpbCgpO1xuICAgICAgbHJ1Q2FjaGUuc2V0KG5vZGUsIHRydWUpO1xuXG4gICAgICBpZiAobHJ1Tm9kZSAmJiBjYWNoZS5zaXplKCkgPiBtYXhTaXplKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG4gICAgICAgIGNhY2hlLmRlbGV0ZShscnVOb2RlLmtleSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNhY2hlO1xufVxuXG52YXIgUmVjb2lsX3RyZWVDYWNoZUxSVSA9IHRyZWVDYWNoZUxSVTtcblxuY29uc3QgVElNRV9XQVJOSU5HX1RIUkVTSE9MRF9NUyA9IDE1O1xuXG5mdW5jdGlvbiBzdHJpbmdpZnkoeCwgb3B0LCBrZXkpIHtcbiAgLy8gQSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgdGhlIG1vcmUgZXhwZW5zaXZlIEpTT04uc3RyaW5naWZ5KCkgZm9yIHNpbXBsZSBzdHJpbmdzXG4gIC8vIFRoaXMgbWF5IGxvc2UgcHJvdGVjdGlvbiBmb3IgdTIwMjggYW5kIHUyMDI5LCB0aG91Z2guXG4gIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiYgIXguaW5jbHVkZXMoJ1wiJykgJiYgIXguaW5jbHVkZXMoJ1xcXFwnKSkge1xuICAgIHJldHVybiBgXCIke3h9XCJgO1xuICB9IC8vIEhhbmRsZSBwcmltaXRpdmUgdHlwZXNcblxuXG4gIHN3aXRjaCAodHlwZW9mIHgpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuICcnO1xuICAgIC8vIEpTT04uc3RyaW5naWZ5KHVuZGVmaW5lZCkgcmV0dXJucyB1bmRlZmluZWQsIGJ1dCB3ZSBhbHdheXMgd2FudCB0byByZXR1cm4gYSBzdHJpbmdcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHggPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgLy8gY2FzZSAnYmlnaW50JzogLy8gQmlnSW50IGlzIG5vdCBzdXBwb3J0ZWQgaW4gd3d3XG4gICAgICByZXR1cm4gU3RyaW5nKHgpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIC8vIEFkZCBzdXJyb3VuZGluZyBxdW90ZXMgYW5kIGVzY2FwZSBpbnRlcm5hbCBxdW90ZXNcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KTtcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGlmICgob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmFsbG93RnVuY3Rpb25zKSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBSZWNvaWxfZXJyKCdBdHRlbXB0IHRvIHNlcmlhbGl6ZSBmdW5jdGlvbiBpbiBhIFJlY29pbCBjYWNoZSBrZXknKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGBfX0ZVTkNUSU9OKCR7eC5uYW1lfSlfX2A7XG4gIH1cblxuICBpZiAoeCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH0gLy8gRmFsbGJhY2sgY2FzZSBmb3IgdW5rbm93biB0eXBlc1xuXG5cbiAgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgIHZhciBfSlNPTiRzdHJpbmdpZnk7XG5cbiAgICByZXR1cm4gKF9KU09OJHN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5KHgpKSAhPT0gbnVsbCAmJiBfSlNPTiRzdHJpbmdpZnkgIT09IHZvaWQgMCA/IF9KU09OJHN0cmluZ2lmeSA6ICcnO1xuICB9IC8vIERlYWwgd2l0aCBhbGwgcHJvbWlzZXMgYXMgZXF1aXZhbGVudCBmb3Igbm93LlxuXG5cbiAgaWYgKFJlY29pbF9pc1Byb21pc2UoeCkpIHtcbiAgICByZXR1cm4gJ19fUFJPTUlTRV9fJztcbiAgfSAvLyBBcnJheXMgaGFuZGxlIHJlY3Vyc2l2ZSBzdHJpbmdpZmljYXRpb25cblxuXG4gIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICAgIHJldHVybiBgWyR7eC5tYXAoKHYsIGkpID0+IHN0cmluZ2lmeSh2LCBvcHQsIGkudG9TdHJpbmcoKSkpfV1gO1xuICB9IC8vIElmIGFuIG9iamVjdCBkZWZpbmVzIGEgdG9KU09OKCkgbWV0aG9kLCB0aGVuIHVzZSB0aGF0IHRvIG92ZXJyaWRlIHRoZVxuICAvLyBzZXJpYWxpemF0aW9uLiAgVGhpcyBtYXRjaGVzIHRoZSBiZWhhdmlvciBvZiBKU09OLnN0cmluZ2lmeSgpLlxuICAvLyBQYXNzIHRoZSBrZXkgZm9yIGNvbXBhdGliaWxpdHkuXG4gIC8vIEltbXV0YWJsZS5qcyBjb2xsZWN0aW9ucyBkZWZpbmUgdGhpcyBtZXRob2QgdG8gYWxsb3cgdXMgdG8gc2VyaWFsaXplIHRoZW0uXG5cblxuICBpZiAodHlwZW9mIHgudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG4gICAgcmV0dXJuIHN0cmluZ2lmeSh4LnRvSlNPTihrZXkpLCBvcHQsIGtleSk7XG4gIH0gLy8gRm9yIGJ1aWx0LWluIE1hcHMsIHNvcnQgdGhlIGtleXMgaW4gYSBzdGFibGUgb3JkZXIgaW5zdGVhZCBvZiB0aGVcbiAgLy8gZGVmYXVsdCBpbnNlcnRpb24gb3JkZXIuICBTdXBwb3J0IG5vbi1zdHJpbmcga2V5cy5cblxuXG4gIGlmICh4IGluc3RhbmNlb2YgTWFwKSB7XG4gICAgY29uc3Qgb2JqID0ge307XG5cbiAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB4KSB7XG4gICAgICAvLyBTdHJpbmdpZnkgd2lsbCBlc2NhcGUgYW55IG5lc3RlZCBxdW90ZXNcbiAgICAgIG9ialt0eXBlb2YgayA9PT0gJ3N0cmluZycgPyBrIDogc3RyaW5naWZ5KGssIG9wdCldID0gdjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KG9iaiwgb3B0LCBrZXkpO1xuICB9IC8vIEZvciBidWlsdC1pbiBTZXRzLCBzb3J0IHRoZSBrZXlzIGluIGEgc3RhYmxlIG9yZGVyIGluc3RlYWQgb2YgdGhlXG4gIC8vIGRlZmF1bHQgaW5zZXJ0aW9uIG9yZGVyLlxuXG5cbiAgaWYgKHggaW5zdGFuY2VvZiBTZXQpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5KCAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gICAgQXJyYXkuZnJvbSh4KS5zb3J0KChhLCBiKSA9PiBzdHJpbmdpZnkoYSwgb3B0KS5sb2NhbGVDb21wYXJlKHN0cmluZ2lmeShiLCBvcHQpKSksIG9wdCwga2V5KTtcbiAgfSAvLyBBbnl0aGluZyBlbHNlIHRoYXQgaXMgaXRlcmFibGUgc2VyaWFsaXplIGFzIGFuIEFycmF5LlxuXG5cbiAgaWYgKFN5bWJvbCAhPT0gdW5kZWZpbmVkICYmIHhbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOiBvZmZcbiAgICByZXR1cm4gc3RyaW5naWZ5KEFycmF5LmZyb20oeCksIG9wdCwga2V5KTtcbiAgfSAvLyBGb3IgYWxsIG90aGVyIE9iamVjdHMsIHNvcnQgdGhlIGtleXMgaW4gYSBzdGFibGUgb3JkZXIuXG5cblxuICByZXR1cm4gYHske09iamVjdC5rZXlzKHgpLmZpbHRlcihrID0+IHhba10gIT09IHVuZGVmaW5lZCkuc29ydCgpIC8vIHN0cmluZ2lmeSB0aGUga2V5IHRvIGFkZCBxdW90ZXMgYW5kIGVzY2FwZSBhbnkgbmVzdGVkIHNsYXNoZXMgb3IgcXVvdGVzLlxuICAubWFwKGsgPT4gYCR7c3RyaW5naWZ5KGssIG9wdCl9OiR7c3RyaW5naWZ5KHhba10sIG9wdCwgayl9YCkuam9pbignLCcpfX1gO1xufSAvLyBVdGlsaXR5IHNpbWlsYXIgdG8gSlNPTi5zdHJpbmdpZnkoKSBleGNlcHQ6XG4vLyAqIFNlcmlhbGl6ZSBidWlsdC1pbiBTZXRzIGFzIGFuIEFycmF5XG4vLyAqIFNlcmlhbGl6ZSBidWlsdC1pbiBNYXBzIGFzIGFuIE9iamVjdC4gIFN1cHBvcnRzIG5vbi1zdHJpbmcga2V5cy5cbi8vICogU2VyaWFsaXplIG90aGVyIGl0ZXJhYmxlcyBhcyBhcnJheXNcbi8vICogU29ydCB0aGUga2V5cyBvZiBPYmplY3RzIGFuZCBNYXBzIHRvIGhhdmUgYSBzdGFibGUgb3JkZXIgYmFzZWQgb24gc3RyaW5nIGNvbnZlcnNpb24uXG4vLyAgICBUaGlzIG92ZXJyaWRlcyB0aGVpciBkZWZhdWx0IGluc2VydGlvbiBvcmRlci5cbi8vICogU3RpbGwgdXNlcyB0b0pTT04oKSBvZiBhbnkgb2JqZWN0IHRvIG92ZXJyaWRlIHNlcmlhbGl6YXRpb25cbi8vICogU3VwcG9ydCBTeW1ib2xzICh0aG91Z2ggZG9uJ3QgZ3VhcmFudGVlIHVuaXF1ZW5lc3MpXG4vLyAqIFdlIGNvdWxkIHN1cHBvcnQgQmlnSW50LCBidXQgRmxvdyBkb2Vzbid0IHNlZW0gdG8gbGlrZSBpdC5cbi8vIFNlZSBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5LXRlc3QuanMgZm9yIGV4YW1wbGVzXG5cblxuZnVuY3Rpb24gc3RhYmxlU3RyaW5naWZ5KHgsIG9wdCA9IHtcbiAgYWxsb3dGdW5jdGlvbnM6IGZhbHNlXG59KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IDA7XG4gICAgICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoeCwgb3B0KTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2UgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgOiAwO1xuXG4gICAgICBpZiAoZW5kVGltZSAtIHN0YXJ0VGltZSA+IFRJTUVfV0FSTklOR19USFJFU0hPTERfTVMpIHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgZmItd3d3L25vLWNvbnNvbGUgKi9cbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZChgUmVjb2lsOiBTcGVudCAke2VuZFRpbWUgLSBzdGFydFRpbWV9bXMgY29tcHV0aW5nIGEgY2FjaGUga2V5YCk7XG4gICAgICAgIGNvbnNvbGUud2Fybih4LCBzdHIpO1xuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKCk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgZmItd3d3L25vLWNvbnNvbGUgKi9cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHgsIG9wdCk7XG59XG5cbnZhciBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5ID0gc3RhYmxlU3RyaW5naWZ5O1xuXG5jb25zdCB7XG4gIFRyZWVDYWNoZTogVHJlZUNhY2hlJDJcbn0gPSBSZWNvaWxfVHJlZUNhY2hlJDE7XG5cblxuXG5cblxuXG5cblxuXG5jb25zdCBkZWZhdWx0UG9saWN5ID0ge1xuICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXG4gIGV2aWN0aW9uOiAna2VlcC1hbGwnLFxuICBtYXhTaXplOiBJbmZpbml0eVxufTtcblxuZnVuY3Rpb24gdHJlZUNhY2hlRnJvbVBvbGljeSh7XG4gIGVxdWFsaXR5ID0gZGVmYXVsdFBvbGljeS5lcXVhbGl0eSxcbiAgZXZpY3Rpb24gPSBkZWZhdWx0UG9saWN5LmV2aWN0aW9uLFxuICBtYXhTaXplID0gZGVmYXVsdFBvbGljeS5tYXhTaXplXG59ID0gZGVmYXVsdFBvbGljeSwgbmFtZSkge1xuICBjb25zdCB2YWx1ZU1hcHBlciA9IGdldFZhbHVlTWFwcGVyKGVxdWFsaXR5KTtcbiAgcmV0dXJuIGdldFRyZWVDYWNoZShldmljdGlvbiwgbWF4U2l6ZSwgdmFsdWVNYXBwZXIsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZU1hcHBlcihlcXVhbGl0eSkge1xuICBzd2l0Y2ggKGVxdWFsaXR5KSB7XG4gICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgIHJldHVybiB2YWwgPT4gdmFsO1xuXG4gICAgY2FzZSAndmFsdWUnOlxuICAgICAgcmV0dXJuIHZhbCA9PiBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHZhbCk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXF1YWxpdHkgcG9saWN5ICR7ZXF1YWxpdHl9YCk7XG59XG5cbmZ1bmN0aW9uIGdldFRyZWVDYWNoZShldmljdGlvbiwgbWF4U2l6ZSwgbWFwTm9kZVZhbHVlLCBuYW1lKSB7XG4gIHN3aXRjaCAoZXZpY3Rpb24pIHtcbiAgICBjYXNlICdrZWVwLWFsbCc6XG4gICAgICByZXR1cm4gbmV3IFRyZWVDYWNoZSQyKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgbWFwTm9kZVZhbHVlXG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2xydSc6XG4gICAgICByZXR1cm4gUmVjb2lsX3RyZWVDYWNoZUxSVSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1heFNpemU6IFJlY29pbF9udWxsdGhyb3dzKG1heFNpemUpLFxuICAgICAgICBtYXBOb2RlVmFsdWVcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnbW9zdC1yZWNlbnQnOlxuICAgICAgcmV0dXJuIFJlY29pbF90cmVlQ2FjaGVMUlUoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBtYXhTaXplOiAxLFxuICAgICAgICBtYXBOb2RlVmFsdWVcbiAgICAgIH0pO1xuICB9XG5cbiAgdGhyb3cgUmVjb2lsX2VycihgVW5yZWNvZ25pemVkIGV2aWN0aW9uIHBvbGljeSAke2V2aWN0aW9ufWApO1xufVxuXG52YXIgUmVjb2lsX3RyZWVDYWNoZUZyb21Qb2xpY3kgPSB0cmVlQ2FjaGVGcm9tUG9saWN5O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgdmFyIF9vd25lckRvY3VtZW50LCBfZG9jJGRlZmF1bHRWaWV3O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IGRvYyA9IG9iamVjdCAhPSBudWxsID8gKF9vd25lckRvY3VtZW50ID0gb2JqZWN0Lm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9vd25lckRvY3VtZW50ICE9PSB2b2lkIDAgPyBfb3duZXJEb2N1bWVudCA6IG9iamVjdCA6IGRvY3VtZW50O1xuICBjb25zdCBkZWZhdWx0VmlldyA9IChfZG9jJGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3KSAhPT0gbnVsbCAmJiBfZG9jJGRlZmF1bHRWaWV3ICE9PSB2b2lkIDAgPyBfZG9jJGRlZmF1bHRWaWV3IDogd2luZG93O1xuICByZXR1cm4gISEob2JqZWN0ICE9IG51bGwgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbnZhciBSZWNvaWxfaXNOb2RlID0gaXNOb2RlO1xuXG5jb25zdCB7XG4gIGlzUmVhY3ROYXRpdmU6IGlzUmVhY3ROYXRpdmUkMSxcbiAgaXNXaW5kb3c6IGlzV2luZG93JDFcbn0gPSBSZWNvaWxfRW52aXJvbm1lbnQ7XG5cblxuXG5cblxuZnVuY3Rpb24gc2hvdWxkTm90QmVGcm96ZW4odmFsdWUpIHtcbiAgLy8gUHJpbWl0aXZlcyBhbmQgZnVuY3Rpb25zOlxuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFJlYWN0IGVsZW1lbnRzOlxuXG5cbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUuJCR0eXBlb2YpIHtcbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW1tdXRhYmxlIHN0cnVjdHVyZXM6XG5cblxuICBpZiAodmFsdWVbJ0BAX19JTU1VVEFCTEVfSVRFUkFCTEVfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9LRVlFRF9fQEAnXSAhPSBudWxsIHx8IHZhbHVlWydAQF9fSU1NVVRBQkxFX0lOREVYRURfX0BAJ10gIT0gbnVsbCB8fCB2YWx1ZVsnQEBfX0lNTVVUQUJMRV9PUkRFUkVEX19AQCddICE9IG51bGwgfHwgdmFsdWVbJ0BAX19JTU1VVEFCTEVfUkVDT1JEX19AQCddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBET00gbm9kZXM6XG5cblxuICBpZiAoUmVjb2lsX2lzTm9kZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gU29tZSBlbnZpcm9ubWVudHMsIGp1c3QgYXMgSmVzdCwgZG9uJ3Qgd29yayB3aXRoIHRoZSBpbnN0YW5jZW9mIGNoZWNrXG5cblxuICBpZiAoIWlzUmVhY3ROYXRpdmUkMSAmJiBpc1dpbmRvdyQxKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSAvLyBSZWN1cnNpdmVseSBmcmVlemUgYSB2YWx1ZSB0byBlbmZvcmNlIGl0IGlzIHJlYWQtb25seS5cbi8vIFRoaXMgbWF5IGFsc28gaGF2ZSBtaW5pbWFsIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50cyBmb3IgZW51bWVyYXRpbmdcbi8vIG9iamVjdHMgKGJhc2VkIG9uIGJyb3dzZXIgaW1wbGVtZW50YXRpb25zLCBvZiBjb3Vyc2UpXG5cblxuZnVuY3Rpb24gZGVlcEZyZWV6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHNob3VsZE5vdEJlRnJvemVuKHZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5mcmVlemUodmFsdWUpOyAvLyBNYWtlIGFsbCBwcm9wZXJ0aWVzIHJlYWQtb25seVxuXG4gIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgLy8gJEZsb3dJc3N1ZVttZXRob2QtdW5iaW5kaW5nXSBhZGRlZCB3aGVuIGltcHJvdmluZyB0eXBpbmcgZm9yIHRoaXMgcGFyYW1ldGVyc1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSB2YWx1ZVtrZXldOyAvLyBQcmV2ZW50IGluZmluaXRlIHJlY3Vyc3Npb24gZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ29iamVjdCcgJiYgcHJvcCAhPSBudWxsICYmICFPYmplY3QuaXNGcm96ZW4ocHJvcCkpIHtcbiAgICAgICAgZGVlcEZyZWV6ZVZhbHVlKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5zZWFsKHZhbHVlKTsgLy8gVGhpcyBhbHNvIG1ha2VzIGV4aXN0aW5nIHByb3BlcnRpZXMgbm9uLWNvbmZpZ3VyYWJsZS5cbn1cblxudmFyIFJlY29pbF9kZWVwRnJlZXplVmFsdWUgPSBkZWVwRnJlZXplVmFsdWU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBUaGlzIGlzIGEgc3R1YiBmb3Igc29tZSBpbnRlZ3JhdGlvbiBpbnRvIEZCIGludGVybmFsIHN0dWZmXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5mdW5jdGlvbiBzdGFydFBlcmZCbG9jayhfaWQpIHtcbiAgcmV0dXJuICgpID0+IG51bGw7XG59XG5cbnZhciBSZWNvaWxfUGVyZm9ybWFuY2VUaW1pbmdzID0ge1xuICBzdGFydFBlcmZCbG9ja1xufTtcblxuY29uc3Qge1xuICBpc0xvYWRhYmxlOiBpc0xvYWRhYmxlJDEsXG4gIGxvYWRhYmxlV2l0aEVycm9yOiBsb2FkYWJsZVdpdGhFcnJvciQxLFxuICBsb2FkYWJsZVdpdGhQcm9taXNlOiBsb2FkYWJsZVdpdGhQcm9taXNlJDEsXG4gIGxvYWRhYmxlV2l0aFZhbHVlOiBsb2FkYWJsZVdpdGhWYWx1ZSQyXG59ID0gUmVjb2lsX0xvYWRhYmxlJDE7XG5cbmNvbnN0IHtcbiAgV3JhcHBlZFZhbHVlOiBXcmFwcGVkVmFsdWUkMVxufSA9IFJlY29pbF9XcmFwcGVyJDE7XG5cblxuXG5jb25zdCB7XG4gIGdldE5vZGVMb2FkYWJsZTogZ2V0Tm9kZUxvYWRhYmxlJDIsXG4gIHBlZWtOb2RlTG9hZGFibGU6IHBlZWtOb2RlTG9hZGFibGUkMSxcbiAgc2V0Tm9kZVZhbHVlOiBzZXROb2RlVmFsdWUkM1xufSA9IFJlY29pbF9GdW5jdGlvbmFsQ29yZTtcblxuY29uc3Qge1xuICBzYXZlRGVwc1RvU3RvcmU6IHNhdmVEZXBzVG9TdG9yZSQxXG59ID0gUmVjb2lsX0dyYXBoO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNixcbiAgZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMSxcbiAgZ2V0Tm9kZTogZ2V0Tm9kZSQ2LFxuICByZWdpc3Rlck5vZGU6IHJlZ2lzdGVyTm9kZSQxXG59ID0gUmVjb2lsX05vZGU7XG5cbmNvbnN0IHtcbiAgaXNSZWNvaWxWYWx1ZTogaXNSZWNvaWxWYWx1ZSQzXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlJDE7XG5cbmNvbnN0IHtcbiAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQ6IG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkJDFcbn0gPSBSZWNvaWxfUmVjb2lsVmFsdWVJbnRlcmZhY2U7XG5cbmNvbnN0IHtcbiAgcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0OiByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMVxufSA9IFJlY29pbF9SZXRlbnRpb247XG5cbmNvbnN0IHtcbiAgcmVjb2lsQ2FsbGJhY2s6IHJlY29pbENhbGxiYWNrJDFcbn0gPSBSZWNvaWxfdXNlUmVjb2lsQ2FsbGJhY2s7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmNvbnN0IHtcbiAgc3RhcnRQZXJmQmxvY2s6IHN0YXJ0UGVyZkJsb2NrJDFcbn0gPSBSZWNvaWxfUGVyZm9ybWFuY2VUaW1pbmdzO1xuXG5cblxuY2xhc3MgQ2FuY2VsZWQge31cblxuY29uc3QgQ0FOQ0VMRUQgPSBuZXcgQ2FuY2VsZWQoKTtcbi8qKlxuICogQW4gRXhlY3V0aW9uSUQgaXMgYW4gYXJiaXRyYXJ5IElEIHRoYXQgbGV0cyB1cyBkaXN0aW5ndWlzaCBleGVjdXRpb25zIGZyb21cbiAqIGVhY2ggb3RoZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IGFzIHdlIG5lZWQgYSB3YXkgb2Ygc29sdmluZyB0aGlzIHByb2JsZW06XG4gKiBcImdpdmVuIDMgYXN5bmMgZXhlY3V0aW9ucywgb25seSB1cGRhdGUgc3RhdGUgZm9yIHRoZSAnbGF0ZXN0JyBleGVjdXRpb24gd2hlblxuICogaXQgZmluaXNoZXMgcnVubmluZyByZWdhcmRsZXNzIG9mIHdoZW4gdGhlIG90aGVyIDIgZmluaXNoXCIuIEV4ZWN1dGlvbklEc1xuICogcHJvdmlkZSBhIGNvbnZlbmllbnQgd2F5IG9mIGlkZW50aWZ5aW5nIGV4ZWN1dGlvbnMgc28gdGhhdCB3ZSBjYW4gdHJhY2sgYW5kXG4gKiBtYW5hZ2UgdGhlbSBvdmVyIHRpbWUuXG4gKi9cblxuY29uc3QgZGVwZW5kZW5jeVN0YWNrID0gW107IC8vIGZvciBkZXRlY3RpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuXG5jb25zdCB3YWl0aW5nU3RvcmVzID0gbmV3IE1hcCgpO1xuXG5jb25zdCBnZXROZXdFeGVjdXRpb25JRCA9ICgoKSA9PiB7XG4gIGxldCBleGVjdXRpb25JRCA9IDA7XG4gIHJldHVybiAoKSA9PiBleGVjdXRpb25JRCsrO1xufSkoKTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG5cbmZ1bmN0aW9uIHNlbGVjdG9yKG9wdGlvbnMpIHtcbiAgbGV0IHJlY29pbFZhbHVlID0gbnVsbDtcbiAgY29uc3Qge1xuICAgIGtleSxcbiAgICBnZXQsXG4gICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IGNhY2hlUG9saWN5XG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBzZXQgPSBvcHRpb25zLnNldCAhPSBudWxsID8gb3B0aW9ucy5zZXQgOiB1bmRlZmluZWQ7IC8vIGZsb3dcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKCdBIGtleSBvcHRpb24gd2l0aCBhIHVuaXF1ZSBzdHJpbmcgdmFsdWUgbXVzdCBiZSBwcm92aWRlZCB3aGVuIGNyZWF0aW5nIGEgc2VsZWN0b3IuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NlbGVjdG9ycyBtdXN0IHNwZWNpZnkgYSBnZXQgY2FsbGJhY2sgb3B0aW9uIHRvIGdldCB0aGUgc2VsZWN0b3IgdmFsdWUuJyk7XG4gICAgfVxuICB9IC8vIFRoaXMgaXMgZXZlcnkgZGlzY292ZXJlZCBkZXBlbmRlbmN5IGFjcm9zcyBhbGwgZXhlY3V0aW9uc1xuXG5cbiAgY29uc3QgZGlzY292ZXJlZERlcGVuZGVuY3lOb2RlS2V5cyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgY2FjaGUgPSBSZWNvaWxfdHJlZUNhY2hlRnJvbVBvbGljeShjYWNoZVBvbGljeSAhPT0gbnVsbCAmJiBjYWNoZVBvbGljeSAhPT0gdm9pZCAwID8gY2FjaGVQb2xpY3kgOiB7XG4gICAgZXF1YWxpdHk6ICdyZWZlcmVuY2UnLFxuICAgIGV2aWN0aW9uOiAna2VlcC1hbGwnXG4gIH0sIGtleSk7XG4gIGNvbnN0IHJldGFpbmVkQnkgPSByZXRhaW5lZEJ5T3B0aW9uV2l0aERlZmF1bHQkMShvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUpO1xuICBjb25zdCBleGVjdXRpb25JbmZvTWFwID0gbmV3IE1hcCgpO1xuICBsZXQgbGl2ZVN0b3Jlc0NvdW50ID0gMDtcblxuICBmdW5jdGlvbiBzZWxlY3RvcklzTGl2ZSgpIHtcbiAgICByZXR1cm4gIVJlY29pbF9na3goJ3JlY29pbF9tZW1vcnlfbWFuYWdhbWVudF8yMDIwJykgfHwgbGl2ZVN0b3Jlc0NvdW50ID4gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9ySW5pdChzdG9yZSkge1xuICAgIHN0b3JlLmdldFN0YXRlKCkua25vd25TZWxlY3RvcnMuYWRkKGtleSk7XG4gICAgbGl2ZVN0b3Jlc0NvdW50Kys7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpdmVTdG9yZXNDb3VudC0tO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RvclNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZSgpIHtcbiAgICByZXR1cm4gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEoa2V5KSAhPT0gdW5kZWZpbmVkICYmICFzZWxlY3RvcklzTGl2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpIHtcbiAgICBzZXRDYWNoZShzdGF0ZSwgbG9hZGFibGUsIGRlcFZhbHVlcyk7XG4gICAgbm90aWZ5U3RvcmVzT2ZSZXNvbHZlZEFzeW5jKHN0b3JlLCBleGVjdXRpb25JRCk7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlTdG9yZXNPZlJlc29sdmVkQXN5bmMoc3RvcmUsIGV4ZWN1dGlvbklEKSB7XG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcbiAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgfVxuXG4gICAgbm90aWZ5V2FpdGluZ1N0b3JlcyhleGVjdXRpb25JRCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGlmeSBzdG9yZXMgdG8gcHVsbCB0aGUgc2VsZWN0b3IgYWdhaW4gaWYgYSBuZXcgYXN5bmMgZGVwIHdhcyBkaXNjb3ZlcmVkLlxuICAgKiAxKSBBc3luYyBzZWxlY3RvciBhZGRzIGEgbmV3IGRlcCBidXQgZG9lc24ndCByZXNvbHZlIHlldC5cbiAgICogICAgTm90ZSB0aGF0IGRlcHMgZm9yIGFuIGFzeW5jIHNlbGVjdG9yIGFyZSBiYXNlZCBvbiB0aGUgc3RhdGUgd2hlbiB0aGVcbiAgICogICAgZXZhbHVhdGlvbiBzdGFydGVkLCBpbiBvcmRlciB0byBwcm92aWRlIGEgY29uc2lzdGVudCBwaWN0dXJlIG9mIHN0YXRlLlxuICAgKiAyKSBCdXQsIG5ldyB2YWx1ZSBvZiBkZXAgYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGUgbWlnaHQgY2F1c2UgdGhlIHNlbGVjdG9yXG4gICAqICAgIHRvIHJlc29sdmUgb3IgcmVzb2x2ZSBkaWZmZXJlbnRseS5cbiAgICogMykgVGhlcmVmb3JlLCB0aGlzIG5vdGlmaWNhdGlvbiB3aWxsIHB1bGwgdGhlIHNlbGVjdG9yIGJhc2VkIG9uIHRoZSBjdXJyZW50XG4gICAqICAgIHN0YXRlIGZvciB0aGUgY29tcG9uZW50c1xuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG5vdGlmeVN0b3Jlc09mTmV3QXN5bmNEZXAoc3RvcmUsIGV4ZWN1dGlvbklEKSB7XG4gICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGlvbkluZm8gPSBSZWNvaWxfbnVsbHRocm93cyhnZXRFeGVjdXRpb25JbmZvKHN0b3JlKSk7XG4gICAgICBleGVjdXRpb25JbmZvLnN0YXRlVmVyc2lvbnMuY2xlYXIoKTtcbiAgICAgIG5vdGlmeVdhaXRpbmdTdG9yZXMoZXhlY3V0aW9uSUQsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnlXYWl0aW5nU3RvcmVzKGV4ZWN1dGlvbklELCBjbGVhcldhaXRsaXN0KSB7XG4gICAgY29uc3Qgc3RvcmVzID0gd2FpdGluZ1N0b3Jlcy5nZXQoZXhlY3V0aW9uSUQpO1xuXG4gICAgaWYgKHN0b3JlcyAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IHdhaXRpbmdTdG9yZSBvZiBzdG9yZXMpIHtcbiAgICAgICAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMSh3YWl0aW5nU3RvcmUsIFJlY29pbF9udWxsdGhyb3dzKHJlY29pbFZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGVhcldhaXRsaXN0KSB7XG4gICAgICAgIHdhaXRpbmdTdG9yZXMuZGVsZXRlKGV4ZWN1dGlvbklEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RvcmVXYWl0aW5nRm9yUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpIHtcbiAgICBsZXQgc3RvcmVzID0gd2FpdGluZ1N0b3Jlcy5nZXQoZXhlY3V0aW9uSUQpO1xuXG4gICAgaWYgKHN0b3JlcyA9PSBudWxsKSB7XG4gICAgICB3YWl0aW5nU3RvcmVzLnNldChleGVjdXRpb25JRCwgc3RvcmVzID0gbmV3IFNldCgpKTtcbiAgICB9XG5cbiAgICBzdG9yZXMuYWRkKHN0b3JlKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhdHRhY2hlcyBhIHRoZW4oKSBhbmQgYSBjYXRjaCgpIHRvIGEgcHJvbWlzZSB0aGF0IHdhc1xuICAgKiByZXR1cm5lZCBmcm9tIGEgc2VsZWN0b3IncyBnZXQoKSAoZWl0aGVyIGV4cGxpY2l0bHkgb3IgaW1wbGljaXRseSBieVxuICAgKiBydW5uaW5nIGEgZnVuY3Rpb24gdGhhdCB1c2VzIHRoZSBcImFzeW5jXCIga2V5d29yZCkuIElmIGEgc2VsZWN0b3IncyBnZXQoKVxuICAgKiByZXR1cm5zIGEgcHJvbWlzZSwgd2UgaGF2ZSB0d28gcG9zc2liaWxpdGllczpcbiAgICpcbiAgICogMS4gVGhlIHByb21pc2Ugd2lsbCByZXNvbHZlLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgaGF2ZSBjb21wbGV0ZWx5IGZpbmlzaGVkXG4gICAqICAgIGV4ZWN1dGluZyB3aXRob3V0IGFueSByZW1haW5pbmcgcGVuZGluZyBkZXBlbmRlbmNpZXMuIE5vIG1vcmUgcmV0cmllc1xuICAgKiAgICBhcmUgbmVlZGVkIGFuZCB3ZSBjYW4gcHJvY2VlZCB3aXRoIHVwZGF0aW5nIHRoZSBjYWNoZSBhbmQgbm90aWZ5aW5nXG4gICAqICAgIHN1YnNjcmliZXJzIChpZiBpdCBpcyB0aGUgbGF0ZXN0IGV4ZWN1dGlvbiwgb3RoZXJ3aXNlIG9ubHkgdGhlIGNhY2hlXG4gICAqICAgIHdpbGwgYmUgdXBkYXRlZCBhbmQgc3Vic2NyaXB0aW9ucyB3aWxsIG5vdCBiZSBmaXJlZCkuIFRoaXMgaXMgdGhlIGNhc2VcbiAgICogICAgaGFuZGxlZCBieSB0aGUgYXR0YWNoZWQgdGhlbigpIGhhbmRsZXIuXG4gICAqXG4gICAqIDIuIFRoZSBwcm9taXNlIHdpbGwgdGhyb3cgYmVjYXVzZSBpdCBlaXRoZXIgaGFzIGFuIGVycm9yIG9yIGl0IGNhbWUgYWNyb3NzXG4gICAqICAgIGFuIGFzeW5jIGRlcGVuZGVuY3kgdGhhdCBoYXMgbm90IHlldCByZXNvbHZlZCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsXG4gICAqICAgIGNhbGwgd3JhcERlcGRlbmN5UHJvbWlzZSgpLCB3aG9zZSByZXNwb25zaWJpbGl0eSBpcyB0byBoYW5kbGUgZGVwZW5kZW5jeVxuICAgKiAgICBwcm9taXNlcy4gVGhpcyBjYXNlIGlzIGhhbmRsZWQgYnkgdGhlIGF0dGFjaGVkIGNhdGNoKCkgaGFuZGxlci5cbiAgICpcbiAgICogQm90aCBicmFuY2hlcyB3aWxsIGV2ZW50dWFsbHkgcmVzb2x2ZSB0byB0aGUgZmluYWwgcmVzdWx0IG9mIHRoZSBzZWxlY3RvclxuICAgKiAob3IgYW4gZXJyb3IgaWYgYSByZWFsIGVycm9yIG9jY3VycmVkKS5cbiAgICpcbiAgICogVGhlIGV4ZWN1dGlvbiB3aWxsIHJ1biB0byBjb21wbGV0aW9uIGV2ZW4gaWYgaXQgaXMgc3RhbGUsIGFuZCBpdHMgdmFsdWVcbiAgICogd2lsbCBiZSBjYWNoZWQuIEJ1dCBzdGFsZSBleGVjdXRpb25zIHdpbGwgbm90IHVwZGF0ZSBnbG9iYWwgc3RhdGUgb3IgdXBkYXRlXG4gICAqIGV4ZWN1dGlvbkluZm8gYXMgdGhhdCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlICdsYXRlc3QnIGV4ZWN1dGlvbi5cbiAgICpcbiAgICogTm90ZSB0aGlzIGZ1bmN0aW9uIHNob3VsZCBub3QgYmUgcGFzc2VkIGEgcHJvbWlzZSB0aGF0IHdhcyB0aHJvd24tLUFLQSBhXG4gICAqIGRlcGVuZGVuY3kgcHJvbWlzZS4gRGVwZW5kZW5jeSBwcm9taXNlcyBzaG91bGQgYmUgcGFzc2VkIHRvXG4gICAqIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2UoKSkuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gd3JhcFJlc3VsdFByb21pc2Uoc3RvcmUsIHByb21pc2UsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKSB7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbih2YWx1ZSA9PiB7XG4gICAgICBpZiAoIXNlbGVjdG9ySXNMaXZlKCkpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdG9yIHdhcyByZWxlYXNlZCBzaW5jZSB0aGUgcmVxdWVzdCBiZWdhbjsgaWdub3JlIHRoZSByZXNwb25zZS5cbiAgICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gbG9hZGFibGVXaXRoVmFsdWUkMih2YWx1ZSk7XG4gICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcyk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSkuY2F0Y2goZXJyb3JPclByb21pc2UgPT4ge1xuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXG4gICAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShlcnJvck9yUHJvbWlzZSkpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBQZW5kaW5nRGVwZW5kZW5jeVByb21pc2Uoc3RvcmUsIGVycm9yT3JQcm9taXNlLCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShlcnJvck9yUHJvbWlzZSk7XG4gICAgICByZXNvbHZlQXN5bmMoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCwgbG9hZGFibGUsIGRlcFZhbHVlcyk7XG4gICAgICB0aHJvdyBlcnJvck9yUHJvbWlzZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhdHRhY2hlcyBhIHRoZW4oKSBhbmQgYSBjYXRjaCgpIHRvIGEgcHJvbWlzZSB0aGF0IHdhc1xuICAgKiB0aHJvd24gZnJvbSBhIHNlbGVjdG9yJ3MgZ2V0KCkuIElmIGEgc2VsZWN0b3IncyBnZXQoKSB0aHJvd3MgYSBwcm9taXNlLFxuICAgKiB3ZSBoYXZlIHR3byBwb3NzaWJpbGl0aWVzOlxuICAgKlxuICAgKiAxLiBUaGUgcHJvbWlzZSB3aWxsIHJlc29sdmUsIG1lYW5pbmcgb25lIG9mIG91ciBzZWxlY3RvcidzIGRlcGVuZGVuY2llcyBpc1xuICAgKiAgICBub3cgYXZhaWxhYmxlIGFuZCB3ZSBzaG91bGQgXCJyZXRyeVwiIG91ciBnZXQoKSBieSBydW5uaW5nIGl0IGFnYWluLiBUaGlzXG4gICAqICAgIGlzIHRoZSBjYXNlIGhhbmRsZWQgYnkgdGhlIGF0dGFjaGVkIHRoZW4oKSBoYW5kbGVyLlxuICAgKlxuICAgKiAyLiBUaGUgcHJvbWlzZSB3aWxsIHRocm93IGJlY2F1c2Ugc29tZXRoaW5nIHdlbnQgd3Jvbmcgd2l0aCB0aGUgZGVwZW5kZW5jeVxuICAgKiAgICBwcm9taXNlIChpbiBvdGhlciB3b3JkcyBhIHJlYWwgZXJyb3Igb2NjdXJyZWQpLiBUaGlzIGNhc2UgaXMgaGFuZGxlZCBieVxuICAgKiAgICB0aGUgYXR0YWNoZWQgY2F0Y2goKSBoYW5kbGVyLiBJZiB0aGUgZGVwZW5kZW5jeSBwcm9taXNlIHRocm93cywgaXQgaXNcbiAgICogICAgX2Fsd2F5c18gYSByZWFsIGVycm9yIGFuZCBub3QgYW5vdGhlciBkZXBlbmRlbmN5IHByb21pc2UgKGFueSBkZXBlbmRlbmN5XG4gICAqICAgIHByb21pc2VzIHdvdWxkIGhhdmUgYmVlbiBoYW5kbGVkIHVwc3RyZWFtKS5cbiAgICpcbiAgICogVGhlIHRoZW4oKSBicmFuY2ggd2lsbCBldmVudHVhbGx5IHJlc29sdmUgdG8gdGhlIGZpbmFsIHJlc3VsdCBvZiB0aGVcbiAgICogc2VsZWN0b3IgKG9yIGFuIGVycm9yIGlmIGEgcmVhbCBlcnJvciBvY2N1cnMpLCBhbmQgdGhlIGNhdGNoKCkgd2lsbCBhbHdheXNcbiAgICogcmVzb2x2ZSB0byBhbiBlcnJvciBiZWNhdXNlIHRoZSBkZXBlbmRlbmN5IHByb21pc2UgaXMgYSBwcm9taXNlIHRoYXQgd2FzXG4gICAqIHdyYXBwZWQgdXBzdHJlYW0sIG1lYW5pbmcgaXQgd2lsbCBvbmx5IHJlc29sdmUgdG8gaXRzIHJlYWwgdmFsdWUgb3IgdG8gYVxuICAgKiByZWFsIGVycm9yLlxuICAgKlxuICAgKiBUaGUgZXhlY3V0aW9uIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gZXZlbiBpZiBpdCBpcyBzdGFsZSwgYW5kIGl0cyB2YWx1ZVxuICAgKiB3aWxsIGJlIGNhY2hlZC4gQnV0IHN0YWxlIGV4ZWN1dGlvbnMgd2lsbCBub3QgdXBkYXRlIGdsb2JhbCBzdGF0ZSBvciB1cGRhdGVcbiAgICogZXhlY3V0aW9uSW5mbyBhcyB0aGF0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgJ2xhdGVzdCcgZXhlY3V0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG5vdCBiZSBwYXNzZWQgYSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb21cbiAgICogZ2V0KCkuIFRoZSBpbnRlbnRpb24gaXMgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgcGFzc2VkIHByb21pc2VzIHRoYXRcbiAgICogd2VyZSB0aHJvd24gZHVlIHRvIGEgcGVuZGluZyBkZXBlbmRlbmN5LiBQcm9taXNlcyByZXR1cm5lZCBieSBnZXQoKSBzaG91bGRcbiAgICogYmUgcGFzc2VkIHRvIHdyYXBSZXN1bHRQcm9taXNlKCkgaW5zdGVhZC5cbiAgICovXG5cblxuICBmdW5jdGlvbiB3cmFwUGVuZGluZ0RlcGVuZGVuY3lQcm9taXNlKHN0b3JlLCBwcm9taXNlLCBzdGF0ZSwgZXhpc3RpbmdEZXBzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4ocmVzb2x2ZWREZXAgPT4ge1xuICAgICAgaWYgKCFzZWxlY3RvcklzTGl2ZSgpKSB7XG4gICAgICAgIC8vIFRoZSBzZWxlY3RvciB3YXMgcmVsZWFzZWQgc2luY2UgdGhlIHJlcXVlc3QgYmVnYW47IGlnbm9yZSB0aGUgcmVzcG9uc2UuXG4gICAgICAgIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSk7XG4gICAgICAgIHRocm93IENBTkNFTEVEO1xuICAgICAgfSAvLyBDaGVjayBpZiB3ZSBhcmUgaGFuZGxpbmcgYSBwZW5kaW5nIFJlY29pbCBkZXBlbmRlbmN5IG9yIGlmIHRoZSB1c2VyXG4gICAgICAvLyB0aHJldyB0aGVpciBvd24gUHJvbWlzZSB0byBcInN1c3BlbmRcIiBhIHNlbGVjdG9yIGV2YWx1YXRpb24uICBXZSBuZWVkXG4gICAgICAvLyB0byBjaGVjayB0aGF0IHRoZSBsb2FkaW5nRGVwUHJvbWlzZSBhY3R1YWxseSBtYXRjaGVzIHRoZSBwcm9taXNlIHRoYXRcbiAgICAgIC8vIHdlIGNhdWdodCBpbiBjYXNlIHRoZSBzZWxlY3RvciBoYXBwZW5lZCB0byBjYXRjaCB0aGUgcHJvbWlzZSB3ZSB0aHJld1xuICAgICAgLy8gZm9yIGEgcGVuZGluZyBSZWNvaWwgZGVwZW5kZW5jeSBmcm9tIGBnZXRSZWNvaWxWYWx1ZSgpYCBhbmQgdGhyZXdcbiAgICAgIC8vIHRoZWlyIG93biBwcm9taXNlIGluc3RlYWQuXG5cblxuICAgICAgaWYgKGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcEtleSAhPSBudWxsICYmIGxvYWRpbmdEZXBzU3RhdGUubG9hZGluZ0RlcFByb21pc2UgPT09IHByb21pc2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vdGUgZm9yIGFzeW5jIGF0b21zLCB0aGlzIG1lYW5zIHdlIGFyZSBjaGFuZ2luZyB0aGUgYXRvbSdzIHZhbHVlXG4gICAgICAgICAqIGluIHRoZSBzdG9yZSBmb3IgdGhlIGdpdmVuIHZlcnNpb24uIFRoaXMgc2hvdWxkIGJlIGFscmlnaHQgYmVjYXVzZVxuICAgICAgICAgKiB0aGUgdmVyc2lvbiBvZiBzdGF0ZSBpcyBub3cgc3RhbGUgYW5kIGEgbmV3IHZlcnNpb24gd2lsbCBoYXZlXG4gICAgICAgICAqIGFscmVhZHkgYmVlbiB0cmlnZ2VyZWQgYnkgdGhlIGF0b20gYmVpbmcgcmVzb2x2ZWQgKHNlZSB0aGlzIGxvZ2ljXG4gICAgICAgICAqIGluIFJlY29pbF9hdG9tLmpzKVxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQobG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwS2V5LCBsb2FkYWJsZVdpdGhWYWx1ZSQyKHJlc29sdmVkRGVwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcmVzb2x2ZWREZXBLZXkgaXMgbm90IGRlZmluZWQsIHRoZSBwcm9taXNlIHdhcyBhIHVzZXItdGhyb3duXG4gICAgICAgICAqIHByb21pc2UuIFVzZXItdGhyb3duIHByb21pc2VzIGFyZSBhbiBhZHZhbmNlZCBmZWF0dXJlIGFuZCB0aGV5XG4gICAgICAgICAqIHNob3VsZCBiZSBhdm9pZGVkIGluIGFsbW9zdCBhbGwgY2FzZXMuIFVzaW5nIGBsb2FkYWJsZS5tYXAoKWAgaW5zaWRlXG4gICAgICAgICAqIG9mIHNlbGVjdG9ycyBmb3IgbG9hZGluZyBsb2FkYWJsZXMgYW5kIHRoZW4gdGhyb3dpbmcgdGhhdCBtYXBwZWRcbiAgICAgICAgICogbG9hZGFibGUncyBwcm9taXNlIGlzIGFuIGV4YW1wbGUgb2YgYSB1c2VyLXRocm93biBwcm9taXNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHdlIGhpdCBhIHVzZXItdGhyb3duIHByb21pc2UsIHdlIGhhdmUgdG8gYmFpbCBvdXQgb2YgYW4gb3B0aW1pemF0aW9uXG4gICAgICAgICAqIHdoZXJlIHdlIGJ5cGFzcyBjYWxjdWxhdGluZyBzZWxlY3RvciBjYWNoZSBrZXlzIGZvciBzZWxlY3RvcnMgdGhhdFxuICAgICAgICAgKiBoYXZlIGJlZW4gcHJldmlvdXNseSBzZWVuIGZvciBhIGdpdmVuIHN0YXRlICh0aGVzZSBzZWxlY3RvcnMgYXJlIHNhdmVkIGluXG4gICAgICAgICAqIHN0YXRlLmF0b21WYWx1ZXMpIHRvIGF2b2lkIHN0YWxlIHN0YXRlIGFzIHdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmdcbiAgICAgICAgICogd2hhdCBzdGF0ZSBjaGFuZ2VzIGhhcHBlbmVkIChpZiBhbnkpIGluIHJlc3VsdCB0byB0aGUgcHJvbWlzZSByZXNvbHZpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIElkZWFsbHkgd2Ugd291bGQgb25seSBiYWlsIG91dCBzZWxlY3RvcnMgdGhhdCBhcmUgaW4gdGhlIGNoYWluIG9mXG4gICAgICAgICAqIGRlcGVuZGVuY2llcyBmb3IgdGhpcyBzZWxlY3RvciwgYnV0IHRoZXJlJ3MgY3VycmVudGx5IG5vIHdheSB0byBnZXRcbiAgICAgICAgICogYSBmdWxsIGxpc3Qgb2YgYSBzZWxlY3RvcidzIGRvd25zdHJlYW0gbm9kZXMgYmVjYXVzZSB0aGUgc3RhdGUgdGhhdFxuICAgICAgICAgKiBpcyBleGVjdXRpbmcgbWF5IGJlIGEgZGlzY2FyZGVkIHRyZWUgKHNvIHN0b3JlLmdldEdyYXBoKHN0YXRlLnZlcnNpb24pXG4gICAgICAgICAqIHdpbGwgYmUgZW1wdHkpLCBhbmQgdGhlIGZ1bGwgZGVwIHRyZWUgbWF5IG5vdCBiZSBpbiB0aGUgc2VsZWN0b3JcbiAgICAgICAgICogY2FjaGVzIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBzZWxlY3RvcidzIGNhY2hlIHdhcyBjbGVhcmVkLiBUbyBzb2x2ZVxuICAgICAgICAgKiBmb3IgdGhpcyB3ZSB3b3VsZCBoYXZlIHRvIGtlZXAgdHJhY2sgb2YgYWxsIHJ1bm5pbmcgc2VsZWN0b3JcbiAgICAgICAgICogZXhlY3V0aW9ucyBhbmQgdGhlaXIgZG93bnN0cmVhbSBkZXBzLiBCZWNhdXNlIHRoaXMgb25seSBjb3ZlcnMgZWRnZVxuICAgICAgICAgKiBjYXNlcywgdGhhdCBjb21wbGV4aXR5IG1pZ2h0IG5vdCBiZSBqdXN0aWZ5YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHN0b3JlLmdldFN0YXRlKCkua25vd25TZWxlY3RvcnMuZm9yRWFjaChub2RlS2V5ID0+IHtcbiAgICAgICAgICBzdGF0ZS5hdG9tVmFsdWVzLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIE9wdGltaXphdGlvbjogTm93IHRoYXQgdGhlIGRlcGVuZGVuY3kgaGFzIHJlc29sdmVkLCBsZXQncyB0cnkgaGl0dGluZ1xuICAgICAgICogdGhlIGNhY2hlIGluIGNhc2UgdGhlIGRlcCByZXNvbHZlZCB0byBhIHZhbHVlIHdlIGhhdmUgcHJldmlvdXNseSBzZWVuLlxuICAgICAgICpcbiAgICAgICAqIFRPRE86XG4gICAgICAgKiBOb3RlIHRoaXMgb3B0aW1pemF0aW9uIGlzIG5vdCBwZXJmZWN0IGJlY2F1c2UgaXQgb25seSBwcmV2ZW50cyByZS1leGVjdXRpb25zXG4gICAgICAgKiBfYWZ0ZXJfIHRoZSBwb2ludCB3aGVyZSBhbiBhc3luYyBkZXBlbmRlbmN5IGlzIGZvdW5kLiBBbnkgY29kZSBsZWFkaW5nXG4gICAgICAgKiB1cCB0byB0aGUgYXN5bmMgZGVwZW5kZW5jeSBtYXkgaGF2ZSBydW4gdW5uZWNlc3NhcmlseS4gVGhlIGlkZWFsIGNhc2VcbiAgICAgICAqIHdvdWxkIGJlIHRvIHdhaXQgZm9yIHRoZSBhc3luYyBkZXBlbmRlbmN5IHRvIHJlc29sdmUgZmlyc3QsIGNoZWNrIHRoZVxuICAgICAgICogY2FjaGUsIGFuZCBwcmV2ZW50IF9hbnlfIGV4ZWN1dGlvbiBvZiB0aGUgc2VsZWN0b3IgaWYgdGhlIHJlc3VsdGluZ1xuICAgICAgICogdmFsdWUgb2YgdGhlIGRlcGVuZGVuY3kgbGVhZHMgdG8gYSBwYXRoIHRoYXQgaXMgZm91bmQgaW4gdGhlIGNhY2hlLlxuICAgICAgICogVGhlIGlkZWFsIGNhc2UgaXMgbW9yZSBkaWZmaWN1bHQgdG8gaW1wbGVtZW50IGFzIGl0IHdvdWxkIHJlcXVpcmUgdGhhdFxuICAgICAgICogd2UgY2FwdHVyZSBhbmQgd2FpdCBmb3IgdGhlIHRoZSBhc3luYyBkZXBlbmRlbmN5IHJpZ2h0IGFmdGVyIGNoZWNraW5nXG4gICAgICAgKiB0aGUgY2FjaGUuIFRoZSBjdXJyZW50IGFwcHJvYWNoIHRha2VzIGFkdmFudGFnZSBvZiB0aGUgZmFjdCB0aGF0IHJ1bm5pbmdcbiAgICAgICAqIHRoZSBzZWxlY3RvciBhbHJlYWR5IGhhcyBhIGNvZGUgcGF0aCB0aGF0IGxldHMgdXMgZXhpdCBlYXJseSB3aGVuXG4gICAgICAgKiBhbiBhc3luYyBkZXAgcmVzb2x2ZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBjYWNoZWRMb2FkYWJsZSA9IGdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpO1xuXG4gICAgICBpZiAoY2FjaGVkTG9hZGFibGUgJiYgY2FjaGVkTG9hZGFibGUuc3RhdGUgIT09ICdsb2FkaW5nJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBoYXMgdG8gbm90aWZ5IHN0b3JlcyBvZiBhIHJlc29sdmVkIGFzeW5jLCBldmVuIGlmIHRoZXJlIGlzIG5vXG4gICAgICAgICAqIGN1cnJlbnQgcGVuZGluZyBleGVjdXRpb24gZm9yIHRoZSBmb2xsb3dpbmcgY2FzZTpcbiAgICAgICAgICogMSkgQSBjb21wb25lbnQgcmVuZGVycyB3aXRoIHRoaXMgcGVuZGluZyBsb2FkYWJsZS5cbiAgICAgICAgICogMikgVGhlIHVwc3RyZWFtIGRlcGVuZGVuY3kgcmVzb2x2ZXMuXG4gICAgICAgICAqIDMpIFdoaWxlIHByb2Nlc3Npbmcgc29tZSBvdGhlciBzZWxlY3RvciBpdCByZWFkcyB0aGlzIG9uZSwgc3VjaCBhc1xuICAgICAgICAgKiAgICB3aGlsZSB0cmF2ZXJzaW5nIGl0cyBkZXBlbmRlbmNpZXMuICBBdCB0aGlzIHBvaW50IGl0IGdldHMgdGhlXG4gICAgICAgICAqICAgIG5ldyByZXNvbHZlZCB2YWx1ZSBzeW5jaHJvbm91c2x5IGFuZCBjbGVhcnMgdGhlIGN1cnJlbnRcbiAgICAgICAgICogICAgZXhlY3V0aW9uIElELiAgVGhlIGNvbXBvbmVudCB3YXNuJ3QgZ2V0dGluZyB0aGUgdmFsdWUgaXRzZWxmLFxuICAgICAgICAgKiAgICB0aG91Z2gsIHNvIGl0IHN0aWxsIGhhcyB0aGUgcGVuZGluZyBsb2FkYWJsZS5cbiAgICAgICAgICogNCkgV2hlbiB0aGlzIGNvZGUgZXhlY3V0ZXMgdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGlkIHdhcyBjbGVhcmVkXG4gICAgICAgICAqICAgIGFuZCBpdCB3b3VsZG4ndCBub3RpZnkgdGhlIGNvbXBvbmVudCBvZiB0aGUgbmV3IHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJIHRoaW5rIHRoaXMgaXMgb25seSBhbiBpc3N1ZSB3aXRoIFwiZWFybHlcIiByZW5kZXJpbmcgc2luY2UgdGhlXG4gICAgICAgICAqIGNvbXBvbmVudHMgZ290IHRoZWlyIHZhbHVlIHVzaW5nIHRoZSBpbi1wcm9ncmVzcyBleGVjdXRpb24uXG4gICAgICAgICAqIFdlIGRvbid0IGhhdmUgYSB1bml0IHRlc3QgZm9yIHRoaXMgY2FzZSB5ZXQuICBJJ20gbm90IHN1cmUgaXQgaXNcbiAgICAgICAgICogbmVjZXNzYXJ5IHdpdGggcmVjb2lsX3RyYW5zaXRpb25fc3VwcG9ydCBtb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkgfHwgZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkgPT0gbnVsbCkge1xuICAgICAgICAgIG5vdGlmeVN0b3Jlc09mUmVzb2x2ZWRBc3luYyhzdG9yZSwgZXhlY3V0aW9uSUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhY2hlZExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGNhY2hlZExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIElmIHRoaXMgZXhlY3V0aW9uIGlzIHN0YWxlLCBsZXQncyBjaGVjayB0byBzZWUgaWYgdGhlcmUgaXMgc29tZSBpblxuICAgICAgICogcHJvZ3Jlc3MgZXhlY3V0aW9uIHdpdGggYSBtYXRjaGluZyBzdGF0ZS4gSWYgd2UgZmluZCBhIG1hdGNoLCB0aGVuXG4gICAgICAgKiB3ZSBjYW4gdGFrZSB0aGUgdmFsdWUgZnJvbSB0aGF0IGluLXByb2dyZXNzIGV4ZWN1dGlvbi4gTm90ZSB0aGlzIG1heVxuICAgICAgICogc291bmQgbGlrZSBhbiBlZGdlIGNhc2UsIGJ1dCBtYXkgYmUgdmVyeSBjb21tb24gaW4gY2FzZXMgd2hlcmUgYVxuICAgICAgICogbG9hZGluZyBkZXBlbmRlbmN5IHJlc29sdmVzIGZyb20gbG9hZGluZyB0byBoYXZpbmcgYSB2YWx1ZSAodGh1c1xuICAgICAgICogcG9zc2libHkgdHJpZ2dlcmluZyBhIHJlLXJlbmRlciksIGFuZCBSZWFjdCByZS1yZW5kZXJzIGJlZm9yZSB0aGVcbiAgICAgICAqIGNoYWluZWQgLnRoZW4oKSBmdW5jdGlvbnMgcnVuLCB0aHVzIHN0YXJ0aW5nIGEgbmV3IGV4ZWN1dGlvbiBhcyB0aGVcbiAgICAgICAqIGRlcCBoYXMgY2hhbmdlZCB2YWx1ZS4gV2l0aG91dCB0aGlzIGNoZWNrIHdlIHdpbGwgcnVuIHRoZSBzZWxlY3RvclxuICAgICAgICogdHdpY2UgKG9uY2UgaW4gdGhlIG5ldyBleGVjdXRpb24gYW5kIG9uY2UgYWdhaW4gaW4gdGhpcyAudGhlbigpLCBzb1xuICAgICAgICogdGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8ga2VlcCB1bm5lY2Vzc2FyeSByZS1leGVjdXRpb25zIHRvIGFcbiAgICAgICAqIG1pbmltdW0pLlxuICAgICAgICpcbiAgICAgICAqIEFsc28gbm90ZSB0aGlzIGNvZGUgZG9lcyBub3QgY2hlY2sgYWNyb3NzIGFsbCBleGVjdXRpb25zIHRoYXQgbWF5IGJlXG4gICAgICAgKiBydW5uaW5nLiBJdCBvbmx5IG9wdGltaXplcyBmb3IgdGhlIF9sYXRlc3RfIGV4ZWN1dGlvbiBwZXIgc3RvcmUgYXNcbiAgICAgICAqIHdlIGN1cnJlbnRseSBkbyBub3QgbWFpbnRhaW4gYSBsaXN0IG9mIGFsbCBjdXJyZW50bHkgcnVubmluZyBleGVjdXRpb25zLlxuICAgICAgICogVGhpcyBtZWFucyBpbiBzb21lIGNhc2VzIHdlIG1heSBydW4gc2VsZWN0b3JzIG1vcmUgdGhhbiBzdHJpY3RseVxuICAgICAgICogbmVjZXNzYXJ5IHdoZW4gdGhlcmUgYXJlIG11bHRpcGxlIGV4ZWN1dGlvbnMgcnVubmluZyBmb3IgdGhlIHNhbWVcbiAgICAgICAqIHNlbGVjdG9yLiBUaGlzIG1heSBiZSBhIHZhbGlkIHRyYWRlb2ZmIGFzIGNoZWNraW5nIGZvciBkZXAgY2hhbmdlc1xuICAgICAgICogYWNyb3NzIGFsbCBpbi1wcm9ncmVzcyBleGVjdXRpb25zIG1heSB0YWtlIGxvbmdlciB0aGFuIGp1c3RcbiAgICAgICAqIHJlLXJ1bm5pbmcgdGhlIHNlbGVjdG9yLiBUaGlzIHdpbGwgYmUgYXBwLWRlcGVuZGVudCwgYW5kIG1heWJlIGluIHRoZVxuICAgICAgICogZnV0dXJlIHdlIGNhbiBtYWtlIHRoZSBiZWhhdmlvciBjb25maWd1cmFibGUuIEFuIGlkZWFsIGZpeCBtYXkgYmVcbiAgICAgICAqIHRvIGV4dGVuZCB0aGUgdHJlZSBjYWNoZSB0byBzdXBwb3J0IGNhY2hpbmcgbG9hZGluZyBzdGF0ZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBpZiAoIWlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkpIHtcbiAgICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKHN0b3JlLCBzdGF0ZSk7XG5cbiAgICAgICAgaWYgKGV4ZWN1dGlvbkluZm8gIT0gbnVsbCkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFJldHVybmluZyBwcm9taXNlIGhlcmUgd2l0aG91dCB3cmFwcGluZyBhcyB0aGUgd3JhcHBlciBsb2dpYyB3YXNcbiAgICAgICAgICAgKiBhbHJlYWR5IGRvbmUgdXBzdHJlYW0gd2hlbiB0aGlzIHByb21pc2Ugd2FzIGdlbmVyYXRlZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICByZXR1cm4gZXhlY3V0aW9uSW5mby5sb2FkaW5nTG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0cnkgdGhlIHNlbGVjdG9yIGV2YWx1YXRpb24gbm93IHRoYXQgdGhlIGRlcGVuZGVuY3kgaGFzIHJlc29sdmVkXG5cblxuICAgICAgY29uc3QgW2xvYWRhYmxlLCBkZXBWYWx1ZXNdID0gZXZhbHVhdGVTZWxlY3RvckdldHRlcihzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklEKTtcblxuICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgcmVzb2x2ZUFzeW5jKHN0b3JlLCBzdGF0ZSwgZXhlY3V0aW9uSUQsIGxvYWRhYmxlLCBkZXBWYWx1ZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgbG9hZGFibGUuY29udGVudHM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2FkYWJsZS5jb250ZW50cztcbiAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAvLyBUaGUgc2VsZWN0b3Igd2FzIHJlbGVhc2VkIHNpbmNlIHRoZSByZXF1ZXN0IGJlZ2FuOyBpZ25vcmUgdGhlIHJlc3BvbnNlLlxuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ2FuY2VsZWQpIHtcbiAgICAgICAgdGhyb3cgQ0FOQ0VMRUQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZWN0b3JJc0xpdmUoKSkge1xuICAgICAgICBjbGVhckV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuICAgICAgICB0aHJvdyBDQU5DRUxFRDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9hZGFibGUgPSBsb2FkYWJsZVdpdGhFcnJvciQxKGVycm9yKTtcbiAgICAgIHJlc29sdmVBc3luYyhzdG9yZSwgc3RhdGUsIGV4ZWN1dGlvbklELCBsb2FkYWJsZSwgZXhpc3RpbmdEZXBzKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUsIGRlcHMsIGV4ZWN1dGlvbklEKSB7XG4gICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSwgX3N0b3JlJGdldFN0YXRlJGN1cnJlLCBfc3RvcmUkZ2V0U3RhdGUyLCBfc3RvcmUkZ2V0U3RhdGUyJG5leHQ7XG5cbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSB8fCBzdGF0ZS52ZXJzaW9uID09PSAoKF9zdG9yZSRnZXRTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCkpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zdG9yZSRnZXRTdGF0ZSRjdXJyZSA9IF9zdG9yZSRnZXRTdGF0ZS5jdXJyZW50VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlJGN1cnJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RvcmUkZ2V0U3RhdGUkY3VycmUudmVyc2lvbikgfHwgc3RhdGUudmVyc2lvbiA9PT0gKChfc3RvcmUkZ2V0U3RhdGUyID0gc3RvcmUuZ2V0U3RhdGUoKSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9zdG9yZSRnZXRTdGF0ZTIkbmV4dCA9IF9zdG9yZSRnZXRTdGF0ZTIubmV4dFRyZWUpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTIkbmV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlMiRuZXh0LnZlcnNpb24pKSB7XG4gICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRULCBfc3RvcmUkZ2V0U3RhdGUzLCBfc3RvcmUkZ2V0U3RhdGUzJG5leHQ7XG5cbiAgICAgIHNhdmVEZXBzVG9TdG9yZSQxKGtleSwgZGVwcywgc3RvcmUsIChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgPSAoX3N0b3JlJGdldFN0YXRlMyA9IHN0b3JlLmdldFN0YXRlKCkpID09PSBudWxsIHx8IF9zdG9yZSRnZXRTdGF0ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfc3RvcmUkZ2V0U3RhdGUzJG5leHQgPSBfc3RvcmUkZ2V0U3RhdGUzLm5leHRUcmVlKSA9PT0gbnVsbCB8fCBfc3RvcmUkZ2V0U3RhdGUzJG5leHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdG9yZSRnZXRTdGF0ZTMkbmV4dC52ZXJzaW9uKSAhPT0gbnVsbCAmJiBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VCA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWUudmVyc2lvbik7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRlcHMpIHtcbiAgICAgIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMuYWRkKG5vZGVLZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBleGVjdXRpb25JRCkge1xuICAgIGNvbnN0IGVuZFBlcmZCbG9jayA9IHN0YXJ0UGVyZkJsb2NrJDEoa2V5KTsgLy8gVE9ETyBUNjM5NjU4NjY6IHVzZSBleGVjdXRpb24gSUQgaGVyZVxuXG4gICAgbGV0IGR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uID0gdHJ1ZTtcbiAgICBsZXQgZHVyaW5nQXN5bmNocm9ub3VzRXhlY3V0aW9uID0gdHJ1ZTtcblxuICAgIGNvbnN0IGZpbmlzaEV2YWx1YXRpb24gPSAoKSA9PiB7XG4gICAgICBlbmRQZXJmQmxvY2soKTtcbiAgICAgIGR1cmluZ0FzeW5jaHJvbm91c0V4ZWN1dGlvbiA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCByZXN1bHRJc0Vycm9yID0gZmFsc2U7XG4gICAgbGV0IGxvYWRhYmxlO1xuICAgIGNvbnN0IGxvYWRpbmdEZXBzU3RhdGUgPSB7XG4gICAgICBsb2FkaW5nRGVwS2V5OiBudWxsLFxuICAgICAgbG9hZGluZ0RlcFByb21pc2U6IG51bGxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0YXJ0aW5nIGEgZnJlc2ggc2V0IG9mIGRlcHMgdGhhdCB3ZSdsbCBiZSB1c2luZyB0byB1cGRhdGUgc3RhdGUuIFdlJ3JlXG4gICAgICogc3RhcnRpbmcgYSBuZXcgc2V0IHZlcnN1cyBhZGRpbmcgaXQgaW4gZXhpc3Rpbmcgc3RhdGUgZGVwcyBiZWNhdXNlXG4gICAgICogdGhlIHZlcnNpb24gb2Ygc3RhdGUgdGhhdCB3ZSB1cGRhdGUgZGVwcyBmb3IgbWF5IGJlIGEgbW9yZSByZWNlbnQgdmVyc2lvblxuICAgICAqIHRoYW4gdGhlIHZlcnNpb24gdGhlIHNlbGVjdG9yIHdhcyBjYWxsZWQgd2l0aC4gVGhpcyBpcyBiZWNhdXNlIHRoZSBsYXRlc3RcbiAgICAgKiBleGVjdXRpb24gd2lsbCB1cGRhdGUgdGhlIGRlcHMgb2YgdGhlIGN1cnJlbnQvbGF0ZXN0IHZlcnNpb24gb2Ygc3RhdGVcbiAgICAgKiAoVGhpcyBpcyBzYWZlIHRvIGRvIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCB0aGUgc2VsZWN0b3IgaXMgdGhlIGxhdGVzdFxuICAgICAqIGV4ZWN1dGlvbiBtZWFucyB0aGUgZGVwcyB3ZSBkaXNjb3ZlciBiZWxvdyBhcmUgb3VyIGJlc3QgZ3Vlc3MgYXQgdGhlXG4gICAgICogZGVwcyBmb3IgdGhlIGN1cnJlbnQvbGF0ZXN0IHN0YXRlIGluIHRoZSBzdG9yZSlcbiAgICAgKi9cblxuICAgIGNvbnN0IGRlcFZhbHVlcyA9IG5ldyBNYXAoKTtcblxuICAgIGZ1bmN0aW9uIGdldFJlY29pbFZhbHVlKHtcbiAgICAgIGtleTogZGVwS2V5XG4gICAgfSkge1xuICAgICAgY29uc3QgZGVwTG9hZGFibGUgPSBnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIGRlcEtleSk7XG4gICAgICBkZXBWYWx1ZXMuc2V0KGRlcEtleSwgZGVwTG9hZGFibGUpOyAvLyBXZSBuZWVkIHRvIHVwZGF0ZSBhc3luY2hyb25vdXMgZGVwZW5kZW5jaWVzIGFzIHdlIGdvIHNvIHRoZSBzZWxlY3RvclxuICAgICAgLy8ga25vd3MgaWYgaXQgaGFzIHRvIHJlc3RhcnQgZXZhbHVhdGlvbiBpZiBvbmUgb2YgdGhlbSBpcyB1cGRhdGVkIGJlZm9yZVxuICAgICAgLy8gdGhlIGFzeW5jaHJvbm91cyBzZWxlY3RvciBjb21wbGV0ZWx5IHJlc29sdmVzLlxuXG4gICAgICBpZiAoIWR1cmluZ1N5bmNocm9ub3VzRXhlY3V0aW9uKSB7XG4gICAgICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBuZXcgU2V0KGRlcFZhbHVlcy5rZXlzKCkpLCBleGVjdXRpb25JRCk7XG4gICAgICAgIG5vdGlmeVN0b3Jlc09mTmV3QXN5bmNEZXAoc3RvcmUsIGV4ZWN1dGlvbklEKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChkZXBMb2FkYWJsZS5zdGF0ZSkge1xuICAgICAgICBjYXNlICdoYXNWYWx1ZSc6XG4gICAgICAgICAgcmV0dXJuIGRlcExvYWRhYmxlLmNvbnRlbnRzO1xuXG4gICAgICAgIGNhc2UgJ2hhc0Vycm9yJzpcbiAgICAgICAgICB0aHJvdyBkZXBMb2FkYWJsZS5jb250ZW50cztcblxuICAgICAgICBjYXNlICdsb2FkaW5nJzpcbiAgICAgICAgICBsb2FkaW5nRGVwc1N0YXRlLmxvYWRpbmdEZXBLZXkgPSBkZXBLZXk7XG4gICAgICAgICAgbG9hZGluZ0RlcHNTdGF0ZS5sb2FkaW5nRGVwUHJvbWlzZSA9IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICAgIHRocm93IGRlcExvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKCdJbnZhbGlkIExvYWRhYmxlIHN0YXRlJyk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2V0Q2FsbGJhY2sgPSBmbiA9PiB7XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGR1cmluZ0FzeW5jaHJvbm91c0V4ZWN1dGlvbikge1xuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIoJ0NhbGxiYWNrcyBmcm9tIGdldENhbGxiYWNrKCkgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGFmdGVyIHRoZSBzZWxlY3RvciBpcyBldmFsdXRhdGVkLiAgSXQgY2FuIGJlIHVzZWQgZm9yIHNlbGVjdG9ycyB0byByZXR1cm4gb2JqZWN0cyB3aXRoIGNhbGxiYWNrcyB0aGF0IGNhbiB3b3JrIHdpdGggUmVjb2lsIHN0YXRlIHdpdGhvdXQgYSBzdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAhKHJlY29pbFZhbHVlICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ1JlY29pbCBWYWx1ZSBjYW4gbmV2ZXIgYmUgbnVsbCcpIDogUmVjb2lsX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiByZWNvaWxDYWxsYmFjayQxKHN0b3JlLCBmbiwgYXJncywge1xuICAgICAgICAgIG5vZGU6IHJlY29pbFZhbHVlXG4gICAgICAgIH0gLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gZ2V0KHtcbiAgICAgICAgZ2V0OiBnZXRSZWNvaWxWYWx1ZSxcbiAgICAgICAgZ2V0Q2FsbGJhY2tcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0ID0gaXNSZWNvaWxWYWx1ZSQzKHJlc3VsdCkgPyBnZXRSZWNvaWxWYWx1ZShyZXN1bHQpIDogcmVzdWx0O1xuXG4gICAgICBpZiAoaXNMb2FkYWJsZSQxKHJlc3VsdCkpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0ZSA9PT0gJ2hhc0Vycm9yJykge1xuICAgICAgICAgIHJlc3VsdElzRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbnRlbnRzO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdCA9IHdyYXBSZXN1bHRQcm9taXNlKHN0b3JlLCByZXN1bHQsIHN0YXRlLCBkZXBWYWx1ZXMsIGV4ZWN1dGlvbklELCBsb2FkaW5nRGVwc1N0YXRlKS5maW5hbGx5KGZpbmlzaEV2YWx1YXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoRXZhbHVhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSByZXN1bHQgaW5zdGFuY2VvZiBXcmFwcGVkVmFsdWUkMSA/IHJlc3VsdC52YWx1ZSA6IHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvck9yRGVwUHJvbWlzZSkge1xuICAgICAgcmVzdWx0ID0gZXJyb3JPckRlcFByb21pc2U7XG5cbiAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0ID0gd3JhcFBlbmRpbmdEZXBlbmRlbmN5UHJvbWlzZShzdG9yZSwgcmVzdWx0LCBzdGF0ZSwgZGVwVmFsdWVzLCBleGVjdXRpb25JRCwgbG9hZGluZ0RlcHNTdGF0ZSkuZmluYWxseShmaW5pc2hFdmFsdWF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdElzRXJyb3IgPSB0cnVlO1xuICAgICAgICBmaW5pc2hFdmFsdWF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdElzRXJyb3IpIHtcbiAgICAgIGxvYWRhYmxlID0gbG9hZGFibGVXaXRoRXJyb3IkMShyZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAoUmVjb2lsX2lzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFByb21pc2UkMShyZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFZhbHVlJDIocmVzdWx0KTtcbiAgICB9XG5cbiAgICBkdXJpbmdTeW5jaHJvbm91c0V4ZWN1dGlvbiA9IGZhbHNlO1xuICAgIHVwZGF0ZUV4ZWN1dGlvbkluZm9EZXBWYWx1ZXMoc3RvcmUsIGV4ZWN1dGlvbklELCBkZXBWYWx1ZXMpO1xuICAgIHVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlLCBuZXcgU2V0KGRlcFZhbHVlcy5rZXlzKCkpLCBleGVjdXRpb25JRCk7XG4gICAgcmV0dXJuIFtsb2FkYWJsZSwgZGVwVmFsdWVzXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExvYWRhYmxlRnJvbUNhY2hlQW5kVXBkYXRlRGVwcyhzdG9yZSwgc3RhdGUpIHtcbiAgICAvLyBGaXJzdCwgbG9vayB1cCBpbiB0aGUgc3RhdGUgY2FjaGVcbiAgICAvLyBJZiBpdCdzIGhlcmUsIHRoZW4gdGhlIGRlcHMgaW4gdGhlIHN0b3JlIHNob3VsZCBhbHJlYWR5IGJlIHZhbGlkLlxuICAgIGxldCBjYWNoZWRMb2FkYWJsZSA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSk7XG5cbiAgICBpZiAoY2FjaGVkTG9hZGFibGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlO1xuICAgIH0gLy8gU2Vjb25kLCBsb29rIHVwIGluIHRoZSBzZWxlY3RvciBjYWNoZSBhbmQgdXBkYXRlIHRoZSBkZXBzIGluIHRoZSBzdG9yZVxuXG5cbiAgICBjb25zdCBkZXBzQWZ0ZXJDYWNoZUxvb2t1cCA9IG5ldyBTZXQoKTtcblxuICAgIHRyeSB7XG4gICAgICBjYWNoZWRMb2FkYWJsZSA9IGNhY2hlLmdldChub2RlS2V5ID0+IHtcbiAgICAgICAgISh0eXBlb2Ygbm9kZUtleSA9PT0gJ3N0cmluZycpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gUmVjb2lsX2ludmFyaWFudChmYWxzZSwgJ0NhY2hlIG5vZGVLZXkgaXMgdHlwZSBzdHJpbmcnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgICAgICByZXR1cm4gZ2V0Tm9kZUxvYWRhYmxlJDIoc3RvcmUsIHN0YXRlLCBub2RlS2V5KS5jb250ZW50cztcbiAgICAgIH0sIHtcbiAgICAgICAgb25Ob2RlVmlzaXQ6IG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdicmFuY2gnICYmIG5vZGUubm9kZUtleSAhPT0ga2V5KSB7XG4gICAgICAgICAgICBkZXBzQWZ0ZXJDYWNoZUxvb2t1cC5hZGQobm9kZS5ub2RlS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggY2FjaGUgbG9va3VwIGZvciBzZWxlY3RvciBcIiR7a2V5fVwiOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlZExvYWRhYmxlKSB7XG4gICAgICB2YXIgX2dldEV4ZWN1dGlvbkluZm87XG5cbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRzIGluIHRoZSBzdGF0ZSB0byBhbGxvdyBmb3IgY2hlYXBlciBsb29rdXAgdGhhblxuICAgICAgLy8gaXRlcmF0aW5nIHRoZSB0cmVlIGNhY2hlIG9mIGRlcGVuZGVuY2llcy5cbiAgICAgIHN0YXRlLmF0b21WYWx1ZXMuc2V0KGtleSwgY2FjaGVkTG9hZGFibGUpO1xuICAgICAgLyoqXG4gICAgICAgKiBFbnN1cmUgc3RvcmUgY29udGFpbnMgY29ycmVjdCBkZXBlbmRlbmNpZXMgaWYgd2UgaGl0IHRoZSBjYWNoZSBzbyB0aGF0XG4gICAgICAgKiB0aGUgc3RvcmUgZGVwcyBhbmQgY2FjaGUgYXJlIGluIHN5bmMgZm9yIGEgZ2l2ZW4gc3RhdGUuIFRoaXMgaXMgaW1wb3J0YW50XG4gICAgICAgKiBiZWNhdXNlIHN0b3JlIGRlcHMgYXJlIG5vcm1hbGx5IHVwZGF0ZWQgd2hlbiBuZXcgZXhlY3V0aW9ucyBhcmUgY3JlYXRlZCxcbiAgICAgICAqIGJ1dCBjYWNoZSBoaXRzIGRvbid0IHRyaWdnZXIgbmV3IGV4ZWN1dGlvbnMgYnV0IHRoZXkgc3RpbGwgX21heV8gc2lnbmlmeVxuICAgICAgICogYSBjaGFuZ2UgaW4gZGVwcyBpbiB0aGUgc3RvcmUgaWYgdGhlIHN0b3JlIGRlcHMgZm9yIHRoaXMgc3RhdGUgYXJlIGVtcHR5XG4gICAgICAgKiBvciBzdGFsZS5cbiAgICAgICAqL1xuXG4gICAgICB1cGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSwgZGVwc0FmdGVyQ2FjaGVMb29rdXAsIChfZ2V0RXhlY3V0aW9uSW5mbyA9IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpKSA9PT0gbnVsbCB8fCBfZ2V0RXhlY3V0aW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEV4ZWN1dGlvbkluZm8uZXhlY3V0aW9uSUQpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZWRMb2FkYWJsZTtcbiAgfVxuICAvKipcbiAgICogR2l2ZW4gYSB0cmVlIHN0YXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBMb2FkYWJsZSBvZiB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogVGhlIHNlbGVjdG9yJ3MgZ2V0KCkgZnVuY3Rpb24gd2lsbCBvbmx5IGJlIHJlLWV2YWx1YXRlZCBpZiBfYm90aF8gb2YgdGhlXG4gICAqIGZvbGxvd2luZyBzdGF0ZW1lbnRzIGFyZSB0cnVlOlxuICAgKlxuICAgKiAxLiBUaGUgY3VycmVudCBkZXAgdmFsdWVzIGZyb20gdGhlIGdpdmVuIHN0YXRlIHByb2R1Y2VkIGEgY2FjaGUga2V5IHRoYXRcbiAgICogICAgd2FzIG5vdCBmb3VuZCBpbiB0aGUgY2FjaGUuXG4gICAqIDIuIFRoZXJlIGlzIG5vIGN1cnJlbnRseSBydW5uaW5nIGFzeW5jIGV4ZWN1dGlvbiBPUiB0aGVyZSBpcyBhblxuICAgKiAgICBhc3luYyBleGVjdXRpb24gdGhhdCBpcyBydW5uaW5nLCBidXQgYWZ0ZXIgY29tcGFyaW5nIHRoZSBkZXAgdmFsdWVzIGluXG4gICAqICAgIHRoZSBnaXZlbiBzdGF0ZSB3aXRoIHRoZSBkZXAgdmFsdWVzIHRoYXQgdGhlIGV4ZWN1dGlvbiBoYXMgZGlzY292ZXJlZCBzb1xuICAgKiAgICBmYXIgd2UgZmluZCB0aGF0IGF0IGxlYXN0IG9uZSBkZXAgdmFsdWUgaGFzIGNoYW5nZWQsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICogICAgc3RhcnQgYSBuZXcgZXhlY3V0aW9uICh0aGUgcHJldmlvdXNseSBydW5uaW5nIGV4ZWN1dGlvbiB3aWxsIGNvbnRpbnVlIHRvXG4gICAqICAgIHJ1biB0byBjb21wbGV0aW9uLCBidXQgb25seSB0aGUgbmV3IGV4ZWN1dGlvbiB3aWxsIGJlIGRlZW1lZCB0aGVcbiAgICogICAgJ2xhdGVzdCcgZXhlY3V0aW9uLCBtZWFuaW5nIGl0IHdpbGwgYmUgdGhlIG9ubHkgZXhlY3V0aW9uIHRoYXQgd2lsbFxuICAgKiAgICB1cGRhdGUgZ2xvYmFsIHN0YXRlIHdoZW4gaXQgaXMgZmluaXNoZWQuIEFueSBub24tbGF0ZXN0IGV4ZWN1dGlvbnMgd2lsbFxuICAgKiAgICBydW4gdG8gY29tcGxldGlvbiBhbmQgdXBkYXRlIHRoZSBzZWxlY3RvciBjYWNoZSBidXQgbm90IGdsb2JhbCBzdGF0ZSkuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JMb2FkYWJsZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKSB7XG4gICAgLy8gRmlyc3QsIHNlZSBpZiBvdXIgY3VycmVudCBzdGF0ZSBpcyBjYWNoZWRcbiAgICBjb25zdCBjYWNoZWRWYWwgPSBnZXRMb2FkYWJsZUZyb21DYWNoZUFuZFVwZGF0ZURlcHMoc3RvcmUsIHN0YXRlKTtcblxuICAgIGlmIChjYWNoZWRWYWwgIT0gbnVsbCkge1xuICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgIHJldHVybiBjYWNoZWRWYWw7XG4gICAgfSAvLyBTZWNvbmQsIGNoZWNrIGlmIHRoZXJlIGlzIGFscmVhZHkgYW4gb25nb2luZyBleGVjdXRpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgc3RhdGVcblxuXG4gICAgY29uc3QgaW5Qcm9ncmVzc0V4ZWN1dGlvbkluZm8gPSBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyhzdG9yZSwgc3RhdGUpO1xuXG4gICAgaWYgKGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvICE9IG51bGwpIHtcbiAgICAgIHZhciBfaW5Qcm9ncmVzc0V4ZWN1dGlvbkk7XG5cbiAgICAgIGlmICgoKF9pblByb2dyZXNzRXhlY3V0aW9uSSA9IGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmxvYWRpbmdMb2FkYWJsZSkgPT09IG51bGwgfHwgX2luUHJvZ3Jlc3NFeGVjdXRpb25JID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5Qcm9ncmVzc0V4ZWN1dGlvbkkuc3RhdGUpID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIGluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvLmV4ZWN1dGlvbklEKTtcbiAgICAgIH0gLy8gRklYTUU6IGNoZWNrIGFmdGVyIHRoZSBmYWN0IHRvIHNlZSBpZiB3ZSBtYWRlIHRoZSByaWdodCBjaG9pY2UgYnkgd2FpdGluZ1xuXG5cbiAgICAgIHJldHVybiBpblByb2dyZXNzRXhlY3V0aW9uSW5mby5sb2FkaW5nTG9hZGFibGU7XG4gICAgfSAvLyBUaGlyZCwgc3RhcnQgYSBuZXcgZXZhbHVhdGlvbiBvZiB0aGUgc2VsZWN0b3JcblxuXG4gICAgY29uc3QgbmV3RXhlY3V0aW9uSUQgPSBnZXROZXdFeGVjdXRpb25JRCgpO1xuICAgIGNvbnN0IFtsb2FkYWJsZSwgbmV3RGVwVmFsdWVzXSA9IGV2YWx1YXRlU2VsZWN0b3JHZXR0ZXIoc3RvcmUsIHN0YXRlLCBuZXdFeGVjdXRpb25JRCk7XG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSB1cGRhdGVzIHRoZSBjYWNoZSB3aXRoIGEgZ2l2ZW4gbG9hZGFibGUuXG4gICAgICpcbiAgICAgKiBXZSBvbmx5IGNhY2hlIGxvYWRhYmxlcyB0aGF0IGFyZSBub3QgbG9hZGluZyBiZWNhdXNlIG91ciBjYWNoZSBrZXlzIGFyZVxuICAgICAqIGJhc2VkIG9uIGRlcCB2YWx1ZXMsIHdoaWNoIGFyZSBpbiBhbiB1bmZpbmlzaGVkIHN0YXRlIGZvciBsb2FkYWJsZXMgdGhhdFxuICAgICAqIGhhdmUgYSAnbG9hZGluZycgc3RhdGUgKG5ldyBkZXBzIG1heSBiZSBkaXNjb3ZlcmVkIHdoaWxlIHRoZSBzZWxlY3RvclxuICAgICAqIHJ1bnMgaXRzIGFzeW5jIGNvZGUpLiBXZSBuZXZlciB3YW50IHRvIGNhY2hlIHBhcnRpYWwgZGVwZW5kZW5jaWVzIGIvYyBpdFxuICAgICAqIGNvdWxkIGxlYWQgdG8gZXJyb3JzLCBzdWNoIGFzIHByZW1hdHVyZWx5IHJldHVybmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIGFcbiAgICAgKiBwYXJ0aWFsIGxpc3Qgb2YgZGVwcy0tIHdlIG5lZWQgdGhlIGZ1bGwgbGlzdCBvZiBkZXBzIHRvIGVuc3VyZSB0aGF0IHdlXG4gICAgICogYXJlIHJldHVybmluZyB0aGUgY29ycmVjdCByZXN1bHQgZnJvbSBjYWNoZS5cbiAgICAgKi9cblxuICAgIGlmIChsb2FkYWJsZS5zdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICBzZXRFeGVjdXRpb25JbmZvKHN0b3JlLCBuZXdFeGVjdXRpb25JRCwgbG9hZGFibGUsIG5ld0RlcFZhbHVlcywgc3RhdGUpO1xuICAgICAgbWFya1N0b3JlV2FpdGluZ0ZvclJlc29sdmVkQXN5bmMoc3RvcmUsIG5ld0V4ZWN1dGlvbklEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXJFeGVjdXRpb25JbmZvKHN0b3JlKTtcbiAgICAgIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgbmV3RGVwVmFsdWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9hZGFibGU7XG4gIH1cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGV4ZWN1dGlvbiBpbmZvIGFjcm9zcyBhbGwgc3RvcmVzIHRvIHNlZSBpZiB0aGVyZSBpcyBhbiBpbi1wcm9ncmVzc1xuICAgKiBleGVjdXRpb24gd2hvc2UgZGVwZW5kZW5jeSB2YWx1ZXMgbWF0Y2ggdGhlIHZhbHVlcyBvZiB0aGUgcmVxdWVzdGluZyBzdG9yZS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRJblByb2dyZXNzRXhlY3V0aW9uSW5mbyhzdG9yZSwgc3RhdGUpIHtcbiAgICAvLyBTb3J0IHRoZSBwZW5kaW5nIGV4ZWN1dGlvbnMgc28gdGhhdCBvdXIgY3VycmVudCBzdG9yZSBpcyBjaGVja2VkIGZpcnN0LlxuICAgIGNvbnN0IHBlbmRpbmdFeGVjdXRpb25zID0gUmVjb2lsX2NvbmNhdEl0ZXJhYmxlcyhbZXhlY3V0aW9uSW5mb01hcC5oYXMoc3RvcmUpID8gW1JlY29pbF9udWxsdGhyb3dzKGV4ZWN1dGlvbkluZm9NYXAuZ2V0KHN0b3JlKSldIDogW10sIFJlY29pbF9tYXBJdGVyYWJsZShSZWNvaWxfZmlsdGVySXRlcmFibGUoZXhlY3V0aW9uSW5mb01hcCwgKFtzXSkgPT4gcyAhPT0gc3RvcmUpLCAoWywgZXhlY0luZm9dKSA9PiBleGVjSW5mbyldKTtcblxuICAgIGZ1bmN0aW9uIGFueURlcENoYW5nZWQoZXhlY0RlcFZhbHVlcykge1xuICAgICAgZm9yIChjb25zdCBbZGVwS2V5LCBleGVjTG9hZGFibGVdIG9mIGV4ZWNEZXBWYWx1ZXMpIHtcbiAgICAgICAgaWYgKCFnZXROb2RlTG9hZGFibGUkMihzdG9yZSwgc3RhdGUsIGRlcEtleSkuaXMoZXhlY0xvYWRhYmxlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGV4ZWNJbmZvIG9mIHBlbmRpbmdFeGVjdXRpb25zKSB7XG4gICAgICBpZiAoIC8vIElmIHRoaXMgZXhlY3V0aW9uIHdhcyBhbHJlYWR5IGNoZWNrZWQgdG8gYmUgdmFsaWQgd2l0aCB0aGlzIHZlcnNpb25cbiAgICAgIC8vIG9mIHN0YXRlLCB0aGVuIGxldCdzIHVzZSBpdCFcbiAgICAgIGV4ZWNJbmZvLnN0YXRlVmVyc2lvbnMuZ2V0KHN0YXRlLnZlcnNpb24pIHx8IC8vIElmIHRoZSBkZXBzIGZvciB0aGUgZXhlY3V0aW9uIG1hdGNoIG91ciBjdXJyZW50IHN0YXRlLCB0aGVuIGl0J3MgdmFsaWRcbiAgICAgICFhbnlEZXBDaGFuZ2VkKGV4ZWNJbmZvLmRlcFZhbHVlc0Rpc2NvdmVyZWRTb0ZhckR1cmluZ0FzeW5jV29yaykpIHtcbiAgICAgICAgZXhlY0luZm8uc3RhdGVWZXJzaW9ucy5zZXQoc3RhdGUudmVyc2lvbiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBleGVjSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4ZWNJbmZvLnN0YXRlVmVyc2lvbnMuc2V0KHN0YXRlLnZlcnNpb24sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkge1xuICAgIHJldHVybiBleGVjdXRpb25JbmZvTWFwLmdldChzdG9yZSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCB1cGRhdGUgdGhlIHNlbGVjdG9yJ3MgZXhlY3V0aW9uIGluZm8gd2hlbiB0aGUgc2VsZWN0b3JcbiAgICogaGFzIGVpdGhlciBmaW5pc2hlZCBydW5uaW5nIGFuIGV4ZWN1dGlvbiBvciBoYXMgc3RhcnRlZCBhIG5ldyBleGVjdXRpb24uIElmXG4gICAqIHRoZSBnaXZlbiBsb2FkYWJsZSBpcyBpbiBhICdsb2FkaW5nJyBzdGF0ZSwgdGhlIGludGVudGlvbiBpcyB0aGF0IGEgbmV3XG4gICAqIGV4ZWN1dGlvbiBoYXMgc3RhcnRlZC4gT3RoZXJ3aXNlLCB0aGUgaW50ZW50aW9uIGlzIHRoYXQgYW4gZXhlY3V0aW9uIGhhc1xuICAgKiBqdXN0IGZpbmlzaGVkLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNldEV4ZWN1dGlvbkluZm8oc3RvcmUsIG5ld0V4ZWN1dGlvbklELCBsb2FkYWJsZSwgZGVwVmFsdWVzLCBzdGF0ZSkge1xuICAgIGV4ZWN1dGlvbkluZm9NYXAuc2V0KHN0b3JlLCB7XG4gICAgICBkZXBWYWx1ZXNEaXNjb3ZlcmVkU29GYXJEdXJpbmdBc3luY1dvcms6IGRlcFZhbHVlcyxcbiAgICAgIGV4ZWN1dGlvbklEOiBuZXdFeGVjdXRpb25JRCxcbiAgICAgIGxvYWRpbmdMb2FkYWJsZTogbG9hZGFibGUsXG4gICAgICBzdGF0ZVZlcnNpb25zOiBuZXcgTWFwKFtbc3RhdGUudmVyc2lvbiwgdHJ1ZV1dKVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRXhlY3V0aW9uSW5mb0RlcFZhbHVlcyhzdG9yZSwgZXhlY3V0aW9uSUQsIGRlcFZhbHVlcykge1xuICAgIC8vIFdlIG9ubHkgbmVlZCB0byBib3RoZXIgdXBkYXRpbmcgdGhlIGRlcHMgZm9yIHRoZSBsYXRlc3QgZXhlY3V0aW9uIGJlY2F1c2VcbiAgICAvLyB0aGF0J3MgYWxsIGdldEluUHJvZ3Jlc3NFeGVjdXRpb25JbmZvKCkgd2lsbCBiZSBsb29raW5nIGZvci5cbiAgICBpZiAoaXNMYXRlc3RFeGVjdXRpb24oc3RvcmUsIGV4ZWN1dGlvbklEKSkge1xuICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IGdldEV4ZWN1dGlvbkluZm8oc3RvcmUpO1xuXG4gICAgICBpZiAoZXhlY3V0aW9uSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIGV4ZWN1dGlvbkluZm8uZGVwVmFsdWVzRGlzY292ZXJlZFNvRmFyRHVyaW5nQXN5bmNXb3JrID0gZGVwVmFsdWVzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRXhlY3V0aW9uSW5mbyhzdG9yZSkge1xuICAgIGV4ZWN1dGlvbkluZm9NYXAuZGVsZXRlKHN0b3JlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTGF0ZXN0RXhlY3V0aW9uKHN0b3JlLCBleGVjdXRpb25JRCkge1xuICAgIHZhciBfZ2V0RXhlY3V0aW9uSW5mbzI7XG5cbiAgICByZXR1cm4gZXhlY3V0aW9uSUQgPT09ICgoX2dldEV4ZWN1dGlvbkluZm8yID0gZ2V0RXhlY3V0aW9uSW5mbyhzdG9yZSkpID09PSBudWxsIHx8IF9nZXRFeGVjdXRpb25JbmZvMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2dldEV4ZWN1dGlvbkluZm8yLmV4ZWN1dGlvbklEKTtcbiAgfVxuICAvKipcbiAgICogRklYTUU6IGRlcCBrZXlzIHNob3VsZCB0YWtlIGludG8gYWNjb3VudCB0aGUgc3RhdGUgb2YgdGhlIGxvYWRhYmxlIHRvXG4gICAqIHByZXZlbnQgdGhlIGVkZ2UgY2FzZSB3aGVyZSBhIGxvYWRhYmxlIHdpdGggYW4gZXJyb3IgYW5kIGEgbG9hZGFibGUgd2l0aFxuICAgKiBhbiBlcnJvciBhcyBhIHZhbHVlIGFyZSB0cmVhdGVkIGFzIHRoZSBzYW1lIHRoaW5nIGluY29ycmVjdGx5LiBGb3IgZXhhbXBsZVxuICAgKiB0aGVzZSB0d28gc2hvdWxkIGJlIHRyZWF0ZWQgZGlmZmVyZW50bHk6XG4gICAqXG4gICAqIHNlbGVjdG9yKHtrZXk6ICcnLCBnZXQ6ICgpID0+IG5ldyBFcnJvcignaGknKX0pO1xuICAgKiBzZWxlY3Rvcih7a2V5OiAnJywgZ2V0ICgpID0+IHt0aHJvdyBuZXcgRXJyb3IoJ2hpJyl9fSk7XG4gICAqXG4gICAqIFdpdGggY3VycmVudCBpbXBsZW1lbnRhdGlvbiB0aGV5IGFyZSB0cmVhdGVkIHRoZSBzYW1lXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZGVwVmFsdWVzVG9EZXBSb3V0ZShkZXBWYWx1ZXMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShkZXBWYWx1ZXMuZW50cmllcygpKS5tYXAoKFtkZXBLZXksIHZhbExvYWRhYmxlXSkgPT4gW2RlcEtleSwgdmFsTG9hZGFibGUuY29udGVudHNdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENhY2hlKHN0YXRlLCBsb2FkYWJsZSwgZGVwVmFsdWVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKGxvYWRhYmxlLnN0YXRlICE9PSAnbG9hZGluZycgJiYgQm9vbGVhbihvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgUmVjb2lsX2RlZXBGcmVlemVWYWx1ZShsb2FkYWJsZS5jb250ZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUuYXRvbVZhbHVlcy5zZXQoa2V5LCBsb2FkYWJsZSk7XG5cbiAgICB0cnkge1xuICAgICAgY2FjaGUuc2V0KGRlcFZhbHVlc1RvRGVwUm91dGUoZGVwVmFsdWVzKSwgbG9hZGFibGUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBSZWNvaWxfZXJyKGBQcm9ibGVtIHdpdGggc2V0dGluZyBjYWNoZSBmb3Igc2VsZWN0b3IgXCIke2tleX1cIjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGVjdENpcmN1bGFyRGVwZW5kZW5jaWVzKGZuKSB7XG4gICAgaWYgKGRlcGVuZGVuY3lTdGFjay5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gYFJlY29pbCBzZWxlY3RvciBoYXMgY2lyY3VsYXIgZGVwZW5kZW5jaWVzOiAke2RlcGVuZGVuY3lTdGFjay5zbGljZShkZXBlbmRlbmN5U3RhY2suaW5kZXhPZihrZXkpKS5qb2luKCcgXFx1MjE5MiAnKX1gO1xuICAgICAgcmV0dXJuIGxvYWRhYmxlV2l0aEVycm9yJDEoUmVjb2lsX2VycihtZXNzYWdlKSk7XG4gICAgfVxuXG4gICAgZGVwZW5kZW5jeVN0YWNrLnB1c2goa2V5KTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGVwZW5kZW5jeVN0YWNrLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdG9yUGVlayhzdG9yZSwgc3RhdGUpIHtcbiAgICBjb25zdCBjYWNoZWRMb2FkYWJsZSA9IHN0YXRlLmF0b21WYWx1ZXMuZ2V0KGtleSk7XG5cbiAgICBpZiAoY2FjaGVkTG9hZGFibGUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZExvYWRhYmxlO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZS5nZXQobm9kZUtleSA9PiB7XG4gICAgICB2YXIgX3BlZWtOb2RlTG9hZGFibGU7XG5cbiAgICAgICEodHlwZW9mIG5vZGVLZXkgPT09ICdzdHJpbmcnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdDYWNoZSBub2RlS2V5IGlzIHR5cGUgc3RyaW5nJykgOiBSZWNvaWxfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiAoX3BlZWtOb2RlTG9hZGFibGUgPSBwZWVrTm9kZUxvYWRhYmxlJDEoc3RvcmUsIHN0YXRlLCBub2RlS2V5KSkgPT09IG51bGwgfHwgX3BlZWtOb2RlTG9hZGFibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wZWVrTm9kZUxvYWRhYmxlLmNvbnRlbnRzO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0b3JHZXQoc3RvcmUsIHN0YXRlKSB7XG4gICAgcmV0dXJuIGRldGVjdENpcmN1bGFyRGVwZW5kZW5jaWVzKCgpID0+IGdldFNlbGVjdG9yTG9hZGFibGVBbmRVcGRhdGVEZXBzKHN0b3JlLCBzdGF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZVNlbGVjdG9yKHN0YXRlKSB7XG4gICAgc3RhdGUuYXRvbVZhbHVlcy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyU2VsZWN0b3JDYWNoZShzdG9yZSwgdHJlZVN0YXRlKSB7XG4gICAgIShyZWNvaWxWYWx1ZSAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UsICdSZWNvaWwgVmFsdWUgY2FuIG5ldmVyIGJlIG51bGwnKSA6IFJlY29pbF9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuXG4gICAgZm9yIChjb25zdCBub2RlS2V5IG9mIGRpc2NvdmVyZWREZXBlbmRlbmN5Tm9kZUtleXMpIHtcbiAgICAgIHZhciBfbm9kZSRjbGVhckNhY2hlO1xuXG4gICAgICBjb25zdCBub2RlID0gZ2V0Tm9kZSQ2KG5vZGVLZXkpO1xuICAgICAgKF9ub2RlJGNsZWFyQ2FjaGUgPSBub2RlLmNsZWFyQ2FjaGUpID09PSBudWxsIHx8IF9ub2RlJGNsZWFyQ2FjaGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGNsZWFyQ2FjaGUuY2FsbChub2RlLCBzdG9yZSwgdHJlZVN0YXRlKTtcbiAgICB9XG5cbiAgICBkaXNjb3ZlcmVkRGVwZW5kZW5jeU5vZGVLZXlzLmNsZWFyKCk7XG4gICAgaW52YWxpZGF0ZVNlbGVjdG9yKHRyZWVTdGF0ZSk7XG4gICAgY2FjaGUuY2xlYXIoKTtcbiAgICBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQxKHN0b3JlLCByZWNvaWxWYWx1ZSk7XG4gIH1cblxuICBpZiAoc2V0ICE9IG51bGwpIHtcbiAgICAvKipcbiAgICAgKiBFUzUgc3RyaWN0IG1vZGUgcHJvaGliaXRzIGRlZmluaW5nIG5vbi10b3AtbGV2ZWwgZnVuY3Rpb24gZGVjbGFyYXRpb25zLFxuICAgICAqIHNvIGRvbid0IHVzZSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBzeW50YXggaGVyZVxuICAgICAqL1xuICAgIGNvbnN0IHNlbGVjdG9yU2V0ID0gKHN0b3JlLCBzdGF0ZSwgbmV3VmFsdWUpID0+IHtcbiAgICAgIGxldCBzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgY29uc3Qgd3JpdGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRSZWNvaWxWYWx1ZSh7XG4gICAgICAgIGtleTogZGVwS2V5XG4gICAgICB9KSB7XG4gICAgICAgIGlmIChzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCkge1xuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1JlY29pbDogQXN5bmMgc2VsZWN0b3Igc2V0cyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2FkYWJsZSA9IGdldE5vZGVMb2FkYWJsZSQyKHN0b3JlLCBzdGF0ZSwgZGVwS2V5KTtcblxuICAgICAgICBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdoYXNWYWx1ZScpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZGFibGUuY29udGVudHM7XG4gICAgICAgIH0gZWxzZSBpZiAobG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGNvbnN0IG1zZyA9IGBHZXR0aW5nIHZhbHVlIG9mIGFzeW5jaHJvbm91cyBhdG9tIG9yIHNlbGVjdG9yIFwiJHtkZXBLZXl9XCIgaW4gYSBwZW5kaW5nIHN0YXRlIHdoaWxlIHNldHRpbmcgc2VsZWN0b3IgXCIke2tleX1cIiBpcyBub3QgeWV0IHN1cHBvcnRlZC5gO1xuICAgICAgICAgIFJlY29pbF9yZWNvdmVyYWJsZVZpb2xhdGlvbihtc2cpO1xuICAgICAgICAgIHRocm93IFJlY29pbF9lcnIobXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBsb2FkYWJsZS5jb250ZW50cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRSZWNvaWxTdGF0ZShyZWNvaWxTdGF0ZSwgdmFsdWVPclVwZGF0ZXIgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICAgICAgKSB7XG4gICAgICAgIGlmIChzeW5jU2VsZWN0b3JTZXRGaW5pc2hlZCkge1xuICAgICAgICAgIGNvbnN0IG1zZyA9ICdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLic7XG4gICAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKG1zZyk7XG4gICAgICAgICAgdGhyb3cgUmVjb2lsX2Vycihtc2cpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0VmFsdWUgPSB0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyAvLyBjYXN0IHRvIGFueSBiZWNhdXNlIHdlIGNhbid0IHJlc3RyaWN0IHR5cGUgUyBmcm9tIGJlaW5nIGEgZnVuY3Rpb24gaXRzZWxmIHdpdGhvdXQgbG9zaW5nIHN1cHBvcnQgZm9yIG9wYXF1ZSB0eXBlc1xuICAgICAgICAvLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICB2YWx1ZU9yVXBkYXRlcihnZXRSZWNvaWxWYWx1ZShyZWNvaWxTdGF0ZSkpIDogdmFsdWVPclVwZGF0ZXI7XG4gICAgICAgIGNvbnN0IHVwc3RyZWFtV3JpdGVzID0gc2V0Tm9kZVZhbHVlJDMoc3RvcmUsIHN0YXRlLCByZWNvaWxTdGF0ZS5rZXksIHNldFZhbHVlKTtcbiAgICAgICAgdXBzdHJlYW1Xcml0ZXMuZm9yRWFjaCgodiwgaykgPT4gd3JpdGVzLnNldChrLCB2KSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUpIHtcbiAgICAgICAgc2V0UmVjb2lsU3RhdGUocmVjb2lsU3RhdGUsIERFRkFVTFRfVkFMVUUkNik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJldCA9IHNldCh7XG4gICAgICAgIHNldDogc2V0UmVjb2lsU3RhdGUsXG4gICAgICAgIGdldDogZ2V0UmVjb2lsVmFsdWUsXG4gICAgICAgIHJlc2V0OiByZXNldFJlY29pbFN0YXRlXG4gICAgICB9LCBuZXdWYWx1ZSk7IC8vIHNldCBzaG91bGQgYmUgYSB2b2lkIG1ldGhvZCwgYnV0IGlmIHRoZSB1c2VyIG1ha2VzIGl0IGBhc3luY2AsIHRoZW4gaXRcbiAgICAgIC8vIHdpbGwgcmV0dXJuIGEgUHJvbWlzZSwgd2hpY2ggd2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQuXG5cbiAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBSZWNvaWxfaXNQcm9taXNlKHJldCkgPyBSZWNvaWxfZXJyKCdSZWNvaWw6IEFzeW5jIHNlbGVjdG9yIHNldHMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLicpIDogUmVjb2lsX2VycignUmVjb2lsOiBzZWxlY3RvciBzZXQgc2hvdWxkIGJlIGEgdm9pZCBmdW5jdGlvbi4nKTtcbiAgICAgIH1cblxuICAgICAgc3luY1NlbGVjdG9yU2V0RmluaXNoZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHdyaXRlcztcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJlY29pbFZhbHVlID0gcmVnaXN0ZXJOb2RlJDEoe1xuICAgICAga2V5LFxuICAgICAgbm9kZVR5cGU6ICdzZWxlY3RvcicsXG4gICAgICBwZWVrOiBzZWxlY3RvclBlZWssXG4gICAgICBnZXQ6IHNlbGVjdG9yR2V0LFxuICAgICAgc2V0OiBzZWxlY3RvclNldCxcbiAgICAgIGluaXQ6IHNlbGVjdG9ySW5pdCxcbiAgICAgIGludmFsaWRhdGU6IGludmFsaWRhdGVTZWxlY3RvcixcbiAgICAgIGNsZWFyQ2FjaGU6IGNsZWFyU2VsZWN0b3JDYWNoZSxcbiAgICAgIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZTogc2VsZWN0b3JTaG91bGREZWxldGVDb25maWdPblJlbGVhc2UsXG4gICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgIHNob3VsZFJlc3RvcmVGcm9tU25hcHNob3RzOiBmYWxzZSxcbiAgICAgIHJldGFpbmVkQnlcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVjb2lsVmFsdWUgPSByZWdpc3Rlck5vZGUkMSh7XG4gICAgICBrZXksXG4gICAgICBub2RlVHlwZTogJ3NlbGVjdG9yJyxcbiAgICAgIHBlZWs6IHNlbGVjdG9yUGVlayxcbiAgICAgIGdldDogc2VsZWN0b3JHZXQsXG4gICAgICBpbml0OiBzZWxlY3RvckluaXQsXG4gICAgICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlU2VsZWN0b3IsXG4gICAgICBjbGVhckNhY2hlOiBjbGVhclNlbGVjdG9yQ2FjaGUsXG4gICAgICBzaG91bGREZWxldGVDb25maWdPblJlbGVhc2U6IHNlbGVjdG9yU2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlLFxuICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXG4gICAgICBzaG91bGRSZXN0b3JlRnJvbVNuYXBzaG90czogZmFsc2UsXG4gICAgICByZXRhaW5lZEJ5XG4gICAgfSk7XG4gIH1cbn1cbi8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG4vLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS11c2VdXG4vLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG5cblxuc2VsZWN0b3IudmFsdWUgPSB2YWx1ZSA9PiBuZXcgV3JhcHBlZFZhbHVlJDEodmFsdWUpO1xuXG52YXIgUmVjb2lsX3NlbGVjdG9yID0gc2VsZWN0b3I7XG5cbi8vIEBmYi1vbmx5OiBpbXBvcnQgdHlwZSB7U2NvcGVSdWxlc30gZnJvbSAnUmVjb2lsX1Njb3BlZEF0b20nO1xuLy8gQGZiLW9ubHk6IGNvbnN0IHtzY29wZWRBdG9tfSA9IHJlcXVpcmUoJ1JlY29pbF9TY29wZWRBdG9tJyk7XG5jb25zdCB7XG4gIGlzTG9hZGFibGU6IGlzTG9hZGFibGUkMixcbiAgbG9hZGFibGVXaXRoRXJyb3I6IGxvYWRhYmxlV2l0aEVycm9yJDIsXG4gIGxvYWRhYmxlV2l0aFByb21pc2U6IGxvYWRhYmxlV2l0aFByb21pc2UkMixcbiAgbG9hZGFibGVXaXRoVmFsdWU6IGxvYWRhYmxlV2l0aFZhbHVlJDNcbn0gPSBSZWNvaWxfTG9hZGFibGUkMTtcblxuY29uc3Qge1xuICBXcmFwcGVkVmFsdWU6IFdyYXBwZWRWYWx1ZSQyXG59ID0gUmVjb2lsX1dyYXBwZXIkMTtcblxuY29uc3Qge1xuICBwZWVrTm9kZUluZm86IHBlZWtOb2RlSW5mbyQzXG59ID0gUmVjb2lsX0Z1bmN0aW9uYWxDb3JlO1xuXG5jb25zdCB7XG4gIERFRkFVTFRfVkFMVUU6IERFRkFVTFRfVkFMVUUkNyxcbiAgRGVmYXVsdFZhbHVlOiBEZWZhdWx0VmFsdWUkMixcbiAgZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBnZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMixcbiAgcmVnaXN0ZXJOb2RlOiByZWdpc3Rlck5vZGUkMixcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyOiBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMVxufSA9IFJlY29pbF9Ob2RlO1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNFxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIGdldFJlY29pbFZhbHVlQXNMb2FkYWJsZTogZ2V0UmVjb2lsVmFsdWVBc0xvYWRhYmxlJDQsXG4gIG1hcmtSZWNvaWxWYWx1ZU1vZGlmaWVkOiBtYXJrUmVjb2lsVmFsdWVNb2RpZmllZCQyLFxuICBzZXRSZWNvaWxWYWx1ZTogc2V0UmVjb2lsVmFsdWUkNCxcbiAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZTogc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyXG59ID0gUmVjb2lsX1JlY29pbFZhbHVlSW50ZXJmYWNlO1xuXG5jb25zdCB7XG4gIHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdDogcmV0YWluZWRCeU9wdGlvbldpdGhEZWZhdWx0JDJcbn0gPSBSZWNvaWxfUmV0ZW50aW9uO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3QgdW53cmFwID0geCA9PiB4IGluc3RhbmNlb2YgV3JhcHBlZFZhbHVlJDIgPyB4LnZhbHVlIDogeDtcblxuZnVuY3Rpb24gYmFzZUF0b20ob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAga2V5LFxuICAgIHBlcnNpc3RlbmNlX1VOU1RBQkxFOiBwZXJzaXN0ZW5jZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgcmV0YWluZWRCeSA9IHJldGFpbmVkQnlPcHRpb25XaXRoRGVmYXVsdCQyKG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSk7XG4gIGxldCBsaXZlU3RvcmVzQ291bnQgPSAwO1xuXG4gIGZ1bmN0aW9uIHVud3JhcFByb21pc2UocHJvbWlzZSkge1xuICAgIHJldHVybiBsb2FkYWJsZVdpdGhQcm9taXNlJDIocHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aFZhbHVlJDModmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGRlZmF1bHRMb2FkYWJsZSA9IGxvYWRhYmxlV2l0aEVycm9yJDIoZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSkpO1xuICB9XG5cbiAgbGV0IGRlZmF1bHRMb2FkYWJsZSA9IFJlY29pbF9pc1Byb21pc2Uob3B0aW9ucy5kZWZhdWx0KSA/IHVud3JhcFByb21pc2Uob3B0aW9ucy5kZWZhdWx0KSA6IGlzTG9hZGFibGUkMihvcHRpb25zLmRlZmF1bHQpID8gb3B0aW9ucy5kZWZhdWx0LnN0YXRlID09PSAnbG9hZGluZycgPyB1bndyYXBQcm9taXNlKG9wdGlvbnMuZGVmYXVsdC5jb250ZW50cykgOiBvcHRpb25zLmRlZmF1bHQgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuICBsb2FkYWJsZVdpdGhWYWx1ZSQzKHVud3JhcChvcHRpb25zLmRlZmF1bHQpKTtcbiAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShkZWZhdWx0TG9hZGFibGUuY29udGVudHMpO1xuICBsZXQgY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSA9IHVuZGVmaW5lZDsgLy8gQ2xlYW51cCBoYW5kbGVycyBmb3IgdGhpcyBhdG9tXG4gIC8vIFJlbHkgb24gc3RhYmxlIHJlZmVyZW5jZSBlcXVhbGl0eSBvZiB0aGUgc3RvcmUgdG8gdXNlIGl0IGFzIGEga2V5IHBlciA8UmVjb2lsUm9vdD5cblxuICBjb25zdCBjbGVhbnVwRWZmZWN0c0J5U3RvcmUgPSBuZXcgTWFwKCk7XG5cbiAgZnVuY3Rpb24gbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZSh2YWx1ZU9yUHJvbWlzZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmIChvcHRpb25zLmRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5ICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKHZhbHVlT3JQcm9taXNlKSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFJlY29pbF9kZWVwRnJlZXplVmFsdWUodmFsdWVPclByb21pc2UpO1xuICAgICAgICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZU9yUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBQZW5kaW5nUHJvbWlzZShzdG9yZSwgcHJvbWlzZSkge1xuICAgIGNvbnN0IHdyYXBwZWRQcm9taXNlID0gcHJvbWlzZS50aGVuKHZhbHVlID0+IHtcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQsIF9zdGF0ZSRhdG9tVmFsdWVzJGdldDtcblxuICAgICAgY29uc3Qgc3RhdGUgPSAoX3N0b3JlJGdldFN0YXRlJG5leHRUID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUICE9PSB2b2lkIDAgPyBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlO1xuXG4gICAgICBpZiAoKChfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRhdG9tVmFsdWVzJGdldC5jb250ZW50cykgPT09IHdyYXBwZWRQcm9taXNlKSB7XG4gICAgICAgIHNldFJlY29pbFZhbHVlJDQoc3RvcmUsIG5vZGUsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIHZhciBfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyLCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyO1xuXG4gICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQyID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUMiAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUMiA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgIGlmICgoKF9zdGF0ZSRhdG9tVmFsdWVzJGdldDIgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfc3RhdGUkYXRvbVZhbHVlcyRnZXQyLmNvbnRlbnRzKSA9PT0gd3JhcHBlZFByb21pc2UpIHtcbiAgICAgICAgc2V0UmVjb2lsVmFsdWVMb2FkYWJsZSQyKHN0b3JlLCBub2RlLCBsb2FkYWJsZVdpdGhFcnJvciQyKGVycm9yKSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHJldHVybiB3cmFwcGVkUHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRBdG9tKHN0b3JlLCBpbml0U3RhdGUsIHRyaWdnZXIpIHtcbiAgICB2YXIgX29wdGlvbnMkZWZmZWN0cztcblxuICAgIGxpdmVTdG9yZXNDb3VudCsrO1xuXG4gICAgY29uc3QgY2xlYW51cEF0b20gPSAoKSA9PiB7XG4gICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yO1xuXG4gICAgICBsaXZlU3RvcmVzQ291bnQtLTtcbiAgICAgIChfY2xlYW51cEVmZmVjdHNCeVN0b3IgPSBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZ2V0KHN0b3JlKSkgPT09IG51bGwgfHwgX2NsZWFudXBFZmZlY3RzQnlTdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2xlYW51cEVmZmVjdHNCeVN0b3IuZm9yRWFjaChjbGVhbnVwID0+IGNsZWFudXAoKSk7XG4gICAgICBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuZGVsZXRlKHN0b3JlKTtcbiAgICB9O1xuXG4gICAgc3RvcmUuZ2V0U3RhdGUoKS5rbm93bkF0b21zLmFkZChrZXkpOyAvLyBTZXR1cCBhc3luYyBkZWZhdWx0cyB0byBub3RpZnkgc3Vic2NyaWJlcnMgd2hlbiB0aGV5IHJlc29sdmVcblxuICAgIGlmIChkZWZhdWx0TG9hZGFibGUuc3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgY29uc3Qgbm90aWZ5RGVmYXVsdFN1YnNjcmliZXJzID0gKCkgPT4ge1xuICAgICAgICB2YXIgX3N0b3JlJGdldFN0YXRlJG5leHRUMztcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQzID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgIT09IG51bGwgJiYgX3N0b3JlJGdldFN0YXRlJG5leHRUMyAhPT0gdm9pZCAwID8gX3N0b3JlJGdldFN0YXRlJG5leHRUMyA6IHN0b3JlLmdldFN0YXRlKCkuY3VycmVudFRyZWU7XG5cbiAgICAgICAgaWYgKCFzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgbWFya1JlY29pbFZhbHVlTW9kaWZpZWQkMihzdG9yZSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGRlZmF1bHRMb2FkYWJsZS5jb250ZW50cy5maW5hbGx5KG5vdGlmeURlZmF1bHRTdWJzY3JpYmVycyk7XG4gICAgfSAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gUnVuIEF0b20gRWZmZWN0c1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4gICAgY29uc3QgZWZmZWN0cyA9IChfb3B0aW9ucyRlZmZlY3RzID0gb3B0aW9ucy5lZmZlY3RzKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRlZmZlY3RzICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRlZmZlY3RzIDogb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFO1xuXG4gICAgaWYgKGVmZmVjdHMgIT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBzdGF0ZSBpcyBzY29wZWQgYnkgU3RvcmUsIHNpbmNlIHRoaXMgaXMgaW4gdGhlIGluaXRBdG9tKCkgY2xvc3VyZVxuICAgICAgbGV0IGluaXRWYWx1ZSA9IERFRkFVTFRfVkFMVUUkNztcbiAgICAgIGxldCBpc0R1cmluZ0luaXQgPSB0cnVlO1xuICAgICAgbGV0IGlzSW5pdEVycm9yID0gZmFsc2U7XG4gICAgICBsZXQgcGVuZGluZ1NldFNlbGYgPSBudWxsO1xuXG4gICAgICBmdW5jdGlvbiBnZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSBjYW4ganVzdCBnZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYW5vdGhlciBhdG9tLlxuICAgICAgICAvLyBCdXQgZm9yIG91ciBvd24gdmFsdWUgd2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBhIHBlbmRpbmdcbiAgICAgICAgLy8gaW5pdGlhbGl6ZWQgdmFsdWUgb3IgZ2V0IHRoZSBmYWxsYmFjayBkZWZhdWx0IHZhbHVlLlxuICAgICAgICBpZiAoaXNEdXJpbmdJbml0ICYmIHJlY29pbFZhbHVlLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgLy8gQ2FzdCBUIHRvIFNcbiAgICAgICAgICBjb25zdCByZXRWYWx1ZSA9IGluaXRWYWx1ZTsgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6b2ZmXG5cbiAgICAgICAgICByZXR1cm4gcmV0VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IHBlZWtBdG9tKHN0b3JlLCBpbml0U3RhdGUpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgIDogUmVjb2lsX2lzUHJvbWlzZShyZXRWYWx1ZSkgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDIocmV0VmFsdWUudGhlbih2ID0+IHYgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IC8vIENhc3QgVCB0byBTXG4gICAgICAgICAgZGVmYXVsdExvYWRhYmxlLnRvUHJvbWlzZSgpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgIDogdikpIDogLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF1cbiAgICAgICAgICBsb2FkYWJsZVdpdGhWYWx1ZSQzKHJldFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRSZWNvaWxWYWx1ZUFzTG9hZGFibGUkNChzdG9yZSwgcmVjb2lsVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQcm9taXNlKHJlY29pbFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSkudG9Qcm9taXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEluZm9fVU5TVEFCTEUocmVjb2lsVmFsdWUpIHtcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQ7XG5cbiAgICAgICAgY29uc3QgaW5mbyA9IHBlZWtOb2RlSW5mbyQzKHN0b3JlLCAoX3N0b3JlJGdldFN0YXRlJG5leHRUNCA9IHN0b3JlLmdldFN0YXRlKCkubmV4dFRyZWUpICE9PSBudWxsICYmIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQgIT09IHZvaWQgMCA/IF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDQgOiBzdG9yZS5nZXRTdGF0ZSgpLmN1cnJlbnRUcmVlLCByZWNvaWxWYWx1ZS5rZXkpO1xuICAgICAgICByZXR1cm4gaXNEdXJpbmdJbml0ICYmIHJlY29pbFZhbHVlLmtleSA9PT0ga2V5ICYmICEoaW5pdFZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIpID8geyAuLi5pbmZvLFxuICAgICAgICAgIGlzU2V0OiB0cnVlLFxuICAgICAgICAgIGxvYWRhYmxlOiBnZXRMb2FkYWJsZShyZWNvaWxWYWx1ZSlcbiAgICAgICAgfSA6IGluZm87XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNldFNlbGYgPSBlZmZlY3QgPT4gdmFsdWVPclVwZGF0ZXIgPT4ge1xuICAgICAgICBpZiAoaXNEdXJpbmdJbml0KSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudExvYWRhYmxlID0gZ2V0TG9hZGFibGUobm9kZSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gY3VycmVudExvYWRhYmxlLnN0YXRlID09PSAnaGFzVmFsdWUnID8gY3VycmVudExvYWRhYmxlLmNvbnRlbnRzIDogREVGQVVMVF9WQUxVRSQ3O1xuICAgICAgICAgIGluaXRWYWx1ZSA9IHR5cGVvZiB2YWx1ZU9yVXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IC8vIGNhc3QgdG8gYW55IGJlY2F1c2Ugd2UgY2FuJ3QgcmVzdHJpY3QgVCBmcm9tIGJlaW5nIGEgZnVuY3Rpb24gd2l0aG91dCBsb3Npbmcgc3VwcG9ydCBmb3Igb3BhcXVlIHR5cGVzXG4gICAgICAgICAgdmFsdWVPclVwZGF0ZXIoY3VycmVudFZhbHVlKSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTpvZmZcbiAgICAgICAgICA6IHZhbHVlT3JVcGRhdGVyO1xuXG4gICAgICAgICAgaWYgKFJlY29pbF9pc1Byb21pc2UoaW5pdFZhbHVlKSkge1xuICAgICAgICAgICAgaW5pdFZhbHVlID0gaW5pdFZhbHVlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgICAvLyBBdm9pZCBjYWxsaW5nIG9uU2V0KCkgd2hlbiBzZXRTZWxmKCkgaW5pdGlhbGl6ZXMgd2l0aCBhIFByb21pc2VcbiAgICAgICAgICAgICAgcGVuZGluZ1NldFNlbGYgPSB7XG4gICAgICAgICAgICAgICAgZWZmZWN0LFxuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoUmVjb2lsX2lzUHJvbWlzZSh2YWx1ZU9yVXBkYXRlcikpIHtcbiAgICAgICAgICAgIHRocm93IFJlY29pbF9lcnIoJ1NldHRpbmcgYXRvbXMgdG8gYXN5bmMgdmFsdWVzIGlzIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlT3JVcGRhdGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IHtcbiAgICAgICAgICAgICAgZWZmZWN0LFxuICAgICAgICAgICAgICB2YWx1ZTogdW53cmFwKHZhbHVlT3JVcGRhdGVyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRSZWNvaWxWYWx1ZSQ0KHN0b3JlLCBub2RlLCB0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicgPyBjdXJyZW50VmFsdWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB1bndyYXAoIC8vIGNhc3QgdG8gYW55IGJlY2F1c2Ugd2UgY2FuJ3QgcmVzdHJpY3QgVCBmcm9tIGJlaW5nIGEgZnVuY3Rpb24gd2l0aG91dCBsb3Npbmcgc3VwcG9ydCBmb3Igb3BhcXVlIHR5cGVzXG4gICAgICAgICAgICB2YWx1ZU9yVXBkYXRlcihjdXJyZW50VmFsdWUpIC8vIGZsb3dsaW50LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuICAgICAgICAgICAgKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV1cblxuICAgICAgICAgICAgcGVuZGluZ1NldFNlbGYgPSB7XG4gICAgICAgICAgICAgIGVmZmVjdCxcbiAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgICAgIH0gOiB1bndyYXAodmFsdWVPclVwZGF0ZXIpKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3QgcmVzZXRTZWxmID0gZWZmZWN0ID0+ICgpID0+IHNldFNlbGYoZWZmZWN0KShERUZBVUxUX1ZBTFVFJDcpO1xuXG4gICAgICBjb25zdCBvblNldCA9IGVmZmVjdCA9PiBoYW5kbGVyID0+IHtcbiAgICAgICAgdmFyIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjI7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlbGVhc2VcbiAgICAgICAgfSA9IHN0b3JlLnN1YnNjcmliZVRvVHJhbnNhY3Rpb25zKGN1cnJlbnRTdG9yZSA9PiB7XG4gICAgICAgICAgdmFyIF9jdXJyZW50VHJlZSRhdG9tVmFsdTtcblxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgY3VycmVudFRyZWUsXG4gICAgICAgICAgICBwcmV2aW91c1RyZWVcbiAgICAgICAgICB9ID0gY3VycmVudFN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgICAgICBpZiAoIXByZXZpb3VzVHJlZSkge1xuICAgICAgICAgICAgUmVjb2lsX3JlY292ZXJhYmxlVmlvbGF0aW9uKCdUcmFuc2FjdGlvbiBzdWJzY3JpYmVycyBub3RpZmllZCB3aXRob3V0IGEgbmV4dCB0cmVlIGJlaW5nIHByZXNlbnQgLS0gdGhpcyBpcyBhIGJ1ZyBpbiBSZWNvaWwnKTtcbiAgICAgICAgICAgIHByZXZpb3VzVHJlZSA9IGN1cnJlbnRUcmVlOyAvLyBhdHRlbXB0IHRvIHRydW5kbGUgb25cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBuZXdMb2FkYWJsZSA9IChfY3VycmVudFRyZWUkYXRvbVZhbHUgPSBjdXJyZW50VHJlZS5hdG9tVmFsdWVzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfY3VycmVudFRyZWUkYXRvbVZhbHUgIT09IHZvaWQgMCA/IF9jdXJyZW50VHJlZSRhdG9tVmFsdSA6IGRlZmF1bHRMb2FkYWJsZTtcblxuICAgICAgICAgIGlmIChuZXdMb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJykge1xuICAgICAgICAgICAgdmFyIF9wcmV2aW91c1RyZWUkYXRvbVZhbCwgX3BlbmRpbmdTZXRTZWxmLCBfcGVuZGluZ1NldFNlbGYyLCBfcGVuZGluZ1NldFNlbGYzO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IG5ld0xvYWRhYmxlLmNvbnRlbnRzO1xuICAgICAgICAgICAgY29uc3Qgb2xkTG9hZGFibGUgPSAoX3ByZXZpb3VzVHJlZSRhdG9tVmFsID0gcHJldmlvdXNUcmVlLmF0b21WYWx1ZXMuZ2V0KGtleSkpICE9PSBudWxsICYmIF9wcmV2aW91c1RyZWUkYXRvbVZhbCAhPT0gdm9pZCAwID8gX3ByZXZpb3VzVHJlZSRhdG9tVmFsIDogZGVmYXVsdExvYWRhYmxlO1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBvbGRMb2FkYWJsZS5zdGF0ZSA9PT0gJ2hhc1ZhbHVlJyA/IG9sZExvYWRhYmxlLmNvbnRlbnRzIDogREVGQVVMVF9WQUxVRSQ3OyAvLyBUT0RPIFRoaXMgaXNuJ3QgYWN0dWFsbHkgdmFsaWQsIHVzZSBhcyBhIHBsYWNlaG9sZGVyIGZvciBub3cuXG4gICAgICAgICAgICAvLyBJZ25vcmUgYXRvbSB2YWx1ZSBjaGFuZ2VzIHRoYXQgd2VyZSBzZXQgdmlhIHNldFNlbGYoKSBpbiB0aGUgc2FtZSBlZmZlY3QuXG4gICAgICAgICAgICAvLyBXZSB3aWxsIHN0aWxsIHByb3Blcmx5IGNhbGwgdGhlIGhhbmRsZXIgaWYgdGhlcmUgd2FzIGEgc3Vic2VxdWVudFxuICAgICAgICAgICAgLy8gc2V0IGZyb20gc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gYXRvbSBlZmZlY3Qgd2hpY2ggd2FzIGJhdGNoZWRcbiAgICAgICAgICAgIC8vIHdpdGggdGhlIGBzZXRTZWxmKClgIGNhbGwuICBIb3dldmVyLCB3ZSBtYXkgaW5jb3JyZWN0bHkgaWdub3JlXG4gICAgICAgICAgICAvLyB0aGUgaGFuZGxlciBpZiB0aGUgc3Vic2VxdWVudCBiYXRjaGVkIGNhbGwgaGFwcGVucyB0byBzZXQgdGhlXG4gICAgICAgICAgICAvLyBhdG9tIHRvIHRoZSBleGFjdCBzYW1lIHZhbHVlIGFzIHRoZSBgc2V0U2VsZigpYC4gICBCdXQsIGluIHRoYXRcbiAgICAgICAgICAgIC8vIGNhc2UsIGl0IHdhcyBraW5kIG9mIGEgbm9vcCwgc28gdGhlIHNlbWFudGljcyBhcmUgZGViYXRhYmxlLi5cblxuICAgICAgICAgICAgaWYgKCgoX3BlbmRpbmdTZXRTZWxmID0gcGVuZGluZ1NldFNlbGYpID09PSBudWxsIHx8IF9wZW5kaW5nU2V0U2VsZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BlbmRpbmdTZXRTZWxmLmVmZmVjdCkgIT09IGVmZmVjdCB8fCAoKF9wZW5kaW5nU2V0U2VsZjIgPSBwZW5kaW5nU2V0U2VsZikgPT09IG51bGwgfHwgX3BlbmRpbmdTZXRTZWxmMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3BlbmRpbmdTZXRTZWxmMi52YWx1ZSkgIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgIGhhbmRsZXIobmV3VmFsdWUsIG9sZFZhbHVlLCAhY3VycmVudFRyZWUuYXRvbVZhbHVlcy5oYXMoa2V5KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCgoX3BlbmRpbmdTZXRTZWxmMyA9IHBlbmRpbmdTZXRTZWxmKSA9PT0gbnVsbCB8fCBfcGVuZGluZ1NldFNlbGYzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ1NldFNlbGYzLmVmZmVjdCkgPT09IGVmZmVjdCkge1xuICAgICAgICAgICAgICBwZW5kaW5nU2V0U2VsZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBrZXkpO1xuICAgICAgICBjbGVhbnVwRWZmZWN0c0J5U3RvcmUuc2V0KHN0b3JlLCBbLi4uKChfY2xlYW51cEVmZmVjdHNCeVN0b3IyID0gY2xlYW51cEVmZmVjdHNCeVN0b3JlLmdldChzdG9yZSkpICE9PSBudWxsICYmIF9jbGVhbnVwRWZmZWN0c0J5U3RvcjIgIT09IHZvaWQgMCA/IF9jbGVhbnVwRWZmZWN0c0J5U3RvcjIgOiBbXSksIHJlbGVhc2VdKTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIGVmZmVjdHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjbGVhbnVwID0gZWZmZWN0KHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBzdG9yZUlEOiBzdG9yZS5zdG9yZUlELFxuICAgICAgICAgICAgcGFyZW50U3RvcmVJRF9VTlNUQUJMRTogc3RvcmUucGFyZW50U3RvcmVJRCxcbiAgICAgICAgICAgIHRyaWdnZXIsXG4gICAgICAgICAgICBzZXRTZWxmOiBzZXRTZWxmKGVmZmVjdCksXG4gICAgICAgICAgICByZXNldFNlbGY6IHJlc2V0U2VsZihlZmZlY3QpLFxuICAgICAgICAgICAgb25TZXQ6IG9uU2V0KGVmZmVjdCksXG4gICAgICAgICAgICBnZXRQcm9taXNlLFxuICAgICAgICAgICAgZ2V0TG9hZGFibGUsXG4gICAgICAgICAgICBnZXRJbmZvX1VOU1RBQkxFXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoY2xlYW51cCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2NsZWFudXBFZmZlY3RzQnlTdG9yMztcblxuICAgICAgICAgICAgY2xlYW51cEVmZmVjdHNCeVN0b3JlLnNldChzdG9yZSwgWy4uLigoX2NsZWFudXBFZmZlY3RzQnlTdG9yMyA9IGNsZWFudXBFZmZlY3RzQnlTdG9yZS5nZXQoc3RvcmUpKSAhPT0gbnVsbCAmJiBfY2xlYW51cEVmZmVjdHNCeVN0b3IzICE9PSB2b2lkIDAgPyBfY2xlYW51cEVmZmVjdHNCeVN0b3IzIDogW10pLCBjbGVhbnVwXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGluaXRWYWx1ZSA9IGVycm9yO1xuICAgICAgICAgIGlzSW5pdEVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpc0R1cmluZ0luaXQgPSBmYWxzZTsgLy8gTXV0YXRlIGluaXRpYWwgc3RhdGUgaW4gcGxhY2Ugc2luY2Ugd2Uga25vdyB0aGVyZSBhcmUgbm8gb3RoZXIgc3Vic2NyaWJlcnNcbiAgICAgIC8vIHNpbmNlIHdlIGFyZSB0aGUgb25lcyBpbml0aWFsaXppbmcgb24gZmlyc3QgdXNlLlxuXG4gICAgICBpZiAoIShpbml0VmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMikpIHtcbiAgICAgICAgdmFyIF9zdG9yZSRnZXRTdGF0ZSRuZXh0VDU7XG5cbiAgICAgICAgY29uc3QgaW5pdExvYWRhYmxlID0gaXNJbml0RXJyb3IgPyBsb2FkYWJsZVdpdGhFcnJvciQyKGluaXRWYWx1ZSkgOiBSZWNvaWxfaXNQcm9taXNlKGluaXRWYWx1ZSkgPyBsb2FkYWJsZVdpdGhQcm9taXNlJDIod3JhcFBlbmRpbmdQcm9taXNlKHN0b3JlLCBpbml0VmFsdWUpKSA6IGxvYWRhYmxlV2l0aFZhbHVlJDModW53cmFwKGluaXRWYWx1ZSkpO1xuICAgICAgICBtYXliZUZyZWV6ZVZhbHVlT3JQcm9taXNlKGluaXRMb2FkYWJsZS5jb250ZW50cyk7XG4gICAgICAgIGluaXRTdGF0ZS5hdG9tVmFsdWVzLnNldChrZXksIGluaXRMb2FkYWJsZSk7IC8vIElmIHRoZXJlIGlzIGEgcGVuZGluZyB0cmFuc2FjdGlvbiwgdGhlbiBhbHNvIG11dGF0ZSB0aGUgbmV4dCBzdGF0ZSB0cmVlLlxuICAgICAgICAvLyBUaGlzIGNvdWxkIGhhcHBlbiBpZiB0aGUgYXRvbSB3YXMgZmlyc3QgaW5pdGlhbGl6ZWQgaW4gYW4gYWN0aW9uIHRoYXRcbiAgICAgICAgLy8gYWxzbyB1cGRhdGVkIHNvbWUgb3RoZXIgYXRvbSdzIHN0YXRlLlxuXG4gICAgICAgIChfc3RvcmUkZ2V0U3RhdGUkbmV4dFQ1ID0gc3RvcmUuZ2V0U3RhdGUoKS5uZXh0VHJlZSkgPT09IG51bGwgfHwgX3N0b3JlJGdldFN0YXRlJG5leHRUNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3N0b3JlJGdldFN0YXRlJG5leHRUNS5hdG9tVmFsdWVzLnNldChrZXksIGluaXRMb2FkYWJsZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsZWFudXBBdG9tO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVla0F0b20oX3N0b3JlLCBzdGF0ZSkge1xuICAgIHZhciBfcmVmLCBfc3RhdGUkYXRvbVZhbHVlcyRnZXQzO1xuXG4gICAgcmV0dXJuIChfcmVmID0gKF9zdGF0ZSRhdG9tVmFsdWVzJGdldDMgPSBzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKSAhPT0gbnVsbCAmJiBfc3RhdGUkYXRvbVZhbHVlcyRnZXQzICE9PSB2b2lkIDAgPyBfc3RhdGUkYXRvbVZhbHVlcyRnZXQzIDogY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IGRlZmF1bHRMb2FkYWJsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF0b20oX3N0b3JlLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5hdG9tVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAvLyBBdG9tIHZhbHVlIGlzIHN0b3JlZCBpbiBzdGF0ZTpcbiAgICAgIHJldHVybiBSZWNvaWxfbnVsbHRocm93cyhzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmhhcyhrZXkpKSB7XG4gICAgICAvLyBBdG9tIHZhbHVlIGlzIHN0b3JlZCBidXQgbmVlZHMgdmFsaWRhdGlvbiBiZWZvcmUgdXNlLlxuICAgICAgLy8gV2UgbWlnaHQgaGF2ZSBhbHJlYWR5IHZhbGlkYXRlZCBpdCBhbmQgaGF2ZSBhIGNhY2hlZCB2YWxpZGF0ZWQgdmFsdWU6XG4gICAgICBpZiAoY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocGVyc2lzdGVuY2UgPT0gbnVsbCkge1xuICAgICAgICBSZWNvaWxfZXhwZWN0YXRpb25WaW9sYXRpb24oYFRyaWVkIHRvIHJlc3RvcmUgYSBwZXJzaXN0ZWQgdmFsdWUgZm9yIGF0b20gJHtrZXl9IGJ1dCBpdCBoYXMgbm8gcGVyc2lzdGVuY2Ugc2V0dGluZ3MuYCk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9hZGFibGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vbnZhbGlkYXRlZFZhbHVlID0gc3RhdGUubm9udmFsaWRhdGVkQXRvbXMuZ2V0KGtleSk7XG4gICAgICBjb25zdCB2YWxpZGF0b3JSZXN1bHQgPSBwZXJzaXN0ZW5jZS52YWxpZGF0b3Iobm9udmFsaWRhdGVkVmFsdWUsIERFRkFVTFRfVkFMVUUkNyk7XG4gICAgICBjb25zdCB2YWxpZGF0ZWRWYWx1ZUxvYWRhYmxlID0gdmFsaWRhdG9yUmVzdWx0IGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIgPyBkZWZhdWx0TG9hZGFibGUgOiBsb2FkYWJsZVdpdGhWYWx1ZSQzKHZhbGlkYXRvclJlc3VsdCk7XG4gICAgICBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlID0gdmFsaWRhdGVkVmFsdWVMb2FkYWJsZTtcbiAgICAgIHJldHVybiBjYWNoZWRBbnN3ZXJGb3JVbnZhbGlkYXRlZFZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVmYXVsdExvYWRhYmxlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRhdGVBdG9tKCkge1xuICAgIGNhY2hlZEFuc3dlckZvclVudmFsaWRhdGVkVmFsdWUgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRBdG9tKF9zdG9yZSwgc3RhdGUsIG5ld1ZhbHVlKSB7XG4gICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgYmVpbmcgc2V0IHRvIHRoZSBleGlzdGluZyB2YWx1ZSwgb3IgaWYgd2UncmUgYmVpbmdcbiAgICAvLyByZXNldCBidXQgaGF2ZSBubyBzdG9yZWQgdmFsdWUgKHZhbGlkYXRlZCBvciB1bnZhbGlkYXRlZCkgdG8gcmVzZXQgZnJvbTpcbiAgICBpZiAoc3RhdGUuYXRvbVZhbHVlcy5oYXMoa2V5KSkge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSBSZWNvaWxfbnVsbHRocm93cyhzdGF0ZS5hdG9tVmFsdWVzLmdldChrZXkpKTtcblxuICAgICAgaWYgKGV4aXN0aW5nLnN0YXRlID09PSAnaGFzVmFsdWUnICYmIG5ld1ZhbHVlID09PSBleGlzdGluZy5jb250ZW50cykge1xuICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXN0YXRlLm5vbnZhbGlkYXRlZEF0b21zLmhhcyhrZXkpICYmIG5ld1ZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIpIHtcbiAgICAgIHJldHVybiBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgbWF5YmVGcmVlemVWYWx1ZU9yUHJvbWlzZShuZXdWYWx1ZSk7XG4gICAgY2FjaGVkQW5zd2VyRm9yVW52YWxpZGF0ZWRWYWx1ZSA9IHVuZGVmaW5lZDsgLy8gY2FuIGJlIHJlbGVhc2VkIG5vdyBpZiBpdCB3YXMgcHJldmlvdXNseSBpbiB1c2VcblxuICAgIHJldHVybiBuZXcgTWFwKCkuc2V0KGtleSwgbG9hZGFibGVXaXRoVmFsdWUkMyhuZXdWYWx1ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSgpIHtcbiAgICByZXR1cm4gZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIoa2V5KSAhPT0gdW5kZWZpbmVkICYmIGxpdmVTdG9yZXNDb3VudCA8PSAwO1xuICB9XG5cbiAgY29uc3Qgbm9kZSA9IHJlZ2lzdGVyTm9kZSQyKHtcbiAgICBrZXksXG4gICAgbm9kZVR5cGU6ICdhdG9tJyxcbiAgICBwZWVrOiBwZWVrQXRvbSxcbiAgICBnZXQ6IGdldEF0b20sXG4gICAgc2V0OiBzZXRBdG9tLFxuICAgIGluaXQ6IGluaXRBdG9tLFxuICAgIGludmFsaWRhdGU6IGludmFsaWRhdGVBdG9tLFxuICAgIHNob3VsZERlbGV0ZUNvbmZpZ09uUmVsZWFzZTogc2hvdWxkRGVsZXRlQ29uZmlnT25SZWxlYXNlQXRvbSxcbiAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICBwZXJzaXN0ZW5jZV9VTlNUQUJMRTogb3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSA/IHtcbiAgICAgIHR5cGU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUudHlwZSxcbiAgICAgIGJhY2tCdXR0b246IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUuYmFja0J1dHRvblxuICAgIH0gOiB1bmRlZmluZWQsXG4gICAgc2hvdWxkUmVzdG9yZUZyb21TbmFwc2hvdHM6IHRydWUsXG4gICAgcmV0YWluZWRCeVxuICB9KTtcbiAgcmV0dXJuIG5vZGU7XG59IC8vIHByZXR0aWVyLWlnbm9yZVxuXG5cbmZ1bmN0aW9uIGF0b20ob3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IFJlY29pbF9lcnIoJ0Ega2V5IG9wdGlvbiB3aXRoIGEgdW5pcXVlIHN0cmluZyB2YWx1ZSBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgYW4gYXRvbS4nKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB7IC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MsXG4gICAgLi4ucmVzdE9wdGlvbnNcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IG9wdGlvbnNEZWZhdWx0ID0gJ2RlZmF1bHQnIGluIG9wdGlvbnMgPyAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS10eXBlXSBObyB3YXkgdG8gcmVmaW5lIGluIEZsb3cgdGhhdCBwcm9wZXJ0eSBpcyBub3QgZGVmaW5lZFxuICBvcHRpb25zLmRlZmF1bHQgOiBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG5cbiAgaWYgKGlzUmVjb2lsVmFsdWUkNChvcHRpb25zRGVmYXVsdCkgLy8gQ29udGludWUgdG8gdXNlIGF0b21XaXRoRmFsbGJhY2sgZm9yIHByb21pc2UgZGVmYXVsdHMgZm9yIHNjb3BlZCBhdG9tc1xuICAvLyBmb3Igbm93LCBzaW5jZSBzY29wZWQgYXRvbXMgZG9uJ3Qgc3VwcG9ydCBhc3luYyBkZWZhdWx0c1xuICAvLyBAZmItb25seTogfHwgKGlzUHJvbWlzZShvcHRpb25zRGVmYXVsdCkgJiYgc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTKVxuICAvLyBAZmItb25seTogfHwgKGlzTG9hZGFibGUob3B0aW9uc0RlZmF1bHQpICYmIHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUylcbiAgKSB7XG4gICAgcmV0dXJuIGF0b21XaXRoRmFsbGJhY2soeyAuLi5yZXN0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0IC8vIEBmYi1vbmx5OiBzY29wZVJ1bGVzX0FQUEVORF9PTkxZX1JFQURfVEhFX0RPQ1MsXG5cbiAgICB9KTsgLy8gQGZiLW9ubHk6IH0gZWxzZSBpZiAoc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc1Byb21pc2Uob3B0aW9uc0RlZmF1bHQpXG4gICAgLy8gQGZiLW9ubHk6ICYmICFpc0xvYWRhYmxlKG9wdGlvbnNEZWZhdWx0KVxuICAgIC8vIEBmYi1vbmx5OiApIHtcbiAgICAvLyBAZmItb25seTogcmV0dXJuIHNjb3BlZEF0b208VD4oe1xuICAgIC8vIEBmYi1vbmx5OiAuLi5yZXN0T3B0aW9ucyxcbiAgICAvLyBAZmItb25seTogZGVmYXVsdDogdW53cmFwPFQ+KG9wdGlvbnNEZWZhdWx0KSxcbiAgICAvLyBAZmItb25seTogc2NvcGVSdWxlc19BUFBFTkRfT05MWV9SRUFEX1RIRV9ET0NTLFxuICAgIC8vIEBmYi1vbmx5OiB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZUF0b20oeyAuLi5yZXN0T3B0aW9ucyxcbiAgICAgIGRlZmF1bHQ6IG9wdGlvbnNEZWZhdWx0XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXRvbVdpdGhGYWxsYmFjayhvcHRpb25zKSB7XG4gIGNvbnN0IGJhc2UgPSBhdG9tKHsgLi4ub3B0aW9ucyxcbiAgICBkZWZhdWx0OiBERUZBVUxUX1ZBTFVFJDcsXG4gICAgcGVyc2lzdGVuY2VfVU5TVEFCTEU6IG9wdGlvbnMucGVyc2lzdGVuY2VfVU5TVEFCTEUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHsgLi4ub3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSxcbiAgICAgIHZhbGlkYXRvcjogc3RvcmVkVmFsdWUgPT4gc3RvcmVkVmFsdWUgaW5zdGFuY2VvZiBEZWZhdWx0VmFsdWUkMiA/IHN0b3JlZFZhbHVlIDogUmVjb2lsX251bGx0aHJvd3Mob3B0aW9ucy5wZXJzaXN0ZW5jZV9VTlNUQUJMRSkudmFsaWRhdG9yKHN0b3JlZFZhbHVlLCBERUZBVUxUX1ZBTFVFJDcpXG4gICAgfSxcbiAgICAvLyBUT0RPIEhhY2sgZm9yIG5vdy5cbiAgICBlZmZlY3RzOiBvcHRpb25zLmVmZmVjdHMsXG4gICAgLy8gZmxvd2xpbnQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICAgIGVmZmVjdHNfVU5TVEFCTEU6IG9wdGlvbnMuZWZmZWN0c19VTlNUQUJMRSAvLyBmbG93bGludC1saW5lIHVuY2xlYXItdHlwZTogb2ZmXG5cbiAgfSk7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdXG5cbiAgY29uc3Qgc2VsID0gUmVjb2lsX3NlbGVjdG9yKHtcbiAgICBrZXk6IGAke29wdGlvbnMua2V5fV9fd2l0aEZhbGxiYWNrYCxcbiAgICBnZXQ6ICh7XG4gICAgICBnZXRcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCBiYXNlVmFsdWUgPSBnZXQoYmFzZSk7XG4gICAgICByZXR1cm4gYmFzZVZhbHVlIGluc3RhbmNlb2YgRGVmYXVsdFZhbHVlJDIgPyBvcHRpb25zLmRlZmF1bHQgOiBiYXNlVmFsdWU7XG4gICAgfSxcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXVxuICAgIHNldDogKHtcbiAgICAgIHNldFxuICAgIH0sIG5ld1ZhbHVlKSA9PiBzZXQoYmFzZSwgbmV3VmFsdWUpLFxuICAgIC8vIFRoaXMgc2VsZWN0b3IgZG9lcyBub3QgbmVlZCB0byBjYWNoZSBhcyBpdCBpcyBhIHdyYXBwZXIgc2VsZWN0b3JcbiAgICAvLyBhbmQgdGhlIHNlbGVjdG9yIHdpdGhpbiB0aGUgd3JhcHBlciBzZWxlY3RvciB3aWxsIGhhdmUgYSBjYWNoZVxuICAgIC8vIG9wdGlvbiBieSBkZWZhdWx0XG4gICAgY2FjaGVQb2xpY3lfVU5TVEFCTEU6IHtcbiAgICAgIGV2aWN0aW9uOiAnbW9zdC1yZWNlbnQnXG4gICAgfSxcbiAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eVxuICB9KTtcbiAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDEoc2VsLmtleSwgZ2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDIob3B0aW9ucy5rZXkpKTtcbiAgcmV0dXJuIHNlbDtcbn0gLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuXG5cbmF0b20udmFsdWUgPSB2YWx1ZSA9PiBuZXcgV3JhcHBlZFZhbHVlJDIodmFsdWUpO1xuXG52YXIgUmVjb2lsX2F0b20gPSBhdG9tO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKiBAZm9ybWF0XG4gKiBAb25jYWxsIHJlY29pbFxuICovXG5cbmNsYXNzIE1hcENhY2hlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRtYXBLZXk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfbWFwXCIsIHZvaWQgMCk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJfa2V5TWFwcGVyXCIsIHZvaWQgMCk7XG5cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fa2V5TWFwcGVyID0gKF9vcHRpb25zJG1hcEtleSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXBLZXkpICE9PSBudWxsICYmIF9vcHRpb25zJG1hcEtleSAhPT0gdm9pZCAwID8gX29wdGlvbnMkbWFwS2V5IDogdiA9PiB2O1xuICB9XG5cbiAgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFwLnNpemU7XG4gIH1cblxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX21hcC5oYXModGhpcy5fa2V5TWFwcGVyKGtleSkpO1xuICB9XG5cbiAgZ2V0KGtleSkge1xuICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KHRoaXMuX2tleU1hcHBlcihrZXkpKTtcbiAgfVxuXG4gIHNldChrZXksIHZhbCkge1xuICAgIHRoaXMuX21hcC5zZXQodGhpcy5fa2V5TWFwcGVyKGtleSksIHZhbCk7XG4gIH1cblxuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5fbWFwLmRlbGV0ZSh0aGlzLl9rZXlNYXBwZXIoa2V5KSk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9tYXAuY2xlYXIoKTtcbiAgfVxuXG59XG5cbnZhciBSZWNvaWxfTWFwQ2FjaGUgPSB7XG4gIE1hcENhY2hlXG59O1xuXG52YXIgUmVjb2lsX01hcENhY2hlXzEgPSBSZWNvaWxfTWFwQ2FjaGUuTWFwQ2FjaGU7XG5cbnZhciBSZWNvaWxfTWFwQ2FjaGUkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBNYXBDYWNoZTogUmVjb2lsX01hcENhY2hlXzFcbn0pO1xuXG5jb25zdCB7XG4gIExSVUNhY2hlOiBMUlVDYWNoZSQyXG59ID0gUmVjb2lsX0xSVUNhY2hlJDE7XG5cbmNvbnN0IHtcbiAgTWFwQ2FjaGU6IE1hcENhY2hlJDFcbn0gPSBSZWNvaWxfTWFwQ2FjaGUkMTtcblxuXG5cblxuXG5cblxuY29uc3QgZGVmYXVsdFBvbGljeSQxID0ge1xuICBlcXVhbGl0eTogJ3JlZmVyZW5jZScsXG4gIGV2aWN0aW9uOiAnbm9uZScsXG4gIG1heFNpemU6IEluZmluaXR5XG59O1xuXG5mdW5jdGlvbiBjYWNoZUZyb21Qb2xpY3koe1xuICBlcXVhbGl0eSA9IGRlZmF1bHRQb2xpY3kkMS5lcXVhbGl0eSxcbiAgZXZpY3Rpb24gPSBkZWZhdWx0UG9saWN5JDEuZXZpY3Rpb24sXG4gIG1heFNpemUgPSBkZWZhdWx0UG9saWN5JDEubWF4U2l6ZVxufSA9IGRlZmF1bHRQb2xpY3kkMSkge1xuICBjb25zdCB2YWx1ZU1hcHBlciA9IGdldFZhbHVlTWFwcGVyJDEoZXF1YWxpdHkpO1xuICBjb25zdCBjYWNoZSA9IGdldENhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCB2YWx1ZU1hcHBlcik7XG4gIHJldHVybiBjYWNoZTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVNYXBwZXIkMShlcXVhbGl0eSkge1xuICBzd2l0Y2ggKGVxdWFsaXR5KSB7XG4gICAgY2FzZSAncmVmZXJlbmNlJzpcbiAgICAgIHJldHVybiB2YWwgPT4gdmFsO1xuXG4gICAgY2FzZSAndmFsdWUnOlxuICAgICAgcmV0dXJuIHZhbCA9PiBSZWNvaWxfc3RhYmxlU3RyaW5naWZ5KHZhbCk7XG4gIH1cblxuICB0aHJvdyBSZWNvaWxfZXJyKGBVbnJlY29nbml6ZWQgZXF1YWxpdHkgcG9saWN5ICR7ZXF1YWxpdHl9YCk7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlKGV2aWN0aW9uLCBtYXhTaXplLCBtYXBLZXkpIHtcbiAgc3dpdGNoIChldmljdGlvbikge1xuICAgIGNhc2UgJ2tlZXAtYWxsJzpcbiAgICAgIHJldHVybiBuZXcgTWFwQ2FjaGUkMSh7XG4gICAgICAgIG1hcEtleVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdscnUnOlxuICAgICAgcmV0dXJuIG5ldyBMUlVDYWNoZSQyKHtcbiAgICAgICAgbWFwS2V5LFxuICAgICAgICBtYXhTaXplOiBSZWNvaWxfbnVsbHRocm93cyhtYXhTaXplKVxuICAgICAgfSk7XG5cbiAgICBjYXNlICdtb3N0LXJlY2VudCc6XG4gICAgICByZXR1cm4gbmV3IExSVUNhY2hlJDIoe1xuICAgICAgICBtYXBLZXksXG4gICAgICAgIG1heFNpemU6IDFcbiAgICAgIH0pO1xuICB9XG5cbiAgdGhyb3cgUmVjb2lsX2VycihgVW5yZWNvZ25pemVkIGV2aWN0aW9uIHBvbGljeSAke2V2aWN0aW9ufWApO1xufVxuXG52YXIgUmVjb2lsX2NhY2hlRnJvbVBvbGljeSA9IGNhY2hlRnJvbVBvbGljeTtcblxuLy8gQGZiLW9ubHk6IGltcG9ydCB0eXBlIHtTY29wZVJ1bGVzfSBmcm9tICdSZWNvaWxfU2NvcGVkQXRvbSc7XG5cblxuY29uc3Qge1xuICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXI6IHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlciQyXG59ID0gUmVjb2lsX05vZGU7XG5cblxuXG5cblxuLy8gUHJvY2VzcyBzY29wZVJ1bGVzIHRvIGhhbmRsZSBhbnkgZW50cmllcyB3aGljaCBhcmUgZnVuY3Rpb25zIHRha2luZyBwYXJhbWV0ZXJzXG4vLyBwcmV0dGllci1pZ25vcmVcbi8vIEBmYi1vbmx5OiBmdW5jdGlvbiBtYXBTY29wZVJ1bGVzPFA+KFxuLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXM/OiBQYXJhbWV0ZXJpemVkU2NvcGVSdWxlczxQPixcbi8vIEBmYi1vbmx5OiBwYXJhbTogUCxcbi8vIEBmYi1vbmx5OiApOiBTY29wZVJ1bGVzIHwgdm9pZCB7XG4vLyBAZmItb25seTogcmV0dXJuIHNjb3BlUnVsZXM/Lm1hcChydWxlID0+XG4vLyBAZmItb25seTogQXJyYXkuaXNBcnJheShydWxlKVxuLy8gQGZiLW9ubHk6ID8gcnVsZS5tYXAoZW50cnkgPT4gKHR5cGVvZiBlbnRyeSA9PT0gJ2Z1bmN0aW9uJyA/IGVudHJ5KHBhcmFtKSA6IGVudHJ5KSlcbi8vIEBmYi1vbmx5OiA6IHJ1bGUsXG4vLyBAZmItb25seTogKTtcbi8vIEBmYi1vbmx5OiB9XG5cbi8qXG5BIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gYXRvbSBiYXNlZCBvbiB0aGUgaW5wdXQgcGFyYW1ldGVyLlxuXG5FYWNoIHVuaXF1ZSBwYXJhbWV0ZXIgcmV0dXJucyBhIHVuaXF1ZSBhdG9tLiBFLmcuLFxuXG4gIGNvbnN0IGYgPSBhdG9tRmFtaWx5KC4uLik7XG4gIGYoe2E6IDF9KSA9PiBhbiBhdG9tXG4gIGYoe2E6IDJ9KSA9PiBhIGRpZmZlcmVudCBhdG9tXG5cblRoaXMgYWxsb3dzIGNvbXBvbmVudHMgdG8gcGVyc2lzdCBsb2NhbCwgcHJpdmF0ZSBzdGF0ZSB1c2luZyBhdG9tcy4gIEVhY2hcbmluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgbWF5IGhhdmUgYSBkaWZmZXJlbnQga2V5LCB3aGljaCBpdCB1c2VzIGFzIHRoZVxucGFyYW1ldGVyIGZvciBhIGZhbWlseSBvZiBhdG9tczsgaW4gdGhpcyB3YXksIGVhY2ggY29tcG9uZW50IHdpbGwgaGF2ZVxuaXRzIG93biBhdG9tIG5vdCBzaGFyZWQgYnkgb3RoZXIgaW5zdGFuY2VzLiAgVGhlc2Ugc3RhdGUga2V5cyBtYXkgYmUgY29tcG9zZWRcbmludG8gY2hpbGRyZW4ncyBzdGF0ZSBrZXlzIGFzIHdlbGwuXG4qL1xuZnVuY3Rpb24gYXRvbUZhbWlseShvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucyRjYWNoZVBvbGljeUYsIF9vcHRpb25zJGNhY2hlUG9saWN5RjI7XG5cbiAgY29uc3QgYXRvbUNhY2hlID0gUmVjb2lsX2NhY2hlRnJvbVBvbGljeSh7XG4gICAgZXF1YWxpdHk6IChfb3B0aW9ucyRjYWNoZVBvbGljeUYgPSAoX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9IG9wdGlvbnMuY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEUpID09PSBudWxsIHx8IF9vcHRpb25zJGNhY2hlUG9saWN5RjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRpb25zJGNhY2hlUG9saWN5RjIuZXF1YWxpdHkpICE9PSBudWxsICYmIF9vcHRpb25zJGNhY2hlUG9saWN5RiAhPT0gdm9pZCAwID8gX29wdGlvbnMkY2FjaGVQb2xpY3lGIDogJ3ZhbHVlJyxcbiAgICBldmljdGlvbjogJ2tlZXAtYWxsJ1xuICB9KTsgLy8gU2ltcGxlIGF0b21GYW1pbHkgaW1wbGVtZW50YXRpb24gdG8gY2FjaGUgaW5kaXZpZHVhbCBhdG9tcyBiYXNlZFxuICAvLyBvbiB0aGUgcGFyYW1ldGVyIHZhbHVlIGVxdWFsaXR5LlxuXG4gIHJldHVybiBwYXJhbXMgPT4ge1xuICAgIHZhciBfc3RhYmxlU3RyaW5naWZ5LCBfb3B0aW9ucyRlZmZlY3RzO1xuXG4gICAgY29uc3QgY2FjaGVkQXRvbSA9IGF0b21DYWNoZS5nZXQocGFyYW1zKTtcblxuICAgIGlmIChjYWNoZWRBdG9tICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWRBdG9tO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFLFxuICAgICAgLi4uYXRvbU9wdGlvbnNcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zRGVmYXVsdCA9ICdkZWZhdWx0JyBpbiBvcHRpb25zID8gLy8gJEZsb3dJc3N1ZVtpbmNvbXBhdGlibGUtdHlwZV0gTm8gd2F5IHRvIHJlZmluZSBpbiBGbG93IHRoYXQgcHJvcGVydHkgaXMgbm90IGRlZmluZWRcbiAgICBvcHRpb25zLmRlZmF1bHQgOiBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG4gICAgY29uc3QgbmV3QXRvbSA9IFJlY29pbF9hdG9tKHsgLi4uYXRvbU9wdGlvbnMsXG4gICAgICBrZXk6IGAke29wdGlvbnMua2V5fV9fJHsoX3N0YWJsZVN0cmluZ2lmeSA9IFJlY29pbF9zdGFibGVTdHJpbmdpZnkocGFyYW1zKSkgIT09IG51bGwgJiYgX3N0YWJsZVN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX3N0YWJsZVN0cmluZ2lmeSA6ICd2b2lkJ31gLFxuICAgICAgZGVmYXVsdDogdHlwZW9mIG9wdGlvbnNEZWZhdWx0ID09PSAnZnVuY3Rpb24nID8gLy8gVGhlIGRlZmF1bHQgd2FzIHBhcmFtZXRlcml6ZWRcbiAgICAgIC8vIEZsb3cgZG9lc24ndCBrbm93IHRoYXQgVCBpc24ndCBhIGZ1bmN0aW9uLCBzbyB3ZSBuZWVkIHRvIGNhc2UgdG8gYW55XG4gICAgICAvLyAkRmxvd0lzc3VlW2luY29tcGF0aWJsZS11c2VdXG4gICAgICBvcHRpb25zRGVmYXVsdChwYXJhbXMpIDogLy8gRGVmYXVsdCBtYXkgYmUgYSBzdGF0aWMgdmFsdWUsIHByb21pc2UsIG9yIFJlY29pbFZhbHVlXG4gICAgICBvcHRpb25zRGVmYXVsdCxcbiAgICAgIHJldGFpbmVkQnlfVU5TVEFCTEU6IHR5cGVvZiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEUocGFyYW1zKSA6IG9wdGlvbnMucmV0YWluZWRCeV9VTlNUQUJMRSxcbiAgICAgIGVmZmVjdHM6IHR5cGVvZiBvcHRpb25zLmVmZmVjdHMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmVmZmVjdHMocGFyYW1zKSA6IHR5cGVvZiBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmVmZmVjdHNfVU5TVEFCTEUocGFyYW1zKSA6IChfb3B0aW9ucyRlZmZlY3RzID0gb3B0aW9ucy5lZmZlY3RzKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRlZmZlY3RzICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRlZmZlY3RzIDogb3B0aW9ucy5lZmZlY3RzX1VOU1RBQkxFIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgLy8gQGZiLW9ubHk6IHNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUzogbWFwU2NvcGVSdWxlcyhcbiAgICAgIC8vIEBmYi1vbmx5OiBvcHRpb25zLnNjb3BlUnVsZXNfQVBQRU5EX09OTFlfUkVBRF9USEVfRE9DUyxcbiAgICAgIC8vIEBmYi1vbmx5OiBwYXJhbXMsXG4gICAgICAvLyBAZmItb25seTogKSxcblxuICAgIH0pO1xuICAgIGF0b21DYWNoZS5zZXQocGFyYW1zLCBuZXdBdG9tKTtcbiAgICBzZXRDb25maWdEZWxldGlvbkhhbmRsZXIkMihuZXdBdG9tLmtleSwgKCkgPT4ge1xuICAgICAgYXRvbUNhY2hlLmRlbGV0ZShwYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdBdG9tO1xuICB9O1xufVxuXG52YXIgUmVjb2lsX2F0b21GYW1pbHkgPSBhdG9tRmFtaWx5O1xuXG5jb25zdCB7XG4gIHNldENvbmZpZ0RlbGV0aW9uSGFuZGxlcjogc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDNcbn0gPSBSZWNvaWxfTm9kZTtcblxuXG5cblxuXG4gLy8gS2VlcCBpbiBtaW5kIHRoZSBwYXJhbWV0ZXIgbmVlZHMgdG8gYmUgc2VyaWFsaXphYmxlIGFzIGEgY2FoY2hlIGtleVxuLy8gdXNpbmcgUmVjb2lsX3N0YWJsZVN0cmluZ2lmeVxuXG5cbi8vIEFkZCBhIHVuaXF1ZSBpbmRleCB0byBlYWNoIHNlbGVjdG9yIGluIGNhc2UgdGhlIGNhY2hlIGltcGxlbWVudGF0aW9uIGFsbG93c1xuLy8gZHVwbGljYXRlIGtleXMgYmFzZWQgb24gZXF1aXZhbGVudCBzdHJpbmdpZmllZCBwYXJhbWV0ZXJzXG5sZXQgbmV4dEluZGV4ID0gMDtcbi8qIGVzbGludC1kaXNhYmxlIG5vLXJlZGVjbGFyZSAqL1xuXG4vLyBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbWVtYmVycyBvZiBhIGZhbWlseSBvZiBzZWxlY3RvcnMgb2YgdGhlIHNhbWUgdHlwZVxuLy8gRS5nLixcbi8vXG4vLyBjb25zdCBzID0gc2VsZWN0b3JGYW1pbHkoLi4uKTtcbi8vIHMoe2E6IDF9KSA9PiBhIHNlbGVjdG9yXG4vLyBzKHthOiAyfSkgPT4gYSBkaWZmZXJlbnQgc2VsZWN0b3Jcbi8vXG4vLyBCeSBkZWZhdWx0LCB0aGUgc2VsZWN0b3JzIGFyZSBkaXN0aW5ndWlzaGVkIGJ5IGRpc3RpbmN0IHZhbHVlcyBvZiB0aGVcbi8vIHBhcmFtZXRlciBiYXNlZCBvbiB2YWx1ZSBlcXVhbGl0eSwgbm90IHJlZmVyZW5jZSBlcXVhbGl0eS4gIFRoaXMgYWxsb3dzIHVzaW5nXG4vLyBvYmplY3QgbGl0ZXJhbHMgb3Igb3RoZXIgZXF1aXZhbGVudCBvYmplY3RzIGF0IGNhbGxzaXRlcyB0byBub3QgY3JlYXRlXG4vLyBkdXBsaWNhdGUgY2FjaGUgZW50cmllcy4gIFRoaXMgYmVoYXZpb3IgbWF5IGJlIG92ZXJyaWRkZW4gd2l0aCB0aGVcbi8vIGNhY2hlSW1wbGVtZW50YXRpb25Gb3JQYXJhbXMgb3B0aW9uLlxuZnVuY3Rpb24gc2VsZWN0b3JGYW1pbHkob3B0aW9ucykge1xuICB2YXIgX29wdGlvbnMkY2FjaGVQb2xpY3lGLCBfb3B0aW9ucyRjYWNoZVBvbGljeUYyO1xuXG4gIGNvbnN0IHNlbGVjdG9yQ2FjaGUgPSBSZWNvaWxfY2FjaGVGcm9tUG9saWN5KHtcbiAgICBlcXVhbGl0eTogKF9vcHRpb25zJGNhY2hlUG9saWN5RiA9IChfb3B0aW9ucyRjYWNoZVBvbGljeUYyID0gb3B0aW9ucy5jYWNoZVBvbGljeUZvclBhcmFtc19VTlNUQUJMRSkgPT09IG51bGwgfHwgX29wdGlvbnMkY2FjaGVQb2xpY3lGMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdGlvbnMkY2FjaGVQb2xpY3lGMi5lcXVhbGl0eSkgIT09IG51bGwgJiYgX29wdGlvbnMkY2FjaGVQb2xpY3lGICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRjYWNoZVBvbGljeUYgOiAndmFsdWUnLFxuICAgIGV2aWN0aW9uOiAna2VlcC1hbGwnXG4gIH0pO1xuICByZXR1cm4gcGFyYW1zID0+IHtcbiAgICB2YXIgX3N0YWJsZVN0cmluZ2lmeTtcblxuICAgIC8vIFRocm93IGFuIGVycm9yIHdpdGggc2VsZWN0b3Iga2V5IHNvIHRoYXQgaXQgaXMgY2xlYXIgd2hpY2hcbiAgICAvLyBzZWxlY3RvciBpcyBjYXVzaW5nIGFuIGVycm9yXG4gICAgbGV0IGNhY2hlZFNlbGVjdG9yO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhY2hlZFNlbGVjdG9yID0gc2VsZWN0b3JDYWNoZS5nZXQocGFyYW1zKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgUmVjb2lsX2VycihgUHJvYmxlbSB3aXRoIGNhY2hlIGxvb2t1cCBmb3Igc2VsZWN0b3IgJHtvcHRpb25zLmtleX06ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGVkU2VsZWN0b3IgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZFNlbGVjdG9yO1xuICAgIH1cblxuICAgIGNvbnN0IG15S2V5ID0gYCR7b3B0aW9ucy5rZXl9X19zZWxlY3RvckZhbWlseS8keyhfc3RhYmxlU3RyaW5naWZ5ID0gUmVjb2lsX3N0YWJsZVN0cmluZ2lmeShwYXJhbXMsIHtcbiAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRvIHVzZSBmdW5jdGlvbnMgaW4gcGFyYW1ldGVycyBpZiB0aGUgdXNlciB1c2VzXG4gICAgICAvLyBhIGNhY2hlIHdpdGggcmVmZXJlbmNlIGVxdWFsaXR5IHRoYW5rcyB0byB0aGUgaW5jcmVtZW50aW5nIGluZGV4LlxuICAgICAgYWxsb3dGdW5jdGlvbnM6IHRydWVcbiAgICB9KSkgIT09IG51bGwgJiYgX3N0YWJsZVN0cmluZ2lmeSAhPT0gdm9pZCAwID8gX3N0YWJsZVN0cmluZ2lmeSA6ICd2b2lkJ30vJHtuZXh0SW5kZXgrK31gOyAvLyBBcHBlbmQgaW5kZXggaW4gY2FzZSB2YWx1ZXMgc2VyaWFsaXplIHRvIHRoZSBzYW1lIGtleSBzdHJpbmdcblxuICAgIGNvbnN0IG15R2V0ID0gY2FsbGJhY2tzID0+IG9wdGlvbnMuZ2V0KHBhcmFtcykoY2FsbGJhY2tzKTtcblxuICAgIGNvbnN0IG15Q2FjaGVQb2xpY3kgPSBvcHRpb25zLmNhY2hlUG9saWN5X1VOU1RBQkxFO1xuICAgIGNvbnN0IHJldGFpbmVkQnkgPSB0eXBlb2Ygb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5yZXRhaW5lZEJ5X1VOU1RBQkxFKHBhcmFtcykgOiBvcHRpb25zLnJldGFpbmVkQnlfVU5TVEFCTEU7XG4gICAgbGV0IG5ld1NlbGVjdG9yO1xuXG4gICAgaWYgKG9wdGlvbnMuc2V0ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHNldCA9IG9wdGlvbnMuc2V0O1xuXG4gICAgICBjb25zdCBteVNldCA9IChjYWxsYmFja3MsIG5ld1ZhbHVlKSA9PiBzZXQocGFyYW1zKShjYWxsYmFja3MsIG5ld1ZhbHVlKTtcblxuICAgICAgbmV3U2VsZWN0b3IgPSBSZWNvaWxfc2VsZWN0b3Ioe1xuICAgICAgICBrZXk6IG15S2V5LFxuICAgICAgICBnZXQ6IG15R2V0LFxuICAgICAgICBzZXQ6IG15U2V0LFxuICAgICAgICBjYWNoZVBvbGljeV9VTlNUQUJMRTogbXlDYWNoZVBvbGljeSxcbiAgICAgICAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IG9wdGlvbnMuZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHksXG4gICAgICAgIHJldGFpbmVkQnlfVU5TVEFCTEU6IHJldGFpbmVkQnlcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTZWxlY3RvciA9IFJlY29pbF9zZWxlY3Rvcih7XG4gICAgICAgIGtleTogbXlLZXksXG4gICAgICAgIGdldDogbXlHZXQsXG4gICAgICAgIGNhY2hlUG9saWN5X1VOU1RBQkxFOiBteUNhY2hlUG9saWN5LFxuICAgICAgICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eSxcbiAgICAgICAgcmV0YWluZWRCeV9VTlNUQUJMRTogcmV0YWluZWRCeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZWN0b3JDYWNoZS5zZXQocGFyYW1zLCBuZXdTZWxlY3Rvcik7XG4gICAgc2V0Q29uZmlnRGVsZXRpb25IYW5kbGVyJDMobmV3U2VsZWN0b3Iua2V5LCAoKSA9PiB7XG4gICAgICBzZWxlY3RvckNhY2hlLmRlbGV0ZShwYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdTZWxlY3RvcjtcbiAgfTtcbn1cbi8qIGVzbGludC1lbmFibGUgbm8tcmVkZWNsYXJlICovXG5cblxudmFyIFJlY29pbF9zZWxlY3RvckZhbWlseSA9IHNlbGVjdG9yRmFtaWx5O1xuXG4vLyBmbG93bGludC1uZXh0LWxpbmUgdW5jbGVhci10eXBlOm9mZlxuXG5cbmNvbnN0IGNvbnN0YW50U2VsZWN0b3IgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX2NvbnN0YW50JyxcbiAgZ2V0OiBjb25zdGFudCA9PiAoKSA9PiBjb25zdGFudCxcbiAgY2FjaGVQb2xpY3lGb3JQYXJhbXNfVU5TVEFCTEU6IHtcbiAgICBlcXVhbGl0eTogJ3JlZmVyZW5jZSdcbiAgfVxufSk7IC8vIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNlbGVjdG9yIHdoaWNoIGFsd2F5cyBwcm9kdWNlcyB0aGVcbi8vIHNhbWUgY29uc3RhbnQgdmFsdWUuICBJdCBtYXkgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGggdGhlXG4vLyBzYW1lIHZhbHVlLCBiYXNlZCBvbiByZWZlcmVuY2UgZXF1YWxpdHksIGFuZCB3aWxsIHByb3ZpZGUgdGhlXG4vLyBzYW1lIHNlbGVjdG9yLlxuXG5mdW5jdGlvbiBjb25zdFNlbGVjdG9yKGNvbnN0YW50KSB7XG4gIHJldHVybiBjb25zdGFudFNlbGVjdG9yKGNvbnN0YW50KTtcbn1cblxudmFyIFJlY29pbF9jb25zdFNlbGVjdG9yID0gY29uc3RTZWxlY3RvcjtcblxuLy8gZmxvd2xpbnQtbmV4dC1saW5lIHVuY2xlYXItdHlwZTpvZmZcblxuXG5jb25zdCB0aHJvd2luZ1NlbGVjdG9yID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX19lcnJvcicsXG4gIGdldDogbWVzc2FnZSA9PiAoKSA9PiB7XG4gICAgdGhyb3cgUmVjb2lsX2VycihtZXNzYWdlKTtcbiAgfSxcbiAgLy8gVE9ETyBXaHk/XG4gIGNhY2hlUG9saWN5Rm9yUGFyYW1zX1VOU1RBQkxFOiB7XG4gICAgZXF1YWxpdHk6ICdyZWZlcmVuY2UnXG4gIH1cbn0pOyAvLyBGdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZWxlY3RvciB3aGljaCBhbHdheXMgdGhyb3dzIGFuIGVycm9yXG4vLyB3aXRoIHRoZSBwcm92aWRlZCBtZXNzYWdlLlxuXG5mdW5jdGlvbiBlcnJvclNlbGVjdG9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHRocm93aW5nU2VsZWN0b3IobWVzc2FnZSk7XG59XG5cbnZhciBSZWNvaWxfZXJyb3JTZWxlY3RvciA9IGVycm9yU2VsZWN0b3I7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBXcmFwcyBhbm90aGVyIHJlY29pbCB2YWx1ZSBhbmQgcHJldmVudHMgd3JpdGluZyB0byBpdC5cbiAqXG4gKiBcbiAqIEBmb3JtYXRcbiAqIEBvbmNhbGwgcmVjb2lsXG4gKi9cblxuZnVuY3Rpb24gcmVhZE9ubHlTZWxlY3RvcihhdG9tKSB7XG4gIC8vIGZsb3dsaW50LW5leHQtbGluZSB1bmNsZWFyLXR5cGU6IG9mZlxuICByZXR1cm4gYXRvbTtcbn1cblxudmFyIFJlY29pbF9yZWFkT25seVNlbGVjdG9yID0gcmVhZE9ubHlTZWxlY3RvcjtcblxuY29uc3Qge1xuICBsb2FkYWJsZVdpdGhFcnJvcjogbG9hZGFibGVXaXRoRXJyb3IkMyxcbiAgbG9hZGFibGVXaXRoUHJvbWlzZTogbG9hZGFibGVXaXRoUHJvbWlzZSQzLFxuICBsb2FkYWJsZVdpdGhWYWx1ZTogbG9hZGFibGVXaXRoVmFsdWUkNFxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5cblxuXG5cbiAvLy8vLy8vLy8vLy8vLy8vL1xuLy8gIFRSVVRIIFRBQkxFXG4vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRGVwZW5kZW5jaWVzICAgICAgICB3YWl0Rm9yTm9uZSAgICAgICAgIHdhaXRGb3JBbnkgICAgICAgIHdhaXRGb3JBbGwgICAgICAgd2FpdEZvckFsbFNldHRsZWRcbi8vICBbbG9hZGluZywgbG9hZGluZ10gIFtQcm9taXNlLCBQcm9taXNlXSAgUHJvbWlzZSAgICAgICAgICAgUHJvbWlzZSAgICAgICAgIFByb21pc2Vcbi8vICBbdmFsdWUsIGxvYWRpbmddICAgIFt2YWx1ZSwgUHJvbWlzZV0gICAgW3ZhbHVlLCBQcm9taXNlXSAgUHJvbWlzZSAgICAgICAgIFByb21pc2Vcbi8vICBbdmFsdWUsIHZhbHVlXSAgICAgIFt2YWx1ZSwgdmFsdWVdICAgICAgW3ZhbHVlLCB2YWx1ZV0gICAgW3ZhbHVlLCB2YWx1ZV0gIFt2YWx1ZSwgdmFsdWVdXG4vL1xuLy8gIFtlcnJvciwgbG9hZGluZ10gICAgW0Vycm9yLCBQcm9taXNlXSAgICBbRXJyb3IsIFByb21pc2VdICBFcnJvciAgICAgICAgICAgUHJvbWlzZVxuLy8gIFtlcnJvciwgZXJyb3JdICAgICAgW0Vycm9yLCBFcnJvcl0gICAgICBbRXJyb3IsIEVycm9yXSAgICBFcnJvciAgICAgICAgICAgW2Vycm9yLCBlcnJvcl1cbi8vICBbdmFsdWUsIGVycm9yXSAgICAgIFt2YWx1ZSwgRXJyb3JdICAgICAgW3ZhbHVlLCBFcnJvcl0gICAgRXJyb3IgICAgICAgICAgIFt2YWx1ZSwgZXJyb3JdXG4vLyBJc3N1ZSBwYXJhbGxlbCByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBhbmQgcmV0dXJuIHRoZSBjdXJyZW50XG4vLyBzdGF0dXMgaWYgdGhleSBoYXZlIHJlc3VsdHMsIGhhdmUgc29tZSBlcnJvciwgb3IgYXJlIHN0aWxsIHBlbmRpbmcuXG5cblxuZnVuY3Rpb24gY29uY3VycmVudFJlcXVlc3RzKGdldFJlY29pbFZhbHVlLCBkZXBzKSB7XG4gIGNvbnN0IHJlc3VsdHMgPSBBcnJheShkZXBzLmxlbmd0aCkuZmlsbCh1bmRlZmluZWQpO1xuICBjb25zdCBleGNlcHRpb25zID0gQXJyYXkoZGVwcy5sZW5ndGgpLmZpbGwodW5kZWZpbmVkKTtcblxuICBmb3IgKGNvbnN0IFtpLCBkZXBdIG9mIGRlcHMuZW50cmllcygpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdHNbaV0gPSBnZXRSZWNvaWxWYWx1ZShkZXApO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbcmVzdWx0cywgZXhjZXB0aW9uc107XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZXhwKSB7XG4gIHJldHVybiBleHAgIT0gbnVsbCAmJiAhUmVjb2lsX2lzUHJvbWlzZShleHApO1xufVxuXG5mdW5jdGlvbiB1bndyYXBEZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRlcGVuZGVuY2llcykgPyBkZXBlbmRlbmNpZXMgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkZXBlbmRlbmNpZXMpLm1hcChrZXkgPT4gZGVwZW5kZW5jaWVzW2tleV0pO1xufVxuXG5mdW5jdGlvbiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsXG4vKiAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdIFRoZSB0eXBlIGFubm90YXRpb24ocykgcmVxdWlyZWQgYnkgRmxvdydzXG4gKiBMVEkgdXBkYXRlIGNvdWxkIG5vdCBiZSBhZGRlZCB2aWEgY29kZW1vZCAqL1xucmVzdWx0cykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gcmVzdWx0cyA6IC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKCkgaGFzIGNvbnNpc3RlbnQga2V5IG9yZGVyaW5nIHdpdGggRVM2XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRlcGVuZGVuY2llcykucmVkdWNlKChvdXQsIGtleSwgaWR4KSA9PiAoeyAuLi5vdXQsXG4gICAgW2tleV06IHJlc3VsdHNbaWR4XVxuICB9KSwge30pO1xufVxuXG5mdW5jdGlvbiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykge1xuICBjb25zdCBvdXRwdXQgPSBleGNlcHRpb25zLm1hcCgoZXhjZXB0aW9uLCBpZHgpID0+IGV4Y2VwdGlvbiA9PSBudWxsID8gbG9hZGFibGVXaXRoVmFsdWUkNChyZXN1bHRzW2lkeF0pIDogUmVjb2lsX2lzUHJvbWlzZShleGNlcHRpb24pID8gbG9hZGFibGVXaXRoUHJvbWlzZSQzKGV4Y2VwdGlvbikgOiBsb2FkYWJsZVdpdGhFcnJvciQzKGV4Y2VwdGlvbikpO1xuICByZXR1cm4gd3JhcFJlc3VsdHMoZGVwZW5kZW5jaWVzLCBvdXRwdXQpO1xufVxuXG5mdW5jdGlvbiBjb21iaW5lQXN5bmNSZXN1bHRzV2l0aFN5bmNSZXN1bHRzKHN5bmNSZXN1bHRzLCBhc3luY1Jlc3VsdHMpIHtcbiAgcmV0dXJuIGFzeW5jUmVzdWx0cy5tYXAoKHJlc3VsdCwgaWR4KSA9PlxuICAvKipcbiAgICogaXQncyBpbXBvcnRhbnQgd2UgdXNlID09PSB1bmRlZmluZWQgYXMgb3Bwb3NlZCB0byA9PSBudWxsLCBiZWNhdXNlIHRoZVxuICAgKiByZXNvbHZlZCB2YWx1ZSBvZiB0aGUgYXN5bmMgcHJvbWlzZSBjb3VsZCBiZSBgbnVsbGAsIGluIHdoaWNoIGNhc2Ugd2VcbiAgICogZG9uJ3Qgd2FudCB0byB1c2Ugc3luY1Jlc3VsdHNbaWR4XSwgd2hpY2ggd291bGQgYmUgdW5kZWZpbmVkLiBJZiBhc3luY1xuICAgKiBwcm9taXNlIHJlc29sdmVzIHRvIGB1bmRlZmluZWRgLCB0aGF0J3Mgb2sgYmVjYXVzZSBgc3luY1Jlc3VsdHNbaWR4XWBcbiAgICogd2lsbCBhbHNvIGJlIGB1bmRlZmluZWRgLiBUaGF0J3MgYSBsaXR0bGUgaGFja3ksIGJ1dCBpdCB3b3Jrcy5cbiAgICovXG4gIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gc3luY1Jlc3VsdHNbaWR4XSA6IHJlc3VsdCk7XG59IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgaW1tZWRpYXRlbHkgcmV0dXJuc1xuLy8gY3VycmVudCByZXN1bHRzIHdpdGhvdXQgd2FpdGluZy5cblxuXG5jb25zdCB3YWl0Rm9yTm9uZSA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fd2FpdEZvck5vbmUnLFxuICBnZXQ6IGRlcGVuZGVuY2llcyA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgLy8gSXNzdWUgcmVxdWVzdHMgZm9yIGFsbCBkZXBlbmRlbmNpZXMgaW4gcGFyYWxsZWwuXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IFtyZXN1bHRzLCBleGNlcHRpb25zXSA9IGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXQsIGRlcHMpOyAvLyBBbHdheXMgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgcmVzdWx0czsgbmV2ZXIgYmxvY2suXG5cbiAgICByZXR1cm4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpO1xuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7IC8vIFNlbGVjdG9yIHRoYXQgcmVxdWVzdHMgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbCBhbmQgd2FpdHMgZm9yIGF0IGxlYXN0XG4vLyBvbmUgdG8gYmUgYXZhaWxhYmxlIGJlZm9yZSByZXR1cm5pbmcgcmVzdWx0cy4gIEl0IHdpbGwgb25seSBlcnJvciBpZiBhbGxcbi8vIGRlcGVuZGVuY2llcyBoYXZlIGVycm9ycy5cblxuY29uc3Qgd2FpdEZvckFueSA9IFJlY29pbF9zZWxlY3RvckZhbWlseSh7XG4gIGtleTogJ19fd2FpdEZvckFueScsXG4gIGdldDogZGVwZW5kZW5jaWVzID0+ICh7XG4gICAgZ2V0XG4gIH0pID0+IHtcbiAgICAvLyBJc3N1ZSByZXF1ZXN0cyBmb3IgYWxsIGRlcGVuZGVuY2llcyBpbiBwYXJhbGxlbC5cbiAgICAvLyBFeGNlcHRpb25zIGNhbiBlaXRoZXIgYmUgUHJvbWlzZXMgb2YgcGVuZGluZyByZXN1bHRzIG9yIHJlYWwgZXJyb3JzXG4gICAgY29uc3QgZGVwcyA9IHVud3JhcERlcGVuZGVuY2llcyhkZXBlbmRlbmNpZXMpO1xuICAgIGNvbnN0IFtyZXN1bHRzLCBleGNlcHRpb25zXSA9IGNvbmN1cnJlbnRSZXF1ZXN0cyhnZXQsIGRlcHMpOyAvLyBJZiBhbnkgcmVzdWx0cyBhcmUgYXZhaWxhYmxlLCB2YWx1ZSBvciBlcnJvciwgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXR1c1xuXG4gICAgaWYgKGV4Y2VwdGlvbnMuc29tZShleHAgPT4gIVJlY29pbF9pc1Byb21pc2UoZXhwKSkpIHtcbiAgICAgIHJldHVybiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucyk7XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgbmV4dCByZXN1bHQgaXNcbiAgICAvLyBhdmFpbGFibGUsIHdoaWNoZXZlciBvbmUgaGFwcGVucyB0byBiZSBuZXh0LiAgQnV0LCBpZiBhbGwgcGVuZGluZ1xuICAgIC8vIGRlcGVuZGVuY2llcyBlbmQgdXAgd2l0aCBlcnJvcnMsIHRoZW4gcmVqZWN0IHRoZSBwcm9taXNlLlxuXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtpLCBleHBdIG9mIGV4Y2VwdGlvbnMuZW50cmllcygpKSB7XG4gICAgICAgIGlmIChSZWNvaWxfaXNQcm9taXNlKGV4cCkpIHtcbiAgICAgICAgICBleHAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXBMb2FkYWJsZXMoZGVwZW5kZW5jaWVzLCByZXN1bHRzLCBleGNlcHRpb25zKSk7XG4gICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgZXhjZXB0aW9uc1tpXSA9IGVycm9yO1xuICAgICAgICAgICAgcmVzb2x2ZSh3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGRhbmdlcm91c2x5QWxsb3dNdXRhYmlsaXR5OiB0cnVlXG59KTsgLy8gU2VsZWN0b3IgdGhhdCByZXF1ZXN0cyBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsIGFuZCB3YWl0cyBmb3IgYWxsIHRvIGJlXG4vLyBhdmFpbGFibGUgYmVmb3JlIHJldHVybmluZyBhIHZhbHVlLiAgSXQgd2lsbCBlcnJvciBpZiBhbnkgZGVwZW5kZW5jaWVzIGVycm9yLlxuXG5jb25zdCB3YWl0Rm9yQWxsID0gUmVjb2lsX3NlbGVjdG9yRmFtaWx5KHtcbiAga2V5OiAnX193YWl0Rm9yQWxsJyxcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxuICAgIC8vIEV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0c1xuXG4gICAgaWYgKGV4Y2VwdGlvbnMuZXZlcnkoZXhwID0+IGV4cCA9PSBudWxsKSkge1xuICAgICAgcmV0dXJuIHdyYXBSZXN1bHRzKGRlcGVuZGVuY2llcywgcmVzdWx0cyk7XG4gICAgfSAvLyBJZiB3ZSBoYXZlIGFueSBlcnJvcnMsIHRocm93IHRoZSBmaXJzdCBlcnJvclxuXG5cbiAgICBjb25zdCBlcnJvciA9IGV4Y2VwdGlvbnMuZmluZChpc0Vycm9yKTtcblxuICAgIGlmIChlcnJvciAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSB3aGVuIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGVcblxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGV4Y2VwdGlvbnMpLnRoZW4oZXhjZXB0aW9uUmVzdWx0cyA9PiB3cmFwUmVzdWx0cyhkZXBlbmRlbmNpZXMsIGNvbWJpbmVBc3luY1Jlc3VsdHNXaXRoU3luY1Jlc3VsdHMocmVzdWx0cywgZXhjZXB0aW9uUmVzdWx0cykpKTtcbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pO1xuY29uc3Qgd2FpdEZvckFsbFNldHRsZWQgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX3dhaXRGb3JBbGxTZXR0bGVkJyxcbiAgZ2V0OiBkZXBlbmRlbmNpZXMgPT4gKHtcbiAgICBnZXRcbiAgfSkgPT4ge1xuICAgIC8vIElzc3VlIHJlcXVlc3RzIGZvciBhbGwgZGVwZW5kZW5jaWVzIGluIHBhcmFsbGVsLlxuICAgIC8vIEV4Y2VwdGlvbnMgY2FuIGVpdGhlciBiZSBQcm9taXNlcyBvZiBwZW5kaW5nIHJlc3VsdHMgb3IgcmVhbCBlcnJvcnNcbiAgICBjb25zdCBkZXBzID0gdW53cmFwRGVwZW5kZW5jaWVzKGRlcGVuZGVuY2llcyk7XG4gICAgY29uc3QgW3Jlc3VsdHMsIGV4Y2VwdGlvbnNdID0gY29uY3VycmVudFJlcXVlc3RzKGdldCwgZGVwcyk7IC8vIElmIGFsbCByZXN1bHRzIGFyZSBhdmFpbGFibGUsIHJldHVybiB0aGUgcmVzdWx0c1xuXG4gICAgaWYgKGV4Y2VwdGlvbnMuZXZlcnkoZXhwID0+ICFSZWNvaWxfaXNQcm9taXNlKGV4cCkpKSB7XG4gICAgICByZXR1cm4gd3JhcExvYWRhYmxlcyhkZXBlbmRlbmNpZXMsIHJlc3VsdHMsIGV4Y2VwdGlvbnMpO1xuICAgIH0gLy8gV2FpdCBmb3IgYWxsIHJlc3VsdHMgdG8gc2V0dGxlXG5cblxuICAgIHJldHVybiBQcm9taXNlLmFsbChleGNlcHRpb25zLm1hcCgoZXhwLCBpKSA9PiBSZWNvaWxfaXNQcm9taXNlKGV4cCkgPyBleHAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSB1bmRlZmluZWQ7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgcmVzdWx0c1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIGV4Y2VwdGlvbnNbaV0gPSBlcnJvcjtcbiAgICB9KSA6IG51bGwpKSAvLyBUaGVuIHdyYXAgdGhlbSBhcyBsb2FkYWJsZXNcbiAgICAudGhlbigoKSA9PiB3cmFwTG9hZGFibGVzKGRlcGVuZGVuY2llcywgcmVzdWx0cywgZXhjZXB0aW9ucykpO1xuICB9LFxuICBkYW5nZXJvdXNseUFsbG93TXV0YWJpbGl0eTogdHJ1ZVxufSk7XG5jb25zdCBub1dhaXQgPSBSZWNvaWxfc2VsZWN0b3JGYW1pbHkoe1xuICBrZXk6ICdfX25vV2FpdCcsXG4gIGdldDogZGVwZW5kZW5jeSA9PiAoe1xuICAgIGdldFxuICB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBSZWNvaWxfc2VsZWN0b3IudmFsdWUobG9hZGFibGVXaXRoVmFsdWUkNChnZXQoZGVwZW5kZW5jeSkpKTtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgIHJldHVybiBSZWNvaWxfc2VsZWN0b3IudmFsdWUoUmVjb2lsX2lzUHJvbWlzZShleGNlcHRpb24pID8gbG9hZGFibGVXaXRoUHJvbWlzZSQzKGV4Y2VwdGlvbikgOiBsb2FkYWJsZVdpdGhFcnJvciQzKGV4Y2VwdGlvbikpO1xuICAgIH1cbiAgfSxcbiAgZGFuZ2Vyb3VzbHlBbGxvd011dGFiaWxpdHk6IHRydWVcbn0pO1xudmFyIFJlY29pbF9XYWl0Rm9yID0ge1xuICB3YWl0Rm9yTm9uZSxcbiAgd2FpdEZvckFueSxcbiAgd2FpdEZvckFsbCxcbiAgd2FpdEZvckFsbFNldHRsZWQsXG4gIG5vV2FpdFxufTtcblxuY29uc3Qge1xuICBSZWNvaWxMb2FkYWJsZVxufSA9IFJlY29pbF9Mb2FkYWJsZSQxO1xuXG5jb25zdCB7XG4gIERlZmF1bHRWYWx1ZTogRGVmYXVsdFZhbHVlJDNcbn0gPSBSZWNvaWxfTm9kZTtcblxuY29uc3Qge1xuICBSZWNvaWxSb290OiBSZWNvaWxSb290JDIsXG4gIHVzZVJlY29pbFN0b3JlSUQ6IHVzZVJlY29pbFN0b3JlSUQkMVxufSA9IFJlY29pbF9SZWNvaWxSb290O1xuXG5jb25zdCB7XG4gIGlzUmVjb2lsVmFsdWU6IGlzUmVjb2lsVmFsdWUkNVxufSA9IFJlY29pbF9SZWNvaWxWYWx1ZSQxO1xuXG5jb25zdCB7XG4gIHJldGVudGlvblpvbmU6IHJldGVudGlvblpvbmUkMVxufSA9IFJlY29pbF9SZXRlbnRpb25ab25lO1xuXG5jb25zdCB7XG4gIGZyZXNoU25hcHNob3Q6IGZyZXNoU25hcHNob3QkMlxufSA9IFJlY29pbF9TbmFwc2hvdCQxO1xuXG5jb25zdCB7XG4gIHVzZVJlY29pbFN0YXRlOiB1c2VSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFN0YXRlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSQxLFxuICB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU6IHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFZhbHVlTG9hZGFibGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSQxLFxuICB1c2VSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlJDEsXG4gIHVzZVNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSQxXG59ID0gUmVjb2lsX0hvb2tzO1xuXG5jb25zdCB7XG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdDogdXNlR290b1JlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyOiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyJDFcbn0gPSBSZWNvaWxfU25hcHNob3RIb29rcztcblxuXG5cblxuXG5jb25zdCB7XG4gIHVzZVJlY29pbENhbGxiYWNrOiB1c2VSZWNvaWxDYWxsYmFjayQxXG59ID0gUmVjb2lsX3VzZVJlY29pbENhbGxiYWNrO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuY29uc3Qge1xuICBub1dhaXQ6IG5vV2FpdCQxLFxuICB3YWl0Rm9yQWxsOiB3YWl0Rm9yQWxsJDEsXG4gIHdhaXRGb3JBbGxTZXR0bGVkOiB3YWl0Rm9yQWxsU2V0dGxlZCQxLFxuICB3YWl0Rm9yQW55OiB3YWl0Rm9yQW55JDEsXG4gIHdhaXRGb3JOb25lOiB3YWl0Rm9yTm9uZSQxXG59ID0gUmVjb2lsX1dhaXRGb3I7XG5cblxuXG52YXIgUmVjb2lsX2luZGV4ID0ge1xuICAvLyBUeXBlc1xuICBEZWZhdWx0VmFsdWU6IERlZmF1bHRWYWx1ZSQzLFxuICBpc1JlY29pbFZhbHVlOiBpc1JlY29pbFZhbHVlJDUsXG4gIFJlY29pbExvYWRhYmxlLFxuICAvLyBHbG9iYWwgUmVjb2lsIGVudmlyb25tZW50IHNldHRpb25nc1xuICBSZWNvaWxFbnY6IFJlY29pbF9SZWNvaWxFbnYsXG4gIC8vIFJlY29pbCBSb290XG4gIFJlY29pbFJvb3Q6IFJlY29pbFJvb3QkMixcbiAgdXNlUmVjb2lsU3RvcmVJRDogdXNlUmVjb2lsU3RvcmVJRCQxLFxuICB1c2VSZWNvaWxCcmlkZ2VBY3Jvc3NSZWFjdFJvb3RzX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290cyxcbiAgLy8gQXRvbXMvU2VsZWN0b3JzXG4gIGF0b206IFJlY29pbF9hdG9tLFxuICBzZWxlY3RvcjogUmVjb2lsX3NlbGVjdG9yLFxuICAvLyBDb252ZW5pZW5jZSBBdG9tcy9TZWxlY3RvcnNcbiAgYXRvbUZhbWlseTogUmVjb2lsX2F0b21GYW1pbHksXG4gIHNlbGVjdG9yRmFtaWx5OiBSZWNvaWxfc2VsZWN0b3JGYW1pbHksXG4gIGNvbnN0U2VsZWN0b3I6IFJlY29pbF9jb25zdFNlbGVjdG9yLFxuICBlcnJvclNlbGVjdG9yOiBSZWNvaWxfZXJyb3JTZWxlY3RvcixcbiAgcmVhZE9ubHlTZWxlY3RvcjogUmVjb2lsX3JlYWRPbmx5U2VsZWN0b3IsXG4gIC8vIENvbmN1cnJlbmN5IEhlbHBlcnMgZm9yIEF0b21zL1NlbGVjdG9yc1xuICBub1dhaXQ6IG5vV2FpdCQxLFxuICB3YWl0Rm9yTm9uZTogd2FpdEZvck5vbmUkMSxcbiAgd2FpdEZvckFueTogd2FpdEZvckFueSQxLFxuICB3YWl0Rm9yQWxsOiB3YWl0Rm9yQWxsJDEsXG4gIHdhaXRGb3JBbGxTZXR0bGVkOiB3YWl0Rm9yQWxsU2V0dGxlZCQxLFxuICAvLyBIb29rcyBmb3IgQXRvbXMvU2VsZWN0b3JzXG4gIHVzZVJlY29pbFZhbHVlOiB1c2VSZWNvaWxWYWx1ZSQxLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlOiB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlJDEsXG4gIHVzZVJlY29pbFN0YXRlOiB1c2VSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlOiB1c2VSZWNvaWxTdGF0ZUxvYWRhYmxlJDEsXG4gIHVzZVNldFJlY29pbFN0YXRlOiB1c2VTZXRSZWNvaWxTdGF0ZSQxLFxuICB1c2VSZXNldFJlY29pbFN0YXRlOiB1c2VSZXNldFJlY29pbFN0YXRlJDEsXG4gIHVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRTogUmVjb2lsX3VzZUdldFJlY29pbFZhbHVlSW5mbyxcbiAgdXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFOiBSZWNvaWxfdXNlUmVjb2lsUmVmcmVzaGVyLFxuICB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTogdXNlUmVjb2lsVmFsdWVMb2FkYWJsZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcbiAgdXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxWYWx1ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcbiAgdXNlUmVjb2lsU3RhdGVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFOiB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUkMSxcbiAgLy8gSG9va3MgZm9yIGNvbXBsZXggb3BlcmF0aW9uc1xuICB1c2VSZWNvaWxDYWxsYmFjazogdXNlUmVjb2lsQ2FsbGJhY2skMSxcbiAgdXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEU6IFJlY29pbF91c2VSZWNvaWxUcmFuc2FjdGlvbixcbiAgLy8gU25hcHNob3RzXG4gIHVzZUdvdG9SZWNvaWxTbmFwc2hvdDogdXNlR290b1JlY29pbFNuYXBzaG90JDEsXG4gIHVzZVJlY29pbFNuYXBzaG90OiB1c2VSZWNvaWxTbmFwc2hvdCQxLFxuICB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFOiB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyJDEsXG4gIHNuYXBzaG90X1VOU1RBQkxFOiBmcmVzaFNuYXBzaG90JDIsXG4gIC8vIE1lbW9yeSBNYW5hZ2VtZW50XG4gIHVzZVJldGFpbjogUmVjb2lsX3VzZVJldGFpbixcbiAgcmV0ZW50aW9uWm9uZTogcmV0ZW50aW9uWm9uZSQxXG59O1xudmFyIFJlY29pbF9pbmRleF8xID0gUmVjb2lsX2luZGV4LkRlZmF1bHRWYWx1ZTtcbnZhciBSZWNvaWxfaW5kZXhfMiA9IFJlY29pbF9pbmRleC5pc1JlY29pbFZhbHVlO1xudmFyIFJlY29pbF9pbmRleF8zID0gUmVjb2lsX2luZGV4LlJlY29pbExvYWRhYmxlO1xudmFyIFJlY29pbF9pbmRleF80ID0gUmVjb2lsX2luZGV4LlJlY29pbEVudjtcbnZhciBSZWNvaWxfaW5kZXhfNSA9IFJlY29pbF9pbmRleC5SZWNvaWxSb290O1xudmFyIFJlY29pbF9pbmRleF82ID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFN0b3JlSUQ7XG52YXIgUmVjb2lsX2luZGV4XzcgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290c19VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfOCA9IFJlY29pbF9pbmRleC5hdG9tO1xudmFyIFJlY29pbF9pbmRleF85ID0gUmVjb2lsX2luZGV4LnNlbGVjdG9yO1xudmFyIFJlY29pbF9pbmRleF8xMCA9IFJlY29pbF9pbmRleC5hdG9tRmFtaWx5O1xudmFyIFJlY29pbF9pbmRleF8xMSA9IFJlY29pbF9pbmRleC5zZWxlY3RvckZhbWlseTtcbnZhciBSZWNvaWxfaW5kZXhfMTIgPSBSZWNvaWxfaW5kZXguY29uc3RTZWxlY3RvcjtcbnZhciBSZWNvaWxfaW5kZXhfMTMgPSBSZWNvaWxfaW5kZXguZXJyb3JTZWxlY3RvcjtcbnZhciBSZWNvaWxfaW5kZXhfMTQgPSBSZWNvaWxfaW5kZXgucmVhZE9ubHlTZWxlY3RvcjtcbnZhciBSZWNvaWxfaW5kZXhfMTUgPSBSZWNvaWxfaW5kZXgubm9XYWl0O1xudmFyIFJlY29pbF9pbmRleF8xNiA9IFJlY29pbF9pbmRleC53YWl0Rm9yTm9uZTtcbnZhciBSZWNvaWxfaW5kZXhfMTcgPSBSZWNvaWxfaW5kZXgud2FpdEZvckFueTtcbnZhciBSZWNvaWxfaW5kZXhfMTggPSBSZWNvaWxfaW5kZXgud2FpdEZvckFsbDtcbnZhciBSZWNvaWxfaW5kZXhfMTkgPSBSZWNvaWxfaW5kZXgud2FpdEZvckFsbFNldHRsZWQ7XG52YXIgUmVjb2lsX2luZGV4XzIwID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbFZhbHVlO1xudmFyIFJlY29pbF9pbmRleF8yMSA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxWYWx1ZUxvYWRhYmxlO1xudmFyIFJlY29pbF9pbmRleF8yMiA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxTdGF0ZTtcbnZhciBSZWNvaWxfaW5kZXhfMjMgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsU3RhdGVMb2FkYWJsZTtcbnZhciBSZWNvaWxfaW5kZXhfMjQgPSBSZWNvaWxfaW5kZXgudXNlU2V0UmVjb2lsU3RhdGU7XG52YXIgUmVjb2lsX2luZGV4XzI1ID0gUmVjb2lsX2luZGV4LnVzZVJlc2V0UmVjb2lsU3RhdGU7XG52YXIgUmVjb2lsX2luZGV4XzI2ID0gUmVjb2lsX2luZGV4LnVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMjcgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8yOCA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMjkgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVmFsdWVfVFJBTlNJVElPTl9TVVBQT1JUX1VOU1RBQkxFO1xudmFyIFJlY29pbF9pbmRleF8zMCA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzMxID0gUmVjb2lsX2luZGV4LnVzZVJlY29pbENhbGxiYWNrO1xudmFyIFJlY29pbF9pbmRleF8zMiA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxUcmFuc2FjdGlvbl9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMzMgPSBSZWNvaWxfaW5kZXgudXNlR290b1JlY29pbFNuYXBzaG90O1xudmFyIFJlY29pbF9pbmRleF8zNCA9IFJlY29pbF9pbmRleC51c2VSZWNvaWxTbmFwc2hvdDtcbnZhciBSZWNvaWxfaW5kZXhfMzUgPSBSZWNvaWxfaW5kZXgudXNlUmVjb2lsVHJhbnNhY3Rpb25PYnNlcnZlcl9VTlNUQUJMRTtcbnZhciBSZWNvaWxfaW5kZXhfMzYgPSBSZWNvaWxfaW5kZXguc25hcHNob3RfVU5TVEFCTEU7XG52YXIgUmVjb2lsX2luZGV4XzM3ID0gUmVjb2lsX2luZGV4LnVzZVJldGFpbjtcbnZhciBSZWNvaWxfaW5kZXhfMzggPSBSZWNvaWxfaW5kZXgucmV0ZW50aW9uWm9uZTtcblxuZXhwb3J0IGRlZmF1bHQgUmVjb2lsX2luZGV4O1xuZXhwb3J0IHsgUmVjb2lsX2luZGV4XzEgYXMgRGVmYXVsdFZhbHVlLCBSZWNvaWxfaW5kZXhfNCBhcyBSZWNvaWxFbnYsIFJlY29pbF9pbmRleF8zIGFzIFJlY29pbExvYWRhYmxlLCBSZWNvaWxfaW5kZXhfNSBhcyBSZWNvaWxSb290LCBSZWNvaWxfaW5kZXhfOCBhcyBhdG9tLCBSZWNvaWxfaW5kZXhfMTAgYXMgYXRvbUZhbWlseSwgUmVjb2lsX2luZGV4XzEyIGFzIGNvbnN0U2VsZWN0b3IsIFJlY29pbF9pbmRleF8xMyBhcyBlcnJvclNlbGVjdG9yLCBSZWNvaWxfaW5kZXhfMiBhcyBpc1JlY29pbFZhbHVlLCBSZWNvaWxfaW5kZXhfMTUgYXMgbm9XYWl0LCBSZWNvaWxfaW5kZXhfMTQgYXMgcmVhZE9ubHlTZWxlY3RvciwgUmVjb2lsX2luZGV4XzM4IGFzIHJldGVudGlvblpvbmUsIFJlY29pbF9pbmRleF85IGFzIHNlbGVjdG9yLCBSZWNvaWxfaW5kZXhfMTEgYXMgc2VsZWN0b3JGYW1pbHksIFJlY29pbF9pbmRleF8zNiBhcyBzbmFwc2hvdF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzI2IGFzIHVzZUdldFJlY29pbFZhbHVlSW5mb19VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMzIGFzIHVzZUdvdG9SZWNvaWxTbmFwc2hvdCwgUmVjb2lsX2luZGV4XzcgYXMgdXNlUmVjb2lsQnJpZGdlQWNyb3NzUmVhY3RSb290c19VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzMxIGFzIHVzZVJlY29pbENhbGxiYWNrLCBSZWNvaWxfaW5kZXhfMjcgYXMgdXNlUmVjb2lsUmVmcmVzaGVyX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMzQgYXMgdXNlUmVjb2lsU25hcHNob3QsIFJlY29pbF9pbmRleF8yMiBhcyB1c2VSZWNvaWxTdGF0ZSwgUmVjb2lsX2luZGV4XzIzIGFzIHVzZVJlY29pbFN0YXRlTG9hZGFibGUsIFJlY29pbF9pbmRleF8zMCBhcyB1c2VSZWNvaWxTdGF0ZV9UUkFOU0lUSU9OX1NVUFBPUlRfVU5TVEFCTEUsIFJlY29pbF9pbmRleF82IGFzIHVzZVJlY29pbFN0b3JlSUQsIFJlY29pbF9pbmRleF8zNSBhcyB1c2VSZWNvaWxUcmFuc2FjdGlvbk9ic2VydmVyX1VOU1RBQkxFLCBSZWNvaWxfaW5kZXhfMzIgYXMgdXNlUmVjb2lsVHJhbnNhY3Rpb25fVU5TVEFCTEUsIFJlY29pbF9pbmRleF8yMCBhcyB1c2VSZWNvaWxWYWx1ZSwgUmVjb2lsX2luZGV4XzIxIGFzIHVzZVJlY29pbFZhbHVlTG9hZGFibGUsIFJlY29pbF9pbmRleF8yOCBhcyB1c2VSZWNvaWxWYWx1ZUxvYWRhYmxlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzI5IGFzIHVzZVJlY29pbFZhbHVlX1RSQU5TSVRJT05fU1VQUE9SVF9VTlNUQUJMRSwgUmVjb2lsX2luZGV4XzI1IGFzIHVzZVJlc2V0UmVjb2lsU3RhdGUsIFJlY29pbF9pbmRleF8zNyBhcyB1c2VSZXRhaW4sIFJlY29pbF9pbmRleF8yNCBhcyB1c2VTZXRSZWNvaWxTdGF0ZSwgUmVjb2lsX2luZGV4XzE4IGFzIHdhaXRGb3JBbGwsIFJlY29pbF9pbmRleF8xOSBhcyB3YWl0Rm9yQWxsU2V0dGxlZCwgUmVjb2lsX2luZGV4XzE3IGFzIHdhaXRGb3JBbnksIFJlY29pbF9pbmRleF8xNiBhcyB3YWl0Rm9yTm9uZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/recoil/es/index.js\n");

/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/***/ (function(module) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcz9jNmIwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/process/browser.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);